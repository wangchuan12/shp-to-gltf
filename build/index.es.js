#!/usr/bin/env node --max_old_space_size=8192
const Dy = {}, Ny = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Dy
}, Symbol.toStringTag, { value: "Module" }));
var cn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Wl(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
function Fy(n) {
  if (n.__esModule)
    return n;
  var t = n.default;
  if (typeof t == "function") {
    var e = function i() {
      return this instanceof i ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    e.prototype = t.prototype;
  } else
    e = {};
  return Object.defineProperty(e, "__esModule", { value: !0 }), Object.keys(n).forEach(function(i) {
    var r = Object.getOwnPropertyDescriptor(n, i);
    Object.defineProperty(e, i, r.get ? r : {
      enumerable: !0,
      get: function() {
        return n[i];
      }
    });
  }), e;
}
function Ui(n) {
  throw new Error('Could not dynamically require "' + n + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var ud = { exports: {} };
(function(n, t) {
  (function(e) {
    n.exports = e();
  })(function() {
    return (/* @__PURE__ */ function() {
      function e(i, r, s) {
        function a(h, l) {
          if (!r[h]) {
            if (!i[h]) {
              var f = typeof Ui == "function" && Ui;
              if (!l && f)
                return f(h, !0);
              if (o)
                return o(h, !0);
              var d = new Error("Cannot find module '" + h + "'");
              throw d.code = "MODULE_NOT_FOUND", d;
            }
            var m = r[h] = { exports: {} };
            i[h][0].call(m.exports, function(v) {
              var E = i[h][1][v];
              return a(E || v);
            }, m, m.exports, e, i, r, s);
          }
          return r[h].exports;
        }
        for (var o = typeof Ui == "function" && Ui, c = 0; c < s.length; c++)
          a(s[c]);
        return a;
      }
      return e;
    }())({ 1: [function(e, i, r) {
      const s = e("lie"), a = e("./combine"), o = e("buffer").Buffer;
      i.exports = c;
      function c(h, l) {
        return new s(function(f, d) {
          const m = a(h, l), v = new XMLHttpRequest();
          v.open("GET", m, !0), l !== "prj" && l !== "cpg" && (v.responseType = "arraybuffer"), v.addEventListener("load", function() {
            return v.status > 399 ? l === "prj" || l === "cpg" ? f(!1) : d(new Error(v.status)) : f(l !== "prj" && l !== "cpg" ? o.from(v.response) : v.response);
          }, !1), v.send();
        });
      }
    }, { "./combine": 3, buffer: 8, lie: 12 }], 2: [function(e, i, r) {
      (function(s) {
        (function() {
          const a = e("./binaryajax-browser"), o = e("./combine"), c = e("buffer").Buffer;
          i.exports = async function(l, f) {
            if (!s.fetch)
              return a(l, f);
            const d = o(l, f), m = f === "prj" || f === "cpg";
            try {
              const v = await fetch(d);
              if (v.status > 399)
                throw new Error(v.statusText);
              if (m)
                return v.text();
              const E = await v.arrayBuffer();
              return c.from(E);
            } catch (v) {
              if (console.log("ERROR", v, f), m || f === "dbf")
                return !1;
              throw v;
            }
          };
        }).call(this);
      }).call(this, typeof cn < "u" ? cn : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "./binaryajax-browser": 1, "./combine": 3, buffer: 8 }], 3: [function(e, i, r) {
      (function(s) {
        (function() {
          const a = s.URL;
          i.exports = (o, c) => {
            if (!c)
              return o;
            const h = new a(o);
            return h.pathname = `${h.pathname}.${c}`, h.href;
          };
        }).call(this);
      }).call(this, typeof cn < "u" ? cn : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 4: [function(e, i, r) {
      function s(l) {
        let f = 0, d = 1;
        const m = l.length;
        let v, E;
        for (; d < m; )
          v = E || l[0], E = l[d], f += (E[0] - v[0]) * (E[1] + v[1]), d++;
        return f > 0;
      }
      function a(l, f) {
        return s(f) || !l.length ? l.push([f]) : l[l.length - 1].push(f), l;
      }
      h.prototype.parsePoint = function(l) {
        return {
          type: "Point",
          coordinates: this.parseCoord(l, 0)
        };
      }, h.prototype.parseZPoint = function(l) {
        const f = this.parsePoint(l);
        return f.coordinates.push(l.readDoubleLE(16)), f;
      }, h.prototype.parsePointArray = function(l, f, d) {
        const m = [];
        let v = 0;
        for (; v < d; )
          m.push(this.parseCoord(l, f)), f += 16, v++;
        return m;
      }, h.prototype.parseZPointArray = function(l, f, d, m) {
        let v = 0;
        for (; v < d; )
          m[v].push(l.readDoubleLE(f)), v++, f += 8;
        return m;
      }, h.prototype.parseArrayGroup = function(l, f, d, m, v) {
        const E = [];
        let _ = 0, p, R = 0, M;
        for (; _ < m; )
          _++, d += 4, p = R, _ === m ? R = v : R = l.readInt32LE(d), M = R - p, M && (E.push(this.parsePointArray(l, f, M)), f += M << 4);
        return E;
      }, h.prototype.parseZArrayGroup = function(l, f, d, m) {
        let v = 0;
        for (; v < d; )
          m[v] = this.parseZPointArray(l, f, m[v].length, m[v]), f += m[v].length << 3, v++;
        return m;
      }, h.prototype.parseMultiPoint = function(l) {
        const f = {}, d = l.readInt32LE(32, !0);
        if (!d)
          return null;
        const m = this.parseCoord(l, 0), v = this.parseCoord(l, 16);
        f.bbox = [
          m[0],
          m[1],
          v[0],
          v[1]
        ];
        const E = 36;
        return d === 1 ? (f.type = "Point", f.coordinates = this.parseCoord(l, E)) : (f.type = "MultiPoint", f.coordinates = this.parsePointArray(l, E, d)), f;
      }, h.prototype.parseZMultiPoint = function(l) {
        const f = this.parseMultiPoint(l);
        if (!f)
          return null;
        let d;
        if (f.type === "Point")
          return f.coordinates.push(l.readDoubleLE(72)), f;
        d = f.coordinates.length;
        const m = 52 + (d << 4);
        return f.coordinates = this.parseZPointArray(l, m, d, f.coordinates), f;
      }, h.prototype.parsePolyline = function(l) {
        const f = {}, d = l.readInt32LE(32);
        if (!d)
          return null;
        const m = this.parseCoord(l, 0), v = this.parseCoord(l, 16);
        f.bbox = [
          m[0],
          m[1],
          v[0],
          v[1]
        ];
        const E = l.readInt32LE(36);
        let _, p;
        return d === 1 ? (f.type = "LineString", _ = 44, f.coordinates = this.parsePointArray(l, _, E)) : (f.type = "MultiLineString", _ = 40 + (d << 2), p = 40, f.coordinates = this.parseArrayGroup(l, _, p, d, E)), f;
      }, h.prototype.parseZPolyline = function(l) {
        const f = this.parsePolyline(l);
        if (!f)
          return null;
        const d = f.coordinates.length;
        let m;
        return f.type === "LineString" ? (m = 60 + (d << 4), f.coordinates = this.parseZPointArray(l, m, d, f.coordinates), f) : (m = 56 + (f.coordinates.reduce(function(E, _) {
          return E + _.length;
        }, 0) << 4) + (d << 2), f.coordinates = this.parseZArrayGroup(l, m, d, f.coordinates), f);
      }, h.prototype.polyFuncs = function(l) {
        return l && (l.type === "LineString" ? (l.type = "Polygon", l.coordinates = [l.coordinates], l) : (l.coordinates = l.coordinates.reduce(a, []), l.coordinates.length === 1 ? (l.type = "Polygon", l.coordinates = l.coordinates[0], l) : (l.type = "MultiPolygon", l)));
      }, h.prototype.parsePolygon = function(l) {
        return this.polyFuncs(this.parsePolyline(l));
      }, h.prototype.parseZPolygon = function(l) {
        return this.polyFuncs(this.parseZPolyline(l));
      };
      const o = {
        1: "parsePoint",
        3: "parsePolyline",
        5: "parsePolygon",
        8: "parseMultiPoint",
        11: "parseZPoint",
        13: "parseZPolyline",
        15: "parseZPolygon",
        18: "parseZMultiPoint"
      };
      function c(l) {
        return l ? function(f, d) {
          const m = [f.readDoubleLE(d), f.readDoubleLE(d + 8)];
          return l.inverse(m);
        } : function(f, d) {
          return [f.readDoubleLE(d), f.readDoubleLE(d + 8)];
        };
      }
      function h(l, f) {
        if (!(this instanceof h))
          return new h(l, f);
        this.buffer = l, this.headers = this.parseHeader(), this.headers.length < this.buffer.byteLength && (this.buffer = this.buffer.slice(0, this.headers.length)), this.shpFuncs(f), this.rows = this.getRows();
      }
      h.prototype.shpFuncs = function(l) {
        let f = this.headers.shpCode;
        if (f > 20 && (f -= 20), !(f in o))
          throw new Error("I don't know that shp type");
        this.parseFunc = this[o[f]], this.parseCoord = c(l);
      }, h.prototype.getShpCode = function() {
        return this.parseHeader().shpCode;
      }, h.prototype.parseHeader = function() {
        const l = this.buffer.slice(0, 100);
        return {
          length: l.readInt32BE(24) << 1,
          version: l.readInt32LE(28),
          shpCode: l.readInt32LE(32),
          bbox: [
            l.readDoubleLE(36),
            l.readDoubleLE(44),
            l.readDoubleLE(52),
            l.readDoubleLE(52)
          ]
        };
      }, h.prototype.getRows = function() {
        let l = 100;
        const f = this.buffer.byteLength, d = [];
        let m;
        for (; l < f && (m = this.getRow(l), !!m); )
          l += 8, l += m.len, m.type ? d.push(this.parseFunc(m.data)) : d.push(null);
        return d;
      }, h.prototype.getRow = function(l) {
        const f = this.buffer.slice(l, l + 12), d = f.readInt32BE(4) << 1, m = f.readInt32BE(0);
        return d === 0 ? {
          id: m,
          len: d,
          type: 0
        } : {
          id: m,
          len: d,
          data: this.buffer.slice(l + 12, l + d + 8),
          type: f.readInt32LE(8)
        };
      }, i.exports = function(l, f) {
        return new h(l, f).rows;
      };
    }, {}], 5: [function(e, i, r) {
      const s = e("jszip");
      i.exports = async (a) => {
        const o = new s();
        await o.loadAsync(a);
        const c = o.file(/.+/), h = {};
        return await Promise.all(c.map(async (l) => {
          let f;
          l.name.slice(-3).toLowerCase() === "shp" || l.name.slice(-3).toLowerCase() === "dbf" ? f = await l.async("nodebuffer") : f = await l.async("text"), h[l.name] = f;
        })), h;
      };
    }, { jszip: 11 }], 6: [function(e, i, r) {
      r.byteLength = d, r.toByteArray = v, r.fromByteArray = p;
      for (var s = [], a = [], o = typeof Uint8Array < "u" ? Uint8Array : Array, c = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", h = 0, l = c.length; h < l; ++h)
        s[h] = c[h], a[c.charCodeAt(h)] = h;
      a[45] = 62, a[95] = 63;
      function f(R) {
        var M = R.length;
        if (M % 4 > 0)
          throw new Error("Invalid string. Length must be a multiple of 4");
        var P = R.indexOf("=");
        P === -1 && (P = M);
        var W = P === M ? 0 : 4 - P % 4;
        return [P, W];
      }
      function d(R) {
        var M = f(R), P = M[0], W = M[1];
        return (P + W) * 3 / 4 - W;
      }
      function m(R, M, P) {
        return (M + P) * 3 / 4 - P;
      }
      function v(R) {
        var M, P = f(R), W = P[0], C = P[1], D = new o(m(R, W, C)), N = 0, A = C > 0 ? W - 4 : W, I;
        for (I = 0; I < A; I += 4)
          M = a[R.charCodeAt(I)] << 18 | a[R.charCodeAt(I + 1)] << 12 | a[R.charCodeAt(I + 2)] << 6 | a[R.charCodeAt(I + 3)], D[N++] = M >> 16 & 255, D[N++] = M >> 8 & 255, D[N++] = M & 255;
        return C === 2 && (M = a[R.charCodeAt(I)] << 2 | a[R.charCodeAt(I + 1)] >> 4, D[N++] = M & 255), C === 1 && (M = a[R.charCodeAt(I)] << 10 | a[R.charCodeAt(I + 1)] << 4 | a[R.charCodeAt(I + 2)] >> 2, D[N++] = M >> 8 & 255, D[N++] = M & 255), D;
      }
      function E(R) {
        return s[R >> 18 & 63] + s[R >> 12 & 63] + s[R >> 6 & 63] + s[R & 63];
      }
      function _(R, M, P) {
        for (var W, C = [], D = M; D < P; D += 3)
          W = (R[D] << 16 & 16711680) + (R[D + 1] << 8 & 65280) + (R[D + 2] & 255), C.push(E(W));
        return C.join("");
      }
      function p(R) {
        for (var M, P = R.length, W = P % 3, C = [], D = 16383, N = 0, A = P - W; N < A; N += D)
          C.push(_(R, N, N + D > A ? A : N + D));
        return W === 1 ? (M = R[P - 1], C.push(
          s[M >> 2] + s[M << 4 & 63] + "=="
        )) : W === 2 && (M = (R[P - 2] << 8) + R[P - 1], C.push(
          s[M >> 10] + s[M >> 4 & 63] + s[M << 2 & 63] + "="
        )), C.join("");
      }
    }, {}], 7: [function(e, i, r) {
    }, {}], 8: [function(e, i, r) {
      (function(s) {
        (function() {
          var a = e("base64-js"), o = e("ieee754");
          r.Buffer = f, r.SlowBuffer = W, r.INSPECT_MAX_BYTES = 50;
          var c = 2147483647;
          r.kMaxLength = c, f.TYPED_ARRAY_SUPPORT = h(), !f.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
            "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
          );
          function h() {
            try {
              var y = new Uint8Array(1);
              return y.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
                return 42;
              } }, y.foo() === 42;
            } catch {
              return !1;
            }
          }
          Object.defineProperty(f.prototype, "parent", {
            enumerable: !0,
            get: function() {
              if (f.isBuffer(this))
                return this.buffer;
            }
          }), Object.defineProperty(f.prototype, "offset", {
            enumerable: !0,
            get: function() {
              if (f.isBuffer(this))
                return this.byteOffset;
            }
          });
          function l(y) {
            if (y > c)
              throw new RangeError('The value "' + y + '" is invalid for option "size"');
            var g = new Uint8Array(y);
            return g.__proto__ = f.prototype, g;
          }
          function f(y, g, S) {
            if (typeof y == "number") {
              if (typeof g == "string")
                throw new TypeError(
                  'The "string" argument must be of type string. Received type number'
                );
              return E(y);
            }
            return d(y, g, S);
          }
          typeof Symbol < "u" && Symbol.species != null && f[Symbol.species] === f && Object.defineProperty(f, Symbol.species, {
            value: null,
            configurable: !0,
            enumerable: !1,
            writable: !1
          }), f.poolSize = 8192;
          function d(y, g, S) {
            if (typeof y == "string")
              return _(y, g);
            if (ArrayBuffer.isView(y))
              return p(y);
            if (y == null)
              throw TypeError(
                "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof y
              );
            if (wt(y, ArrayBuffer) || y && wt(y.buffer, ArrayBuffer))
              return R(y, g, S);
            if (typeof y == "number")
              throw new TypeError(
                'The "value" argument must not be of type number. Received type number'
              );
            var O = y.valueOf && y.valueOf();
            if (O != null && O !== y)
              return f.from(O, g, S);
            var Z = M(y);
            if (Z)
              return Z;
            if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof y[Symbol.toPrimitive] == "function")
              return f.from(
                y[Symbol.toPrimitive]("string"),
                g,
                S
              );
            throw new TypeError(
              "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof y
            );
          }
          f.from = function(y, g, S) {
            return d(y, g, S);
          }, f.prototype.__proto__ = Uint8Array.prototype, f.__proto__ = Uint8Array;
          function m(y) {
            if (typeof y != "number")
              throw new TypeError('"size" argument must be of type number');
            if (y < 0)
              throw new RangeError('The value "' + y + '" is invalid for option "size"');
          }
          function v(y, g, S) {
            return m(y), y <= 0 ? l(y) : g !== void 0 ? typeof S == "string" ? l(y).fill(g, S) : l(y).fill(g) : l(y);
          }
          f.alloc = function(y, g, S) {
            return v(y, g, S);
          };
          function E(y) {
            return m(y), l(y < 0 ? 0 : P(y) | 0);
          }
          f.allocUnsafe = function(y) {
            return E(y);
          }, f.allocUnsafeSlow = function(y) {
            return E(y);
          };
          function _(y, g) {
            if ((typeof g != "string" || g === "") && (g = "utf8"), !f.isEncoding(g))
              throw new TypeError("Unknown encoding: " + g);
            var S = C(y, g) | 0, O = l(S), Z = O.write(y, g);
            return Z !== S && (O = O.slice(0, Z)), O;
          }
          function p(y) {
            for (var g = y.length < 0 ? 0 : P(y.length) | 0, S = l(g), O = 0; O < g; O += 1)
              S[O] = y[O] & 255;
            return S;
          }
          function R(y, g, S) {
            if (g < 0 || y.byteLength < g)
              throw new RangeError('"offset" is outside of buffer bounds');
            if (y.byteLength < g + (S || 0))
              throw new RangeError('"length" is outside of buffer bounds');
            var O;
            return g === void 0 && S === void 0 ? O = new Uint8Array(y) : S === void 0 ? O = new Uint8Array(y, g) : O = new Uint8Array(y, g, S), O.__proto__ = f.prototype, O;
          }
          function M(y) {
            if (f.isBuffer(y)) {
              var g = P(y.length) | 0, S = l(g);
              return S.length === 0 || y.copy(S, 0, 0, g), S;
            }
            if (y.length !== void 0)
              return typeof y.length != "number" || Q(y.length) ? l(0) : p(y);
            if (y.type === "Buffer" && Array.isArray(y.data))
              return p(y.data);
          }
          function P(y) {
            if (y >= c)
              throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + c.toString(16) + " bytes");
            return y | 0;
          }
          function W(y) {
            return +y != y && (y = 0), f.alloc(+y);
          }
          f.isBuffer = function(g) {
            return g != null && g._isBuffer === !0 && g !== f.prototype;
          }, f.compare = function(g, S) {
            if (wt(g, Uint8Array) && (g = f.from(g, g.offset, g.byteLength)), wt(S, Uint8Array) && (S = f.from(S, S.offset, S.byteLength)), !f.isBuffer(g) || !f.isBuffer(S))
              throw new TypeError(
                'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
              );
            if (g === S)
              return 0;
            for (var O = g.length, Z = S.length, tt = 0, gt = Math.min(O, Z); tt < gt; ++tt)
              if (g[tt] !== S[tt]) {
                O = g[tt], Z = S[tt];
                break;
              }
            return O < Z ? -1 : Z < O ? 1 : 0;
          }, f.isEncoding = function(g) {
            switch (String(g).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return !0;
              default:
                return !1;
            }
          }, f.concat = function(g, S) {
            if (!Array.isArray(g))
              throw new TypeError('"list" argument must be an Array of Buffers');
            if (g.length === 0)
              return f.alloc(0);
            var O;
            if (S === void 0)
              for (S = 0, O = 0; O < g.length; ++O)
                S += g[O].length;
            var Z = f.allocUnsafe(S), tt = 0;
            for (O = 0; O < g.length; ++O) {
              var gt = g[O];
              if (wt(gt, Uint8Array) && (gt = f.from(gt)), !f.isBuffer(gt))
                throw new TypeError('"list" argument must be an Array of Buffers');
              gt.copy(Z, tt), tt += gt.length;
            }
            return Z;
          };
          function C(y, g) {
            if (f.isBuffer(y))
              return y.length;
            if (ArrayBuffer.isView(y) || wt(y, ArrayBuffer))
              return y.byteLength;
            if (typeof y != "string")
              throw new TypeError(
                'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof y
              );
            var S = y.length, O = arguments.length > 2 && arguments[2] === !0;
            if (!O && S === 0)
              return 0;
            for (var Z = !1; ; )
              switch (g) {
                case "ascii":
                case "latin1":
                case "binary":
                  return S;
                case "utf8":
                case "utf-8":
                  return yt(y).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return S * 2;
                case "hex":
                  return S >>> 1;
                case "base64":
                  return Lt(y).length;
                default:
                  if (Z)
                    return O ? -1 : yt(y).length;
                  g = ("" + g).toLowerCase(), Z = !0;
              }
          }
          f.byteLength = C;
          function D(y, g, S) {
            var O = !1;
            if ((g === void 0 || g < 0) && (g = 0), g > this.length || ((S === void 0 || S > this.length) && (S = this.length), S <= 0) || (S >>>= 0, g >>>= 0, S <= g))
              return "";
            for (y || (y = "utf8"); ; )
              switch (y) {
                case "hex":
                  return F(this, g, S);
                case "utf8":
                case "utf-8":
                  return w(this, g, S);
                case "ascii":
                  return _t(this, g, S);
                case "latin1":
                case "binary":
                  return vt(this, g, S);
                case "base64":
                  return H(this, g, S);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return rt(this, g, S);
                default:
                  if (O)
                    throw new TypeError("Unknown encoding: " + y);
                  y = (y + "").toLowerCase(), O = !0;
              }
          }
          f.prototype._isBuffer = !0;
          function N(y, g, S) {
            var O = y[g];
            y[g] = y[S], y[S] = O;
          }
          f.prototype.swap16 = function() {
            var g = this.length;
            if (g % 2 !== 0)
              throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (var S = 0; S < g; S += 2)
              N(this, S, S + 1);
            return this;
          }, f.prototype.swap32 = function() {
            var g = this.length;
            if (g % 4 !== 0)
              throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (var S = 0; S < g; S += 4)
              N(this, S, S + 3), N(this, S + 1, S + 2);
            return this;
          }, f.prototype.swap64 = function() {
            var g = this.length;
            if (g % 8 !== 0)
              throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (var S = 0; S < g; S += 8)
              N(this, S, S + 7), N(this, S + 1, S + 6), N(this, S + 2, S + 5), N(this, S + 3, S + 4);
            return this;
          }, f.prototype.toString = function() {
            var g = this.length;
            return g === 0 ? "" : arguments.length === 0 ? w(this, 0, g) : D.apply(this, arguments);
          }, f.prototype.toLocaleString = f.prototype.toString, f.prototype.equals = function(g) {
            if (!f.isBuffer(g))
              throw new TypeError("Argument must be a Buffer");
            return this === g ? !0 : f.compare(this, g) === 0;
          }, f.prototype.inspect = function() {
            var g = "", S = r.INSPECT_MAX_BYTES;
            return g = this.toString("hex", 0, S).replace(/(.{2})/g, "$1 ").trim(), this.length > S && (g += " ... "), "<Buffer " + g + ">";
          }, f.prototype.compare = function(g, S, O, Z, tt) {
            if (wt(g, Uint8Array) && (g = f.from(g, g.offset, g.byteLength)), !f.isBuffer(g))
              throw new TypeError(
                'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof g
              );
            if (S === void 0 && (S = 0), O === void 0 && (O = g ? g.length : 0), Z === void 0 && (Z = 0), tt === void 0 && (tt = this.length), S < 0 || O > g.length || Z < 0 || tt > this.length)
              throw new RangeError("out of range index");
            if (Z >= tt && S >= O)
              return 0;
            if (Z >= tt)
              return -1;
            if (S >= O)
              return 1;
            if (S >>>= 0, O >>>= 0, Z >>>= 0, tt >>>= 0, this === g)
              return 0;
            for (var gt = tt - Z, st = O - S, Tt = Math.min(gt, st), Ft = this.slice(Z, tt), ht = g.slice(S, O), It = 0; It < Tt; ++It)
              if (Ft[It] !== ht[It]) {
                gt = Ft[It], st = ht[It];
                break;
              }
            return gt < st ? -1 : st < gt ? 1 : 0;
          };
          function A(y, g, S, O, Z) {
            if (y.length === 0)
              return -1;
            if (typeof S == "string" ? (O = S, S = 0) : S > 2147483647 ? S = 2147483647 : S < -2147483648 && (S = -2147483648), S = +S, Q(S) && (S = Z ? 0 : y.length - 1), S < 0 && (S = y.length + S), S >= y.length) {
              if (Z)
                return -1;
              S = y.length - 1;
            } else if (S < 0)
              if (Z)
                S = 0;
              else
                return -1;
            if (typeof g == "string" && (g = f.from(g, O)), f.isBuffer(g))
              return g.length === 0 ? -1 : I(y, g, S, O, Z);
            if (typeof g == "number")
              return g = g & 255, typeof Uint8Array.prototype.indexOf == "function" ? Z ? Uint8Array.prototype.indexOf.call(y, g, S) : Uint8Array.prototype.lastIndexOf.call(y, g, S) : I(y, [g], S, O, Z);
            throw new TypeError("val must be string, number or Buffer");
          }
          function I(y, g, S, O, Z) {
            var tt = 1, gt = y.length, st = g.length;
            if (O !== void 0 && (O = String(O).toLowerCase(), O === "ucs2" || O === "ucs-2" || O === "utf16le" || O === "utf-16le")) {
              if (y.length < 2 || g.length < 2)
                return -1;
              tt = 2, gt /= 2, st /= 2, S /= 2;
            }
            function Tt(ft, nt) {
              return tt === 1 ? ft[nt] : ft.readUInt16BE(nt * tt);
            }
            var Ft;
            if (Z) {
              var ht = -1;
              for (Ft = S; Ft < gt; Ft++)
                if (Tt(y, Ft) === Tt(g, ht === -1 ? 0 : Ft - ht)) {
                  if (ht === -1 && (ht = Ft), Ft - ht + 1 === st)
                    return ht * tt;
                } else
                  ht !== -1 && (Ft -= Ft - ht), ht = -1;
            } else
              for (S + st > gt && (S = gt - st), Ft = S; Ft >= 0; Ft--) {
                for (var It = !0, z = 0; z < st; z++)
                  if (Tt(y, Ft + z) !== Tt(g, z)) {
                    It = !1;
                    break;
                  }
                if (It)
                  return Ft;
              }
            return -1;
          }
          f.prototype.includes = function(g, S, O) {
            return this.indexOf(g, S, O) !== -1;
          }, f.prototype.indexOf = function(g, S, O) {
            return A(this, g, S, O, !0);
          }, f.prototype.lastIndexOf = function(g, S, O) {
            return A(this, g, S, O, !1);
          };
          function it(y, g, S, O) {
            S = Number(S) || 0;
            var Z = y.length - S;
            O ? (O = Number(O), O > Z && (O = Z)) : O = Z;
            var tt = g.length;
            O > tt / 2 && (O = tt / 2);
            for (var gt = 0; gt < O; ++gt) {
              var st = parseInt(g.substr(gt * 2, 2), 16);
              if (Q(st))
                return gt;
              y[S + gt] = st;
            }
            return gt;
          }
          function V(y, g, S, O) {
            return Wt(yt(g, y.length - S), y, S, O);
          }
          function mt(y, g, S, O) {
            return Wt(Et(g), y, S, O);
          }
          function k(y, g, S, O) {
            return mt(y, g, S, O);
          }
          function B(y, g, S, O) {
            return Wt(Lt(g), y, S, O);
          }
          function G(y, g, S, O) {
            return Wt(Ct(g, y.length - S), y, S, O);
          }
          f.prototype.write = function(g, S, O, Z) {
            if (S === void 0)
              Z = "utf8", O = this.length, S = 0;
            else if (O === void 0 && typeof S == "string")
              Z = S, O = this.length, S = 0;
            else if (isFinite(S))
              S = S >>> 0, isFinite(O) ? (O = O >>> 0, Z === void 0 && (Z = "utf8")) : (Z = O, O = void 0);
            else
              throw new Error(
                "Buffer.write(string, encoding, offset[, length]) is no longer supported"
              );
            var tt = this.length - S;
            if ((O === void 0 || O > tt) && (O = tt), g.length > 0 && (O < 0 || S < 0) || S > this.length)
              throw new RangeError("Attempt to write outside buffer bounds");
            Z || (Z = "utf8");
            for (var gt = !1; ; )
              switch (Z) {
                case "hex":
                  return it(this, g, S, O);
                case "utf8":
                case "utf-8":
                  return V(this, g, S, O);
                case "ascii":
                  return mt(this, g, S, O);
                case "latin1":
                case "binary":
                  return k(this, g, S, O);
                case "base64":
                  return B(this, g, S, O);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return G(this, g, S, O);
                default:
                  if (gt)
                    throw new TypeError("Unknown encoding: " + Z);
                  Z = ("" + Z).toLowerCase(), gt = !0;
              }
          }, f.prototype.toJSON = function() {
            return {
              type: "Buffer",
              data: Array.prototype.slice.call(this._arr || this, 0)
            };
          };
          function H(y, g, S) {
            return g === 0 && S === y.length ? a.fromByteArray(y) : a.fromByteArray(y.slice(g, S));
          }
          function w(y, g, S) {
            S = Math.min(y.length, S);
            for (var O = [], Z = g; Z < S; ) {
              var tt = y[Z], gt = null, st = tt > 239 ? 4 : tt > 223 ? 3 : tt > 191 ? 2 : 1;
              if (Z + st <= S) {
                var Tt, Ft, ht, It;
                switch (st) {
                  case 1:
                    tt < 128 && (gt = tt);
                    break;
                  case 2:
                    Tt = y[Z + 1], (Tt & 192) === 128 && (It = (tt & 31) << 6 | Tt & 63, It > 127 && (gt = It));
                    break;
                  case 3:
                    Tt = y[Z + 1], Ft = y[Z + 2], (Tt & 192) === 128 && (Ft & 192) === 128 && (It = (tt & 15) << 12 | (Tt & 63) << 6 | Ft & 63, It > 2047 && (It < 55296 || It > 57343) && (gt = It));
                    break;
                  case 4:
                    Tt = y[Z + 1], Ft = y[Z + 2], ht = y[Z + 3], (Tt & 192) === 128 && (Ft & 192) === 128 && (ht & 192) === 128 && (It = (tt & 15) << 18 | (Tt & 63) << 12 | (Ft & 63) << 6 | ht & 63, It > 65535 && It < 1114112 && (gt = It));
                }
              }
              gt === null ? (gt = 65533, st = 1) : gt > 65535 && (gt -= 65536, O.push(gt >>> 10 & 1023 | 55296), gt = 56320 | gt & 1023), O.push(gt), Z += st;
            }
            return pt(O);
          }
          var ut = 4096;
          function pt(y) {
            var g = y.length;
            if (g <= ut)
              return String.fromCharCode.apply(String, y);
            for (var S = "", O = 0; O < g; )
              S += String.fromCharCode.apply(
                String,
                y.slice(O, O += ut)
              );
            return S;
          }
          function _t(y, g, S) {
            var O = "";
            S = Math.min(y.length, S);
            for (var Z = g; Z < S; ++Z)
              O += String.fromCharCode(y[Z] & 127);
            return O;
          }
          function vt(y, g, S) {
            var O = "";
            S = Math.min(y.length, S);
            for (var Z = g; Z < S; ++Z)
              O += String.fromCharCode(y[Z]);
            return O;
          }
          function F(y, g, S) {
            var O = y.length;
            (!g || g < 0) && (g = 0), (!S || S < 0 || S > O) && (S = O);
            for (var Z = "", tt = g; tt < S; ++tt)
              Z += K(y[tt]);
            return Z;
          }
          function rt(y, g, S) {
            for (var O = y.slice(g, S), Z = "", tt = 0; tt < O.length; tt += 2)
              Z += String.fromCharCode(O[tt] + O[tt + 1] * 256);
            return Z;
          }
          f.prototype.slice = function(g, S) {
            var O = this.length;
            g = ~~g, S = S === void 0 ? O : ~~S, g < 0 ? (g += O, g < 0 && (g = 0)) : g > O && (g = O), S < 0 ? (S += O, S < 0 && (S = 0)) : S > O && (S = O), S < g && (S = g);
            var Z = this.subarray(g, S);
            return Z.__proto__ = f.prototype, Z;
          };
          function b(y, g, S) {
            if (y % 1 !== 0 || y < 0)
              throw new RangeError("offset is not uint");
            if (y + g > S)
              throw new RangeError("Trying to access beyond buffer length");
          }
          f.prototype.readUIntLE = function(g, S, O) {
            g = g >>> 0, S = S >>> 0, O || b(g, S, this.length);
            for (var Z = this[g], tt = 1, gt = 0; ++gt < S && (tt *= 256); )
              Z += this[g + gt] * tt;
            return Z;
          }, f.prototype.readUIntBE = function(g, S, O) {
            g = g >>> 0, S = S >>> 0, O || b(g, S, this.length);
            for (var Z = this[g + --S], tt = 1; S > 0 && (tt *= 256); )
              Z += this[g + --S] * tt;
            return Z;
          }, f.prototype.readUInt8 = function(g, S) {
            return g = g >>> 0, S || b(g, 1, this.length), this[g];
          }, f.prototype.readUInt16LE = function(g, S) {
            return g = g >>> 0, S || b(g, 2, this.length), this[g] | this[g + 1] << 8;
          }, f.prototype.readUInt16BE = function(g, S) {
            return g = g >>> 0, S || b(g, 2, this.length), this[g] << 8 | this[g + 1];
          }, f.prototype.readUInt32LE = function(g, S) {
            return g = g >>> 0, S || b(g, 4, this.length), (this[g] | this[g + 1] << 8 | this[g + 2] << 16) + this[g + 3] * 16777216;
          }, f.prototype.readUInt32BE = function(g, S) {
            return g = g >>> 0, S || b(g, 4, this.length), this[g] * 16777216 + (this[g + 1] << 16 | this[g + 2] << 8 | this[g + 3]);
          }, f.prototype.readIntLE = function(g, S, O) {
            g = g >>> 0, S = S >>> 0, O || b(g, S, this.length);
            for (var Z = this[g], tt = 1, gt = 0; ++gt < S && (tt *= 256); )
              Z += this[g + gt] * tt;
            return tt *= 128, Z >= tt && (Z -= Math.pow(2, 8 * S)), Z;
          }, f.prototype.readIntBE = function(g, S, O) {
            g = g >>> 0, S = S >>> 0, O || b(g, S, this.length);
            for (var Z = S, tt = 1, gt = this[g + --Z]; Z > 0 && (tt *= 256); )
              gt += this[g + --Z] * tt;
            return tt *= 128, gt >= tt && (gt -= Math.pow(2, 8 * S)), gt;
          }, f.prototype.readInt8 = function(g, S) {
            return g = g >>> 0, S || b(g, 1, this.length), this[g] & 128 ? (255 - this[g] + 1) * -1 : this[g];
          }, f.prototype.readInt16LE = function(g, S) {
            g = g >>> 0, S || b(g, 2, this.length);
            var O = this[g] | this[g + 1] << 8;
            return O & 32768 ? O | 4294901760 : O;
          }, f.prototype.readInt16BE = function(g, S) {
            g = g >>> 0, S || b(g, 2, this.length);
            var O = this[g + 1] | this[g] << 8;
            return O & 32768 ? O | 4294901760 : O;
          }, f.prototype.readInt32LE = function(g, S) {
            return g = g >>> 0, S || b(g, 4, this.length), this[g] | this[g + 1] << 8 | this[g + 2] << 16 | this[g + 3] << 24;
          }, f.prototype.readInt32BE = function(g, S) {
            return g = g >>> 0, S || b(g, 4, this.length), this[g] << 24 | this[g + 1] << 16 | this[g + 2] << 8 | this[g + 3];
          }, f.prototype.readFloatLE = function(g, S) {
            return g = g >>> 0, S || b(g, 4, this.length), o.read(this, g, !0, 23, 4);
          }, f.prototype.readFloatBE = function(g, S) {
            return g = g >>> 0, S || b(g, 4, this.length), o.read(this, g, !1, 23, 4);
          }, f.prototype.readDoubleLE = function(g, S) {
            return g = g >>> 0, S || b(g, 8, this.length), o.read(this, g, !0, 52, 8);
          }, f.prototype.readDoubleBE = function(g, S) {
            return g = g >>> 0, S || b(g, 8, this.length), o.read(this, g, !1, 52, 8);
          };
          function lt(y, g, S, O, Z, tt) {
            if (!f.isBuffer(y))
              throw new TypeError('"buffer" argument must be a Buffer instance');
            if (g > Z || g < tt)
              throw new RangeError('"value" argument is out of bounds');
            if (S + O > y.length)
              throw new RangeError("Index out of range");
          }
          f.prototype.writeUIntLE = function(g, S, O, Z) {
            if (g = +g, S = S >>> 0, O = O >>> 0, !Z) {
              var tt = Math.pow(2, 8 * O) - 1;
              lt(this, g, S, O, tt, 0);
            }
            var gt = 1, st = 0;
            for (this[S] = g & 255; ++st < O && (gt *= 256); )
              this[S + st] = g / gt & 255;
            return S + O;
          }, f.prototype.writeUIntBE = function(g, S, O, Z) {
            if (g = +g, S = S >>> 0, O = O >>> 0, !Z) {
              var tt = Math.pow(2, 8 * O) - 1;
              lt(this, g, S, O, tt, 0);
            }
            var gt = O - 1, st = 1;
            for (this[S + gt] = g & 255; --gt >= 0 && (st *= 256); )
              this[S + gt] = g / st & 255;
            return S + O;
          }, f.prototype.writeUInt8 = function(g, S, O) {
            return g = +g, S = S >>> 0, O || lt(this, g, S, 1, 255, 0), this[S] = g & 255, S + 1;
          }, f.prototype.writeUInt16LE = function(g, S, O) {
            return g = +g, S = S >>> 0, O || lt(this, g, S, 2, 65535, 0), this[S] = g & 255, this[S + 1] = g >>> 8, S + 2;
          }, f.prototype.writeUInt16BE = function(g, S, O) {
            return g = +g, S = S >>> 0, O || lt(this, g, S, 2, 65535, 0), this[S] = g >>> 8, this[S + 1] = g & 255, S + 2;
          }, f.prototype.writeUInt32LE = function(g, S, O) {
            return g = +g, S = S >>> 0, O || lt(this, g, S, 4, 4294967295, 0), this[S + 3] = g >>> 24, this[S + 2] = g >>> 16, this[S + 1] = g >>> 8, this[S] = g & 255, S + 4;
          }, f.prototype.writeUInt32BE = function(g, S, O) {
            return g = +g, S = S >>> 0, O || lt(this, g, S, 4, 4294967295, 0), this[S] = g >>> 24, this[S + 1] = g >>> 16, this[S + 2] = g >>> 8, this[S + 3] = g & 255, S + 4;
          }, f.prototype.writeIntLE = function(g, S, O, Z) {
            if (g = +g, S = S >>> 0, !Z) {
              var tt = Math.pow(2, 8 * O - 1);
              lt(this, g, S, O, tt - 1, -tt);
            }
            var gt = 0, st = 1, Tt = 0;
            for (this[S] = g & 255; ++gt < O && (st *= 256); )
              g < 0 && Tt === 0 && this[S + gt - 1] !== 0 && (Tt = 1), this[S + gt] = (g / st >> 0) - Tt & 255;
            return S + O;
          }, f.prototype.writeIntBE = function(g, S, O, Z) {
            if (g = +g, S = S >>> 0, !Z) {
              var tt = Math.pow(2, 8 * O - 1);
              lt(this, g, S, O, tt - 1, -tt);
            }
            var gt = O - 1, st = 1, Tt = 0;
            for (this[S + gt] = g & 255; --gt >= 0 && (st *= 256); )
              g < 0 && Tt === 0 && this[S + gt + 1] !== 0 && (Tt = 1), this[S + gt] = (g / st >> 0) - Tt & 255;
            return S + O;
          }, f.prototype.writeInt8 = function(g, S, O) {
            return g = +g, S = S >>> 0, O || lt(this, g, S, 1, 127, -128), g < 0 && (g = 255 + g + 1), this[S] = g & 255, S + 1;
          }, f.prototype.writeInt16LE = function(g, S, O) {
            return g = +g, S = S >>> 0, O || lt(this, g, S, 2, 32767, -32768), this[S] = g & 255, this[S + 1] = g >>> 8, S + 2;
          }, f.prototype.writeInt16BE = function(g, S, O) {
            return g = +g, S = S >>> 0, O || lt(this, g, S, 2, 32767, -32768), this[S] = g >>> 8, this[S + 1] = g & 255, S + 2;
          }, f.prototype.writeInt32LE = function(g, S, O) {
            return g = +g, S = S >>> 0, O || lt(this, g, S, 4, 2147483647, -2147483648), this[S] = g & 255, this[S + 1] = g >>> 8, this[S + 2] = g >>> 16, this[S + 3] = g >>> 24, S + 4;
          }, f.prototype.writeInt32BE = function(g, S, O) {
            return g = +g, S = S >>> 0, O || lt(this, g, S, 4, 2147483647, -2147483648), g < 0 && (g = 4294967295 + g + 1), this[S] = g >>> 24, this[S + 1] = g >>> 16, this[S + 2] = g >>> 8, this[S + 3] = g & 255, S + 4;
          };
          function q(y, g, S, O, Z, tt) {
            if (S + O > y.length)
              throw new RangeError("Index out of range");
            if (S < 0)
              throw new RangeError("Index out of range");
          }
          function U(y, g, S, O, Z) {
            return g = +g, S = S >>> 0, Z || q(y, g, S, 4), o.write(y, g, S, O, 23, 4), S + 4;
          }
          f.prototype.writeFloatLE = function(g, S, O) {
            return U(this, g, S, !0, O);
          }, f.prototype.writeFloatBE = function(g, S, O) {
            return U(this, g, S, !1, O);
          };
          function L(y, g, S, O, Z) {
            return g = +g, S = S >>> 0, Z || q(y, g, S, 8), o.write(y, g, S, O, 52, 8), S + 8;
          }
          f.prototype.writeDoubleLE = function(g, S, O) {
            return L(this, g, S, !0, O);
          }, f.prototype.writeDoubleBE = function(g, S, O) {
            return L(this, g, S, !1, O);
          }, f.prototype.copy = function(g, S, O, Z) {
            if (!f.isBuffer(g))
              throw new TypeError("argument should be a Buffer");
            if (O || (O = 0), !Z && Z !== 0 && (Z = this.length), S >= g.length && (S = g.length), S || (S = 0), Z > 0 && Z < O && (Z = O), Z === O || g.length === 0 || this.length === 0)
              return 0;
            if (S < 0)
              throw new RangeError("targetStart out of bounds");
            if (O < 0 || O >= this.length)
              throw new RangeError("Index out of range");
            if (Z < 0)
              throw new RangeError("sourceEnd out of bounds");
            Z > this.length && (Z = this.length), g.length - S < Z - O && (Z = g.length - S + O);
            var tt = Z - O;
            if (this === g && typeof Uint8Array.prototype.copyWithin == "function")
              this.copyWithin(S, O, Z);
            else if (this === g && O < S && S < Z)
              for (var gt = tt - 1; gt >= 0; --gt)
                g[gt + S] = this[gt + O];
            else
              Uint8Array.prototype.set.call(
                g,
                this.subarray(O, Z),
                S
              );
            return tt;
          }, f.prototype.fill = function(g, S, O, Z) {
            if (typeof g == "string") {
              if (typeof S == "string" ? (Z = S, S = 0, O = this.length) : typeof O == "string" && (Z = O, O = this.length), Z !== void 0 && typeof Z != "string")
                throw new TypeError("encoding must be a string");
              if (typeof Z == "string" && !f.isEncoding(Z))
                throw new TypeError("Unknown encoding: " + Z);
              if (g.length === 1) {
                var tt = g.charCodeAt(0);
                (Z === "utf8" && tt < 128 || Z === "latin1") && (g = tt);
              }
            } else
              typeof g == "number" && (g = g & 255);
            if (S < 0 || this.length < S || this.length < O)
              throw new RangeError("Out of range index");
            if (O <= S)
              return this;
            S = S >>> 0, O = O === void 0 ? this.length : O >>> 0, g || (g = 0);
            var gt;
            if (typeof g == "number")
              for (gt = S; gt < O; ++gt)
                this[gt] = g;
            else {
              var st = f.isBuffer(g) ? g : f.from(g, Z), Tt = st.length;
              if (Tt === 0)
                throw new TypeError('The value "' + g + '" is invalid for argument "value"');
              for (gt = 0; gt < O - S; ++gt)
                this[gt + S] = st[gt % Tt];
            }
            return this;
          };
          var j = /[^+/0-9A-Za-z-_]/g;
          function Y(y) {
            if (y = y.split("=")[0], y = y.trim().replace(j, ""), y.length < 2)
              return "";
            for (; y.length % 4 !== 0; )
              y = y + "=";
            return y;
          }
          function K(y) {
            return y < 16 ? "0" + y.toString(16) : y.toString(16);
          }
          function yt(y, g) {
            g = g || 1 / 0;
            for (var S, O = y.length, Z = null, tt = [], gt = 0; gt < O; ++gt) {
              if (S = y.charCodeAt(gt), S > 55295 && S < 57344) {
                if (!Z) {
                  if (S > 56319) {
                    (g -= 3) > -1 && tt.push(239, 191, 189);
                    continue;
                  } else if (gt + 1 === O) {
                    (g -= 3) > -1 && tt.push(239, 191, 189);
                    continue;
                  }
                  Z = S;
                  continue;
                }
                if (S < 56320) {
                  (g -= 3) > -1 && tt.push(239, 191, 189), Z = S;
                  continue;
                }
                S = (Z - 55296 << 10 | S - 56320) + 65536;
              } else
                Z && (g -= 3) > -1 && tt.push(239, 191, 189);
              if (Z = null, S < 128) {
                if ((g -= 1) < 0)
                  break;
                tt.push(S);
              } else if (S < 2048) {
                if ((g -= 2) < 0)
                  break;
                tt.push(
                  S >> 6 | 192,
                  S & 63 | 128
                );
              } else if (S < 65536) {
                if ((g -= 3) < 0)
                  break;
                tt.push(
                  S >> 12 | 224,
                  S >> 6 & 63 | 128,
                  S & 63 | 128
                );
              } else if (S < 1114112) {
                if ((g -= 4) < 0)
                  break;
                tt.push(
                  S >> 18 | 240,
                  S >> 12 & 63 | 128,
                  S >> 6 & 63 | 128,
                  S & 63 | 128
                );
              } else
                throw new Error("Invalid code point");
            }
            return tt;
          }
          function Et(y) {
            for (var g = [], S = 0; S < y.length; ++S)
              g.push(y.charCodeAt(S) & 255);
            return g;
          }
          function Ct(y, g) {
            for (var S, O, Z, tt = [], gt = 0; gt < y.length && !((g -= 2) < 0); ++gt)
              S = y.charCodeAt(gt), O = S >> 8, Z = S % 256, tt.push(Z), tt.push(O);
            return tt;
          }
          function Lt(y) {
            return a.toByteArray(Y(y));
          }
          function Wt(y, g, S, O) {
            for (var Z = 0; Z < O && !(Z + S >= g.length || Z >= y.length); ++Z)
              g[Z + S] = y[Z];
            return Z;
          }
          function wt(y, g) {
            return y instanceof g || y != null && y.constructor != null && y.constructor.name != null && y.constructor.name === g.name;
          }
          function Q(y) {
            return y !== y;
          }
        }).call(this);
      }).call(this, e("buffer").Buffer);
    }, { "base64-js": 6, buffer: 8, ieee754: 9 }], 9: [function(e, i, r) {
      /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
      r.read = function(s, a, o, c, h) {
        var l, f, d = h * 8 - c - 1, m = (1 << d) - 1, v = m >> 1, E = -7, _ = o ? h - 1 : 0, p = o ? -1 : 1, R = s[a + _];
        for (_ += p, l = R & (1 << -E) - 1, R >>= -E, E += d; E > 0; l = l * 256 + s[a + _], _ += p, E -= 8)
          ;
        for (f = l & (1 << -E) - 1, l >>= -E, E += c; E > 0; f = f * 256 + s[a + _], _ += p, E -= 8)
          ;
        if (l === 0)
          l = 1 - v;
        else {
          if (l === m)
            return f ? NaN : (R ? -1 : 1) * (1 / 0);
          f = f + Math.pow(2, c), l = l - v;
        }
        return (R ? -1 : 1) * f * Math.pow(2, l - c);
      }, r.write = function(s, a, o, c, h, l) {
        var f, d, m, v = l * 8 - h - 1, E = (1 << v) - 1, _ = E >> 1, p = h === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, R = c ? 0 : l - 1, M = c ? 1 : -1, P = a < 0 || a === 0 && 1 / a < 0 ? 1 : 0;
        for (a = Math.abs(a), isNaN(a) || a === 1 / 0 ? (d = isNaN(a) ? 1 : 0, f = E) : (f = Math.floor(Math.log(a) / Math.LN2), a * (m = Math.pow(2, -f)) < 1 && (f--, m *= 2), f + _ >= 1 ? a += p / m : a += p * Math.pow(2, 1 - _), a * m >= 2 && (f++, m /= 2), f + _ >= E ? (d = 0, f = E) : f + _ >= 1 ? (d = (a * m - 1) * Math.pow(2, h), f = f + _) : (d = a * Math.pow(2, _ - 1) * Math.pow(2, h), f = 0)); h >= 8; s[o + R] = d & 255, R += M, d /= 256, h -= 8)
          ;
        for (f = f << h | d, v += h; v > 0; s[o + R] = f & 255, R += M, f /= 256, v -= 8)
          ;
        s[o + R - M] |= P * 128;
      };
    }, {}], 10: [function(e, i, r) {
      (function(s) {
        (function() {
          var a = s.MutationObserver || s.WebKitMutationObserver, o;
          if (a) {
            var c = 0, h = new a(v), l = s.document.createTextNode("");
            h.observe(l, {
              characterData: !0
            }), o = function() {
              l.data = c = ++c % 2;
            };
          } else if (!s.setImmediate && typeof s.MessageChannel < "u") {
            var f = new s.MessageChannel();
            f.port1.onmessage = v, o = function() {
              f.port2.postMessage(0);
            };
          } else
            "document" in s && "onreadystatechange" in s.document.createElement("script") ? o = function() {
              var _ = s.document.createElement("script");
              _.onreadystatechange = function() {
                v(), _.onreadystatechange = null, _.parentNode.removeChild(_), _ = null;
              }, s.document.documentElement.appendChild(_);
            } : o = function() {
              setTimeout(v, 0);
            };
          var d, m = [];
          function v() {
            d = !0;
            for (var _, p, R = m.length; R; ) {
              for (p = m, m = [], _ = -1; ++_ < R; )
                p[_]();
              R = m.length;
            }
            d = !1;
          }
          i.exports = E;
          function E(_) {
            m.push(_) === 1 && !d && o();
          }
        }).call(this);
      }).call(this, typeof cn < "u" ? cn : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 11: [function(e, i, r) {
      (function(s, a, o) {
        (function() {
          /*!
          
          	JSZip v3.6.0 - A JavaScript class for generating and reading zip files
          	<http://stuartk.com/jszip>
          
          	(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
          	Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.
          
          	JSZip uses the library pako released under the MIT license :
          	https://github.com/nodeca/pako/blob/master/LICENSE
          	*/
          (function(c) {
            typeof r == "object" && typeof i < "u" ? i.exports = c() : (typeof window < "u" ? window : typeof s < "u" ? s : typeof self < "u" ? self : this).JSZip = c();
          })(function() {
            return function c(h, l, f) {
              function d(E, _) {
                if (!l[E]) {
                  if (!h[E]) {
                    var p = typeof e == "function" && e;
                    if (!_ && p)
                      return p(E, !0);
                    if (m)
                      return m(E, !0);
                    var R = new Error("Cannot find module '" + E + "'");
                    throw R.code = "MODULE_NOT_FOUND", R;
                  }
                  var M = l[E] = { exports: {} };
                  h[E][0].call(M.exports, function(P) {
                    var W = h[E][1][P];
                    return d(W || P);
                  }, M, M.exports, c, h, l, f);
                }
                return l[E].exports;
              }
              for (var m = typeof e == "function" && e, v = 0; v < f.length; v++)
                d(f[v]);
              return d;
            }({ 1: [function(c, h, l) {
              (function(f) {
                (function(d) {
                  typeof l == "object" && h !== void 0 ? h.exports = d() : (typeof window < "u" ? window : f !== void 0 ? f : typeof self < "u" ? self : this).JSZip = d();
                })(function() {
                  return function d(m, v, E) {
                    function _(M, P) {
                      if (!v[M]) {
                        if (!m[M]) {
                          var W = typeof c == "function" && c;
                          if (!P && W)
                            return W(M, !0);
                          if (p)
                            return p(M, !0);
                          var C = new Error("Cannot find module '" + M + "'");
                          throw C.code = "MODULE_NOT_FOUND", C;
                        }
                        var D = v[M] = { exports: {} };
                        m[M][0].call(D.exports, function(N) {
                          return _(m[M][1][N] || N);
                        }, D, D.exports, d, m, v, E);
                      }
                      return v[M].exports;
                    }
                    for (var p = typeof c == "function" && c, R = 0; R < E.length; R++)
                      _(E[R]);
                    return _;
                  }({ 1: [function(d, m, v) {
                    (function(E) {
                      (function(_) {
                        typeof v == "object" && m !== void 0 ? m.exports = _() : (typeof window < "u" ? window : E !== void 0 ? E : typeof self < "u" ? self : this).JSZip = _();
                      })(function() {
                        return function _(p, R, M) {
                          function P(D, N) {
                            if (!R[D]) {
                              if (!p[D]) {
                                var A = typeof d == "function" && d;
                                if (!N && A)
                                  return A(D, !0);
                                if (W)
                                  return W(D, !0);
                                var I = new Error("Cannot find module '" + D + "'");
                                throw I.code = "MODULE_NOT_FOUND", I;
                              }
                              var it = R[D] = { exports: {} };
                              p[D][0].call(it.exports, function(V) {
                                return P(p[D][1][V] || V);
                              }, it, it.exports, _, p, R, M);
                            }
                            return R[D].exports;
                          }
                          for (var W = typeof d == "function" && d, C = 0; C < M.length; C++)
                            P(M[C]);
                          return P;
                        }({ 1: [function(_, p, R) {
                          (function(M) {
                            (function(P) {
                              typeof R == "object" && p !== void 0 ? p.exports = P() : (typeof window < "u" ? window : M !== void 0 ? M : typeof self < "u" ? self : this).JSZip = P();
                            })(function() {
                              return function P(W, C, D) {
                                function N(it, V) {
                                  if (!C[it]) {
                                    if (!W[it]) {
                                      var mt = typeof _ == "function" && _;
                                      if (!V && mt)
                                        return mt(it, !0);
                                      if (A)
                                        return A(it, !0);
                                      var k = new Error("Cannot find module '" + it + "'");
                                      throw k.code = "MODULE_NOT_FOUND", k;
                                    }
                                    var B = C[it] = { exports: {} };
                                    W[it][0].call(B.exports, function(G) {
                                      return N(W[it][1][G] || G);
                                    }, B, B.exports, P, W, C, D);
                                  }
                                  return C[it].exports;
                                }
                                for (var A = typeof _ == "function" && _, I = 0; I < D.length; I++)
                                  N(D[I]);
                                return N;
                              }({ 1: [function(P, W, C) {
                                (function(D) {
                                  (function(N) {
                                    typeof C == "object" && W !== void 0 ? W.exports = N() : (typeof window < "u" ? window : D !== void 0 ? D : typeof self < "u" ? self : this).JSZip = N();
                                  })(function() {
                                    return function N(A, I, it) {
                                      function V(B, G) {
                                        if (!I[B]) {
                                          if (!A[B]) {
                                            var H = typeof P == "function" && P;
                                            if (!G && H)
                                              return H(B, !0);
                                            if (mt)
                                              return mt(B, !0);
                                            var w = new Error("Cannot find module '" + B + "'");
                                            throw w.code = "MODULE_NOT_FOUND", w;
                                          }
                                          var ut = I[B] = { exports: {} };
                                          A[B][0].call(ut.exports, function(pt) {
                                            return V(A[B][1][pt] || pt);
                                          }, ut, ut.exports, N, A, I, it);
                                        }
                                        return I[B].exports;
                                      }
                                      for (var mt = typeof P == "function" && P, k = 0; k < it.length; k++)
                                        V(it[k]);
                                      return V;
                                    }({ 1: [function(N, A, I) {
                                      (function(it) {
                                        (function(V) {
                                          typeof I == "object" && A !== void 0 ? A.exports = V() : (typeof window < "u" ? window : it !== void 0 ? it : typeof self < "u" ? self : this).JSZip = V();
                                        })(function() {
                                          return function V(mt, k, B) {
                                            function G(ut, pt) {
                                              if (!k[ut]) {
                                                if (!mt[ut]) {
                                                  var _t = typeof N == "function" && N;
                                                  if (!pt && _t)
                                                    return _t(ut, !0);
                                                  if (H)
                                                    return H(ut, !0);
                                                  var vt = new Error("Cannot find module '" + ut + "'");
                                                  throw vt.code = "MODULE_NOT_FOUND", vt;
                                                }
                                                var F = k[ut] = { exports: {} };
                                                mt[ut][0].call(F.exports, function(rt) {
                                                  return G(mt[ut][1][rt] || rt);
                                                }, F, F.exports, V, mt, k, B);
                                              }
                                              return k[ut].exports;
                                            }
                                            for (var H = typeof N == "function" && N, w = 0; w < B.length; w++)
                                              G(B[w]);
                                            return G;
                                          }({ 1: [function(V, mt, k) {
                                            var B = V("./utils"), G = V("./support"), H = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                                            k.encode = function(w) {
                                              for (var ut, pt, _t, vt, F, rt, b, lt = [], q = 0, U = w.length, L = U, j = B.getTypeOf(w) !== "string"; q < w.length; )
                                                L = U - q, _t = j ? (ut = w[q++], pt = q < U ? w[q++] : 0, q < U ? w[q++] : 0) : (ut = w.charCodeAt(q++), pt = q < U ? w.charCodeAt(q++) : 0, q < U ? w.charCodeAt(q++) : 0), vt = ut >> 2, F = (3 & ut) << 4 | pt >> 4, rt = 1 < L ? (15 & pt) << 2 | _t >> 6 : 64, b = 2 < L ? 63 & _t : 64, lt.push(H.charAt(vt) + H.charAt(F) + H.charAt(rt) + H.charAt(b));
                                              return lt.join("");
                                            }, k.decode = function(w) {
                                              var ut, pt, _t, vt, F, rt, b = 0, lt = 0;
                                              if (w.substr(0, 5) === "data:")
                                                throw new Error("Invalid base64 input, it looks like a data url.");
                                              var q, U = 3 * (w = w.replace(/[^A-Za-z0-9\+\/\=]/g, "")).length / 4;
                                              if (w.charAt(w.length - 1) === H.charAt(64) && U--, w.charAt(w.length - 2) === H.charAt(64) && U--, U % 1 != 0)
                                                throw new Error("Invalid base64 input, bad content length.");
                                              for (q = G.uint8array ? new Uint8Array(0 | U) : new Array(0 | U); b < w.length; )
                                                ut = H.indexOf(w.charAt(b++)) << 2 | (vt = H.indexOf(w.charAt(b++))) >> 4, pt = (15 & vt) << 4 | (F = H.indexOf(w.charAt(b++))) >> 2, _t = (3 & F) << 6 | (rt = H.indexOf(w.charAt(b++))), q[lt++] = ut, F !== 64 && (q[lt++] = pt), rt !== 64 && (q[lt++] = _t);
                                              return q;
                                            };
                                          }, { "./support": 30, "./utils": 32 }], 2: [function(V, mt, k) {
                                            var B = V("./external"), G = V("./stream/DataWorker"), H = V("./stream/Crc32Probe"), w = V("./stream/DataLengthProbe");
                                            function ut(pt, _t, vt, F, rt) {
                                              this.compressedSize = pt, this.uncompressedSize = _t, this.crc32 = vt, this.compression = F, this.compressedContent = rt;
                                            }
                                            ut.prototype = { getContentWorker: function() {
                                              var pt = new G(B.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new w("data_length")), _t = this;
                                              return pt.on("end", function() {
                                                if (this.streamInfo.data_length !== _t.uncompressedSize)
                                                  throw new Error("Bug : uncompressed data size mismatch");
                                              }), pt;
                                            }, getCompressedWorker: function() {
                                              return new G(B.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
                                            } }, ut.createWorkerFrom = function(pt, _t, vt) {
                                              return pt.pipe(new H()).pipe(new w("uncompressedSize")).pipe(_t.compressWorker(vt)).pipe(new w("compressedSize")).withStreamInfo("compression", _t);
                                            }, mt.exports = ut;
                                          }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(V, mt, k) {
                                            var B = V("./stream/GenericWorker");
                                            k.STORE = { magic: "\0\0", compressWorker: function(G) {
                                              return new B("STORE compression");
                                            }, uncompressWorker: function() {
                                              return new B("STORE decompression");
                                            } }, k.DEFLATE = V("./flate");
                                          }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(V, mt, k) {
                                            var B = V("./utils"), G = function() {
                                              for (var H, w = [], ut = 0; ut < 256; ut++) {
                                                H = ut;
                                                for (var pt = 0; pt < 8; pt++)
                                                  H = 1 & H ? 3988292384 ^ H >>> 1 : H >>> 1;
                                                w[ut] = H;
                                              }
                                              return w;
                                            }();
                                            mt.exports = function(H, w) {
                                              return H !== void 0 && H.length ? B.getTypeOf(H) !== "string" ? function(ut, pt, _t) {
                                                var vt = G, F = 0 + _t;
                                                ut ^= -1;
                                                for (var rt = 0; rt < F; rt++)
                                                  ut = ut >>> 8 ^ vt[255 & (ut ^ pt[rt])];
                                                return -1 ^ ut;
                                              }(0 | w, H, H.length) : function(ut, pt, _t) {
                                                var vt = G, F = 0 + _t;
                                                ut ^= -1;
                                                for (var rt = 0; rt < F; rt++)
                                                  ut = ut >>> 8 ^ vt[255 & (ut ^ pt.charCodeAt(rt))];
                                                return -1 ^ ut;
                                              }(0 | w, H, H.length) : 0;
                                            };
                                          }, { "./utils": 32 }], 5: [function(V, mt, k) {
                                            k.base64 = !1, k.binary = !1, k.dir = !1, k.createFolders = !0, k.date = null, k.compression = null, k.compressionOptions = null, k.comment = null, k.unixPermissions = null, k.dosPermissions = null;
                                          }, {}], 6: [function(V, mt, k) {
                                            var B;
                                            B = typeof Promise < "u" ? Promise : V("lie"), mt.exports = { Promise: B };
                                          }, { lie: 37 }], 7: [function(V, mt, k) {
                                            var B = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", G = V("pako"), H = V("./utils"), w = V("./stream/GenericWorker"), ut = B ? "uint8array" : "array";
                                            function pt(_t, vt) {
                                              w.call(this, "FlateWorker/" + _t), this._pako = null, this._pakoAction = _t, this._pakoOptions = vt, this.meta = {};
                                            }
                                            k.magic = "\b\0", H.inherits(pt, w), pt.prototype.processChunk = function(_t) {
                                              this.meta = _t.meta, this._pako === null && this._createPako(), this._pako.push(H.transformTo(ut, _t.data), !1);
                                            }, pt.prototype.flush = function() {
                                              w.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
                                            }, pt.prototype.cleanUp = function() {
                                              w.prototype.cleanUp.call(this), this._pako = null;
                                            }, pt.prototype._createPako = function() {
                                              this._pako = new G[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
                                              var _t = this;
                                              this._pako.onData = function(vt) {
                                                _t.push({ data: vt, meta: _t.meta });
                                              };
                                            }, k.compressWorker = function(_t) {
                                              return new pt("Deflate", _t);
                                            }, k.uncompressWorker = function() {
                                              return new pt("Inflate", {});
                                            };
                                          }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(V, mt, k) {
                                            function B(F, rt) {
                                              var b, lt = "";
                                              for (b = 0; b < rt; b++)
                                                lt += String.fromCharCode(255 & F), F >>>= 8;
                                              return lt;
                                            }
                                            function G(F, rt, b, lt, q, U) {
                                              var L, j, Y = F.file, K = F.compression, yt = U !== ut.utf8encode, Et = H.transformTo("string", U(Y.name)), Ct = H.transformTo("string", ut.utf8encode(Y.name)), Lt = Y.comment, Wt = H.transformTo("string", U(Lt)), wt = H.transformTo("string", ut.utf8encode(Lt)), Q = Ct.length !== Y.name.length, y = wt.length !== Lt.length, g = "", S = "", O = "", Z = Y.dir, tt = Y.date, gt = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
                                              rt && !b || (gt.crc32 = F.crc32, gt.compressedSize = F.compressedSize, gt.uncompressedSize = F.uncompressedSize);
                                              var st = 0;
                                              rt && (st |= 8), yt || !Q && !y || (st |= 2048);
                                              var Tt, Ft = 0, ht = 0;
                                              Z && (Ft |= 16), q === "UNIX" ? (ht = 798, Ft |= ((Tt = Y.unixPermissions) || (Tt = Z ? 16893 : 33204), (65535 & Tt) << 16)) : (ht = 20, Ft |= 63 & (Y.dosPermissions || 0)), L = tt.getUTCHours(), L <<= 6, L |= tt.getUTCMinutes(), L <<= 5, L |= tt.getUTCSeconds() / 2, j = tt.getUTCFullYear() - 1980, j <<= 4, j |= tt.getUTCMonth() + 1, j <<= 5, j |= tt.getUTCDate(), Q && (g += "up" + B((S = B(1, 1) + B(pt(Et), 4) + Ct).length, 2) + S), y && (g += "uc" + B((O = B(1, 1) + B(pt(Wt), 4) + wt).length, 2) + O);
                                              var It = "";
                                              return It += `
\0`, It += B(st, 2), It += K.magic, It += B(L, 2), It += B(j, 2), It += B(gt.crc32, 4), It += B(gt.compressedSize, 4), It += B(gt.uncompressedSize, 4), It += B(Et.length, 2), It += B(g.length, 2), { fileRecord: _t.LOCAL_FILE_HEADER + It + Et + g, dirRecord: _t.CENTRAL_FILE_HEADER + B(ht, 2) + It + B(Wt.length, 2) + "\0\0\0\0" + B(Ft, 4) + B(lt, 4) + Et + g + Wt };
                                            }
                                            var H = V("../utils"), w = V("../stream/GenericWorker"), ut = V("../utf8"), pt = V("../crc32"), _t = V("../signature");
                                            function vt(F, rt, b, lt) {
                                              w.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = rt, this.zipPlatform = b, this.encodeFileName = lt, this.streamFiles = F, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
                                            }
                                            H.inherits(vt, w), vt.prototype.push = function(F) {
                                              var rt = F.meta.percent || 0, b = this.entriesCount, lt = this._sources.length;
                                              this.accumulate ? this.contentBuffer.push(F) : (this.bytesWritten += F.data.length, w.prototype.push.call(this, { data: F.data, meta: { currentFile: this.currentFile, percent: b ? (rt + 100 * (b - lt - 1)) / b : 100 } }));
                                            }, vt.prototype.openedSource = function(F) {
                                              this.currentSourceOffset = this.bytesWritten, this.currentFile = F.file.name;
                                              var rt = this.streamFiles && !F.file.dir;
                                              if (rt) {
                                                var b = G(F, rt, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
                                                this.push({ data: b.fileRecord, meta: { percent: 0 } });
                                              } else
                                                this.accumulate = !0;
                                            }, vt.prototype.closedSource = function(F) {
                                              this.accumulate = !1;
                                              var rt, b = this.streamFiles && !F.file.dir, lt = G(F, b, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
                                              if (this.dirRecords.push(lt.dirRecord), b)
                                                this.push({ data: (rt = F, _t.DATA_DESCRIPTOR + B(rt.crc32, 4) + B(rt.compressedSize, 4) + B(rt.uncompressedSize, 4)), meta: { percent: 100 } });
                                              else
                                                for (this.push({ data: lt.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
                                                  this.push(this.contentBuffer.shift());
                                              this.currentFile = null;
                                            }, vt.prototype.flush = function() {
                                              for (var F = this.bytesWritten, rt = 0; rt < this.dirRecords.length; rt++)
                                                this.push({ data: this.dirRecords[rt], meta: { percent: 100 } });
                                              var b, lt, q, U, L, j, Y = this.bytesWritten - F, K = (b = this.dirRecords.length, lt = Y, q = F, U = this.zipComment, L = this.encodeFileName, j = H.transformTo("string", L(U)), _t.CENTRAL_DIRECTORY_END + "\0\0\0\0" + B(b, 2) + B(b, 2) + B(lt, 4) + B(q, 4) + B(j.length, 2) + j);
                                              this.push({ data: K, meta: { percent: 100 } });
                                            }, vt.prototype.prepareNextSource = function() {
                                              this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
                                            }, vt.prototype.registerPrevious = function(F) {
                                              this._sources.push(F);
                                              var rt = this;
                                              return F.on("data", function(b) {
                                                rt.processChunk(b);
                                              }), F.on("end", function() {
                                                rt.closedSource(rt.previous.streamInfo), rt._sources.length ? rt.prepareNextSource() : rt.end();
                                              }), F.on("error", function(b) {
                                                rt.error(b);
                                              }), this;
                                            }, vt.prototype.resume = function() {
                                              return !!w.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
                                            }, vt.prototype.error = function(F) {
                                              var rt = this._sources;
                                              if (!w.prototype.error.call(this, F))
                                                return !1;
                                              for (var b = 0; b < rt.length; b++)
                                                try {
                                                  rt[b].error(F);
                                                } catch {
                                                }
                                              return !0;
                                            }, vt.prototype.lock = function() {
                                              w.prototype.lock.call(this);
                                              for (var F = this._sources, rt = 0; rt < F.length; rt++)
                                                F[rt].lock();
                                            }, mt.exports = vt;
                                          }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(V, mt, k) {
                                            var B = V("../compressions"), G = V("./ZipFileWorker");
                                            k.generateWorker = function(H, w, ut) {
                                              var pt = new G(w.streamFiles, ut, w.platform, w.encodeFileName), _t = 0;
                                              try {
                                                H.forEach(function(vt, F) {
                                                  _t++;
                                                  var rt = function(U, L) {
                                                    var j = U || L, Y = B[j];
                                                    if (!Y)
                                                      throw new Error(j + " is not a valid compression method !");
                                                    return Y;
                                                  }(F.options.compression, w.compression), b = F.options.compressionOptions || w.compressionOptions || {}, lt = F.dir, q = F.date;
                                                  F._compressWorker(rt, b).withStreamInfo("file", { name: vt, dir: lt, date: q, comment: F.comment || "", unixPermissions: F.unixPermissions, dosPermissions: F.dosPermissions }).pipe(pt);
                                                }), pt.entriesCount = _t;
                                              } catch (vt) {
                                                pt.error(vt);
                                              }
                                              return pt;
                                            };
                                          }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(V, mt, k) {
                                            function B() {
                                              if (!(this instanceof B))
                                                return new B();
                                              if (arguments.length)
                                                throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
                                              this.files = {}, this.comment = null, this.root = "", this.clone = function() {
                                                var G = new B();
                                                for (var H in this)
                                                  typeof this[H] != "function" && (G[H] = this[H]);
                                                return G;
                                              };
                                            }
                                            (B.prototype = V("./object")).loadAsync = V("./load"), B.support = V("./support"), B.defaults = V("./defaults"), B.version = "3.5.0", B.loadAsync = function(G, H) {
                                              return new B().loadAsync(G, H);
                                            }, B.external = V("./external"), mt.exports = B;
                                          }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(V, mt, k) {
                                            var B = V("./utils"), G = V("./external"), H = V("./utf8"), w = V("./zipEntries"), ut = V("./stream/Crc32Probe"), pt = V("./nodejsUtils");
                                            function _t(vt) {
                                              return new G.Promise(function(F, rt) {
                                                var b = vt.decompressed.getContentWorker().pipe(new ut());
                                                b.on("error", function(lt) {
                                                  rt(lt);
                                                }).on("end", function() {
                                                  b.streamInfo.crc32 !== vt.decompressed.crc32 ? rt(new Error("Corrupted zip : CRC32 mismatch")) : F();
                                                }).resume();
                                              });
                                            }
                                            mt.exports = function(vt, F) {
                                              var rt = this;
                                              return F = B.extend(F || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: H.utf8decode }), pt.isNode && pt.isStream(vt) ? G.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : B.prepareContent("the loaded zip file", vt, !0, F.optimizedBinaryString, F.base64).then(function(b) {
                                                var lt = new w(F);
                                                return lt.load(b), lt;
                                              }).then(function(b) {
                                                var lt = [G.Promise.resolve(b)], q = b.files;
                                                if (F.checkCRC32)
                                                  for (var U = 0; U < q.length; U++)
                                                    lt.push(_t(q[U]));
                                                return G.Promise.all(lt);
                                              }).then(function(b) {
                                                for (var lt = b.shift(), q = lt.files, U = 0; U < q.length; U++) {
                                                  var L = q[U];
                                                  rt.file(L.fileNameStr, L.decompressed, { binary: !0, optimizedBinaryString: !0, date: L.date, dir: L.dir, comment: L.fileCommentStr.length ? L.fileCommentStr : null, unixPermissions: L.unixPermissions, dosPermissions: L.dosPermissions, createFolders: F.createFolders });
                                                }
                                                return lt.zipComment.length && (rt.comment = lt.zipComment), rt;
                                              });
                                            };
                                          }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(V, mt, k) {
                                            var B = V("../utils"), G = V("../stream/GenericWorker");
                                            function H(w, ut) {
                                              G.call(this, "Nodejs stream input adapter for " + w), this._upstreamEnded = !1, this._bindStream(ut);
                                            }
                                            B.inherits(H, G), H.prototype._bindStream = function(w) {
                                              var ut = this;
                                              (this._stream = w).pause(), w.on("data", function(pt) {
                                                ut.push({ data: pt, meta: { percent: 0 } });
                                              }).on("error", function(pt) {
                                                ut.isPaused ? this.generatedError = pt : ut.error(pt);
                                              }).on("end", function() {
                                                ut.isPaused ? ut._upstreamEnded = !0 : ut.end();
                                              });
                                            }, H.prototype.pause = function() {
                                              return !!G.prototype.pause.call(this) && (this._stream.pause(), !0);
                                            }, H.prototype.resume = function() {
                                              return !!G.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
                                            }, mt.exports = H;
                                          }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(V, mt, k) {
                                            var B = V("readable-stream").Readable;
                                            function G(H, w, ut) {
                                              B.call(this, w), this._helper = H;
                                              var pt = this;
                                              H.on("data", function(_t, vt) {
                                                pt.push(_t) || pt._helper.pause(), ut && ut(vt);
                                              }).on("error", function(_t) {
                                                pt.emit("error", _t);
                                              }).on("end", function() {
                                                pt.push(null);
                                              });
                                            }
                                            V("../utils").inherits(G, B), G.prototype._read = function() {
                                              this._helper.resume();
                                            }, mt.exports = G;
                                          }, { "../utils": 32, "readable-stream": 16 }], 14: [function(V, mt, k) {
                                            mt.exports = { isNode: typeof a < "u", newBufferFrom: function(B, G) {
                                              if (a.from && a.from !== Uint8Array.from)
                                                return a.from(B, G);
                                              if (typeof B == "number")
                                                throw new Error('The "data" argument must not be a number');
                                              return new a(B, G);
                                            }, allocBuffer: function(B) {
                                              if (a.alloc)
                                                return a.alloc(B);
                                              var G = new a(B);
                                              return G.fill(0), G;
                                            }, isBuffer: function(B) {
                                              return a.isBuffer(B);
                                            }, isStream: function(B) {
                                              return B && typeof B.on == "function" && typeof B.pause == "function" && typeof B.resume == "function";
                                            } };
                                          }, {}], 15: [function(V, mt, k) {
                                            function B(j, Y, K) {
                                              var yt, Et = w.getTypeOf(Y), Ct = w.extend(K || {}, _t);
                                              Ct.date = Ct.date || /* @__PURE__ */ new Date(), Ct.compression !== null && (Ct.compression = Ct.compression.toUpperCase()), typeof Ct.unixPermissions == "string" && (Ct.unixPermissions = parseInt(Ct.unixPermissions, 8)), Ct.unixPermissions && 16384 & Ct.unixPermissions && (Ct.dir = !0), Ct.dosPermissions && 16 & Ct.dosPermissions && (Ct.dir = !0), Ct.dir && (j = G(j)), Ct.createFolders && (yt = function(Q) {
                                                Q.slice(-1) === "/" && (Q = Q.substring(0, Q.length - 1));
                                                var y = Q.lastIndexOf("/");
                                                return 0 < y ? Q.substring(0, y) : "";
                                              }(j)) && q.call(this, yt, !0);
                                              var Lt, Wt = Et === "string" && Ct.binary === !1 && Ct.base64 === !1;
                                              K && K.binary !== void 0 || (Ct.binary = !Wt), (Y instanceof vt && Y.uncompressedSize === 0 || Ct.dir || !Y || Y.length === 0) && (Ct.base64 = !1, Ct.binary = !0, Y = "", Ct.compression = "STORE", Et = "string"), Lt = Y instanceof vt || Y instanceof ut ? Y : b.isNode && b.isStream(Y) ? new lt(j, Y) : w.prepareContent(j, Y, Ct.binary, Ct.optimizedBinaryString, Ct.base64);
                                              var wt = new F(j, Lt, Ct);
                                              this.files[j] = wt;
                                            }
                                            function G(j) {
                                              return j.slice(-1) !== "/" && (j += "/"), j;
                                            }
                                            var H = V("./utf8"), w = V("./utils"), ut = V("./stream/GenericWorker"), pt = V("./stream/StreamHelper"), _t = V("./defaults"), vt = V("./compressedObject"), F = V("./zipObject"), rt = V("./generate"), b = V("./nodejsUtils"), lt = V("./nodejs/NodejsStreamInputAdapter"), q = function(j, Y) {
                                              return Y = Y !== void 0 ? Y : _t.createFolders, j = G(j), this.files[j] || B.call(this, j, null, { dir: !0, createFolders: Y }), this.files[j];
                                            };
                                            function U(j) {
                                              return Object.prototype.toString.call(j) === "[object RegExp]";
                                            }
                                            var L = { load: function() {
                                              throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
                                            }, forEach: function(j) {
                                              var Y, K, yt;
                                              for (Y in this.files)
                                                this.files.hasOwnProperty(Y) && (yt = this.files[Y], (K = Y.slice(this.root.length, Y.length)) && Y.slice(0, this.root.length) === this.root && j(K, yt));
                                            }, filter: function(j) {
                                              var Y = [];
                                              return this.forEach(function(K, yt) {
                                                j(K, yt) && Y.push(yt);
                                              }), Y;
                                            }, file: function(j, Y, K) {
                                              if (arguments.length !== 1)
                                                return j = this.root + j, B.call(this, j, Y, K), this;
                                              if (U(j)) {
                                                var yt = j;
                                                return this.filter(function(Ct, Lt) {
                                                  return !Lt.dir && yt.test(Ct);
                                                });
                                              }
                                              var Et = this.files[this.root + j];
                                              return Et && !Et.dir ? Et : null;
                                            }, folder: function(j) {
                                              if (!j)
                                                return this;
                                              if (U(j))
                                                return this.filter(function(Et, Ct) {
                                                  return Ct.dir && j.test(Et);
                                                });
                                              var Y = this.root + j, K = q.call(this, Y), yt = this.clone();
                                              return yt.root = K.name, yt;
                                            }, remove: function(j) {
                                              j = this.root + j;
                                              var Y = this.files[j];
                                              if (Y || (j.slice(-1) !== "/" && (j += "/"), Y = this.files[j]), Y && !Y.dir)
                                                delete this.files[j];
                                              else
                                                for (var K = this.filter(function(Et, Ct) {
                                                  return Ct.name.slice(0, j.length) === j;
                                                }), yt = 0; yt < K.length; yt++)
                                                  delete this.files[K[yt].name];
                                              return this;
                                            }, generate: function(j) {
                                              throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
                                            }, generateInternalStream: function(j) {
                                              var Y, K = {};
                                              try {
                                                if ((K = w.extend(j || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: H.utf8encode })).type = K.type.toLowerCase(), K.compression = K.compression.toUpperCase(), K.type === "binarystring" && (K.type = "string"), !K.type)
                                                  throw new Error("No output type specified.");
                                                w.checkSupport(K.type), K.platform !== "darwin" && K.platform !== "freebsd" && K.platform !== "linux" && K.platform !== "sunos" || (K.platform = "UNIX"), K.platform === "win32" && (K.platform = "DOS");
                                                var yt = K.comment || this.comment || "";
                                                Y = rt.generateWorker(this, K, yt);
                                              } catch (Et) {
                                                (Y = new ut("error")).error(Et);
                                              }
                                              return new pt(Y, K.type || "string", K.mimeType);
                                            }, generateAsync: function(j, Y) {
                                              return this.generateInternalStream(j).accumulate(Y);
                                            }, generateNodeStream: function(j, Y) {
                                              return (j = j || {}).type || (j.type = "nodebuffer"), this.generateInternalStream(j).toNodejsStream(Y);
                                            } };
                                            mt.exports = L;
                                          }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(V, mt, k) {
                                            mt.exports = V("stream");
                                          }, { stream: void 0 }], 17: [function(V, mt, k) {
                                            var B = V("./DataReader");
                                            function G(H) {
                                              B.call(this, H);
                                              for (var w = 0; w < this.data.length; w++)
                                                H[w] = 255 & H[w];
                                            }
                                            V("../utils").inherits(G, B), G.prototype.byteAt = function(H) {
                                              return this.data[this.zero + H];
                                            }, G.prototype.lastIndexOfSignature = function(H) {
                                              for (var w = H.charCodeAt(0), ut = H.charCodeAt(1), pt = H.charCodeAt(2), _t = H.charCodeAt(3), vt = this.length - 4; 0 <= vt; --vt)
                                                if (this.data[vt] === w && this.data[vt + 1] === ut && this.data[vt + 2] === pt && this.data[vt + 3] === _t)
                                                  return vt - this.zero;
                                              return -1;
                                            }, G.prototype.readAndCheckSignature = function(H) {
                                              var w = H.charCodeAt(0), ut = H.charCodeAt(1), pt = H.charCodeAt(2), _t = H.charCodeAt(3), vt = this.readData(4);
                                              return w === vt[0] && ut === vt[1] && pt === vt[2] && _t === vt[3];
                                            }, G.prototype.readData = function(H) {
                                              if (this.checkOffset(H), H === 0)
                                                return [];
                                              var w = this.data.slice(this.zero + this.index, this.zero + this.index + H);
                                              return this.index += H, w;
                                            }, mt.exports = G;
                                          }, { "../utils": 32, "./DataReader": 18 }], 18: [function(V, mt, k) {
                                            var B = V("../utils");
                                            function G(H) {
                                              this.data = H, this.length = H.length, this.index = 0, this.zero = 0;
                                            }
                                            G.prototype = { checkOffset: function(H) {
                                              this.checkIndex(this.index + H);
                                            }, checkIndex: function(H) {
                                              if (this.length < this.zero + H || H < 0)
                                                throw new Error("End of data reached (data length = " + this.length + ", asked index = " + H + "). Corrupted zip ?");
                                            }, setIndex: function(H) {
                                              this.checkIndex(H), this.index = H;
                                            }, skip: function(H) {
                                              this.setIndex(this.index + H);
                                            }, byteAt: function(H) {
                                            }, readInt: function(H) {
                                              var w, ut = 0;
                                              for (this.checkOffset(H), w = this.index + H - 1; w >= this.index; w--)
                                                ut = (ut << 8) + this.byteAt(w);
                                              return this.index += H, ut;
                                            }, readString: function(H) {
                                              return B.transformTo("string", this.readData(H));
                                            }, readData: function(H) {
                                            }, lastIndexOfSignature: function(H) {
                                            }, readAndCheckSignature: function(H) {
                                            }, readDate: function() {
                                              var H = this.readInt(4);
                                              return new Date(Date.UTC(1980 + (H >> 25 & 127), (H >> 21 & 15) - 1, H >> 16 & 31, H >> 11 & 31, H >> 5 & 63, (31 & H) << 1));
                                            } }, mt.exports = G;
                                          }, { "../utils": 32 }], 19: [function(V, mt, k) {
                                            var B = V("./Uint8ArrayReader");
                                            function G(H) {
                                              B.call(this, H);
                                            }
                                            V("../utils").inherits(G, B), G.prototype.readData = function(H) {
                                              this.checkOffset(H);
                                              var w = this.data.slice(this.zero + this.index, this.zero + this.index + H);
                                              return this.index += H, w;
                                            }, mt.exports = G;
                                          }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(V, mt, k) {
                                            var B = V("./DataReader");
                                            function G(H) {
                                              B.call(this, H);
                                            }
                                            V("../utils").inherits(G, B), G.prototype.byteAt = function(H) {
                                              return this.data.charCodeAt(this.zero + H);
                                            }, G.prototype.lastIndexOfSignature = function(H) {
                                              return this.data.lastIndexOf(H) - this.zero;
                                            }, G.prototype.readAndCheckSignature = function(H) {
                                              return H === this.readData(4);
                                            }, G.prototype.readData = function(H) {
                                              this.checkOffset(H);
                                              var w = this.data.slice(this.zero + this.index, this.zero + this.index + H);
                                              return this.index += H, w;
                                            }, mt.exports = G;
                                          }, { "../utils": 32, "./DataReader": 18 }], 21: [function(V, mt, k) {
                                            var B = V("./ArrayReader");
                                            function G(H) {
                                              B.call(this, H);
                                            }
                                            V("../utils").inherits(G, B), G.prototype.readData = function(H) {
                                              if (this.checkOffset(H), H === 0)
                                                return new Uint8Array(0);
                                              var w = this.data.subarray(this.zero + this.index, this.zero + this.index + H);
                                              return this.index += H, w;
                                            }, mt.exports = G;
                                          }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(V, mt, k) {
                                            var B = V("../utils"), G = V("../support"), H = V("./ArrayReader"), w = V("./StringReader"), ut = V("./NodeBufferReader"), pt = V("./Uint8ArrayReader");
                                            mt.exports = function(_t) {
                                              var vt = B.getTypeOf(_t);
                                              return B.checkSupport(vt), vt !== "string" || G.uint8array ? vt === "nodebuffer" ? new ut(_t) : G.uint8array ? new pt(B.transformTo("uint8array", _t)) : new H(B.transformTo("array", _t)) : new w(_t);
                                            };
                                          }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(V, mt, k) {
                                            k.LOCAL_FILE_HEADER = "PK", k.CENTRAL_FILE_HEADER = "PK", k.CENTRAL_DIRECTORY_END = "PK", k.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", k.ZIP64_CENTRAL_DIRECTORY_END = "PK", k.DATA_DESCRIPTOR = "PK\x07\b";
                                          }, {}], 24: [function(V, mt, k) {
                                            var B = V("./GenericWorker"), G = V("../utils");
                                            function H(w) {
                                              B.call(this, "ConvertWorker to " + w), this.destType = w;
                                            }
                                            G.inherits(H, B), H.prototype.processChunk = function(w) {
                                              this.push({ data: G.transformTo(this.destType, w.data), meta: w.meta });
                                            }, mt.exports = H;
                                          }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(V, mt, k) {
                                            var B = V("./GenericWorker"), G = V("../crc32");
                                            function H() {
                                              B.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
                                            }
                                            V("../utils").inherits(H, B), H.prototype.processChunk = function(w) {
                                              this.streamInfo.crc32 = G(w.data, this.streamInfo.crc32 || 0), this.push(w);
                                            }, mt.exports = H;
                                          }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(V, mt, k) {
                                            var B = V("../utils"), G = V("./GenericWorker");
                                            function H(w) {
                                              G.call(this, "DataLengthProbe for " + w), this.propName = w, this.withStreamInfo(w, 0);
                                            }
                                            B.inherits(H, G), H.prototype.processChunk = function(w) {
                                              if (w) {
                                                var ut = this.streamInfo[this.propName] || 0;
                                                this.streamInfo[this.propName] = ut + w.data.length;
                                              }
                                              G.prototype.processChunk.call(this, w);
                                            }, mt.exports = H;
                                          }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(V, mt, k) {
                                            var B = V("../utils"), G = V("./GenericWorker");
                                            function H(w) {
                                              G.call(this, "DataWorker");
                                              var ut = this;
                                              this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, w.then(function(pt) {
                                                ut.dataIsReady = !0, ut.data = pt, ut.max = pt && pt.length || 0, ut.type = B.getTypeOf(pt), ut.isPaused || ut._tickAndRepeat();
                                              }, function(pt) {
                                                ut.error(pt);
                                              });
                                            }
                                            B.inherits(H, G), H.prototype.cleanUp = function() {
                                              G.prototype.cleanUp.call(this), this.data = null;
                                            }, H.prototype.resume = function() {
                                              return !!G.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, B.delay(this._tickAndRepeat, [], this)), !0);
                                            }, H.prototype._tickAndRepeat = function() {
                                              this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (B.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
                                            }, H.prototype._tick = function() {
                                              if (this.isPaused || this.isFinished)
                                                return !1;
                                              var w = null, ut = Math.min(this.max, this.index + 16384);
                                              if (this.index >= this.max)
                                                return this.end();
                                              switch (this.type) {
                                                case "string":
                                                  w = this.data.substring(this.index, ut);
                                                  break;
                                                case "uint8array":
                                                  w = this.data.subarray(this.index, ut);
                                                  break;
                                                case "array":
                                                case "nodebuffer":
                                                  w = this.data.slice(this.index, ut);
                                              }
                                              return this.index = ut, this.push({ data: w, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
                                            }, mt.exports = H;
                                          }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(V, mt, k) {
                                            function B(G) {
                                              this.name = G || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
                                            }
                                            B.prototype = { push: function(G) {
                                              this.emit("data", G);
                                            }, end: function() {
                                              if (this.isFinished)
                                                return !1;
                                              this.flush();
                                              try {
                                                this.emit("end"), this.cleanUp(), this.isFinished = !0;
                                              } catch (G) {
                                                this.emit("error", G);
                                              }
                                              return !0;
                                            }, error: function(G) {
                                              return !this.isFinished && (this.isPaused ? this.generatedError = G : (this.isFinished = !0, this.emit("error", G), this.previous && this.previous.error(G), this.cleanUp()), !0);
                                            }, on: function(G, H) {
                                              return this._listeners[G].push(H), this;
                                            }, cleanUp: function() {
                                              this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
                                            }, emit: function(G, H) {
                                              if (this._listeners[G])
                                                for (var w = 0; w < this._listeners[G].length; w++)
                                                  this._listeners[G][w].call(this, H);
                                            }, pipe: function(G) {
                                              return G.registerPrevious(this);
                                            }, registerPrevious: function(G) {
                                              if (this.isLocked)
                                                throw new Error("The stream '" + this + "' has already been used.");
                                              this.streamInfo = G.streamInfo, this.mergeStreamInfo(), this.previous = G;
                                              var H = this;
                                              return G.on("data", function(w) {
                                                H.processChunk(w);
                                              }), G.on("end", function() {
                                                H.end();
                                              }), G.on("error", function(w) {
                                                H.error(w);
                                              }), this;
                                            }, pause: function() {
                                              return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
                                            }, resume: function() {
                                              if (!this.isPaused || this.isFinished)
                                                return !1;
                                              var G = this.isPaused = !1;
                                              return this.generatedError && (this.error(this.generatedError), G = !0), this.previous && this.previous.resume(), !G;
                                            }, flush: function() {
                                            }, processChunk: function(G) {
                                              this.push(G);
                                            }, withStreamInfo: function(G, H) {
                                              return this.extraStreamInfo[G] = H, this.mergeStreamInfo(), this;
                                            }, mergeStreamInfo: function() {
                                              for (var G in this.extraStreamInfo)
                                                this.extraStreamInfo.hasOwnProperty(G) && (this.streamInfo[G] = this.extraStreamInfo[G]);
                                            }, lock: function() {
                                              if (this.isLocked)
                                                throw new Error("The stream '" + this + "' has already been used.");
                                              this.isLocked = !0, this.previous && this.previous.lock();
                                            }, toString: function() {
                                              var G = "Worker " + this.name;
                                              return this.previous ? this.previous + " -> " + G : G;
                                            } }, mt.exports = B;
                                          }, {}], 29: [function(V, mt, k) {
                                            var B = V("../utils"), G = V("./ConvertWorker"), H = V("./GenericWorker"), w = V("../base64"), ut = V("../support"), pt = V("../external"), _t = null;
                                            if (ut.nodestream)
                                              try {
                                                _t = V("../nodejs/NodejsStreamOutputAdapter");
                                              } catch {
                                              }
                                            function vt(F, rt, b) {
                                              var lt = rt;
                                              switch (rt) {
                                                case "blob":
                                                case "arraybuffer":
                                                  lt = "uint8array";
                                                  break;
                                                case "base64":
                                                  lt = "string";
                                              }
                                              try {
                                                this._internalType = lt, this._outputType = rt, this._mimeType = b, B.checkSupport(lt), this._worker = F.pipe(new G(lt)), F.lock();
                                              } catch (q) {
                                                this._worker = new H("error"), this._worker.error(q);
                                              }
                                            }
                                            vt.prototype = { accumulate: function(F) {
                                              return rt = this, b = F, new pt.Promise(function(lt, q) {
                                                var U = [], L = rt._internalType, j = rt._outputType, Y = rt._mimeType;
                                                rt.on("data", function(K, yt) {
                                                  U.push(K), b && b(yt);
                                                }).on("error", function(K) {
                                                  U = [], q(K);
                                                }).on("end", function() {
                                                  try {
                                                    var K = function(yt, Et, Ct) {
                                                      switch (yt) {
                                                        case "blob":
                                                          return B.newBlob(B.transformTo("arraybuffer", Et), Ct);
                                                        case "base64":
                                                          return w.encode(Et);
                                                        default:
                                                          return B.transformTo(yt, Et);
                                                      }
                                                    }(j, function(yt, Et) {
                                                      var Ct, Lt = 0, Wt = null, wt = 0;
                                                      for (Ct = 0; Ct < Et.length; Ct++)
                                                        wt += Et[Ct].length;
                                                      switch (yt) {
                                                        case "string":
                                                          return Et.join("");
                                                        case "array":
                                                          return Array.prototype.concat.apply([], Et);
                                                        case "uint8array":
                                                          for (Wt = new Uint8Array(wt), Ct = 0; Ct < Et.length; Ct++)
                                                            Wt.set(Et[Ct], Lt), Lt += Et[Ct].length;
                                                          return Wt;
                                                        case "nodebuffer":
                                                          return a.concat(Et);
                                                        default:
                                                          throw new Error("concat : unsupported type '" + yt + "'");
                                                      }
                                                    }(L, U), Y);
                                                    lt(K);
                                                  } catch (yt) {
                                                    q(yt);
                                                  }
                                                  U = [];
                                                }).resume();
                                              });
                                              var rt, b;
                                            }, on: function(F, rt) {
                                              var b = this;
                                              return F === "data" ? this._worker.on(F, function(lt) {
                                                rt.call(b, lt.data, lt.meta);
                                              }) : this._worker.on(F, function() {
                                                B.delay(rt, arguments, b);
                                              }), this;
                                            }, resume: function() {
                                              return B.delay(this._worker.resume, [], this._worker), this;
                                            }, pause: function() {
                                              return this._worker.pause(), this;
                                            }, toNodejsStream: function(F) {
                                              if (B.checkSupport("nodestream"), this._outputType !== "nodebuffer")
                                                throw new Error(this._outputType + " is not supported by this method");
                                              return new _t(this, { objectMode: this._outputType !== "nodebuffer" }, F);
                                            } }, mt.exports = vt;
                                          }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(V, mt, k) {
                                            if (k.base64 = !0, k.array = !0, k.string = !0, k.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", k.nodebuffer = typeof a < "u", k.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u")
                                              k.blob = !1;
                                            else {
                                              var B = new ArrayBuffer(0);
                                              try {
                                                k.blob = new Blob([B], { type: "application/zip" }).size === 0;
                                              } catch {
                                                try {
                                                  var G = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
                                                  G.append(B), k.blob = G.getBlob("application/zip").size === 0;
                                                } catch {
                                                  k.blob = !1;
                                                }
                                              }
                                            }
                                            try {
                                              k.nodestream = !!V("readable-stream").Readable;
                                            } catch {
                                              k.nodestream = !1;
                                            }
                                          }, { "readable-stream": 16 }], 31: [function(V, mt, k) {
                                            for (var B = V("./utils"), G = V("./support"), H = V("./nodejsUtils"), w = V("./stream/GenericWorker"), ut = new Array(256), pt = 0; pt < 256; pt++)
                                              ut[pt] = 252 <= pt ? 6 : 248 <= pt ? 5 : 240 <= pt ? 4 : 224 <= pt ? 3 : 192 <= pt ? 2 : 1;
                                            function _t() {
                                              w.call(this, "utf-8 decode"), this.leftOver = null;
                                            }
                                            function vt() {
                                              w.call(this, "utf-8 encode");
                                            }
                                            ut[254] = ut[254] = 1, k.utf8encode = function(F) {
                                              return G.nodebuffer ? H.newBufferFrom(F, "utf-8") : function(rt) {
                                                var b, lt, q, U, L, j = rt.length, Y = 0;
                                                for (U = 0; U < j; U++)
                                                  (64512 & (lt = rt.charCodeAt(U))) == 55296 && U + 1 < j && (64512 & (q = rt.charCodeAt(U + 1))) == 56320 && (lt = 65536 + (lt - 55296 << 10) + (q - 56320), U++), Y += lt < 128 ? 1 : lt < 2048 ? 2 : lt < 65536 ? 3 : 4;
                                                for (b = G.uint8array ? new Uint8Array(Y) : new Array(Y), U = L = 0; L < Y; U++)
                                                  (64512 & (lt = rt.charCodeAt(U))) == 55296 && U + 1 < j && (64512 & (q = rt.charCodeAt(U + 1))) == 56320 && (lt = 65536 + (lt - 55296 << 10) + (q - 56320), U++), lt < 128 ? b[L++] = lt : (lt < 2048 ? b[L++] = 192 | lt >>> 6 : (lt < 65536 ? b[L++] = 224 | lt >>> 12 : (b[L++] = 240 | lt >>> 18, b[L++] = 128 | lt >>> 12 & 63), b[L++] = 128 | lt >>> 6 & 63), b[L++] = 128 | 63 & lt);
                                                return b;
                                              }(F);
                                            }, k.utf8decode = function(F) {
                                              return G.nodebuffer ? B.transformTo("nodebuffer", F).toString("utf-8") : function(rt) {
                                                var b, lt, q, U, L = rt.length, j = new Array(2 * L);
                                                for (b = lt = 0; b < L; )
                                                  if ((q = rt[b++]) < 128)
                                                    j[lt++] = q;
                                                  else if (4 < (U = ut[q]))
                                                    j[lt++] = 65533, b += U - 1;
                                                  else {
                                                    for (q &= U === 2 ? 31 : U === 3 ? 15 : 7; 1 < U && b < L; )
                                                      q = q << 6 | 63 & rt[b++], U--;
                                                    1 < U ? j[lt++] = 65533 : q < 65536 ? j[lt++] = q : (q -= 65536, j[lt++] = 55296 | q >> 10 & 1023, j[lt++] = 56320 | 1023 & q);
                                                  }
                                                return j.length !== lt && (j.subarray ? j = j.subarray(0, lt) : j.length = lt), B.applyFromCharCode(j);
                                              }(F = B.transformTo(G.uint8array ? "uint8array" : "array", F));
                                            }, B.inherits(_t, w), _t.prototype.processChunk = function(F) {
                                              var rt = B.transformTo(G.uint8array ? "uint8array" : "array", F.data);
                                              if (this.leftOver && this.leftOver.length) {
                                                if (G.uint8array) {
                                                  var b = rt;
                                                  (rt = new Uint8Array(b.length + this.leftOver.length)).set(this.leftOver, 0), rt.set(b, this.leftOver.length);
                                                } else
                                                  rt = this.leftOver.concat(rt);
                                                this.leftOver = null;
                                              }
                                              var lt = function(U, L) {
                                                var j;
                                                for ((L = L || U.length) > U.length && (L = U.length), j = L - 1; 0 <= j && (192 & U[j]) == 128; )
                                                  j--;
                                                return j < 0 || j === 0 ? L : j + ut[U[j]] > L ? j : L;
                                              }(rt), q = rt;
                                              lt !== rt.length && (G.uint8array ? (q = rt.subarray(0, lt), this.leftOver = rt.subarray(lt, rt.length)) : (q = rt.slice(0, lt), this.leftOver = rt.slice(lt, rt.length))), this.push({ data: k.utf8decode(q), meta: F.meta });
                                            }, _t.prototype.flush = function() {
                                              this.leftOver && this.leftOver.length && (this.push({ data: k.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
                                            }, k.Utf8DecodeWorker = _t, B.inherits(vt, w), vt.prototype.processChunk = function(F) {
                                              this.push({ data: k.utf8encode(F.data), meta: F.meta });
                                            }, k.Utf8EncodeWorker = vt;
                                          }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(V, mt, k) {
                                            var B = V("./support"), G = V("./base64"), H = V("./nodejsUtils"), w = V("set-immediate-shim"), ut = V("./external");
                                            function pt(lt) {
                                              return lt;
                                            }
                                            function _t(lt, q) {
                                              for (var U = 0; U < lt.length; ++U)
                                                q[U] = 255 & lt.charCodeAt(U);
                                              return q;
                                            }
                                            k.newBlob = function(lt, q) {
                                              k.checkSupport("blob");
                                              try {
                                                return new Blob([lt], { type: q });
                                              } catch {
                                                try {
                                                  var U = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
                                                  return U.append(lt), U.getBlob(q);
                                                } catch {
                                                  throw new Error("Bug : can't construct the Blob.");
                                                }
                                              }
                                            };
                                            var vt = { stringifyByChunk: function(lt, q, U) {
                                              var L = [], j = 0, Y = lt.length;
                                              if (Y <= U)
                                                return String.fromCharCode.apply(null, lt);
                                              for (; j < Y; )
                                                q === "array" || q === "nodebuffer" ? L.push(String.fromCharCode.apply(null, lt.slice(j, Math.min(j + U, Y)))) : L.push(String.fromCharCode.apply(null, lt.subarray(j, Math.min(j + U, Y)))), j += U;
                                              return L.join("");
                                            }, stringifyByChar: function(lt) {
                                              for (var q = "", U = 0; U < lt.length; U++)
                                                q += String.fromCharCode(lt[U]);
                                              return q;
                                            }, applyCanBeUsed: { uint8array: function() {
                                              try {
                                                return B.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
                                              } catch {
                                                return !1;
                                              }
                                            }(), nodebuffer: function() {
                                              try {
                                                return B.nodebuffer && String.fromCharCode.apply(null, H.allocBuffer(1)).length === 1;
                                              } catch {
                                                return !1;
                                              }
                                            }() } };
                                            function F(lt) {
                                              var q = 65536, U = k.getTypeOf(lt), L = !0;
                                              if (U === "uint8array" ? L = vt.applyCanBeUsed.uint8array : U === "nodebuffer" && (L = vt.applyCanBeUsed.nodebuffer), L)
                                                for (; 1 < q; )
                                                  try {
                                                    return vt.stringifyByChunk(lt, U, q);
                                                  } catch {
                                                    q = Math.floor(q / 2);
                                                  }
                                              return vt.stringifyByChar(lt);
                                            }
                                            function rt(lt, q) {
                                              for (var U = 0; U < lt.length; U++)
                                                q[U] = lt[U];
                                              return q;
                                            }
                                            k.applyFromCharCode = F;
                                            var b = {};
                                            b.string = { string: pt, array: function(lt) {
                                              return _t(lt, new Array(lt.length));
                                            }, arraybuffer: function(lt) {
                                              return b.string.uint8array(lt).buffer;
                                            }, uint8array: function(lt) {
                                              return _t(lt, new Uint8Array(lt.length));
                                            }, nodebuffer: function(lt) {
                                              return _t(lt, H.allocBuffer(lt.length));
                                            } }, b.array = { string: F, array: pt, arraybuffer: function(lt) {
                                              return new Uint8Array(lt).buffer;
                                            }, uint8array: function(lt) {
                                              return new Uint8Array(lt);
                                            }, nodebuffer: function(lt) {
                                              return H.newBufferFrom(lt);
                                            } }, b.arraybuffer = { string: function(lt) {
                                              return F(new Uint8Array(lt));
                                            }, array: function(lt) {
                                              return rt(new Uint8Array(lt), new Array(lt.byteLength));
                                            }, arraybuffer: pt, uint8array: function(lt) {
                                              return new Uint8Array(lt);
                                            }, nodebuffer: function(lt) {
                                              return H.newBufferFrom(new Uint8Array(lt));
                                            } }, b.uint8array = { string: F, array: function(lt) {
                                              return rt(lt, new Array(lt.length));
                                            }, arraybuffer: function(lt) {
                                              return lt.buffer;
                                            }, uint8array: pt, nodebuffer: function(lt) {
                                              return H.newBufferFrom(lt);
                                            } }, b.nodebuffer = { string: F, array: function(lt) {
                                              return rt(lt, new Array(lt.length));
                                            }, arraybuffer: function(lt) {
                                              return b.nodebuffer.uint8array(lt).buffer;
                                            }, uint8array: function(lt) {
                                              return rt(lt, new Uint8Array(lt.length));
                                            }, nodebuffer: pt }, k.transformTo = function(lt, q) {
                                              if (q = q || "", !lt)
                                                return q;
                                              k.checkSupport(lt);
                                              var U = k.getTypeOf(q);
                                              return b[U][lt](q);
                                            }, k.getTypeOf = function(lt) {
                                              return typeof lt == "string" ? "string" : Object.prototype.toString.call(lt) === "[object Array]" ? "array" : B.nodebuffer && H.isBuffer(lt) ? "nodebuffer" : B.uint8array && lt instanceof Uint8Array ? "uint8array" : B.arraybuffer && lt instanceof ArrayBuffer ? "arraybuffer" : void 0;
                                            }, k.checkSupport = function(lt) {
                                              if (!B[lt.toLowerCase()])
                                                throw new Error(lt + " is not supported by this platform");
                                            }, k.MAX_VALUE_16BITS = 65535, k.MAX_VALUE_32BITS = -1, k.pretty = function(lt) {
                                              var q, U, L = "";
                                              for (U = 0; U < (lt || "").length; U++)
                                                L += "\\x" + ((q = lt.charCodeAt(U)) < 16 ? "0" : "") + q.toString(16).toUpperCase();
                                              return L;
                                            }, k.delay = function(lt, q, U) {
                                              w(function() {
                                                lt.apply(U || null, q || []);
                                              });
                                            }, k.inherits = function(lt, q) {
                                              function U() {
                                              }
                                              U.prototype = q.prototype, lt.prototype = new U();
                                            }, k.extend = function() {
                                              var lt, q, U = {};
                                              for (lt = 0; lt < arguments.length; lt++)
                                                for (q in arguments[lt])
                                                  arguments[lt].hasOwnProperty(q) && U[q] === void 0 && (U[q] = arguments[lt][q]);
                                              return U;
                                            }, k.prepareContent = function(lt, q, U, L, j) {
                                              return ut.Promise.resolve(q).then(function(Y) {
                                                return B.blob && (Y instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(Y)) !== -1) && typeof FileReader < "u" ? new ut.Promise(function(K, yt) {
                                                  var Et = new FileReader();
                                                  Et.onload = function(Ct) {
                                                    K(Ct.target.result);
                                                  }, Et.onerror = function(Ct) {
                                                    yt(Ct.target.error);
                                                  }, Et.readAsArrayBuffer(Y);
                                                }) : Y;
                                              }).then(function(Y) {
                                                var K, yt = k.getTypeOf(Y);
                                                return yt ? (yt === "arraybuffer" ? Y = k.transformTo("uint8array", Y) : yt === "string" && (j ? Y = G.decode(Y) : U && L !== !0 && (Y = _t(K = Y, B.uint8array ? new Uint8Array(K.length) : new Array(K.length)))), Y) : ut.Promise.reject(new Error("Can't read the data of '" + lt + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
                                              });
                                            };
                                          }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, "set-immediate-shim": 54 }], 33: [function(V, mt, k) {
                                            var B = V("./reader/readerFor"), G = V("./utils"), H = V("./signature"), w = V("./zipEntry"), ut = (V("./utf8"), V("./support"));
                                            function pt(_t) {
                                              this.files = [], this.loadOptions = _t;
                                            }
                                            pt.prototype = { checkSignature: function(_t) {
                                              if (!this.reader.readAndCheckSignature(_t)) {
                                                this.reader.index -= 4;
                                                var vt = this.reader.readString(4);
                                                throw new Error("Corrupted zip or bug: unexpected signature (" + G.pretty(vt) + ", expected " + G.pretty(_t) + ")");
                                              }
                                            }, isSignature: function(_t, vt) {
                                              var F = this.reader.index;
                                              this.reader.setIndex(_t);
                                              var rt = this.reader.readString(4) === vt;
                                              return this.reader.setIndex(F), rt;
                                            }, readBlockEndOfCentral: function() {
                                              this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
                                              var _t = this.reader.readData(this.zipCommentLength), vt = ut.uint8array ? "uint8array" : "array", F = G.transformTo(vt, _t);
                                              this.zipComment = this.loadOptions.decodeFileName(F);
                                            }, readBlockZip64EndOfCentral: function() {
                                              this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
                                              for (var _t, vt, F, rt = this.zip64EndOfCentralSize - 44; 0 < rt; )
                                                _t = this.reader.readInt(2), vt = this.reader.readInt(4), F = this.reader.readData(vt), this.zip64ExtensibleData[_t] = { id: _t, length: vt, value: F };
                                            }, readBlockZip64EndOfCentralLocator: function() {
                                              if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
                                                throw new Error("Multi-volumes zip are not supported");
                                            }, readLocalFiles: function() {
                                              var _t, vt;
                                              for (_t = 0; _t < this.files.length; _t++)
                                                vt = this.files[_t], this.reader.setIndex(vt.localHeaderOffset), this.checkSignature(H.LOCAL_FILE_HEADER), vt.readLocalPart(this.reader), vt.handleUTF8(), vt.processAttributes();
                                            }, readCentralDir: function() {
                                              var _t;
                                              for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(H.CENTRAL_FILE_HEADER); )
                                                (_t = new w({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(_t);
                                              if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
                                                throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
                                            }, readEndOfCentral: function() {
                                              var _t = this.reader.lastIndexOfSignature(H.CENTRAL_DIRECTORY_END);
                                              if (_t < 0)
                                                throw this.isSignature(0, H.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
                                              this.reader.setIndex(_t);
                                              var vt = _t;
                                              if (this.checkSignature(H.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === G.MAX_VALUE_16BITS || this.diskWithCentralDirStart === G.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === G.MAX_VALUE_16BITS || this.centralDirRecords === G.MAX_VALUE_16BITS || this.centralDirSize === G.MAX_VALUE_32BITS || this.centralDirOffset === G.MAX_VALUE_32BITS) {
                                                if (this.zip64 = !0, (_t = this.reader.lastIndexOfSignature(H.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
                                                  throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
                                                if (this.reader.setIndex(_t), this.checkSignature(H.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, H.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(H.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
                                                  throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
                                                this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(H.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
                                              }
                                              var F = this.centralDirOffset + this.centralDirSize;
                                              this.zip64 && (F += 20, F += 12 + this.zip64EndOfCentralSize);
                                              var rt = vt - F;
                                              if (0 < rt)
                                                this.isSignature(vt, H.CENTRAL_FILE_HEADER) || (this.reader.zero = rt);
                                              else if (rt < 0)
                                                throw new Error("Corrupted zip: missing " + Math.abs(rt) + " bytes.");
                                            }, prepareReader: function(_t) {
                                              this.reader = B(_t);
                                            }, load: function(_t) {
                                              this.prepareReader(_t), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
                                            } }, mt.exports = pt;
                                          }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utf8": 31, "./utils": 32, "./zipEntry": 34 }], 34: [function(V, mt, k) {
                                            var B = V("./reader/readerFor"), G = V("./utils"), H = V("./compressedObject"), w = V("./crc32"), ut = V("./utf8"), pt = V("./compressions"), _t = V("./support");
                                            function vt(F, rt) {
                                              this.options = F, this.loadOptions = rt;
                                            }
                                            vt.prototype = { isEncrypted: function() {
                                              return (1 & this.bitFlag) == 1;
                                            }, useUTF8: function() {
                                              return (2048 & this.bitFlag) == 2048;
                                            }, readLocalPart: function(F) {
                                              var rt, b;
                                              if (F.skip(22), this.fileNameLength = F.readInt(2), b = F.readInt(2), this.fileName = F.readData(this.fileNameLength), F.skip(b), this.compressedSize === -1 || this.uncompressedSize === -1)
                                                throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
                                              if ((rt = function(lt) {
                                                for (var q in pt)
                                                  if (pt.hasOwnProperty(q) && pt[q].magic === lt)
                                                    return pt[q];
                                                return null;
                                              }(this.compressionMethod)) === null)
                                                throw new Error("Corrupted zip : compression " + G.pretty(this.compressionMethod) + " unknown (inner file : " + G.transformTo("string", this.fileName) + ")");
                                              this.decompressed = new H(this.compressedSize, this.uncompressedSize, this.crc32, rt, F.readData(this.compressedSize));
                                            }, readCentralPart: function(F) {
                                              this.versionMadeBy = F.readInt(2), F.skip(2), this.bitFlag = F.readInt(2), this.compressionMethod = F.readString(2), this.date = F.readDate(), this.crc32 = F.readInt(4), this.compressedSize = F.readInt(4), this.uncompressedSize = F.readInt(4);
                                              var rt = F.readInt(2);
                                              if (this.extraFieldsLength = F.readInt(2), this.fileCommentLength = F.readInt(2), this.diskNumberStart = F.readInt(2), this.internalFileAttributes = F.readInt(2), this.externalFileAttributes = F.readInt(4), this.localHeaderOffset = F.readInt(4), this.isEncrypted())
                                                throw new Error("Encrypted zip are not supported");
                                              F.skip(rt), this.readExtraFields(F), this.parseZIP64ExtraField(F), this.fileComment = F.readData(this.fileCommentLength);
                                            }, processAttributes: function() {
                                              this.unixPermissions = null, this.dosPermissions = null;
                                              var F = this.versionMadeBy >> 8;
                                              this.dir = !!(16 & this.externalFileAttributes), F == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), F == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
                                            }, parseZIP64ExtraField: function(F) {
                                              if (this.extraFields[1]) {
                                                var rt = B(this.extraFields[1].value);
                                                this.uncompressedSize === G.MAX_VALUE_32BITS && (this.uncompressedSize = rt.readInt(8)), this.compressedSize === G.MAX_VALUE_32BITS && (this.compressedSize = rt.readInt(8)), this.localHeaderOffset === G.MAX_VALUE_32BITS && (this.localHeaderOffset = rt.readInt(8)), this.diskNumberStart === G.MAX_VALUE_32BITS && (this.diskNumberStart = rt.readInt(4));
                                              }
                                            }, readExtraFields: function(F) {
                                              var rt, b, lt, q = F.index + this.extraFieldsLength;
                                              for (this.extraFields || (this.extraFields = {}); F.index + 4 < q; )
                                                rt = F.readInt(2), b = F.readInt(2), lt = F.readData(b), this.extraFields[rt] = { id: rt, length: b, value: lt };
                                              F.setIndex(q);
                                            }, handleUTF8: function() {
                                              var F = _t.uint8array ? "uint8array" : "array";
                                              if (this.useUTF8())
                                                this.fileNameStr = ut.utf8decode(this.fileName), this.fileCommentStr = ut.utf8decode(this.fileComment);
                                              else {
                                                var rt = this.findExtraFieldUnicodePath();
                                                if (rt !== null)
                                                  this.fileNameStr = rt;
                                                else {
                                                  var b = G.transformTo(F, this.fileName);
                                                  this.fileNameStr = this.loadOptions.decodeFileName(b);
                                                }
                                                var lt = this.findExtraFieldUnicodeComment();
                                                if (lt !== null)
                                                  this.fileCommentStr = lt;
                                                else {
                                                  var q = G.transformTo(F, this.fileComment);
                                                  this.fileCommentStr = this.loadOptions.decodeFileName(q);
                                                }
                                              }
                                            }, findExtraFieldUnicodePath: function() {
                                              var F = this.extraFields[28789];
                                              if (F) {
                                                var rt = B(F.value);
                                                return rt.readInt(1) !== 1 || w(this.fileName) !== rt.readInt(4) ? null : ut.utf8decode(rt.readData(F.length - 5));
                                              }
                                              return null;
                                            }, findExtraFieldUnicodeComment: function() {
                                              var F = this.extraFields[25461];
                                              if (F) {
                                                var rt = B(F.value);
                                                return rt.readInt(1) !== 1 || w(this.fileComment) !== rt.readInt(4) ? null : ut.utf8decode(rt.readData(F.length - 5));
                                              }
                                              return null;
                                            } }, mt.exports = vt;
                                          }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(V, mt, k) {
                                            function B(rt, b, lt) {
                                              this.name = rt, this.dir = lt.dir, this.date = lt.date, this.comment = lt.comment, this.unixPermissions = lt.unixPermissions, this.dosPermissions = lt.dosPermissions, this._data = b, this._dataBinary = lt.binary, this.options = { compression: lt.compression, compressionOptions: lt.compressionOptions };
                                            }
                                            var G = V("./stream/StreamHelper"), H = V("./stream/DataWorker"), w = V("./utf8"), ut = V("./compressedObject"), pt = V("./stream/GenericWorker");
                                            B.prototype = { internalStream: function(rt) {
                                              var b = null, lt = "string";
                                              try {
                                                if (!rt)
                                                  throw new Error("No output type specified.");
                                                var q = (lt = rt.toLowerCase()) === "string" || lt === "text";
                                                lt !== "binarystring" && lt !== "text" || (lt = "string"), b = this._decompressWorker();
                                                var U = !this._dataBinary;
                                                U && !q && (b = b.pipe(new w.Utf8EncodeWorker())), !U && q && (b = b.pipe(new w.Utf8DecodeWorker()));
                                              } catch (L) {
                                                (b = new pt("error")).error(L);
                                              }
                                              return new G(b, lt, "");
                                            }, async: function(rt, b) {
                                              return this.internalStream(rt).accumulate(b);
                                            }, nodeStream: function(rt, b) {
                                              return this.internalStream(rt || "nodebuffer").toNodejsStream(b);
                                            }, _compressWorker: function(rt, b) {
                                              if (this._data instanceof ut && this._data.compression.magic === rt.magic)
                                                return this._data.getCompressedWorker();
                                              var lt = this._decompressWorker();
                                              return this._dataBinary || (lt = lt.pipe(new w.Utf8EncodeWorker())), ut.createWorkerFrom(lt, rt, b);
                                            }, _decompressWorker: function() {
                                              return this._data instanceof ut ? this._data.getContentWorker() : this._data instanceof pt ? this._data : new H(this._data);
                                            } };
                                            for (var _t = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], vt = function() {
                                              throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
                                            }, F = 0; F < _t.length; F++)
                                              B.prototype[_t[F]] = vt;
                                            mt.exports = B;
                                          }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(V, mt, k) {
                                            (function(B) {
                                              var G, H, w = B.MutationObserver || B.WebKitMutationObserver;
                                              if (w) {
                                                var ut = 0, pt = new w(rt), _t = B.document.createTextNode("");
                                                pt.observe(_t, { characterData: !0 }), G = function() {
                                                  _t.data = ut = ++ut % 2;
                                                };
                                              } else if (B.setImmediate || B.MessageChannel === void 0)
                                                G = "document" in B && "onreadystatechange" in B.document.createElement("script") ? function() {
                                                  var b = B.document.createElement("script");
                                                  b.onreadystatechange = function() {
                                                    rt(), b.onreadystatechange = null, b.parentNode.removeChild(b), b = null;
                                                  }, B.document.documentElement.appendChild(b);
                                                } : function() {
                                                  setTimeout(rt, 0);
                                                };
                                              else {
                                                var vt = new B.MessageChannel();
                                                vt.port1.onmessage = rt, G = function() {
                                                  vt.port2.postMessage(0);
                                                };
                                              }
                                              var F = [];
                                              function rt() {
                                                var b, lt;
                                                H = !0;
                                                for (var q = F.length; q; ) {
                                                  for (lt = F, F = [], b = -1; ++b < q; )
                                                    lt[b]();
                                                  q = F.length;
                                                }
                                                H = !1;
                                              }
                                              mt.exports = function(b) {
                                                F.push(b) !== 1 || H || G();
                                              };
                                            }).call(this, it !== void 0 ? it : typeof self < "u" ? self : typeof window < "u" ? window : {});
                                          }, {}], 37: [function(V, mt, k) {
                                            var B = V("immediate");
                                            function G() {
                                            }
                                            var H = {}, w = ["REJECTED"], ut = ["FULFILLED"], pt = ["PENDING"];
                                            function _t(q) {
                                              if (typeof q != "function")
                                                throw new TypeError("resolver must be a function");
                                              this.state = pt, this.queue = [], this.outcome = void 0, q !== G && b(this, q);
                                            }
                                            function vt(q, U, L) {
                                              this.promise = q, typeof U == "function" && (this.onFulfilled = U, this.callFulfilled = this.otherCallFulfilled), typeof L == "function" && (this.onRejected = L, this.callRejected = this.otherCallRejected);
                                            }
                                            function F(q, U, L) {
                                              B(function() {
                                                var j;
                                                try {
                                                  j = U(L);
                                                } catch (Y) {
                                                  return H.reject(q, Y);
                                                }
                                                j === q ? H.reject(q, new TypeError("Cannot resolve promise with itself")) : H.resolve(q, j);
                                              });
                                            }
                                            function rt(q) {
                                              var U = q && q.then;
                                              if (q && (typeof q == "object" || typeof q == "function") && typeof U == "function")
                                                return function() {
                                                  U.apply(q, arguments);
                                                };
                                            }
                                            function b(q, U) {
                                              var L = !1;
                                              function j(yt) {
                                                L || (L = !0, H.reject(q, yt));
                                              }
                                              function Y(yt) {
                                                L || (L = !0, H.resolve(q, yt));
                                              }
                                              var K = lt(function() {
                                                U(Y, j);
                                              });
                                              K.status === "error" && j(K.value);
                                            }
                                            function lt(q, U) {
                                              var L = {};
                                              try {
                                                L.value = q(U), L.status = "success";
                                              } catch (j) {
                                                L.status = "error", L.value = j;
                                              }
                                              return L;
                                            }
                                            (mt.exports = _t).prototype.finally = function(q) {
                                              if (typeof q != "function")
                                                return this;
                                              var U = this.constructor;
                                              return this.then(function(L) {
                                                return U.resolve(q()).then(function() {
                                                  return L;
                                                });
                                              }, function(L) {
                                                return U.resolve(q()).then(function() {
                                                  throw L;
                                                });
                                              });
                                            }, _t.prototype.catch = function(q) {
                                              return this.then(null, q);
                                            }, _t.prototype.then = function(q, U) {
                                              if (typeof q != "function" && this.state === ut || typeof U != "function" && this.state === w)
                                                return this;
                                              var L = new this.constructor(G);
                                              return this.state !== pt ? F(L, this.state === ut ? q : U, this.outcome) : this.queue.push(new vt(L, q, U)), L;
                                            }, vt.prototype.callFulfilled = function(q) {
                                              H.resolve(this.promise, q);
                                            }, vt.prototype.otherCallFulfilled = function(q) {
                                              F(this.promise, this.onFulfilled, q);
                                            }, vt.prototype.callRejected = function(q) {
                                              H.reject(this.promise, q);
                                            }, vt.prototype.otherCallRejected = function(q) {
                                              F(this.promise, this.onRejected, q);
                                            }, H.resolve = function(q, U) {
                                              var L = lt(rt, U);
                                              if (L.status === "error")
                                                return H.reject(q, L.value);
                                              var j = L.value;
                                              if (j)
                                                b(q, j);
                                              else {
                                                q.state = ut, q.outcome = U;
                                                for (var Y = -1, K = q.queue.length; ++Y < K; )
                                                  q.queue[Y].callFulfilled(U);
                                              }
                                              return q;
                                            }, H.reject = function(q, U) {
                                              q.state = w, q.outcome = U;
                                              for (var L = -1, j = q.queue.length; ++L < j; )
                                                q.queue[L].callRejected(U);
                                              return q;
                                            }, _t.resolve = function(q) {
                                              return q instanceof this ? q : H.resolve(new this(G), q);
                                            }, _t.reject = function(q) {
                                              var U = new this(G);
                                              return H.reject(U, q);
                                            }, _t.all = function(q) {
                                              var U = this;
                                              if (Object.prototype.toString.call(q) !== "[object Array]")
                                                return this.reject(new TypeError("must be an array"));
                                              var L = q.length, j = !1;
                                              if (!L)
                                                return this.resolve([]);
                                              for (var Y = new Array(L), K = 0, yt = -1, Et = new this(G); ++yt < L; )
                                                Ct(q[yt], yt);
                                              return Et;
                                              function Ct(Lt, Wt) {
                                                U.resolve(Lt).then(function(wt) {
                                                  Y[Wt] = wt, ++K !== L || j || (j = !0, H.resolve(Et, Y));
                                                }, function(wt) {
                                                  j || (j = !0, H.reject(Et, wt));
                                                });
                                              }
                                            }, _t.race = function(q) {
                                              if (Object.prototype.toString.call(q) !== "[object Array]")
                                                return this.reject(new TypeError("must be an array"));
                                              var U = q.length, L = !1;
                                              if (!U)
                                                return this.resolve([]);
                                              for (var j, Y = -1, K = new this(G); ++Y < U; )
                                                j = q[Y], this.resolve(j).then(function(yt) {
                                                  L || (L = !0, H.resolve(K, yt));
                                                }, function(yt) {
                                                  L || (L = !0, H.reject(K, yt));
                                                });
                                              return K;
                                            };
                                          }, { immediate: 36 }], 38: [function(V, mt, k) {
                                            var B = {};
                                            (0, V("./lib/utils/common").assign)(B, V("./lib/deflate"), V("./lib/inflate"), V("./lib/zlib/constants")), mt.exports = B;
                                          }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(V, mt, k) {
                                            var B = V("./zlib/deflate"), G = V("./utils/common"), H = V("./utils/strings"), w = V("./zlib/messages"), ut = V("./zlib/zstream"), pt = Object.prototype.toString, _t = 0, vt = -1, F = 0, rt = 8;
                                            function b(q) {
                                              if (!(this instanceof b))
                                                return new b(q);
                                              this.options = G.assign({ level: vt, method: rt, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: F, to: "" }, q || {});
                                              var U = this.options;
                                              U.raw && 0 < U.windowBits ? U.windowBits = -U.windowBits : U.gzip && 0 < U.windowBits && U.windowBits < 16 && (U.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new ut(), this.strm.avail_out = 0;
                                              var L = B.deflateInit2(this.strm, U.level, U.method, U.windowBits, U.memLevel, U.strategy);
                                              if (L !== _t)
                                                throw new Error(w[L]);
                                              if (U.header && B.deflateSetHeader(this.strm, U.header), U.dictionary) {
                                                var j;
                                                if (j = typeof U.dictionary == "string" ? H.string2buf(U.dictionary) : pt.call(U.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(U.dictionary) : U.dictionary, (L = B.deflateSetDictionary(this.strm, j)) !== _t)
                                                  throw new Error(w[L]);
                                                this._dict_set = !0;
                                              }
                                            }
                                            function lt(q, U) {
                                              var L = new b(U);
                                              if (L.push(q, !0), L.err)
                                                throw L.msg || w[L.err];
                                              return L.result;
                                            }
                                            b.prototype.push = function(q, U) {
                                              var L, j, Y = this.strm, K = this.options.chunkSize;
                                              if (this.ended)
                                                return !1;
                                              j = U === ~~U ? U : U === !0 ? 4 : 0, typeof q == "string" ? Y.input = H.string2buf(q) : pt.call(q) === "[object ArrayBuffer]" ? Y.input = new Uint8Array(q) : Y.input = q, Y.next_in = 0, Y.avail_in = Y.input.length;
                                              do {
                                                if (Y.avail_out === 0 && (Y.output = new G.Buf8(K), Y.next_out = 0, Y.avail_out = K), (L = B.deflate(Y, j)) !== 1 && L !== _t)
                                                  return this.onEnd(L), !(this.ended = !0);
                                                Y.avail_out !== 0 && (Y.avail_in !== 0 || j !== 4 && j !== 2) || (this.options.to === "string" ? this.onData(H.buf2binstring(G.shrinkBuf(Y.output, Y.next_out))) : this.onData(G.shrinkBuf(Y.output, Y.next_out)));
                                              } while ((0 < Y.avail_in || Y.avail_out === 0) && L !== 1);
                                              return j === 4 ? (L = B.deflateEnd(this.strm), this.onEnd(L), this.ended = !0, L === _t) : j !== 2 || (this.onEnd(_t), !(Y.avail_out = 0));
                                            }, b.prototype.onData = function(q) {
                                              this.chunks.push(q);
                                            }, b.prototype.onEnd = function(q) {
                                              q === _t && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = G.flattenChunks(this.chunks)), this.chunks = [], this.err = q, this.msg = this.strm.msg;
                                            }, k.Deflate = b, k.deflate = lt, k.deflateRaw = function(q, U) {
                                              return (U = U || {}).raw = !0, lt(q, U);
                                            }, k.gzip = function(q, U) {
                                              return (U = U || {}).gzip = !0, lt(q, U);
                                            };
                                          }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(V, mt, k) {
                                            var B = V("./zlib/inflate"), G = V("./utils/common"), H = V("./utils/strings"), w = V("./zlib/constants"), ut = V("./zlib/messages"), pt = V("./zlib/zstream"), _t = V("./zlib/gzheader"), vt = Object.prototype.toString;
                                            function F(b) {
                                              if (!(this instanceof F))
                                                return new F(b);
                                              this.options = G.assign({ chunkSize: 16384, windowBits: 0, to: "" }, b || {});
                                              var lt = this.options;
                                              lt.raw && 0 <= lt.windowBits && lt.windowBits < 16 && (lt.windowBits = -lt.windowBits, lt.windowBits === 0 && (lt.windowBits = -15)), !(0 <= lt.windowBits && lt.windowBits < 16) || b && b.windowBits || (lt.windowBits += 32), 15 < lt.windowBits && lt.windowBits < 48 && !(15 & lt.windowBits) && (lt.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new pt(), this.strm.avail_out = 0;
                                              var q = B.inflateInit2(this.strm, lt.windowBits);
                                              if (q !== w.Z_OK)
                                                throw new Error(ut[q]);
                                              this.header = new _t(), B.inflateGetHeader(this.strm, this.header);
                                            }
                                            function rt(b, lt) {
                                              var q = new F(lt);
                                              if (q.push(b, !0), q.err)
                                                throw q.msg || ut[q.err];
                                              return q.result;
                                            }
                                            F.prototype.push = function(b, lt) {
                                              var q, U, L, j, Y, K, yt = this.strm, Et = this.options.chunkSize, Ct = this.options.dictionary, Lt = !1;
                                              if (this.ended)
                                                return !1;
                                              U = lt === ~~lt ? lt : lt === !0 ? w.Z_FINISH : w.Z_NO_FLUSH, typeof b == "string" ? yt.input = H.binstring2buf(b) : vt.call(b) === "[object ArrayBuffer]" ? yt.input = new Uint8Array(b) : yt.input = b, yt.next_in = 0, yt.avail_in = yt.input.length;
                                              do {
                                                if (yt.avail_out === 0 && (yt.output = new G.Buf8(Et), yt.next_out = 0, yt.avail_out = Et), (q = B.inflate(yt, w.Z_NO_FLUSH)) === w.Z_NEED_DICT && Ct && (K = typeof Ct == "string" ? H.string2buf(Ct) : vt.call(Ct) === "[object ArrayBuffer]" ? new Uint8Array(Ct) : Ct, q = B.inflateSetDictionary(this.strm, K)), q === w.Z_BUF_ERROR && Lt === !0 && (q = w.Z_OK, Lt = !1), q !== w.Z_STREAM_END && q !== w.Z_OK)
                                                  return this.onEnd(q), !(this.ended = !0);
                                                yt.next_out && (yt.avail_out !== 0 && q !== w.Z_STREAM_END && (yt.avail_in !== 0 || U !== w.Z_FINISH && U !== w.Z_SYNC_FLUSH) || (this.options.to === "string" ? (L = H.utf8border(yt.output, yt.next_out), j = yt.next_out - L, Y = H.buf2string(yt.output, L), yt.next_out = j, yt.avail_out = Et - j, j && G.arraySet(yt.output, yt.output, L, j, 0), this.onData(Y)) : this.onData(G.shrinkBuf(yt.output, yt.next_out)))), yt.avail_in === 0 && yt.avail_out === 0 && (Lt = !0);
                                              } while ((0 < yt.avail_in || yt.avail_out === 0) && q !== w.Z_STREAM_END);
                                              return q === w.Z_STREAM_END && (U = w.Z_FINISH), U === w.Z_FINISH ? (q = B.inflateEnd(this.strm), this.onEnd(q), this.ended = !0, q === w.Z_OK) : U !== w.Z_SYNC_FLUSH || (this.onEnd(w.Z_OK), !(yt.avail_out = 0));
                                            }, F.prototype.onData = function(b) {
                                              this.chunks.push(b);
                                            }, F.prototype.onEnd = function(b) {
                                              b === w.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = G.flattenChunks(this.chunks)), this.chunks = [], this.err = b, this.msg = this.strm.msg;
                                            }, k.Inflate = F, k.inflate = rt, k.inflateRaw = function(b, lt) {
                                              return (lt = lt || {}).raw = !0, rt(b, lt);
                                            }, k.ungzip = rt;
                                          }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(V, mt, k) {
                                            var B = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
                                            k.assign = function(w) {
                                              for (var ut = Array.prototype.slice.call(arguments, 1); ut.length; ) {
                                                var pt = ut.shift();
                                                if (pt) {
                                                  if (typeof pt != "object")
                                                    throw new TypeError(pt + "must be non-object");
                                                  for (var _t in pt)
                                                    pt.hasOwnProperty(_t) && (w[_t] = pt[_t]);
                                                }
                                              }
                                              return w;
                                            }, k.shrinkBuf = function(w, ut) {
                                              return w.length === ut ? w : w.subarray ? w.subarray(0, ut) : (w.length = ut, w);
                                            };
                                            var G = { arraySet: function(w, ut, pt, _t, vt) {
                                              if (ut.subarray && w.subarray)
                                                w.set(ut.subarray(pt, pt + _t), vt);
                                              else
                                                for (var F = 0; F < _t; F++)
                                                  w[vt + F] = ut[pt + F];
                                            }, flattenChunks: function(w) {
                                              var ut, pt, _t, vt, F, rt;
                                              for (ut = _t = 0, pt = w.length; ut < pt; ut++)
                                                _t += w[ut].length;
                                              for (rt = new Uint8Array(_t), ut = vt = 0, pt = w.length; ut < pt; ut++)
                                                F = w[ut], rt.set(F, vt), vt += F.length;
                                              return rt;
                                            } }, H = { arraySet: function(w, ut, pt, _t, vt) {
                                              for (var F = 0; F < _t; F++)
                                                w[vt + F] = ut[pt + F];
                                            }, flattenChunks: function(w) {
                                              return [].concat.apply([], w);
                                            } };
                                            k.setTyped = function(w) {
                                              w ? (k.Buf8 = Uint8Array, k.Buf16 = Uint16Array, k.Buf32 = Int32Array, k.assign(k, G)) : (k.Buf8 = Array, k.Buf16 = Array, k.Buf32 = Array, k.assign(k, H));
                                            }, k.setTyped(B);
                                          }, {}], 42: [function(V, mt, k) {
                                            var B = V("./common"), G = !0, H = !0;
                                            try {
                                              String.fromCharCode.apply(null, [0]);
                                            } catch {
                                              G = !1;
                                            }
                                            try {
                                              String.fromCharCode.apply(null, new Uint8Array(1));
                                            } catch {
                                              H = !1;
                                            }
                                            for (var w = new B.Buf8(256), ut = 0; ut < 256; ut++)
                                              w[ut] = 252 <= ut ? 6 : 248 <= ut ? 5 : 240 <= ut ? 4 : 224 <= ut ? 3 : 192 <= ut ? 2 : 1;
                                            function pt(_t, vt) {
                                              if (vt < 65537 && (_t.subarray && H || !_t.subarray && G))
                                                return String.fromCharCode.apply(null, B.shrinkBuf(_t, vt));
                                              for (var F = "", rt = 0; rt < vt; rt++)
                                                F += String.fromCharCode(_t[rt]);
                                              return F;
                                            }
                                            w[254] = w[254] = 1, k.string2buf = function(_t) {
                                              var vt, F, rt, b, lt, q = _t.length, U = 0;
                                              for (b = 0; b < q; b++)
                                                (64512 & (F = _t.charCodeAt(b))) == 55296 && b + 1 < q && (64512 & (rt = _t.charCodeAt(b + 1))) == 56320 && (F = 65536 + (F - 55296 << 10) + (rt - 56320), b++), U += F < 128 ? 1 : F < 2048 ? 2 : F < 65536 ? 3 : 4;
                                              for (vt = new B.Buf8(U), b = lt = 0; lt < U; b++)
                                                (64512 & (F = _t.charCodeAt(b))) == 55296 && b + 1 < q && (64512 & (rt = _t.charCodeAt(b + 1))) == 56320 && (F = 65536 + (F - 55296 << 10) + (rt - 56320), b++), F < 128 ? vt[lt++] = F : (F < 2048 ? vt[lt++] = 192 | F >>> 6 : (F < 65536 ? vt[lt++] = 224 | F >>> 12 : (vt[lt++] = 240 | F >>> 18, vt[lt++] = 128 | F >>> 12 & 63), vt[lt++] = 128 | F >>> 6 & 63), vt[lt++] = 128 | 63 & F);
                                              return vt;
                                            }, k.buf2binstring = function(_t) {
                                              return pt(_t, _t.length);
                                            }, k.binstring2buf = function(_t) {
                                              for (var vt = new B.Buf8(_t.length), F = 0, rt = vt.length; F < rt; F++)
                                                vt[F] = _t.charCodeAt(F);
                                              return vt;
                                            }, k.buf2string = function(_t, vt) {
                                              var F, rt, b, lt, q = vt || _t.length, U = new Array(2 * q);
                                              for (F = rt = 0; F < q; )
                                                if ((b = _t[F++]) < 128)
                                                  U[rt++] = b;
                                                else if (4 < (lt = w[b]))
                                                  U[rt++] = 65533, F += lt - 1;
                                                else {
                                                  for (b &= lt === 2 ? 31 : lt === 3 ? 15 : 7; 1 < lt && F < q; )
                                                    b = b << 6 | 63 & _t[F++], lt--;
                                                  1 < lt ? U[rt++] = 65533 : b < 65536 ? U[rt++] = b : (b -= 65536, U[rt++] = 55296 | b >> 10 & 1023, U[rt++] = 56320 | 1023 & b);
                                                }
                                              return pt(U, rt);
                                            }, k.utf8border = function(_t, vt) {
                                              var F;
                                              for ((vt = vt || _t.length) > _t.length && (vt = _t.length), F = vt - 1; 0 <= F && (192 & _t[F]) == 128; )
                                                F--;
                                              return F < 0 || F === 0 ? vt : F + w[_t[F]] > vt ? F : vt;
                                            };
                                          }, { "./common": 41 }], 43: [function(V, mt, k) {
                                            mt.exports = function(B, G, H, w) {
                                              for (var ut = 65535 & B | 0, pt = B >>> 16 & 65535 | 0, _t = 0; H !== 0; ) {
                                                for (H -= _t = 2e3 < H ? 2e3 : H; pt = pt + (ut = ut + G[w++] | 0) | 0, --_t; )
                                                  ;
                                                ut %= 65521, pt %= 65521;
                                              }
                                              return ut | pt << 16 | 0;
                                            };
                                          }, {}], 44: [function(V, mt, k) {
                                            mt.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
                                          }, {}], 45: [function(V, mt, k) {
                                            var B = function() {
                                              for (var G, H = [], w = 0; w < 256; w++) {
                                                G = w;
                                                for (var ut = 0; ut < 8; ut++)
                                                  G = 1 & G ? 3988292384 ^ G >>> 1 : G >>> 1;
                                                H[w] = G;
                                              }
                                              return H;
                                            }();
                                            mt.exports = function(G, H, w, ut) {
                                              var pt = B, _t = ut + w;
                                              G ^= -1;
                                              for (var vt = ut; vt < _t; vt++)
                                                G = G >>> 8 ^ pt[255 & (G ^ H[vt])];
                                              return -1 ^ G;
                                            };
                                          }, {}], 46: [function(V, mt, k) {
                                            var B, G = V("../utils/common"), H = V("./trees"), w = V("./adler32"), ut = V("./crc32"), pt = V("./messages"), _t = 0, vt = 0, F = -2, rt = 2, b = 8, lt = 286, q = 30, U = 19, L = 2 * lt + 1, j = 15, Y = 3, K = 258, yt = K + Y + 1, Et = 42, Ct = 113;
                                            function Lt(z, ft) {
                                              return z.msg = pt[ft], ft;
                                            }
                                            function Wt(z) {
                                              return (z << 1) - (4 < z ? 9 : 0);
                                            }
                                            function wt(z) {
                                              for (var ft = z.length; 0 <= --ft; )
                                                z[ft] = 0;
                                            }
                                            function Q(z) {
                                              var ft = z.state, nt = ft.pending;
                                              nt > z.avail_out && (nt = z.avail_out), nt !== 0 && (G.arraySet(z.output, ft.pending_buf, ft.pending_out, nt, z.next_out), z.next_out += nt, ft.pending_out += nt, z.total_out += nt, z.avail_out -= nt, ft.pending -= nt, ft.pending === 0 && (ft.pending_out = 0));
                                            }
                                            function y(z, ft) {
                                              H._tr_flush_block(z, 0 <= z.block_start ? z.block_start : -1, z.strstart - z.block_start, ft), z.block_start = z.strstart, Q(z.strm);
                                            }
                                            function g(z, ft) {
                                              z.pending_buf[z.pending++] = ft;
                                            }
                                            function S(z, ft) {
                                              z.pending_buf[z.pending++] = ft >>> 8 & 255, z.pending_buf[z.pending++] = 255 & ft;
                                            }
                                            function O(z, ft) {
                                              var nt, J, Rt = z.max_chain_length, Nt = z.strstart, Yt = z.prev_length, Ht = z.nice_match, Pt = z.strstart > z.w_size - yt ? z.strstart - (z.w_size - yt) : 0, Mt = z.window, $t = z.w_mask, Kt = z.prev, te = z.strstart + K, Qt = Mt[Nt + Yt - 1], ee = Mt[Nt + Yt];
                                              z.prev_length >= z.good_match && (Rt >>= 2), Ht > z.lookahead && (Ht = z.lookahead);
                                              do
                                                if (Mt[(nt = ft) + Yt] === ee && Mt[nt + Yt - 1] === Qt && Mt[nt] === Mt[Nt] && Mt[++nt] === Mt[Nt + 1]) {
                                                  Nt += 2, nt++;
                                                  do
                                                    ;
                                                  while (Mt[++Nt] === Mt[++nt] && Mt[++Nt] === Mt[++nt] && Mt[++Nt] === Mt[++nt] && Mt[++Nt] === Mt[++nt] && Mt[++Nt] === Mt[++nt] && Mt[++Nt] === Mt[++nt] && Mt[++Nt] === Mt[++nt] && Mt[++Nt] === Mt[++nt] && Nt < te);
                                                  if (J = K - (te - Nt), Nt = te - K, Yt < J) {
                                                    if (z.match_start = ft, Ht <= (Yt = J))
                                                      break;
                                                    Qt = Mt[Nt + Yt - 1], ee = Mt[Nt + Yt];
                                                  }
                                                }
                                              while ((ft = Kt[ft & $t]) > Pt && --Rt != 0);
                                              return Yt <= z.lookahead ? Yt : z.lookahead;
                                            }
                                            function Z(z) {
                                              var ft, nt, J, Rt, Nt, Yt, Ht, Pt, Mt, $t, Kt = z.w_size;
                                              do {
                                                if (Rt = z.window_size - z.lookahead - z.strstart, z.strstart >= Kt + (Kt - yt)) {
                                                  for (G.arraySet(z.window, z.window, Kt, Kt, 0), z.match_start -= Kt, z.strstart -= Kt, z.block_start -= Kt, ft = nt = z.hash_size; J = z.head[--ft], z.head[ft] = Kt <= J ? J - Kt : 0, --nt; )
                                                    ;
                                                  for (ft = nt = Kt; J = z.prev[--ft], z.prev[ft] = Kt <= J ? J - Kt : 0, --nt; )
                                                    ;
                                                  Rt += Kt;
                                                }
                                                if (z.strm.avail_in === 0)
                                                  break;
                                                if (Yt = z.strm, Ht = z.window, Pt = z.strstart + z.lookahead, $t = void 0, (Mt = Rt) < ($t = Yt.avail_in) && ($t = Mt), nt = $t === 0 ? 0 : (Yt.avail_in -= $t, G.arraySet(Ht, Yt.input, Yt.next_in, $t, Pt), Yt.state.wrap === 1 ? Yt.adler = w(Yt.adler, Ht, $t, Pt) : Yt.state.wrap === 2 && (Yt.adler = ut(Yt.adler, Ht, $t, Pt)), Yt.next_in += $t, Yt.total_in += $t, $t), z.lookahead += nt, z.lookahead + z.insert >= Y)
                                                  for (Nt = z.strstart - z.insert, z.ins_h = z.window[Nt], z.ins_h = (z.ins_h << z.hash_shift ^ z.window[Nt + 1]) & z.hash_mask; z.insert && (z.ins_h = (z.ins_h << z.hash_shift ^ z.window[Nt + Y - 1]) & z.hash_mask, z.prev[Nt & z.w_mask] = z.head[z.ins_h], z.head[z.ins_h] = Nt, Nt++, z.insert--, !(z.lookahead + z.insert < Y)); )
                                                    ;
                                              } while (z.lookahead < yt && z.strm.avail_in !== 0);
                                            }
                                            function tt(z, ft) {
                                              for (var nt, J; ; ) {
                                                if (z.lookahead < yt) {
                                                  if (Z(z), z.lookahead < yt && ft === _t)
                                                    return 1;
                                                  if (z.lookahead === 0)
                                                    break;
                                                }
                                                if (nt = 0, z.lookahead >= Y && (z.ins_h = (z.ins_h << z.hash_shift ^ z.window[z.strstart + Y - 1]) & z.hash_mask, nt = z.prev[z.strstart & z.w_mask] = z.head[z.ins_h], z.head[z.ins_h] = z.strstart), nt !== 0 && z.strstart - nt <= z.w_size - yt && (z.match_length = O(z, nt)), z.match_length >= Y)
                                                  if (J = H._tr_tally(z, z.strstart - z.match_start, z.match_length - Y), z.lookahead -= z.match_length, z.match_length <= z.max_lazy_match && z.lookahead >= Y) {
                                                    for (z.match_length--; z.strstart++, z.ins_h = (z.ins_h << z.hash_shift ^ z.window[z.strstart + Y - 1]) & z.hash_mask, nt = z.prev[z.strstart & z.w_mask] = z.head[z.ins_h], z.head[z.ins_h] = z.strstart, --z.match_length != 0; )
                                                      ;
                                                    z.strstart++;
                                                  } else
                                                    z.strstart += z.match_length, z.match_length = 0, z.ins_h = z.window[z.strstart], z.ins_h = (z.ins_h << z.hash_shift ^ z.window[z.strstart + 1]) & z.hash_mask;
                                                else
                                                  J = H._tr_tally(z, 0, z.window[z.strstart]), z.lookahead--, z.strstart++;
                                                if (J && (y(z, !1), z.strm.avail_out === 0))
                                                  return 1;
                                              }
                                              return z.insert = z.strstart < Y - 1 ? z.strstart : Y - 1, ft === 4 ? (y(z, !0), z.strm.avail_out === 0 ? 3 : 4) : z.last_lit && (y(z, !1), z.strm.avail_out === 0) ? 1 : 2;
                                            }
                                            function gt(z, ft) {
                                              for (var nt, J, Rt; ; ) {
                                                if (z.lookahead < yt) {
                                                  if (Z(z), z.lookahead < yt && ft === _t)
                                                    return 1;
                                                  if (z.lookahead === 0)
                                                    break;
                                                }
                                                if (nt = 0, z.lookahead >= Y && (z.ins_h = (z.ins_h << z.hash_shift ^ z.window[z.strstart + Y - 1]) & z.hash_mask, nt = z.prev[z.strstart & z.w_mask] = z.head[z.ins_h], z.head[z.ins_h] = z.strstart), z.prev_length = z.match_length, z.prev_match = z.match_start, z.match_length = Y - 1, nt !== 0 && z.prev_length < z.max_lazy_match && z.strstart - nt <= z.w_size - yt && (z.match_length = O(z, nt), z.match_length <= 5 && (z.strategy === 1 || z.match_length === Y && 4096 < z.strstart - z.match_start) && (z.match_length = Y - 1)), z.prev_length >= Y && z.match_length <= z.prev_length) {
                                                  for (Rt = z.strstart + z.lookahead - Y, J = H._tr_tally(z, z.strstart - 1 - z.prev_match, z.prev_length - Y), z.lookahead -= z.prev_length - 1, z.prev_length -= 2; ++z.strstart <= Rt && (z.ins_h = (z.ins_h << z.hash_shift ^ z.window[z.strstart + Y - 1]) & z.hash_mask, nt = z.prev[z.strstart & z.w_mask] = z.head[z.ins_h], z.head[z.ins_h] = z.strstart), --z.prev_length != 0; )
                                                    ;
                                                  if (z.match_available = 0, z.match_length = Y - 1, z.strstart++, J && (y(z, !1), z.strm.avail_out === 0))
                                                    return 1;
                                                } else if (z.match_available) {
                                                  if ((J = H._tr_tally(z, 0, z.window[z.strstart - 1])) && y(z, !1), z.strstart++, z.lookahead--, z.strm.avail_out === 0)
                                                    return 1;
                                                } else
                                                  z.match_available = 1, z.strstart++, z.lookahead--;
                                              }
                                              return z.match_available && (J = H._tr_tally(z, 0, z.window[z.strstart - 1]), z.match_available = 0), z.insert = z.strstart < Y - 1 ? z.strstart : Y - 1, ft === 4 ? (y(z, !0), z.strm.avail_out === 0 ? 3 : 4) : z.last_lit && (y(z, !1), z.strm.avail_out === 0) ? 1 : 2;
                                            }
                                            function st(z, ft, nt, J, Rt) {
                                              this.good_length = z, this.max_lazy = ft, this.nice_length = nt, this.max_chain = J, this.func = Rt;
                                            }
                                            function Tt() {
                                              this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = b, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new G.Buf16(2 * L), this.dyn_dtree = new G.Buf16(2 * (2 * q + 1)), this.bl_tree = new G.Buf16(2 * (2 * U + 1)), wt(this.dyn_ltree), wt(this.dyn_dtree), wt(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new G.Buf16(j + 1), this.heap = new G.Buf16(2 * lt + 1), wt(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new G.Buf16(2 * lt + 1), wt(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
                                            }
                                            function Ft(z) {
                                              var ft;
                                              return z && z.state ? (z.total_in = z.total_out = 0, z.data_type = rt, (ft = z.state).pending = 0, ft.pending_out = 0, ft.wrap < 0 && (ft.wrap = -ft.wrap), ft.status = ft.wrap ? Et : Ct, z.adler = ft.wrap === 2 ? 0 : 1, ft.last_flush = _t, H._tr_init(ft), vt) : Lt(z, F);
                                            }
                                            function ht(z) {
                                              var ft, nt = Ft(z);
                                              return nt === vt && ((ft = z.state).window_size = 2 * ft.w_size, wt(ft.head), ft.max_lazy_match = B[ft.level].max_lazy, ft.good_match = B[ft.level].good_length, ft.nice_match = B[ft.level].nice_length, ft.max_chain_length = B[ft.level].max_chain, ft.strstart = 0, ft.block_start = 0, ft.lookahead = 0, ft.insert = 0, ft.match_length = ft.prev_length = Y - 1, ft.match_available = 0, ft.ins_h = 0), nt;
                                            }
                                            function It(z, ft, nt, J, Rt, Nt) {
                                              if (!z)
                                                return F;
                                              var Yt = 1;
                                              if (ft === -1 && (ft = 6), J < 0 ? (Yt = 0, J = -J) : 15 < J && (Yt = 2, J -= 16), Rt < 1 || 9 < Rt || nt !== b || J < 8 || 15 < J || ft < 0 || 9 < ft || Nt < 0 || 4 < Nt)
                                                return Lt(z, F);
                                              J === 8 && (J = 9);
                                              var Ht = new Tt();
                                              return (z.state = Ht).strm = z, Ht.wrap = Yt, Ht.gzhead = null, Ht.w_bits = J, Ht.w_size = 1 << Ht.w_bits, Ht.w_mask = Ht.w_size - 1, Ht.hash_bits = Rt + 7, Ht.hash_size = 1 << Ht.hash_bits, Ht.hash_mask = Ht.hash_size - 1, Ht.hash_shift = ~~((Ht.hash_bits + Y - 1) / Y), Ht.window = new G.Buf8(2 * Ht.w_size), Ht.head = new G.Buf16(Ht.hash_size), Ht.prev = new G.Buf16(Ht.w_size), Ht.lit_bufsize = 1 << Rt + 6, Ht.pending_buf_size = 4 * Ht.lit_bufsize, Ht.pending_buf = new G.Buf8(Ht.pending_buf_size), Ht.d_buf = 1 * Ht.lit_bufsize, Ht.l_buf = 3 * Ht.lit_bufsize, Ht.level = ft, Ht.strategy = Nt, Ht.method = nt, ht(z);
                                            }
                                            B = [new st(0, 0, 0, 0, function(z, ft) {
                                              var nt = 65535;
                                              for (nt > z.pending_buf_size - 5 && (nt = z.pending_buf_size - 5); ; ) {
                                                if (z.lookahead <= 1) {
                                                  if (Z(z), z.lookahead === 0 && ft === _t)
                                                    return 1;
                                                  if (z.lookahead === 0)
                                                    break;
                                                }
                                                z.strstart += z.lookahead, z.lookahead = 0;
                                                var J = z.block_start + nt;
                                                if ((z.strstart === 0 || z.strstart >= J) && (z.lookahead = z.strstart - J, z.strstart = J, y(z, !1), z.strm.avail_out === 0) || z.strstart - z.block_start >= z.w_size - yt && (y(z, !1), z.strm.avail_out === 0))
                                                  return 1;
                                              }
                                              return z.insert = 0, ft === 4 ? (y(z, !0), z.strm.avail_out === 0 ? 3 : 4) : (z.strstart > z.block_start && (y(z, !1), z.strm.avail_out), 1);
                                            }), new st(4, 4, 8, 4, tt), new st(4, 5, 16, 8, tt), new st(4, 6, 32, 32, tt), new st(4, 4, 16, 16, gt), new st(8, 16, 32, 32, gt), new st(8, 16, 128, 128, gt), new st(8, 32, 128, 256, gt), new st(32, 128, 258, 1024, gt), new st(32, 258, 258, 4096, gt)], k.deflateInit = function(z, ft) {
                                              return It(z, ft, b, 15, 8, 0);
                                            }, k.deflateInit2 = It, k.deflateReset = ht, k.deflateResetKeep = Ft, k.deflateSetHeader = function(z, ft) {
                                              return z && z.state ? z.state.wrap !== 2 ? F : (z.state.gzhead = ft, vt) : F;
                                            }, k.deflate = function(z, ft) {
                                              var nt, J, Rt, Nt;
                                              if (!z || !z.state || 5 < ft || ft < 0)
                                                return z ? Lt(z, F) : F;
                                              if (J = z.state, !z.output || !z.input && z.avail_in !== 0 || J.status === 666 && ft !== 4)
                                                return Lt(z, z.avail_out === 0 ? -5 : F);
                                              if (J.strm = z, nt = J.last_flush, J.last_flush = ft, J.status === Et)
                                                if (J.wrap === 2)
                                                  z.adler = 0, g(J, 31), g(J, 139), g(J, 8), J.gzhead ? (g(J, (J.gzhead.text ? 1 : 0) + (J.gzhead.hcrc ? 2 : 0) + (J.gzhead.extra ? 4 : 0) + (J.gzhead.name ? 8 : 0) + (J.gzhead.comment ? 16 : 0)), g(J, 255 & J.gzhead.time), g(J, J.gzhead.time >> 8 & 255), g(J, J.gzhead.time >> 16 & 255), g(J, J.gzhead.time >> 24 & 255), g(J, J.level === 9 ? 2 : 2 <= J.strategy || J.level < 2 ? 4 : 0), g(J, 255 & J.gzhead.os), J.gzhead.extra && J.gzhead.extra.length && (g(J, 255 & J.gzhead.extra.length), g(J, J.gzhead.extra.length >> 8 & 255)), J.gzhead.hcrc && (z.adler = ut(z.adler, J.pending_buf, J.pending, 0)), J.gzindex = 0, J.status = 69) : (g(J, 0), g(J, 0), g(J, 0), g(J, 0), g(J, 0), g(J, J.level === 9 ? 2 : 2 <= J.strategy || J.level < 2 ? 4 : 0), g(J, 3), J.status = Ct);
                                                else {
                                                  var Yt = b + (J.w_bits - 8 << 4) << 8;
                                                  Yt |= (2 <= J.strategy || J.level < 2 ? 0 : J.level < 6 ? 1 : J.level === 6 ? 2 : 3) << 6, J.strstart !== 0 && (Yt |= 32), Yt += 31 - Yt % 31, J.status = Ct, S(J, Yt), J.strstart !== 0 && (S(J, z.adler >>> 16), S(J, 65535 & z.adler)), z.adler = 1;
                                                }
                                              if (J.status === 69)
                                                if (J.gzhead.extra) {
                                                  for (Rt = J.pending; J.gzindex < (65535 & J.gzhead.extra.length) && (J.pending !== J.pending_buf_size || (J.gzhead.hcrc && J.pending > Rt && (z.adler = ut(z.adler, J.pending_buf, J.pending - Rt, Rt)), Q(z), Rt = J.pending, J.pending !== J.pending_buf_size)); )
                                                    g(J, 255 & J.gzhead.extra[J.gzindex]), J.gzindex++;
                                                  J.gzhead.hcrc && J.pending > Rt && (z.adler = ut(z.adler, J.pending_buf, J.pending - Rt, Rt)), J.gzindex === J.gzhead.extra.length && (J.gzindex = 0, J.status = 73);
                                                } else
                                                  J.status = 73;
                                              if (J.status === 73)
                                                if (J.gzhead.name) {
                                                  Rt = J.pending;
                                                  do {
                                                    if (J.pending === J.pending_buf_size && (J.gzhead.hcrc && J.pending > Rt && (z.adler = ut(z.adler, J.pending_buf, J.pending - Rt, Rt)), Q(z), Rt = J.pending, J.pending === J.pending_buf_size)) {
                                                      Nt = 1;
                                                      break;
                                                    }
                                                    Nt = J.gzindex < J.gzhead.name.length ? 255 & J.gzhead.name.charCodeAt(J.gzindex++) : 0, g(J, Nt);
                                                  } while (Nt !== 0);
                                                  J.gzhead.hcrc && J.pending > Rt && (z.adler = ut(z.adler, J.pending_buf, J.pending - Rt, Rt)), Nt === 0 && (J.gzindex = 0, J.status = 91);
                                                } else
                                                  J.status = 91;
                                              if (J.status === 91)
                                                if (J.gzhead.comment) {
                                                  Rt = J.pending;
                                                  do {
                                                    if (J.pending === J.pending_buf_size && (J.gzhead.hcrc && J.pending > Rt && (z.adler = ut(z.adler, J.pending_buf, J.pending - Rt, Rt)), Q(z), Rt = J.pending, J.pending === J.pending_buf_size)) {
                                                      Nt = 1;
                                                      break;
                                                    }
                                                    Nt = J.gzindex < J.gzhead.comment.length ? 255 & J.gzhead.comment.charCodeAt(J.gzindex++) : 0, g(J, Nt);
                                                  } while (Nt !== 0);
                                                  J.gzhead.hcrc && J.pending > Rt && (z.adler = ut(z.adler, J.pending_buf, J.pending - Rt, Rt)), Nt === 0 && (J.status = 103);
                                                } else
                                                  J.status = 103;
                                              if (J.status === 103 && (J.gzhead.hcrc ? (J.pending + 2 > J.pending_buf_size && Q(z), J.pending + 2 <= J.pending_buf_size && (g(J, 255 & z.adler), g(J, z.adler >> 8 & 255), z.adler = 0, J.status = Ct)) : J.status = Ct), J.pending !== 0) {
                                                if (Q(z), z.avail_out === 0)
                                                  return J.last_flush = -1, vt;
                                              } else if (z.avail_in === 0 && Wt(ft) <= Wt(nt) && ft !== 4)
                                                return Lt(z, -5);
                                              if (J.status === 666 && z.avail_in !== 0)
                                                return Lt(z, -5);
                                              if (z.avail_in !== 0 || J.lookahead !== 0 || ft !== _t && J.status !== 666) {
                                                var Ht = J.strategy === 2 ? function(Pt, Mt) {
                                                  for (var $t; ; ) {
                                                    if (Pt.lookahead === 0 && (Z(Pt), Pt.lookahead === 0)) {
                                                      if (Mt === _t)
                                                        return 1;
                                                      break;
                                                    }
                                                    if (Pt.match_length = 0, $t = H._tr_tally(Pt, 0, Pt.window[Pt.strstart]), Pt.lookahead--, Pt.strstart++, $t && (y(Pt, !1), Pt.strm.avail_out === 0))
                                                      return 1;
                                                  }
                                                  return Pt.insert = 0, Mt === 4 ? (y(Pt, !0), Pt.strm.avail_out === 0 ? 3 : 4) : Pt.last_lit && (y(Pt, !1), Pt.strm.avail_out === 0) ? 1 : 2;
                                                }(J, ft) : J.strategy === 3 ? function(Pt, Mt) {
                                                  for (var $t, Kt, te, Qt, ee = Pt.window; ; ) {
                                                    if (Pt.lookahead <= K) {
                                                      if (Z(Pt), Pt.lookahead <= K && Mt === _t)
                                                        return 1;
                                                      if (Pt.lookahead === 0)
                                                        break;
                                                    }
                                                    if (Pt.match_length = 0, Pt.lookahead >= Y && 0 < Pt.strstart && (Kt = ee[te = Pt.strstart - 1]) === ee[++te] && Kt === ee[++te] && Kt === ee[++te]) {
                                                      Qt = Pt.strstart + K;
                                                      do
                                                        ;
                                                      while (Kt === ee[++te] && Kt === ee[++te] && Kt === ee[++te] && Kt === ee[++te] && Kt === ee[++te] && Kt === ee[++te] && Kt === ee[++te] && Kt === ee[++te] && te < Qt);
                                                      Pt.match_length = K - (Qt - te), Pt.match_length > Pt.lookahead && (Pt.match_length = Pt.lookahead);
                                                    }
                                                    if (Pt.match_length >= Y ? ($t = H._tr_tally(Pt, 1, Pt.match_length - Y), Pt.lookahead -= Pt.match_length, Pt.strstart += Pt.match_length, Pt.match_length = 0) : ($t = H._tr_tally(Pt, 0, Pt.window[Pt.strstart]), Pt.lookahead--, Pt.strstart++), $t && (y(Pt, !1), Pt.strm.avail_out === 0))
                                                      return 1;
                                                  }
                                                  return Pt.insert = 0, Mt === 4 ? (y(Pt, !0), Pt.strm.avail_out === 0 ? 3 : 4) : Pt.last_lit && (y(Pt, !1), Pt.strm.avail_out === 0) ? 1 : 2;
                                                }(J, ft) : B[J.level].func(J, ft);
                                                if (Ht !== 3 && Ht !== 4 || (J.status = 666), Ht === 1 || Ht === 3)
                                                  return z.avail_out === 0 && (J.last_flush = -1), vt;
                                                if (Ht === 2 && (ft === 1 ? H._tr_align(J) : ft !== 5 && (H._tr_stored_block(J, 0, 0, !1), ft === 3 && (wt(J.head), J.lookahead === 0 && (J.strstart = 0, J.block_start = 0, J.insert = 0))), Q(z), z.avail_out === 0))
                                                  return J.last_flush = -1, vt;
                                              }
                                              return ft !== 4 ? vt : J.wrap <= 0 ? 1 : (J.wrap === 2 ? (g(J, 255 & z.adler), g(J, z.adler >> 8 & 255), g(J, z.adler >> 16 & 255), g(J, z.adler >> 24 & 255), g(J, 255 & z.total_in), g(J, z.total_in >> 8 & 255), g(J, z.total_in >> 16 & 255), g(J, z.total_in >> 24 & 255)) : (S(J, z.adler >>> 16), S(J, 65535 & z.adler)), Q(z), 0 < J.wrap && (J.wrap = -J.wrap), J.pending !== 0 ? vt : 1);
                                            }, k.deflateEnd = function(z) {
                                              var ft;
                                              return z && z.state ? (ft = z.state.status) !== Et && ft !== 69 && ft !== 73 && ft !== 91 && ft !== 103 && ft !== Ct && ft !== 666 ? Lt(z, F) : (z.state = null, ft === Ct ? Lt(z, -3) : vt) : F;
                                            }, k.deflateSetDictionary = function(z, ft) {
                                              var nt, J, Rt, Nt, Yt, Ht, Pt, Mt, $t = ft.length;
                                              if (!z || !z.state || (Nt = (nt = z.state).wrap) === 2 || Nt === 1 && nt.status !== Et || nt.lookahead)
                                                return F;
                                              for (Nt === 1 && (z.adler = w(z.adler, ft, $t, 0)), nt.wrap = 0, $t >= nt.w_size && (Nt === 0 && (wt(nt.head), nt.strstart = 0, nt.block_start = 0, nt.insert = 0), Mt = new G.Buf8(nt.w_size), G.arraySet(Mt, ft, $t - nt.w_size, nt.w_size, 0), ft = Mt, $t = nt.w_size), Yt = z.avail_in, Ht = z.next_in, Pt = z.input, z.avail_in = $t, z.next_in = 0, z.input = ft, Z(nt); nt.lookahead >= Y; ) {
                                                for (J = nt.strstart, Rt = nt.lookahead - (Y - 1); nt.ins_h = (nt.ins_h << nt.hash_shift ^ nt.window[J + Y - 1]) & nt.hash_mask, nt.prev[J & nt.w_mask] = nt.head[nt.ins_h], nt.head[nt.ins_h] = J, J++, --Rt; )
                                                  ;
                                                nt.strstart = J, nt.lookahead = Y - 1, Z(nt);
                                              }
                                              return nt.strstart += nt.lookahead, nt.block_start = nt.strstart, nt.insert = nt.lookahead, nt.lookahead = 0, nt.match_length = nt.prev_length = Y - 1, nt.match_available = 0, z.next_in = Ht, z.input = Pt, z.avail_in = Yt, nt.wrap = Nt, vt;
                                            }, k.deflateInfo = "pako deflate (from Nodeca project)";
                                          }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(V, mt, k) {
                                            mt.exports = function() {
                                              this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
                                            };
                                          }, {}], 48: [function(V, mt, k) {
                                            mt.exports = function(B, G) {
                                              var H, w, ut, pt, _t, vt, F, rt, b, lt, q, U, L, j, Y, K, yt, Et, Ct, Lt, Wt, wt, Q, y, g;
                                              H = B.state, w = B.next_in, y = B.input, ut = w + (B.avail_in - 5), pt = B.next_out, g = B.output, _t = pt - (G - B.avail_out), vt = pt + (B.avail_out - 257), F = H.dmax, rt = H.wsize, b = H.whave, lt = H.wnext, q = H.window, U = H.hold, L = H.bits, j = H.lencode, Y = H.distcode, K = (1 << H.lenbits) - 1, yt = (1 << H.distbits) - 1;
                                              t:
                                                do {
                                                  L < 15 && (U += y[w++] << L, L += 8, U += y[w++] << L, L += 8), Et = j[U & K];
                                                  e:
                                                    for (; ; ) {
                                                      if (U >>>= Ct = Et >>> 24, L -= Ct, (Ct = Et >>> 16 & 255) == 0)
                                                        g[pt++] = 65535 & Et;
                                                      else {
                                                        if (!(16 & Ct)) {
                                                          if (!(64 & Ct)) {
                                                            Et = j[(65535 & Et) + (U & (1 << Ct) - 1)];
                                                            continue e;
                                                          }
                                                          if (32 & Ct) {
                                                            H.mode = 12;
                                                            break t;
                                                          }
                                                          B.msg = "invalid literal/length code", H.mode = 30;
                                                          break t;
                                                        }
                                                        Lt = 65535 & Et, (Ct &= 15) && (L < Ct && (U += y[w++] << L, L += 8), Lt += U & (1 << Ct) - 1, U >>>= Ct, L -= Ct), L < 15 && (U += y[w++] << L, L += 8, U += y[w++] << L, L += 8), Et = Y[U & yt];
                                                        n:
                                                          for (; ; ) {
                                                            if (U >>>= Ct = Et >>> 24, L -= Ct, !(16 & (Ct = Et >>> 16 & 255))) {
                                                              if (!(64 & Ct)) {
                                                                Et = Y[(65535 & Et) + (U & (1 << Ct) - 1)];
                                                                continue n;
                                                              }
                                                              B.msg = "invalid distance code", H.mode = 30;
                                                              break t;
                                                            }
                                                            if (Wt = 65535 & Et, L < (Ct &= 15) && (U += y[w++] << L, (L += 8) < Ct && (U += y[w++] << L, L += 8)), F < (Wt += U & (1 << Ct) - 1)) {
                                                              B.msg = "invalid distance too far back", H.mode = 30;
                                                              break t;
                                                            }
                                                            if (U >>>= Ct, L -= Ct, (Ct = pt - _t) < Wt) {
                                                              if (b < (Ct = Wt - Ct) && H.sane) {
                                                                B.msg = "invalid distance too far back", H.mode = 30;
                                                                break t;
                                                              }
                                                              if (Q = q, (wt = 0) === lt) {
                                                                if (wt += rt - Ct, Ct < Lt) {
                                                                  for (Lt -= Ct; g[pt++] = q[wt++], --Ct; )
                                                                    ;
                                                                  wt = pt - Wt, Q = g;
                                                                }
                                                              } else if (lt < Ct) {
                                                                if (wt += rt + lt - Ct, (Ct -= lt) < Lt) {
                                                                  for (Lt -= Ct; g[pt++] = q[wt++], --Ct; )
                                                                    ;
                                                                  if (wt = 0, lt < Lt) {
                                                                    for (Lt -= Ct = lt; g[pt++] = q[wt++], --Ct; )
                                                                      ;
                                                                    wt = pt - Wt, Q = g;
                                                                  }
                                                                }
                                                              } else if (wt += lt - Ct, Ct < Lt) {
                                                                for (Lt -= Ct; g[pt++] = q[wt++], --Ct; )
                                                                  ;
                                                                wt = pt - Wt, Q = g;
                                                              }
                                                              for (; 2 < Lt; )
                                                                g[pt++] = Q[wt++], g[pt++] = Q[wt++], g[pt++] = Q[wt++], Lt -= 3;
                                                              Lt && (g[pt++] = Q[wt++], 1 < Lt && (g[pt++] = Q[wt++]));
                                                            } else {
                                                              for (wt = pt - Wt; g[pt++] = g[wt++], g[pt++] = g[wt++], g[pt++] = g[wt++], 2 < (Lt -= 3); )
                                                                ;
                                                              Lt && (g[pt++] = g[wt++], 1 < Lt && (g[pt++] = g[wt++]));
                                                            }
                                                            break;
                                                          }
                                                      }
                                                      break;
                                                    }
                                                } while (w < ut && pt < vt);
                                              w -= Lt = L >> 3, U &= (1 << (L -= Lt << 3)) - 1, B.next_in = w, B.next_out = pt, B.avail_in = w < ut ? ut - w + 5 : 5 - (w - ut), B.avail_out = pt < vt ? vt - pt + 257 : 257 - (pt - vt), H.hold = U, H.bits = L;
                                            };
                                          }, {}], 49: [function(V, mt, k) {
                                            var B = V("../utils/common"), G = V("./adler32"), H = V("./crc32"), w = V("./inffast"), ut = V("./inftrees"), pt = 1, _t = 2, vt = 0, F = -2, rt = 1, b = 852, lt = 592;
                                            function q(wt) {
                                              return (wt >>> 24 & 255) + (wt >>> 8 & 65280) + ((65280 & wt) << 8) + ((255 & wt) << 24);
                                            }
                                            function U() {
                                              this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new B.Buf16(320), this.work = new B.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
                                            }
                                            function L(wt) {
                                              var Q;
                                              return wt && wt.state ? (Q = wt.state, wt.total_in = wt.total_out = Q.total = 0, wt.msg = "", Q.wrap && (wt.adler = 1 & Q.wrap), Q.mode = rt, Q.last = 0, Q.havedict = 0, Q.dmax = 32768, Q.head = null, Q.hold = 0, Q.bits = 0, Q.lencode = Q.lendyn = new B.Buf32(b), Q.distcode = Q.distdyn = new B.Buf32(lt), Q.sane = 1, Q.back = -1, vt) : F;
                                            }
                                            function j(wt) {
                                              var Q;
                                              return wt && wt.state ? ((Q = wt.state).wsize = 0, Q.whave = 0, Q.wnext = 0, L(wt)) : F;
                                            }
                                            function Y(wt, Q) {
                                              var y, g;
                                              return wt && wt.state ? (g = wt.state, Q < 0 ? (y = 0, Q = -Q) : (y = 1 + (Q >> 4), Q < 48 && (Q &= 15)), Q && (Q < 8 || 15 < Q) ? F : (g.window !== null && g.wbits !== Q && (g.window = null), g.wrap = y, g.wbits = Q, j(wt))) : F;
                                            }
                                            function K(wt, Q) {
                                              var y, g;
                                              return wt ? (g = new U(), (wt.state = g).window = null, (y = Y(wt, Q)) !== vt && (wt.state = null), y) : F;
                                            }
                                            var yt, Et, Ct = !0;
                                            function Lt(wt) {
                                              if (Ct) {
                                                var Q;
                                                for (yt = new B.Buf32(512), Et = new B.Buf32(32), Q = 0; Q < 144; )
                                                  wt.lens[Q++] = 8;
                                                for (; Q < 256; )
                                                  wt.lens[Q++] = 9;
                                                for (; Q < 280; )
                                                  wt.lens[Q++] = 7;
                                                for (; Q < 288; )
                                                  wt.lens[Q++] = 8;
                                                for (ut(pt, wt.lens, 0, 288, yt, 0, wt.work, { bits: 9 }), Q = 0; Q < 32; )
                                                  wt.lens[Q++] = 5;
                                                ut(_t, wt.lens, 0, 32, Et, 0, wt.work, { bits: 5 }), Ct = !1;
                                              }
                                              wt.lencode = yt, wt.lenbits = 9, wt.distcode = Et, wt.distbits = 5;
                                            }
                                            function Wt(wt, Q, y, g) {
                                              var S, O = wt.state;
                                              return O.window === null && (O.wsize = 1 << O.wbits, O.wnext = 0, O.whave = 0, O.window = new B.Buf8(O.wsize)), g >= O.wsize ? (B.arraySet(O.window, Q, y - O.wsize, O.wsize, 0), O.wnext = 0, O.whave = O.wsize) : (g < (S = O.wsize - O.wnext) && (S = g), B.arraySet(O.window, Q, y - g, S, O.wnext), (g -= S) ? (B.arraySet(O.window, Q, y - g, g, 0), O.wnext = g, O.whave = O.wsize) : (O.wnext += S, O.wnext === O.wsize && (O.wnext = 0), O.whave < O.wsize && (O.whave += S))), 0;
                                            }
                                            k.inflateReset = j, k.inflateReset2 = Y, k.inflateResetKeep = L, k.inflateInit = function(wt) {
                                              return K(wt, 15);
                                            }, k.inflateInit2 = K, k.inflate = function(wt, Q) {
                                              var y, g, S, O, Z, tt, gt, st, Tt, Ft, ht, It, z, ft, nt, J, Rt, Nt, Yt, Ht, Pt, Mt, $t, Kt, te = 0, Qt = new B.Buf8(4), ee = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
                                              if (!wt || !wt.state || !wt.output || !wt.input && wt.avail_in !== 0)
                                                return F;
                                              (y = wt.state).mode === 12 && (y.mode = 13), Z = wt.next_out, S = wt.output, gt = wt.avail_out, O = wt.next_in, g = wt.input, tt = wt.avail_in, st = y.hold, Tt = y.bits, Ft = tt, ht = gt, Mt = vt;
                                              t:
                                                for (; ; )
                                                  switch (y.mode) {
                                                    case rt:
                                                      if (y.wrap === 0) {
                                                        y.mode = 13;
                                                        break;
                                                      }
                                                      for (; Tt < 16; ) {
                                                        if (tt === 0)
                                                          break t;
                                                        tt--, st += g[O++] << Tt, Tt += 8;
                                                      }
                                                      if (2 & y.wrap && st === 35615) {
                                                        Qt[y.check = 0] = 255 & st, Qt[1] = st >>> 8 & 255, y.check = H(y.check, Qt, 2, 0), Tt = st = 0, y.mode = 2;
                                                        break;
                                                      }
                                                      if (y.flags = 0, y.head && (y.head.done = !1), !(1 & y.wrap) || (((255 & st) << 8) + (st >> 8)) % 31) {
                                                        wt.msg = "incorrect header check", y.mode = 30;
                                                        break;
                                                      }
                                                      if ((15 & st) != 8) {
                                                        wt.msg = "unknown compression method", y.mode = 30;
                                                        break;
                                                      }
                                                      if (Tt -= 4, Pt = 8 + (15 & (st >>>= 4)), y.wbits === 0)
                                                        y.wbits = Pt;
                                                      else if (Pt > y.wbits) {
                                                        wt.msg = "invalid window size", y.mode = 30;
                                                        break;
                                                      }
                                                      y.dmax = 1 << Pt, wt.adler = y.check = 1, y.mode = 512 & st ? 10 : 12, Tt = st = 0;
                                                      break;
                                                    case 2:
                                                      for (; Tt < 16; ) {
                                                        if (tt === 0)
                                                          break t;
                                                        tt--, st += g[O++] << Tt, Tt += 8;
                                                      }
                                                      if (y.flags = st, (255 & y.flags) != 8) {
                                                        wt.msg = "unknown compression method", y.mode = 30;
                                                        break;
                                                      }
                                                      if (57344 & y.flags) {
                                                        wt.msg = "unknown header flags set", y.mode = 30;
                                                        break;
                                                      }
                                                      y.head && (y.head.text = st >> 8 & 1), 512 & y.flags && (Qt[0] = 255 & st, Qt[1] = st >>> 8 & 255, y.check = H(y.check, Qt, 2, 0)), Tt = st = 0, y.mode = 3;
                                                    case 3:
                                                      for (; Tt < 32; ) {
                                                        if (tt === 0)
                                                          break t;
                                                        tt--, st += g[O++] << Tt, Tt += 8;
                                                      }
                                                      y.head && (y.head.time = st), 512 & y.flags && (Qt[0] = 255 & st, Qt[1] = st >>> 8 & 255, Qt[2] = st >>> 16 & 255, Qt[3] = st >>> 24 & 255, y.check = H(y.check, Qt, 4, 0)), Tt = st = 0, y.mode = 4;
                                                    case 4:
                                                      for (; Tt < 16; ) {
                                                        if (tt === 0)
                                                          break t;
                                                        tt--, st += g[O++] << Tt, Tt += 8;
                                                      }
                                                      y.head && (y.head.xflags = 255 & st, y.head.os = st >> 8), 512 & y.flags && (Qt[0] = 255 & st, Qt[1] = st >>> 8 & 255, y.check = H(y.check, Qt, 2, 0)), Tt = st = 0, y.mode = 5;
                                                    case 5:
                                                      if (1024 & y.flags) {
                                                        for (; Tt < 16; ) {
                                                          if (tt === 0)
                                                            break t;
                                                          tt--, st += g[O++] << Tt, Tt += 8;
                                                        }
                                                        y.length = st, y.head && (y.head.extra_len = st), 512 & y.flags && (Qt[0] = 255 & st, Qt[1] = st >>> 8 & 255, y.check = H(y.check, Qt, 2, 0)), Tt = st = 0;
                                                      } else
                                                        y.head && (y.head.extra = null);
                                                      y.mode = 6;
                                                    case 6:
                                                      if (1024 & y.flags && (tt < (It = y.length) && (It = tt), It && (y.head && (Pt = y.head.extra_len - y.length, y.head.extra || (y.head.extra = new Array(y.head.extra_len)), B.arraySet(y.head.extra, g, O, It, Pt)), 512 & y.flags && (y.check = H(y.check, g, It, O)), tt -= It, O += It, y.length -= It), y.length))
                                                        break t;
                                                      y.length = 0, y.mode = 7;
                                                    case 7:
                                                      if (2048 & y.flags) {
                                                        if (tt === 0)
                                                          break t;
                                                        for (It = 0; Pt = g[O + It++], y.head && Pt && y.length < 65536 && (y.head.name += String.fromCharCode(Pt)), Pt && It < tt; )
                                                          ;
                                                        if (512 & y.flags && (y.check = H(y.check, g, It, O)), tt -= It, O += It, Pt)
                                                          break t;
                                                      } else
                                                        y.head && (y.head.name = null);
                                                      y.length = 0, y.mode = 8;
                                                    case 8:
                                                      if (4096 & y.flags) {
                                                        if (tt === 0)
                                                          break t;
                                                        for (It = 0; Pt = g[O + It++], y.head && Pt && y.length < 65536 && (y.head.comment += String.fromCharCode(Pt)), Pt && It < tt; )
                                                          ;
                                                        if (512 & y.flags && (y.check = H(y.check, g, It, O)), tt -= It, O += It, Pt)
                                                          break t;
                                                      } else
                                                        y.head && (y.head.comment = null);
                                                      y.mode = 9;
                                                    case 9:
                                                      if (512 & y.flags) {
                                                        for (; Tt < 16; ) {
                                                          if (tt === 0)
                                                            break t;
                                                          tt--, st += g[O++] << Tt, Tt += 8;
                                                        }
                                                        if (st !== (65535 & y.check)) {
                                                          wt.msg = "header crc mismatch", y.mode = 30;
                                                          break;
                                                        }
                                                        Tt = st = 0;
                                                      }
                                                      y.head && (y.head.hcrc = y.flags >> 9 & 1, y.head.done = !0), wt.adler = y.check = 0, y.mode = 12;
                                                      break;
                                                    case 10:
                                                      for (; Tt < 32; ) {
                                                        if (tt === 0)
                                                          break t;
                                                        tt--, st += g[O++] << Tt, Tt += 8;
                                                      }
                                                      wt.adler = y.check = q(st), Tt = st = 0, y.mode = 11;
                                                    case 11:
                                                      if (y.havedict === 0)
                                                        return wt.next_out = Z, wt.avail_out = gt, wt.next_in = O, wt.avail_in = tt, y.hold = st, y.bits = Tt, 2;
                                                      wt.adler = y.check = 1, y.mode = 12;
                                                    case 12:
                                                      if (Q === 5 || Q === 6)
                                                        break t;
                                                    case 13:
                                                      if (y.last) {
                                                        st >>>= 7 & Tt, Tt -= 7 & Tt, y.mode = 27;
                                                        break;
                                                      }
                                                      for (; Tt < 3; ) {
                                                        if (tt === 0)
                                                          break t;
                                                        tt--, st += g[O++] << Tt, Tt += 8;
                                                      }
                                                      switch (y.last = 1 & st, Tt -= 1, 3 & (st >>>= 1)) {
                                                        case 0:
                                                          y.mode = 14;
                                                          break;
                                                        case 1:
                                                          if (Lt(y), y.mode = 20, Q !== 6)
                                                            break;
                                                          st >>>= 2, Tt -= 2;
                                                          break t;
                                                        case 2:
                                                          y.mode = 17;
                                                          break;
                                                        case 3:
                                                          wt.msg = "invalid block type", y.mode = 30;
                                                      }
                                                      st >>>= 2, Tt -= 2;
                                                      break;
                                                    case 14:
                                                      for (st >>>= 7 & Tt, Tt -= 7 & Tt; Tt < 32; ) {
                                                        if (tt === 0)
                                                          break t;
                                                        tt--, st += g[O++] << Tt, Tt += 8;
                                                      }
                                                      if ((65535 & st) != (st >>> 16 ^ 65535)) {
                                                        wt.msg = "invalid stored block lengths", y.mode = 30;
                                                        break;
                                                      }
                                                      if (y.length = 65535 & st, Tt = st = 0, y.mode = 15, Q === 6)
                                                        break t;
                                                    case 15:
                                                      y.mode = 16;
                                                    case 16:
                                                      if (It = y.length) {
                                                        if (tt < It && (It = tt), gt < It && (It = gt), It === 0)
                                                          break t;
                                                        B.arraySet(S, g, O, It, Z), tt -= It, O += It, gt -= It, Z += It, y.length -= It;
                                                        break;
                                                      }
                                                      y.mode = 12;
                                                      break;
                                                    case 17:
                                                      for (; Tt < 14; ) {
                                                        if (tt === 0)
                                                          break t;
                                                        tt--, st += g[O++] << Tt, Tt += 8;
                                                      }
                                                      if (y.nlen = 257 + (31 & st), st >>>= 5, Tt -= 5, y.ndist = 1 + (31 & st), st >>>= 5, Tt -= 5, y.ncode = 4 + (15 & st), st >>>= 4, Tt -= 4, 286 < y.nlen || 30 < y.ndist) {
                                                        wt.msg = "too many length or distance symbols", y.mode = 30;
                                                        break;
                                                      }
                                                      y.have = 0, y.mode = 18;
                                                    case 18:
                                                      for (; y.have < y.ncode; ) {
                                                        for (; Tt < 3; ) {
                                                          if (tt === 0)
                                                            break t;
                                                          tt--, st += g[O++] << Tt, Tt += 8;
                                                        }
                                                        y.lens[ee[y.have++]] = 7 & st, st >>>= 3, Tt -= 3;
                                                      }
                                                      for (; y.have < 19; )
                                                        y.lens[ee[y.have++]] = 0;
                                                      if (y.lencode = y.lendyn, y.lenbits = 7, $t = { bits: y.lenbits }, Mt = ut(0, y.lens, 0, 19, y.lencode, 0, y.work, $t), y.lenbits = $t.bits, Mt) {
                                                        wt.msg = "invalid code lengths set", y.mode = 30;
                                                        break;
                                                      }
                                                      y.have = 0, y.mode = 19;
                                                    case 19:
                                                      for (; y.have < y.nlen + y.ndist; ) {
                                                        for (; J = (te = y.lencode[st & (1 << y.lenbits) - 1]) >>> 16 & 255, Rt = 65535 & te, !((nt = te >>> 24) <= Tt); ) {
                                                          if (tt === 0)
                                                            break t;
                                                          tt--, st += g[O++] << Tt, Tt += 8;
                                                        }
                                                        if (Rt < 16)
                                                          st >>>= nt, Tt -= nt, y.lens[y.have++] = Rt;
                                                        else {
                                                          if (Rt === 16) {
                                                            for (Kt = nt + 2; Tt < Kt; ) {
                                                              if (tt === 0)
                                                                break t;
                                                              tt--, st += g[O++] << Tt, Tt += 8;
                                                            }
                                                            if (st >>>= nt, Tt -= nt, y.have === 0) {
                                                              wt.msg = "invalid bit length repeat", y.mode = 30;
                                                              break;
                                                            }
                                                            Pt = y.lens[y.have - 1], It = 3 + (3 & st), st >>>= 2, Tt -= 2;
                                                          } else if (Rt === 17) {
                                                            for (Kt = nt + 3; Tt < Kt; ) {
                                                              if (tt === 0)
                                                                break t;
                                                              tt--, st += g[O++] << Tt, Tt += 8;
                                                            }
                                                            Tt -= nt, Pt = 0, It = 3 + (7 & (st >>>= nt)), st >>>= 3, Tt -= 3;
                                                          } else {
                                                            for (Kt = nt + 7; Tt < Kt; ) {
                                                              if (tt === 0)
                                                                break t;
                                                              tt--, st += g[O++] << Tt, Tt += 8;
                                                            }
                                                            Tt -= nt, Pt = 0, It = 11 + (127 & (st >>>= nt)), st >>>= 7, Tt -= 7;
                                                          }
                                                          if (y.have + It > y.nlen + y.ndist) {
                                                            wt.msg = "invalid bit length repeat", y.mode = 30;
                                                            break;
                                                          }
                                                          for (; It--; )
                                                            y.lens[y.have++] = Pt;
                                                        }
                                                      }
                                                      if (y.mode === 30)
                                                        break;
                                                      if (y.lens[256] === 0) {
                                                        wt.msg = "invalid code -- missing end-of-block", y.mode = 30;
                                                        break;
                                                      }
                                                      if (y.lenbits = 9, $t = { bits: y.lenbits }, Mt = ut(pt, y.lens, 0, y.nlen, y.lencode, 0, y.work, $t), y.lenbits = $t.bits, Mt) {
                                                        wt.msg = "invalid literal/lengths set", y.mode = 30;
                                                        break;
                                                      }
                                                      if (y.distbits = 6, y.distcode = y.distdyn, $t = { bits: y.distbits }, Mt = ut(_t, y.lens, y.nlen, y.ndist, y.distcode, 0, y.work, $t), y.distbits = $t.bits, Mt) {
                                                        wt.msg = "invalid distances set", y.mode = 30;
                                                        break;
                                                      }
                                                      if (y.mode = 20, Q === 6)
                                                        break t;
                                                    case 20:
                                                      y.mode = 21;
                                                    case 21:
                                                      if (6 <= tt && 258 <= gt) {
                                                        wt.next_out = Z, wt.avail_out = gt, wt.next_in = O, wt.avail_in = tt, y.hold = st, y.bits = Tt, w(wt, ht), Z = wt.next_out, S = wt.output, gt = wt.avail_out, O = wt.next_in, g = wt.input, tt = wt.avail_in, st = y.hold, Tt = y.bits, y.mode === 12 && (y.back = -1);
                                                        break;
                                                      }
                                                      for (y.back = 0; J = (te = y.lencode[st & (1 << y.lenbits) - 1]) >>> 16 & 255, Rt = 65535 & te, !((nt = te >>> 24) <= Tt); ) {
                                                        if (tt === 0)
                                                          break t;
                                                        tt--, st += g[O++] << Tt, Tt += 8;
                                                      }
                                                      if (J && !(240 & J)) {
                                                        for (Nt = nt, Yt = J, Ht = Rt; J = (te = y.lencode[Ht + ((st & (1 << Nt + Yt) - 1) >> Nt)]) >>> 16 & 255, Rt = 65535 & te, !(Nt + (nt = te >>> 24) <= Tt); ) {
                                                          if (tt === 0)
                                                            break t;
                                                          tt--, st += g[O++] << Tt, Tt += 8;
                                                        }
                                                        st >>>= Nt, Tt -= Nt, y.back += Nt;
                                                      }
                                                      if (st >>>= nt, Tt -= nt, y.back += nt, y.length = Rt, J === 0) {
                                                        y.mode = 26;
                                                        break;
                                                      }
                                                      if (32 & J) {
                                                        y.back = -1, y.mode = 12;
                                                        break;
                                                      }
                                                      if (64 & J) {
                                                        wt.msg = "invalid literal/length code", y.mode = 30;
                                                        break;
                                                      }
                                                      y.extra = 15 & J, y.mode = 22;
                                                    case 22:
                                                      if (y.extra) {
                                                        for (Kt = y.extra; Tt < Kt; ) {
                                                          if (tt === 0)
                                                            break t;
                                                          tt--, st += g[O++] << Tt, Tt += 8;
                                                        }
                                                        y.length += st & (1 << y.extra) - 1, st >>>= y.extra, Tt -= y.extra, y.back += y.extra;
                                                      }
                                                      y.was = y.length, y.mode = 23;
                                                    case 23:
                                                      for (; J = (te = y.distcode[st & (1 << y.distbits) - 1]) >>> 16 & 255, Rt = 65535 & te, !((nt = te >>> 24) <= Tt); ) {
                                                        if (tt === 0)
                                                          break t;
                                                        tt--, st += g[O++] << Tt, Tt += 8;
                                                      }
                                                      if (!(240 & J)) {
                                                        for (Nt = nt, Yt = J, Ht = Rt; J = (te = y.distcode[Ht + ((st & (1 << Nt + Yt) - 1) >> Nt)]) >>> 16 & 255, Rt = 65535 & te, !(Nt + (nt = te >>> 24) <= Tt); ) {
                                                          if (tt === 0)
                                                            break t;
                                                          tt--, st += g[O++] << Tt, Tt += 8;
                                                        }
                                                        st >>>= Nt, Tt -= Nt, y.back += Nt;
                                                      }
                                                      if (st >>>= nt, Tt -= nt, y.back += nt, 64 & J) {
                                                        wt.msg = "invalid distance code", y.mode = 30;
                                                        break;
                                                      }
                                                      y.offset = Rt, y.extra = 15 & J, y.mode = 24;
                                                    case 24:
                                                      if (y.extra) {
                                                        for (Kt = y.extra; Tt < Kt; ) {
                                                          if (tt === 0)
                                                            break t;
                                                          tt--, st += g[O++] << Tt, Tt += 8;
                                                        }
                                                        y.offset += st & (1 << y.extra) - 1, st >>>= y.extra, Tt -= y.extra, y.back += y.extra;
                                                      }
                                                      if (y.offset > y.dmax) {
                                                        wt.msg = "invalid distance too far back", y.mode = 30;
                                                        break;
                                                      }
                                                      y.mode = 25;
                                                    case 25:
                                                      if (gt === 0)
                                                        break t;
                                                      if (It = ht - gt, y.offset > It) {
                                                        if ((It = y.offset - It) > y.whave && y.sane) {
                                                          wt.msg = "invalid distance too far back", y.mode = 30;
                                                          break;
                                                        }
                                                        z = It > y.wnext ? (It -= y.wnext, y.wsize - It) : y.wnext - It, It > y.length && (It = y.length), ft = y.window;
                                                      } else
                                                        ft = S, z = Z - y.offset, It = y.length;
                                                      for (gt < It && (It = gt), gt -= It, y.length -= It; S[Z++] = ft[z++], --It; )
                                                        ;
                                                      y.length === 0 && (y.mode = 21);
                                                      break;
                                                    case 26:
                                                      if (gt === 0)
                                                        break t;
                                                      S[Z++] = y.length, gt--, y.mode = 21;
                                                      break;
                                                    case 27:
                                                      if (y.wrap) {
                                                        for (; Tt < 32; ) {
                                                          if (tt === 0)
                                                            break t;
                                                          tt--, st |= g[O++] << Tt, Tt += 8;
                                                        }
                                                        if (ht -= gt, wt.total_out += ht, y.total += ht, ht && (wt.adler = y.check = y.flags ? H(y.check, S, ht, Z - ht) : G(y.check, S, ht, Z - ht)), ht = gt, (y.flags ? st : q(st)) !== y.check) {
                                                          wt.msg = "incorrect data check", y.mode = 30;
                                                          break;
                                                        }
                                                        Tt = st = 0;
                                                      }
                                                      y.mode = 28;
                                                    case 28:
                                                      if (y.wrap && y.flags) {
                                                        for (; Tt < 32; ) {
                                                          if (tt === 0)
                                                            break t;
                                                          tt--, st += g[O++] << Tt, Tt += 8;
                                                        }
                                                        if (st !== (4294967295 & y.total)) {
                                                          wt.msg = "incorrect length check", y.mode = 30;
                                                          break;
                                                        }
                                                        Tt = st = 0;
                                                      }
                                                      y.mode = 29;
                                                    case 29:
                                                      Mt = 1;
                                                      break t;
                                                    case 30:
                                                      Mt = -3;
                                                      break t;
                                                    case 31:
                                                      return -4;
                                                    case 32:
                                                    default:
                                                      return F;
                                                  }
                                              return wt.next_out = Z, wt.avail_out = gt, wt.next_in = O, wt.avail_in = tt, y.hold = st, y.bits = Tt, (y.wsize || ht !== wt.avail_out && y.mode < 30 && (y.mode < 27 || Q !== 4)) && Wt(wt, wt.output, wt.next_out, ht - wt.avail_out) ? (y.mode = 31, -4) : (Ft -= wt.avail_in, ht -= wt.avail_out, wt.total_in += Ft, wt.total_out += ht, y.total += ht, y.wrap && ht && (wt.adler = y.check = y.flags ? H(y.check, S, ht, wt.next_out - ht) : G(y.check, S, ht, wt.next_out - ht)), wt.data_type = y.bits + (y.last ? 64 : 0) + (y.mode === 12 ? 128 : 0) + (y.mode === 20 || y.mode === 15 ? 256 : 0), (Ft == 0 && ht === 0 || Q === 4) && Mt === vt && (Mt = -5), Mt);
                                            }, k.inflateEnd = function(wt) {
                                              if (!wt || !wt.state)
                                                return F;
                                              var Q = wt.state;
                                              return Q.window && (Q.window = null), wt.state = null, vt;
                                            }, k.inflateGetHeader = function(wt, Q) {
                                              var y;
                                              return wt && wt.state && 2 & (y = wt.state).wrap ? ((y.head = Q).done = !1, vt) : F;
                                            }, k.inflateSetDictionary = function(wt, Q) {
                                              var y, g = Q.length;
                                              return wt && wt.state ? (y = wt.state).wrap !== 0 && y.mode !== 11 ? F : y.mode === 11 && G(1, Q, g, 0) !== y.check ? -3 : Wt(wt, Q, g, g) ? (y.mode = 31, -4) : (y.havedict = 1, vt) : F;
                                            }, k.inflateInfo = "pako inflate (from Nodeca project)";
                                          }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(V, mt, k) {
                                            var B = V("../utils/common"), G = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], H = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], w = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], ut = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
                                            mt.exports = function(pt, _t, vt, F, rt, b, lt, q) {
                                              var U, L, j, Y, K, yt, Et, Ct, Lt, Wt = q.bits, wt = 0, Q = 0, y = 0, g = 0, S = 0, O = 0, Z = 0, tt = 0, gt = 0, st = 0, Tt = null, Ft = 0, ht = new B.Buf16(16), It = new B.Buf16(16), z = null, ft = 0;
                                              for (wt = 0; wt <= 15; wt++)
                                                ht[wt] = 0;
                                              for (Q = 0; Q < F; Q++)
                                                ht[_t[vt + Q]]++;
                                              for (S = Wt, g = 15; 1 <= g && ht[g] === 0; g--)
                                                ;
                                              if (g < S && (S = g), g === 0)
                                                return rt[b++] = 20971520, rt[b++] = 20971520, q.bits = 1, 0;
                                              for (y = 1; y < g && ht[y] === 0; y++)
                                                ;
                                              for (S < y && (S = y), wt = tt = 1; wt <= 15; wt++)
                                                if (tt <<= 1, (tt -= ht[wt]) < 0)
                                                  return -1;
                                              if (0 < tt && (pt === 0 || g !== 1))
                                                return -1;
                                              for (It[1] = 0, wt = 1; wt < 15; wt++)
                                                It[wt + 1] = It[wt] + ht[wt];
                                              for (Q = 0; Q < F; Q++)
                                                _t[vt + Q] !== 0 && (lt[It[_t[vt + Q]]++] = Q);
                                              if (yt = pt === 0 ? (Tt = z = lt, 19) : pt === 1 ? (Tt = G, Ft -= 257, z = H, ft -= 257, 256) : (Tt = w, z = ut, -1), wt = y, K = b, Z = Q = st = 0, j = -1, Y = (gt = 1 << (O = S)) - 1, pt === 1 && 852 < gt || pt === 2 && 592 < gt)
                                                return 1;
                                              for (; ; ) {
                                                for (Et = wt - Z, Lt = lt[Q] < yt ? (Ct = 0, lt[Q]) : lt[Q] > yt ? (Ct = z[ft + lt[Q]], Tt[Ft + lt[Q]]) : (Ct = 96, 0), U = 1 << wt - Z, y = L = 1 << O; rt[K + (st >> Z) + (L -= U)] = Et << 24 | Ct << 16 | Lt | 0, L !== 0; )
                                                  ;
                                                for (U = 1 << wt - 1; st & U; )
                                                  U >>= 1;
                                                if (U !== 0 ? (st &= U - 1, st += U) : st = 0, Q++, --ht[wt] == 0) {
                                                  if (wt === g)
                                                    break;
                                                  wt = _t[vt + lt[Q]];
                                                }
                                                if (S < wt && (st & Y) !== j) {
                                                  for (Z === 0 && (Z = S), K += y, tt = 1 << (O = wt - Z); O + Z < g && !((tt -= ht[O + Z]) <= 0); )
                                                    O++, tt <<= 1;
                                                  if (gt += 1 << O, pt === 1 && 852 < gt || pt === 2 && 592 < gt)
                                                    return 1;
                                                  rt[j = st & Y] = S << 24 | O << 16 | K - b | 0;
                                                }
                                              }
                                              return st !== 0 && (rt[K + st] = wt - Z << 24 | 64 << 16 | 0), q.bits = S, 0;
                                            };
                                          }, { "../utils/common": 41 }], 51: [function(V, mt, k) {
                                            mt.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
                                          }, {}], 52: [function(V, mt, k) {
                                            var B = V("../utils/common");
                                            function G(ht) {
                                              for (var It = ht.length; 0 <= --It; )
                                                ht[It] = 0;
                                            }
                                            var H = 15, w = 16, ut = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], pt = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], _t = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], vt = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], F = new Array(576);
                                            G(F);
                                            var rt = new Array(60);
                                            G(rt);
                                            var b = new Array(512);
                                            G(b);
                                            var lt = new Array(256);
                                            G(lt);
                                            var q = new Array(29);
                                            G(q);
                                            var U, L, j, Y = new Array(30);
                                            function K(ht, It, z, ft, nt) {
                                              this.static_tree = ht, this.extra_bits = It, this.extra_base = z, this.elems = ft, this.max_length = nt, this.has_stree = ht && ht.length;
                                            }
                                            function yt(ht, It) {
                                              this.dyn_tree = ht, this.max_code = 0, this.stat_desc = It;
                                            }
                                            function Et(ht) {
                                              return ht < 256 ? b[ht] : b[256 + (ht >>> 7)];
                                            }
                                            function Ct(ht, It) {
                                              ht.pending_buf[ht.pending++] = 255 & It, ht.pending_buf[ht.pending++] = It >>> 8 & 255;
                                            }
                                            function Lt(ht, It, z) {
                                              ht.bi_valid > w - z ? (ht.bi_buf |= It << ht.bi_valid & 65535, Ct(ht, ht.bi_buf), ht.bi_buf = It >> w - ht.bi_valid, ht.bi_valid += z - w) : (ht.bi_buf |= It << ht.bi_valid & 65535, ht.bi_valid += z);
                                            }
                                            function Wt(ht, It, z) {
                                              Lt(ht, z[2 * It], z[2 * It + 1]);
                                            }
                                            function wt(ht, It) {
                                              for (var z = 0; z |= 1 & ht, ht >>>= 1, z <<= 1, 0 < --It; )
                                                ;
                                              return z >>> 1;
                                            }
                                            function Q(ht, It, z) {
                                              var ft, nt, J = new Array(H + 1), Rt = 0;
                                              for (ft = 1; ft <= H; ft++)
                                                J[ft] = Rt = Rt + z[ft - 1] << 1;
                                              for (nt = 0; nt <= It; nt++) {
                                                var Nt = ht[2 * nt + 1];
                                                Nt !== 0 && (ht[2 * nt] = wt(J[Nt]++, Nt));
                                              }
                                            }
                                            function y(ht) {
                                              var It;
                                              for (It = 0; It < 286; It++)
                                                ht.dyn_ltree[2 * It] = 0;
                                              for (It = 0; It < 30; It++)
                                                ht.dyn_dtree[2 * It] = 0;
                                              for (It = 0; It < 19; It++)
                                                ht.bl_tree[2 * It] = 0;
                                              ht.dyn_ltree[512] = 1, ht.opt_len = ht.static_len = 0, ht.last_lit = ht.matches = 0;
                                            }
                                            function g(ht) {
                                              8 < ht.bi_valid ? Ct(ht, ht.bi_buf) : 0 < ht.bi_valid && (ht.pending_buf[ht.pending++] = ht.bi_buf), ht.bi_buf = 0, ht.bi_valid = 0;
                                            }
                                            function S(ht, It, z, ft) {
                                              var nt = 2 * It, J = 2 * z;
                                              return ht[nt] < ht[J] || ht[nt] === ht[J] && ft[It] <= ft[z];
                                            }
                                            function O(ht, It, z) {
                                              for (var ft = ht.heap[z], nt = z << 1; nt <= ht.heap_len && (nt < ht.heap_len && S(It, ht.heap[nt + 1], ht.heap[nt], ht.depth) && nt++, !S(It, ft, ht.heap[nt], ht.depth)); )
                                                ht.heap[z] = ht.heap[nt], z = nt, nt <<= 1;
                                              ht.heap[z] = ft;
                                            }
                                            function Z(ht, It, z) {
                                              var ft, nt, J, Rt, Nt = 0;
                                              if (ht.last_lit !== 0)
                                                for (; ft = ht.pending_buf[ht.d_buf + 2 * Nt] << 8 | ht.pending_buf[ht.d_buf + 2 * Nt + 1], nt = ht.pending_buf[ht.l_buf + Nt], Nt++, ft === 0 ? Wt(ht, nt, It) : (Wt(ht, (J = lt[nt]) + 256 + 1, It), (Rt = ut[J]) !== 0 && Lt(ht, nt -= q[J], Rt), Wt(ht, J = Et(--ft), z), (Rt = pt[J]) !== 0 && Lt(ht, ft -= Y[J], Rt)), Nt < ht.last_lit; )
                                                  ;
                                              Wt(ht, 256, It);
                                            }
                                            function tt(ht, It) {
                                              var z, ft, nt, J = It.dyn_tree, Rt = It.stat_desc.static_tree, Nt = It.stat_desc.has_stree, Yt = It.stat_desc.elems, Ht = -1;
                                              for (ht.heap_len = 0, ht.heap_max = 573, z = 0; z < Yt; z++)
                                                J[2 * z] !== 0 ? (ht.heap[++ht.heap_len] = Ht = z, ht.depth[z] = 0) : J[2 * z + 1] = 0;
                                              for (; ht.heap_len < 2; )
                                                J[2 * (nt = ht.heap[++ht.heap_len] = Ht < 2 ? ++Ht : 0)] = 1, ht.depth[nt] = 0, ht.opt_len--, Nt && (ht.static_len -= Rt[2 * nt + 1]);
                                              for (It.max_code = Ht, z = ht.heap_len >> 1; 1 <= z; z--)
                                                O(ht, J, z);
                                              for (nt = Yt; z = ht.heap[1], ht.heap[1] = ht.heap[ht.heap_len--], O(ht, J, 1), ft = ht.heap[1], ht.heap[--ht.heap_max] = z, ht.heap[--ht.heap_max] = ft, J[2 * nt] = J[2 * z] + J[2 * ft], ht.depth[nt] = (ht.depth[z] >= ht.depth[ft] ? ht.depth[z] : ht.depth[ft]) + 1, J[2 * z + 1] = J[2 * ft + 1] = nt, ht.heap[1] = nt++, O(ht, J, 1), 2 <= ht.heap_len; )
                                                ;
                                              ht.heap[--ht.heap_max] = ht.heap[1], function(Pt, Mt) {
                                                var $t, Kt, te, Qt, ee, Pe, Ne = Mt.dyn_tree, Je = Mt.max_code, ve = Mt.stat_desc.static_tree, tn = Mt.stat_desc.has_stree, dn = Mt.stat_desc.extra_bits, Qn = Mt.stat_desc.extra_base, zn = Mt.stat_desc.max_length, Rn = 0;
                                                for (Qt = 0; Qt <= H; Qt++)
                                                  Pt.bl_count[Qt] = 0;
                                                for (Ne[2 * Pt.heap[Pt.heap_max] + 1] = 0, $t = Pt.heap_max + 1; $t < 573; $t++)
                                                  zn < (Qt = Ne[2 * Ne[2 * (Kt = Pt.heap[$t]) + 1] + 1] + 1) && (Qt = zn, Rn++), Ne[2 * Kt + 1] = Qt, Je < Kt || (Pt.bl_count[Qt]++, ee = 0, Qn <= Kt && (ee = dn[Kt - Qn]), Pe = Ne[2 * Kt], Pt.opt_len += Pe * (Qt + ee), tn && (Pt.static_len += Pe * (ve[2 * Kt + 1] + ee)));
                                                if (Rn !== 0) {
                                                  do {
                                                    for (Qt = zn - 1; Pt.bl_count[Qt] === 0; )
                                                      Qt--;
                                                    Pt.bl_count[Qt]--, Pt.bl_count[Qt + 1] += 2, Pt.bl_count[zn]--, Rn -= 2;
                                                  } while (0 < Rn);
                                                  for (Qt = zn; Qt !== 0; Qt--)
                                                    for (Kt = Pt.bl_count[Qt]; Kt !== 0; )
                                                      Je < (te = Pt.heap[--$t]) || (Ne[2 * te + 1] !== Qt && (Pt.opt_len += (Qt - Ne[2 * te + 1]) * Ne[2 * te], Ne[2 * te + 1] = Qt), Kt--);
                                                }
                                              }(ht, It), Q(J, Ht, ht.bl_count);
                                            }
                                            function gt(ht, It, z) {
                                              var ft, nt, J = -1, Rt = It[1], Nt = 0, Yt = 7, Ht = 4;
                                              for (Rt === 0 && (Yt = 138, Ht = 3), It[2 * (z + 1) + 1] = 65535, ft = 0; ft <= z; ft++)
                                                nt = Rt, Rt = It[2 * (ft + 1) + 1], ++Nt < Yt && nt === Rt || (Nt < Ht ? ht.bl_tree[2 * nt] += Nt : nt !== 0 ? (nt !== J && ht.bl_tree[2 * nt]++, ht.bl_tree[32]++) : Nt <= 10 ? ht.bl_tree[34]++ : ht.bl_tree[36]++, J = nt, Ht = (Nt = 0) === Rt ? (Yt = 138, 3) : nt === Rt ? (Yt = 6, 3) : (Yt = 7, 4));
                                            }
                                            function st(ht, It, z) {
                                              var ft, nt, J = -1, Rt = It[1], Nt = 0, Yt = 7, Ht = 4;
                                              for (Rt === 0 && (Yt = 138, Ht = 3), ft = 0; ft <= z; ft++)
                                                if (nt = Rt, Rt = It[2 * (ft + 1) + 1], !(++Nt < Yt && nt === Rt)) {
                                                  if (Nt < Ht)
                                                    for (; Wt(ht, nt, ht.bl_tree), --Nt != 0; )
                                                      ;
                                                  else
                                                    nt !== 0 ? (nt !== J && (Wt(ht, nt, ht.bl_tree), Nt--), Wt(ht, 16, ht.bl_tree), Lt(ht, Nt - 3, 2)) : Nt <= 10 ? (Wt(ht, 17, ht.bl_tree), Lt(ht, Nt - 3, 3)) : (Wt(ht, 18, ht.bl_tree), Lt(ht, Nt - 11, 7));
                                                  J = nt, Ht = (Nt = 0) === Rt ? (Yt = 138, 3) : nt === Rt ? (Yt = 6, 3) : (Yt = 7, 4);
                                                }
                                            }
                                            G(Y);
                                            var Tt = !1;
                                            function Ft(ht, It, z, ft) {
                                              var nt, J, Rt;
                                              Lt(ht, 0 + (ft ? 1 : 0), 3), J = It, Rt = z, g(nt = ht), Ct(nt, Rt), Ct(nt, ~Rt), B.arraySet(nt.pending_buf, nt.window, J, Rt, nt.pending), nt.pending += Rt;
                                            }
                                            k._tr_init = function(ht) {
                                              Tt || (function() {
                                                var It, z, ft, nt, J, Rt = new Array(H + 1);
                                                for (nt = ft = 0; nt < 28; nt++)
                                                  for (q[nt] = ft, It = 0; It < 1 << ut[nt]; It++)
                                                    lt[ft++] = nt;
                                                for (lt[ft - 1] = nt, nt = J = 0; nt < 16; nt++)
                                                  for (Y[nt] = J, It = 0; It < 1 << pt[nt]; It++)
                                                    b[J++] = nt;
                                                for (J >>= 7; nt < 30; nt++)
                                                  for (Y[nt] = J << 7, It = 0; It < 1 << pt[nt] - 7; It++)
                                                    b[256 + J++] = nt;
                                                for (z = 0; z <= H; z++)
                                                  Rt[z] = 0;
                                                for (It = 0; It <= 143; )
                                                  F[2 * It + 1] = 8, It++, Rt[8]++;
                                                for (; It <= 255; )
                                                  F[2 * It + 1] = 9, It++, Rt[9]++;
                                                for (; It <= 279; )
                                                  F[2 * It + 1] = 7, It++, Rt[7]++;
                                                for (; It <= 287; )
                                                  F[2 * It + 1] = 8, It++, Rt[8]++;
                                                for (Q(F, 287, Rt), It = 0; It < 30; It++)
                                                  rt[2 * It + 1] = 5, rt[2 * It] = wt(It, 5);
                                                U = new K(F, ut, 257, 286, H), L = new K(rt, pt, 0, 30, H), j = new K(new Array(0), _t, 0, 19, 7);
                                              }(), Tt = !0), ht.l_desc = new yt(ht.dyn_ltree, U), ht.d_desc = new yt(ht.dyn_dtree, L), ht.bl_desc = new yt(ht.bl_tree, j), ht.bi_buf = 0, ht.bi_valid = 0, y(ht);
                                            }, k._tr_stored_block = Ft, k._tr_flush_block = function(ht, It, z, ft) {
                                              var nt, J, Rt = 0;
                                              0 < ht.level ? (ht.strm.data_type === 2 && (ht.strm.data_type = function(Nt) {
                                                var Yt, Ht = 4093624447;
                                                for (Yt = 0; Yt <= 31; Yt++, Ht >>>= 1)
                                                  if (1 & Ht && Nt.dyn_ltree[2 * Yt] !== 0)
                                                    return 0;
                                                if (Nt.dyn_ltree[18] !== 0 || Nt.dyn_ltree[20] !== 0 || Nt.dyn_ltree[26] !== 0)
                                                  return 1;
                                                for (Yt = 32; Yt < 256; Yt++)
                                                  if (Nt.dyn_ltree[2 * Yt] !== 0)
                                                    return 1;
                                                return 0;
                                              }(ht)), tt(ht, ht.l_desc), tt(ht, ht.d_desc), Rt = function(Nt) {
                                                var Yt;
                                                for (gt(Nt, Nt.dyn_ltree, Nt.l_desc.max_code), gt(Nt, Nt.dyn_dtree, Nt.d_desc.max_code), tt(Nt, Nt.bl_desc), Yt = 18; 3 <= Yt && Nt.bl_tree[2 * vt[Yt] + 1] === 0; Yt--)
                                                  ;
                                                return Nt.opt_len += 3 * (Yt + 1) + 5 + 5 + 4, Yt;
                                              }(ht), nt = ht.opt_len + 3 + 7 >>> 3, (J = ht.static_len + 3 + 7 >>> 3) <= nt && (nt = J)) : nt = J = z + 5, z + 4 <= nt && It !== -1 ? Ft(ht, It, z, ft) : ht.strategy === 4 || J === nt ? (Lt(ht, 2 + (ft ? 1 : 0), 3), Z(ht, F, rt)) : (Lt(ht, 4 + (ft ? 1 : 0), 3), function(Nt, Yt, Ht, Pt) {
                                                var Mt;
                                                for (Lt(Nt, Yt - 257, 5), Lt(Nt, Ht - 1, 5), Lt(Nt, Pt - 4, 4), Mt = 0; Mt < Pt; Mt++)
                                                  Lt(Nt, Nt.bl_tree[2 * vt[Mt] + 1], 3);
                                                st(Nt, Nt.dyn_ltree, Yt - 1), st(Nt, Nt.dyn_dtree, Ht - 1);
                                              }(ht, ht.l_desc.max_code + 1, ht.d_desc.max_code + 1, Rt + 1), Z(ht, ht.dyn_ltree, ht.dyn_dtree)), y(ht), ft && g(ht);
                                            }, k._tr_tally = function(ht, It, z) {
                                              return ht.pending_buf[ht.d_buf + 2 * ht.last_lit] = It >>> 8 & 255, ht.pending_buf[ht.d_buf + 2 * ht.last_lit + 1] = 255 & It, ht.pending_buf[ht.l_buf + ht.last_lit] = 255 & z, ht.last_lit++, It === 0 ? ht.dyn_ltree[2 * z]++ : (ht.matches++, It--, ht.dyn_ltree[2 * (lt[z] + 256 + 1)]++, ht.dyn_dtree[2 * Et(It)]++), ht.last_lit === ht.lit_bufsize - 1;
                                            }, k._tr_align = function(ht) {
                                              var It;
                                              Lt(ht, 2, 3), Wt(ht, 256, F), (It = ht).bi_valid === 16 ? (Ct(It, It.bi_buf), It.bi_buf = 0, It.bi_valid = 0) : 8 <= It.bi_valid && (It.pending_buf[It.pending++] = 255 & It.bi_buf, It.bi_buf >>= 8, It.bi_valid -= 8);
                                            };
                                          }, { "../utils/common": 41 }], 53: [function(V, mt, k) {
                                            mt.exports = function() {
                                              this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
                                            };
                                          }, {}], 54: [function(V, mt, k) {
                                            mt.exports = typeof o == "function" ? o : function() {
                                              var B = [].slice.apply(arguments);
                                              B.splice(1, 0, 0), setTimeout.apply(null, B);
                                            };
                                          }, {}] }, {}, [10])(10);
                                        });
                                      }).call(this, D !== void 0 ? D : typeof self < "u" ? self : typeof window < "u" ? window : {});
                                    }, {}] }, {}, [1])(1);
                                  });
                                }).call(this, M !== void 0 ? M : typeof self < "u" ? self : typeof window < "u" ? window : {});
                              }, {}] }, {}, [1])(1);
                            });
                          }).call(this, E !== void 0 ? E : typeof self < "u" ? self : typeof window < "u" ? window : {});
                        }, {}] }, {}, [1])(1);
                      });
                    }).call(this, f !== void 0 ? f : typeof self < "u" ? self : typeof window < "u" ? window : {});
                  }, {}] }, {}, [1])(1);
                });
              }).call(this, typeof s < "u" ? s : typeof self < "u" ? self : typeof window < "u" ? window : {});
            }, {}] }, {}, [1])(1);
          });
        }).call(this);
      }).call(this, typeof cn < "u" ? cn : typeof self < "u" ? self : typeof window < "u" ? window : {}, e("buffer").Buffer, e("timers").setImmediate);
    }, { buffer: 8, timers: 22 }], 12: [function(e, i, r) {
      var s = e("immediate");
      function a() {
      }
      var o = {}, c = ["REJECTED"], h = ["FULFILLED"], l = ["PENDING"];
      i.exports = f;
      function f(W) {
        if (typeof W != "function")
          throw new TypeError("resolver must be a function");
        this.state = l, this.queue = [], this.outcome = void 0, W !== a && E(this, W);
      }
      f.prototype.finally = function(W) {
        if (typeof W != "function")
          return this;
        var C = this.constructor;
        return this.then(D, N);
        function D(A) {
          function I() {
            return A;
          }
          return C.resolve(W()).then(I);
        }
        function N(A) {
          function I() {
            throw A;
          }
          return C.resolve(W()).then(I);
        }
      }, f.prototype.catch = function(W) {
        return this.then(null, W);
      }, f.prototype.then = function(W, C) {
        if (typeof W != "function" && this.state === h || typeof C != "function" && this.state === c)
          return this;
        var D = new this.constructor(a);
        if (this.state !== l) {
          var N = this.state === h ? W : C;
          m(D, N, this.outcome);
        } else
          this.queue.push(new d(D, W, C));
        return D;
      };
      function d(W, C, D) {
        this.promise = W, typeof C == "function" && (this.onFulfilled = C, this.callFulfilled = this.otherCallFulfilled), typeof D == "function" && (this.onRejected = D, this.callRejected = this.otherCallRejected);
      }
      d.prototype.callFulfilled = function(W) {
        o.resolve(this.promise, W);
      }, d.prototype.otherCallFulfilled = function(W) {
        m(this.promise, this.onFulfilled, W);
      }, d.prototype.callRejected = function(W) {
        o.reject(this.promise, W);
      }, d.prototype.otherCallRejected = function(W) {
        m(this.promise, this.onRejected, W);
      };
      function m(W, C, D) {
        s(function() {
          var N;
          try {
            N = C(D);
          } catch (A) {
            return o.reject(W, A);
          }
          N === W ? o.reject(W, new TypeError("Cannot resolve promise with itself")) : o.resolve(W, N);
        });
      }
      o.resolve = function(W, C) {
        var D = _(v, C);
        if (D.status === "error")
          return o.reject(W, D.value);
        var N = D.value;
        if (N)
          E(W, N);
        else {
          W.state = h, W.outcome = C;
          for (var A = -1, I = W.queue.length; ++A < I; )
            W.queue[A].callFulfilled(C);
        }
        return W;
      }, o.reject = function(W, C) {
        W.state = c, W.outcome = C;
        for (var D = -1, N = W.queue.length; ++D < N; )
          W.queue[D].callRejected(C);
        return W;
      };
      function v(W) {
        var C = W && W.then;
        if (W && (typeof W == "object" || typeof W == "function") && typeof C == "function")
          return function() {
            C.apply(W, arguments);
          };
      }
      function E(W, C) {
        var D = !1;
        function N(V) {
          D || (D = !0, o.reject(W, V));
        }
        function A(V) {
          D || (D = !0, o.resolve(W, V));
        }
        function I() {
          C(A, N);
        }
        var it = _(I);
        it.status === "error" && N(it.value);
      }
      function _(W, C) {
        var D = {};
        try {
          D.value = W(C), D.status = "success";
        } catch (N) {
          D.status = "error", D.value = N;
        }
        return D;
      }
      f.resolve = p;
      function p(W) {
        return W instanceof this ? W : o.resolve(new this(a), W);
      }
      f.reject = R;
      function R(W) {
        var C = new this(a);
        return o.reject(C, W);
      }
      f.all = M;
      function M(W) {
        var C = this;
        if (Object.prototype.toString.call(W) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var D = W.length, N = !1;
        if (!D)
          return this.resolve([]);
        for (var A = new Array(D), I = 0, it = -1, V = new this(a); ++it < D; )
          mt(W[it], it);
        return V;
        function mt(k, B) {
          C.resolve(k).then(G, function(H) {
            N || (N = !0, o.reject(V, H));
          });
          function G(H) {
            A[B] = H, ++I === D && !N && (N = !0, o.resolve(V, A));
          }
        }
      }
      f.race = P;
      function P(W) {
        var C = this;
        if (Object.prototype.toString.call(W) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var D = W.length, N = !1;
        if (!D)
          return this.resolve([]);
        for (var A = -1, I = new this(a); ++A < D; )
          it(W[A]);
        return I;
        function it(V) {
          C.resolve(V).then(function(mt) {
            N || (N = !0, o.resolve(I, mt));
          }, function(mt) {
            N || (N = !0, o.reject(I, mt));
          });
        }
      }
    }, { immediate: 10 }], 13: [function(e, i, r) {
      (function() {
        typeof i == "object" && i.exports ? i.exports = h : this.LRUCache = h;
        function s(p, R) {
          return Object.prototype.hasOwnProperty.call(p, R);
        }
        function a() {
          return 1;
        }
        var o = !1;
        function c(p) {
          !o && typeof p != "string" && typeof p != "number" && (o = !0, console.error(new TypeError("LRU: key must be a string or number. Almost certainly a bug! " + typeof p).stack));
        }
        function h(p) {
          if (!(this instanceof h))
            return new h(p);
          typeof p == "number" && (p = { max: p }), p || (p = {}), this._max = p.max, (!this._max || typeof this._max != "number" || this._max <= 0) && (this._max = 1 / 0), this._lengthCalculator = p.length || a, typeof this._lengthCalculator != "function" && (this._lengthCalculator = a), this._allowStale = p.stale || !1, this._maxAge = p.maxAge || null, this._dispose = p.dispose, this.reset();
        }
        Object.defineProperty(
          h.prototype,
          "max",
          {
            set: function(p) {
              (!p || typeof p != "number" || p <= 0) && (p = 1 / 0), this._max = p, this._length > this._max && m(this);
            },
            get: function() {
              return this._max;
            },
            enumerable: !0
          }
        ), Object.defineProperty(
          h.prototype,
          "lengthCalculator",
          {
            set: function(p) {
              if (typeof p != "function") {
                this._lengthCalculator = a, this._length = this._itemCount;
                for (var R in this._cache)
                  this._cache[R].length = 1;
              } else {
                this._lengthCalculator = p, this._length = 0;
                for (var R in this._cache)
                  this._cache[R].length = this._lengthCalculator(this._cache[R].value), this._length += this._cache[R].length;
              }
              this._length > this._max && m(this);
            },
            get: function() {
              return this._lengthCalculator;
            },
            enumerable: !0
          }
        ), Object.defineProperty(
          h.prototype,
          "length",
          {
            get: function() {
              return this._length;
            },
            enumerable: !0
          }
        ), Object.defineProperty(
          h.prototype,
          "itemCount",
          {
            get: function() {
              return this._itemCount;
            },
            enumerable: !0
          }
        ), h.prototype.forEach = function(p, R) {
          R = R || this;
          for (var M = 0, P = this._itemCount, W = this._mru - 1; W >= 0 && M < P; W--)
            if (this._lruList[W]) {
              M++;
              var C = this._lruList[W];
              f(this, C) && (E(this, C), this._allowStale || (C = void 0)), C && p.call(R, C.value, C.key, this);
            }
        }, h.prototype.keys = function() {
          for (var p = new Array(this._itemCount), R = 0, M = this._mru - 1; M >= 0 && R < this._itemCount; M--)
            if (this._lruList[M]) {
              var P = this._lruList[M];
              p[R++] = P.key;
            }
          return p;
        }, h.prototype.values = function() {
          for (var p = new Array(this._itemCount), R = 0, M = this._mru - 1; M >= 0 && R < this._itemCount; M--)
            if (this._lruList[M]) {
              var P = this._lruList[M];
              p[R++] = P.value;
            }
          return p;
        }, h.prototype.reset = function() {
          if (this._dispose && this._cache)
            for (var p in this._cache)
              this._dispose(p, this._cache[p].value);
          this._cache = /* @__PURE__ */ Object.create(null), this._lruList = /* @__PURE__ */ Object.create(null), this._mru = 0, this._lru = 0, this._length = 0, this._itemCount = 0;
        }, h.prototype.dump = function() {
          for (var p = [], R = 0, M = this._mru - 1; M >= 0 && R < this._itemCount; M--)
            if (this._lruList[M]) {
              var P = this._lruList[M];
              f(this, P) || (++R, p.push({
                k: P.key,
                v: P.value,
                e: P.now + (P.maxAge || 0)
              }));
            }
          return p;
        }, h.prototype.dumpLru = function() {
          return this._lruList;
        }, h.prototype.set = function(p, R, M) {
          M = M || this._maxAge, c(p);
          var P = M ? Date.now() : 0, W = this._lengthCalculator(R);
          if (s(this._cache, p))
            return W > this._max ? (E(this, this._cache[p]), !1) : (this._dispose && this._dispose(p, this._cache[p].value), this._cache[p].now = P, this._cache[p].maxAge = M, this._cache[p].value = R, this._length += W - this._cache[p].length, this._cache[p].length = W, this.get(p), this._length > this._max && m(this), !0);
          var C = new _(p, R, this._mru++, W, P, M);
          return C.length > this._max ? (this._dispose && this._dispose(p, R), !1) : (this._length += C.length, this._lruList[C.lu] = this._cache[p] = C, this._itemCount++, this._length > this._max && m(this), !0);
        }, h.prototype.has = function(p) {
          if (c(p), !s(this._cache, p))
            return !1;
          var R = this._cache[p];
          return !f(this, R);
        }, h.prototype.get = function(p) {
          return c(p), l(this, p, !0);
        }, h.prototype.peek = function(p) {
          return c(p), l(this, p, !1);
        }, h.prototype.pop = function() {
          var p = this._lruList[this._lru];
          return E(this, p), p || null;
        }, h.prototype.del = function(p) {
          c(p), E(this, this._cache[p]);
        }, h.prototype.load = function(p) {
          this.reset();
          for (var R = Date.now(), M = p.length - 1; M >= 0; M--) {
            var P = p[M];
            c(P.k);
            var W = P.e || 0;
            if (W === 0)
              this.set(P.k, P.v);
            else {
              var C = W - R;
              C > 0 && this.set(P.k, P.v, C);
            }
          }
        };
        function l(p, R, M) {
          c(R);
          var P = p._cache[R];
          return P && (f(p, P) ? (E(p, P), p._allowStale || (P = void 0)) : M && d(p, P), P && (P = P.value)), P;
        }
        function f(p, R) {
          if (!R || !R.maxAge && !p._maxAge)
            return !1;
          var M = !1, P = Date.now() - R.now;
          return R.maxAge ? M = P > R.maxAge : M = p._maxAge && P > p._maxAge, M;
        }
        function d(p, R) {
          v(p, R), R.lu = p._mru++, p._lruList[R.lu] = R;
        }
        function m(p) {
          for (; p._lru < p._mru && p._length > p._max; )
            E(p, p._lruList[p._lru]);
        }
        function v(p, R) {
          for (delete p._lruList[R.lu]; p._lru < p._mru && !p._lruList[p._lru]; )
            p._lru++;
        }
        function E(p, R) {
          R && (p._dispose && p._dispose(R.key, R.value), p._length -= R.length, p._itemCount--, delete p._cache[R.key], v(p, R));
        }
        function _(p, R, M, P, W, C) {
          this.key = p, this.value = R, this.lu = M, this.length = P, this.now = W, C && (this.maxAge = C);
        }
      })();
    }, {}], 14: [function(e, i, r) {
      e("text-encoding-polyfill");
      var s = e("string_decoder").StringDecoder;
      function a(h) {
        var l = new s(), f = l.write(h) + l.end();
        return f.replace(/\0/g, "").trim();
      }
      i.exports = c;
      var o = /^(?:ANSI\s)?(\d+)$/m;
      function c(h, l) {
        if (!h)
          return a;
        try {
          new TextDecoder(h.trim());
        } catch {
          var f = o.exec(h);
          return f && !l ? c("windows-" + f[1], !0) : a;
        }
        return d;
        function d(m) {
          var v = new TextDecoder(h), E = v.decode(m, {
            stream: !0
          }) + v.decode();
          return E.replace(/\0/g, "").trim();
        }
      }
    }, { string_decoder: 19, "text-encoding-polyfill": 20 }], 15: [function(e, i, r) {
      var s = e("./decoder");
      function a(l) {
        var f = {};
        return f.lastUpdated = new Date(l.readUInt8(1) + 1900, l.readUInt8(2), l.readUInt8(3)), f.records = l.readUInt32LE(4), f.headerLen = l.readUInt16LE(8), f.recLen = l.readUInt16LE(10), f;
      }
      function o(l, f, d) {
        for (var m = [], v = 32; v < f && (m.push({
          name: d(l.slice(v, v + 11)),
          dataType: String.fromCharCode(l.readUInt8(v + 11)),
          len: l.readUInt8(v + 16),
          decimal: l.readUInt8(v + 17)
        }), l.readUInt8(v + 32) !== 13); )
          v += 32;
        return m;
      }
      function c(l, f, d, m, v) {
        var E = l.slice(f, f + d), _ = v(E);
        switch (m) {
          case "N":
          case "F":
          case "O":
            return parseFloat(_, 10);
          case "D":
            return new Date(_.slice(0, 4), parseInt(_.slice(4, 6), 10) - 1, _.slice(6, 8));
          case "L":
            return _.toLowerCase() === "y" || _.toLowerCase() === "t";
          default:
            return _;
        }
      }
      function h(l, f, d, m) {
        for (var v = {}, E = 0, _ = d.length, p, R; E < _; )
          R = d[E], p = c(l, f, R.len, R.dataType, m), f += R.len, typeof p < "u" && (v[R.name] = p), E++;
        return v;
      }
      i.exports = function(l, f) {
        for (var d = s(f), m = a(l), v = o(l, m.headerLen - 1, d), E = (v.length + 1 << 5) + 2, _ = m.recLen, p = m.records, R = []; p; )
          R.push(h(l, E, v, d)), E += _, p--;
        return R;
      };
    }, { "./decoder": 14 }], 16: [function(e, i, r) {
      var s = i.exports = {}, a, o;
      function c() {
        throw new Error("setTimeout has not been defined");
      }
      function h() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          typeof setTimeout == "function" ? a = setTimeout : a = c;
        } catch {
          a = c;
        }
        try {
          typeof clearTimeout == "function" ? o = clearTimeout : o = h;
        } catch {
          o = h;
        }
      })();
      function l(P) {
        if (a === setTimeout)
          return setTimeout(P, 0);
        if ((a === c || !a) && setTimeout)
          return a = setTimeout, setTimeout(P, 0);
        try {
          return a(P, 0);
        } catch {
          try {
            return a.call(null, P, 0);
          } catch {
            return a.call(this, P, 0);
          }
        }
      }
      function f(P) {
        if (o === clearTimeout)
          return clearTimeout(P);
        if ((o === h || !o) && clearTimeout)
          return o = clearTimeout, clearTimeout(P);
        try {
          return o(P);
        } catch {
          try {
            return o.call(null, P);
          } catch {
            return o.call(this, P);
          }
        }
      }
      var d = [], m = !1, v, E = -1;
      function _() {
        !m || !v || (m = !1, v.length ? d = v.concat(d) : E = -1, d.length && p());
      }
      function p() {
        if (!m) {
          var P = l(_);
          m = !0;
          for (var W = d.length; W; ) {
            for (v = d, d = []; ++E < W; )
              v && v[E].run();
            E = -1, W = d.length;
          }
          v = null, m = !1, f(P);
        }
      }
      s.nextTick = function(P) {
        var W = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var C = 1; C < arguments.length; C++)
            W[C - 1] = arguments[C];
        d.push(new R(P, W)), d.length === 1 && !m && l(p);
      };
      function R(P, W) {
        this.fun = P, this.array = W;
      }
      R.prototype.run = function() {
        this.fun.apply(null, this.array);
      }, s.title = "browser", s.browser = !0, s.env = {}, s.argv = [], s.version = "", s.versions = {};
      function M() {
      }
      s.on = M, s.addListener = M, s.once = M, s.off = M, s.removeListener = M, s.removeAllListeners = M, s.emit = M, s.prependListener = M, s.prependOnceListener = M, s.listeners = function(P) {
        return [];
      }, s.binding = function(P) {
        throw new Error("process.binding is not supported");
      }, s.cwd = function() {
        return "/";
      }, s.chdir = function(P) {
        throw new Error("process.chdir is not supported");
      }, s.umask = function() {
        return 0;
      };
    }, {}], 17: [function(e, i, r) {
      (function(s, a) {
        typeof r == "object" && typeof i < "u" ? i.exports = a() : s.proj4 = a();
      })(this, function() {
        var s = function(u) {
          u("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), u("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"), u("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"), u.WGS84 = u["EPSG:4326"], u["EPSG:3785"] = u["EPSG:3857"], u.GOOGLE = u["EPSG:3857"], u["EPSG:900913"] = u["EPSG:3857"], u["EPSG:102113"] = u["EPSG:3857"];
        }, a = 1, o = 2, c = 3, h = 4, l = 5, f = 6378137, d = 6356752314e-3, m = 0.0066943799901413165, v = 484813681109536e-20, E = Math.PI / 2, _ = 0.16666666666666666, p = 0.04722222222222222, R = 0.022156084656084655, M = 1e-10, P = 0.017453292519943295, W = 57.29577951308232, C = Math.PI / 4, D = Math.PI * 2, N = 3.14159265359, A = {};
        A.greenwich = 0, A.lisbon = -9.131906111111, A.paris = 2.337229166667, A.bogota = -74.080916666667, A.madrid = -3.687938888889, A.rome = 12.452333333333, A.bern = 7.439583333333, A.jakarta = 106.807719444444, A.ferro = -17.666666666667, A.brussels = 4.367975, A.stockholm = 18.058277777778, A.athens = 23.7163375, A.oslo = 10.722916666667;
        var I = {
          ft: { to_meter: 0.3048 },
          "us-ft": { to_meter: 1200 / 3937 }
        }, it = /[\s_\-\/\(\)]/g;
        function V(u, x) {
          if (u[x])
            return u[x];
          for (var T = Object.keys(u), X = x.toLowerCase().replace(it, ""), $ = -1, ct, dt; ++$ < T.length; )
            if (ct = T[$], dt = ct.toLowerCase().replace(it, ""), dt === X)
              return u[ct];
        }
        var mt = function(u) {
          var x = {}, T = u.split("+").map(function(ot) {
            return ot.trim();
          }).filter(function(ot) {
            return ot;
          }).reduce(function(ot, At) {
            var Dt = At.split("=");
            return Dt.push(!0), ot[Dt[0].toLowerCase()] = Dt[1], ot;
          }, {}), X, $, ct, dt = {
            proj: "projName",
            datum: "datumCode",
            rf: function(ot) {
              x.rf = parseFloat(ot);
            },
            lat_0: function(ot) {
              x.lat0 = ot * P;
            },
            lat_1: function(ot) {
              x.lat1 = ot * P;
            },
            lat_2: function(ot) {
              x.lat2 = ot * P;
            },
            lat_ts: function(ot) {
              x.lat_ts = ot * P;
            },
            lon_0: function(ot) {
              x.long0 = ot * P;
            },
            lon_1: function(ot) {
              x.long1 = ot * P;
            },
            lon_2: function(ot) {
              x.long2 = ot * P;
            },
            alpha: function(ot) {
              x.alpha = parseFloat(ot) * P;
            },
            gamma: function(ot) {
              x.rectified_grid_angle = parseFloat(ot);
            },
            lonc: function(ot) {
              x.longc = ot * P;
            },
            x_0: function(ot) {
              x.x0 = parseFloat(ot);
            },
            y_0: function(ot) {
              x.y0 = parseFloat(ot);
            },
            k_0: function(ot) {
              x.k0 = parseFloat(ot);
            },
            k: function(ot) {
              x.k0 = parseFloat(ot);
            },
            a: function(ot) {
              x.a = parseFloat(ot);
            },
            b: function(ot) {
              x.b = parseFloat(ot);
            },
            r_a: function() {
              x.R_A = !0;
            },
            zone: function(ot) {
              x.zone = parseInt(ot, 10);
            },
            south: function() {
              x.utmSouth = !0;
            },
            towgs84: function(ot) {
              x.datum_params = ot.split(",").map(function(At) {
                return parseFloat(At);
              });
            },
            to_meter: function(ot) {
              x.to_meter = parseFloat(ot);
            },
            units: function(ot) {
              x.units = ot;
              var At = V(I, ot);
              At && (x.to_meter = At.to_meter);
            },
            from_greenwich: function(ot) {
              x.from_greenwich = ot * P;
            },
            pm: function(ot) {
              var At = V(A, ot);
              x.from_greenwich = (At || parseFloat(ot)) * P;
            },
            nadgrids: function(ot) {
              ot === "@null" ? x.datumCode = "none" : x.nadgrids = ot;
            },
            axis: function(ot) {
              var At = "ewnsud";
              ot.length === 3 && At.indexOf(ot.substr(0, 1)) !== -1 && At.indexOf(ot.substr(1, 1)) !== -1 && At.indexOf(ot.substr(2, 1)) !== -1 && (x.axis = ot);
            },
            approx: function() {
              x.approx = !0;
            }
          };
          for (X in T)
            $ = T[X], X in dt ? (ct = dt[X], typeof ct == "function" ? ct($) : x[ct] = $) : x[X] = $;
          return typeof x.datumCode == "string" && x.datumCode !== "WGS84" && (x.datumCode = x.datumCode.toLowerCase()), x;
        }, k = 1, B = 2, G = 3, H = 4, w = 5, ut = -1, pt = /\s/, _t = /[A-Za-z]/, vt = /[A-Za-z84]/, F = /[,\]]/, rt = /[\d\.E\-\+]/;
        function b(u) {
          if (typeof u != "string")
            throw new Error("not a string");
          this.text = u.trim(), this.level = 0, this.place = 0, this.root = null, this.stack = [], this.currentObject = null, this.state = k;
        }
        b.prototype.readCharicter = function() {
          var u = this.text[this.place++];
          if (this.state !== H)
            for (; pt.test(u); ) {
              if (this.place >= this.text.length)
                return;
              u = this.text[this.place++];
            }
          switch (this.state) {
            case k:
              return this.neutral(u);
            case B:
              return this.keyword(u);
            case H:
              return this.quoted(u);
            case w:
              return this.afterquote(u);
            case G:
              return this.number(u);
            case ut:
              return;
          }
        }, b.prototype.afterquote = function(u) {
          if (u === '"') {
            this.word += '"', this.state = H;
            return;
          }
          if (F.test(u)) {
            this.word = this.word.trim(), this.afterItem(u);
            return;
          }
          throw new Error(`havn't handled "` + u + '" in afterquote yet, index ' + this.place);
        }, b.prototype.afterItem = function(u) {
          if (u === ",") {
            this.word !== null && this.currentObject.push(this.word), this.word = null, this.state = k;
            return;
          }
          if (u === "]") {
            this.level--, this.word !== null && (this.currentObject.push(this.word), this.word = null), this.state = k, this.currentObject = this.stack.pop(), this.currentObject || (this.state = ut);
            return;
          }
        }, b.prototype.number = function(u) {
          if (rt.test(u)) {
            this.word += u;
            return;
          }
          if (F.test(u)) {
            this.word = parseFloat(this.word), this.afterItem(u);
            return;
          }
          throw new Error(`havn't handled "` + u + '" in number yet, index ' + this.place);
        }, b.prototype.quoted = function(u) {
          if (u === '"') {
            this.state = w;
            return;
          }
          this.word += u;
        }, b.prototype.keyword = function(u) {
          if (vt.test(u)) {
            this.word += u;
            return;
          }
          if (u === "[") {
            var x = [];
            x.push(this.word), this.level++, this.root === null ? this.root = x : this.currentObject.push(x), this.stack.push(this.currentObject), this.currentObject = x, this.state = k;
            return;
          }
          if (F.test(u)) {
            this.afterItem(u);
            return;
          }
          throw new Error(`havn't handled "` + u + '" in keyword yet, index ' + this.place);
        }, b.prototype.neutral = function(u) {
          if (_t.test(u)) {
            this.word = u, this.state = B;
            return;
          }
          if (u === '"') {
            this.word = "", this.state = H;
            return;
          }
          if (rt.test(u)) {
            this.word = u, this.state = G;
            return;
          }
          if (F.test(u)) {
            this.afterItem(u);
            return;
          }
          throw new Error(`havn't handled "` + u + '" in neutral yet, index ' + this.place);
        }, b.prototype.output = function() {
          for (; this.place < this.text.length; )
            this.readCharicter();
          if (this.state === ut)
            return this.root;
          throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
        };
        function lt(u) {
          var x = new b(u);
          return x.output();
        }
        function q(u, x, T) {
          Array.isArray(x) && (T.unshift(x), x = null);
          var X = x ? {} : u, $ = T.reduce(function(ct, dt) {
            return U(dt, ct), ct;
          }, X);
          x && (u[x] = $);
        }
        function U(u, x) {
          if (!Array.isArray(u)) {
            x[u] = !0;
            return;
          }
          var T = u.shift();
          if (T === "PARAMETER" && (T = u.shift()), u.length === 1) {
            if (Array.isArray(u[0])) {
              x[T] = {}, U(u[0], x[T]);
              return;
            }
            x[T] = u[0];
            return;
          }
          if (!u.length) {
            x[T] = !0;
            return;
          }
          if (T === "TOWGS84") {
            x[T] = u;
            return;
          }
          if (T === "AXIS") {
            T in x || (x[T] = []), x[T].push(u);
            return;
          }
          Array.isArray(T) || (x[T] = {});
          var X;
          switch (T) {
            case "UNIT":
            case "PRIMEM":
            case "VERT_DATUM":
              x[T] = {
                name: u[0].toLowerCase(),
                convert: u[1]
              }, u.length === 3 && U(u[2], x[T]);
              return;
            case "SPHEROID":
            case "ELLIPSOID":
              x[T] = {
                name: u[0],
                a: u[1],
                rf: u[2]
              }, u.length === 4 && U(u[3], x[T]);
              return;
            case "PROJECTEDCRS":
            case "PROJCRS":
            case "GEOGCS":
            case "GEOCCS":
            case "PROJCS":
            case "LOCAL_CS":
            case "GEODCRS":
            case "GEODETICCRS":
            case "GEODETICDATUM":
            case "EDATUM":
            case "ENGINEERINGDATUM":
            case "VERT_CS":
            case "VERTCRS":
            case "VERTICALCRS":
            case "COMPD_CS":
            case "COMPOUNDCRS":
            case "ENGINEERINGCRS":
            case "ENGCRS":
            case "FITTED_CS":
            case "LOCAL_DATUM":
            case "DATUM":
              u[0] = ["name", u[0]], q(x, T, u);
              return;
            default:
              for (X = -1; ++X < u.length; )
                if (!Array.isArray(u[X]))
                  return U(u, x[T]);
              return q(x, T, u);
          }
        }
        var L = 0.017453292519943295;
        function j(u, x) {
          var T = x[0], X = x[1];
          !(T in u) && X in u && (u[T] = u[X], x.length === 3 && (u[T] = x[2](u[T])));
        }
        function Y(u) {
          return u * L;
        }
        function K(u) {
          if (u.type === "GEOGCS" ? u.projName = "longlat" : u.type === "LOCAL_CS" ? (u.projName = "identity", u.local = !0) : typeof u.PROJECTION == "object" ? u.projName = Object.keys(u.PROJECTION)[0] : u.projName = u.PROJECTION, u.AXIS) {
            for (var x = "", T = 0, X = u.AXIS.length; T < X; ++T) {
              var $ = [u.AXIS[T][0].toLowerCase(), u.AXIS[T][1].toLowerCase()];
              $[0].indexOf("north") !== -1 || ($[0] === "y" || $[0] === "lat") && $[1] === "north" ? x += "n" : $[0].indexOf("south") !== -1 || ($[0] === "y" || $[0] === "lat") && $[1] === "south" ? x += "s" : $[0].indexOf("east") !== -1 || ($[0] === "x" || $[0] === "lon") && $[1] === "east" ? x += "e" : ($[0].indexOf("west") !== -1 || ($[0] === "x" || $[0] === "lon") && $[1] === "west") && (x += "w");
            }
            x.length === 2 && (x += "u"), x.length === 3 && (u.axis = x);
          }
          u.UNIT && (u.units = u.UNIT.name.toLowerCase(), u.units === "metre" && (u.units = "meter"), u.UNIT.convert && (u.type === "GEOGCS" ? u.DATUM && u.DATUM.SPHEROID && (u.to_meter = u.UNIT.convert * u.DATUM.SPHEROID.a) : u.to_meter = u.UNIT.convert));
          var ct = u.GEOGCS;
          u.type === "GEOGCS" && (ct = u), ct && (ct.DATUM ? u.datumCode = ct.DATUM.name.toLowerCase() : u.datumCode = ct.name.toLowerCase(), u.datumCode.slice(0, 2) === "d_" && (u.datumCode = u.datumCode.slice(2)), (u.datumCode === "new_zealand_geodetic_datum_1949" || u.datumCode === "new_zealand_1949") && (u.datumCode = "nzgd49"), (u.datumCode === "wgs_1984" || u.datumCode === "world_geodetic_system_1984") && (u.PROJECTION === "Mercator_Auxiliary_Sphere" && (u.sphere = !0), u.datumCode = "wgs84"), u.datumCode.slice(-6) === "_ferro" && (u.datumCode = u.datumCode.slice(0, -6)), u.datumCode.slice(-8) === "_jakarta" && (u.datumCode = u.datumCode.slice(0, -8)), ~u.datumCode.indexOf("belge") && (u.datumCode = "rnb72"), ct.DATUM && ct.DATUM.SPHEROID && (u.ellps = ct.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), u.ellps.toLowerCase().slice(0, 13) === "international" && (u.ellps = "intl"), u.a = ct.DATUM.SPHEROID.a, u.rf = parseFloat(ct.DATUM.SPHEROID.rf, 10)), ct.DATUM && ct.DATUM.TOWGS84 && (u.datum_params = ct.DATUM.TOWGS84), ~u.datumCode.indexOf("osgb_1936") && (u.datumCode = "osgb36"), ~u.datumCode.indexOf("osni_1952") && (u.datumCode = "osni52"), (~u.datumCode.indexOf("tm65") || ~u.datumCode.indexOf("geodetic_datum_of_1965")) && (u.datumCode = "ire65"), u.datumCode === "ch1903+" && (u.datumCode = "ch1903"), ~u.datumCode.indexOf("israel") && (u.datumCode = "isr93")), u.b && !isFinite(u.b) && (u.b = u.a);
          function dt(Dt) {
            var Vt = u.to_meter || 1;
            return Dt * Vt;
          }
          var ot = function(Dt) {
            return j(u, Dt);
          }, At = [
            ["standard_parallel_1", "Standard_Parallel_1"],
            ["standard_parallel_1", "Latitude of 1st standard parallel"],
            ["standard_parallel_2", "Standard_Parallel_2"],
            ["standard_parallel_2", "Latitude of 2nd standard parallel"],
            ["false_easting", "False_Easting"],
            ["false_easting", "False easting"],
            ["false-easting", "Easting at false origin"],
            ["false_northing", "False_Northing"],
            ["false_northing", "False northing"],
            ["false_northing", "Northing at false origin"],
            ["central_meridian", "Central_Meridian"],
            ["central_meridian", "Longitude of natural origin"],
            ["central_meridian", "Longitude of false origin"],
            ["latitude_of_origin", "Latitude_Of_Origin"],
            ["latitude_of_origin", "Central_Parallel"],
            ["latitude_of_origin", "Latitude of natural origin"],
            ["latitude_of_origin", "Latitude of false origin"],
            ["scale_factor", "Scale_Factor"],
            ["k0", "scale_factor"],
            ["latitude_of_center", "Latitude_Of_Center"],
            ["latitude_of_center", "Latitude_of_center"],
            ["lat0", "latitude_of_center", Y],
            ["longitude_of_center", "Longitude_Of_Center"],
            ["longitude_of_center", "Longitude_of_center"],
            ["longc", "longitude_of_center", Y],
            ["x0", "false_easting", dt],
            ["y0", "false_northing", dt],
            ["long0", "central_meridian", Y],
            ["lat0", "latitude_of_origin", Y],
            ["lat0", "standard_parallel_1", Y],
            ["lat1", "standard_parallel_1", Y],
            ["lat2", "standard_parallel_2", Y],
            ["azimuth", "Azimuth"],
            ["alpha", "azimuth", Y],
            ["srsCode", "name"]
          ];
          At.forEach(ot), !u.long0 && u.longc && (u.projName === "Albers_Conic_Equal_Area" || u.projName === "Lambert_Azimuthal_Equal_Area") && (u.long0 = u.longc), !u.lat_ts && u.lat1 && (u.projName === "Stereographic_South_Pole" || u.projName === "Polar Stereographic (variant B)") && (u.lat0 = Y(u.lat1 > 0 ? 90 : -90), u.lat_ts = u.lat1);
        }
        var yt = function(u) {
          var x = lt(u), T = x.shift(), X = x.shift();
          x.unshift(["name", X]), x.unshift(["type", T]);
          var $ = {};
          return U(x, $), K($), $;
        };
        function Et(u) {
          var x = this;
          if (arguments.length === 2) {
            var T = arguments[1];
            typeof T == "string" ? T.charAt(0) === "+" ? Et[u] = mt(arguments[1]) : Et[u] = yt(arguments[1]) : Et[u] = T;
          } else if (arguments.length === 1) {
            if (Array.isArray(u))
              return u.map(function(X) {
                Array.isArray(X) ? Et.apply(x, X) : Et(X);
              });
            if (typeof u == "string") {
              if (u in Et)
                return Et[u];
            } else
              "EPSG" in u ? Et["EPSG:" + u.EPSG] = u : "ESRI" in u ? Et["ESRI:" + u.ESRI] = u : "IAU2000" in u ? Et["IAU2000:" + u.IAU2000] = u : console.log(u);
            return;
          }
        }
        s(Et);
        function Ct(u) {
          return typeof u == "string";
        }
        function Lt(u) {
          return u in Et;
        }
        var Wt = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
        function wt(u) {
          return Wt.some(function(x) {
            return u.indexOf(x) > -1;
          });
        }
        var Q = ["3857", "900913", "3785", "102113"];
        function y(u) {
          var x = V(u, "authority");
          if (x) {
            var T = V(x, "epsg");
            return T && Q.indexOf(T) > -1;
          }
        }
        function g(u) {
          var x = V(u, "extension");
          if (x)
            return V(x, "proj4");
        }
        function S(u) {
          return u[0] === "+";
        }
        function O(u) {
          if (Ct(u)) {
            if (Lt(u))
              return Et[u];
            if (wt(u)) {
              var x = yt(u);
              if (y(x))
                return Et["EPSG:3857"];
              var T = g(x);
              return T ? mt(T) : x;
            }
            if (S(u))
              return mt(u);
          } else
            return u;
        }
        var Z = function(u, x) {
          u = u || {};
          var T, X;
          if (!x)
            return u;
          for (X in x)
            T = x[X], T !== void 0 && (u[X] = T);
          return u;
        }, tt = function(u, x, T) {
          var X = u * x;
          return T / Math.sqrt(1 - X * X);
        }, gt = function(u) {
          return u < 0 ? -1 : 1;
        }, st = function(u) {
          return Math.abs(u) <= N ? u : u - gt(u) * D;
        }, Tt = function(u, x, T) {
          var X = u * T, $ = 0.5 * u;
          return X = Math.pow((1 - X) / (1 + X), $), Math.tan(0.5 * (E - x)) / X;
        }, Ft = function(u, x) {
          for (var T = 0.5 * u, X, $, ct = E - 2 * Math.atan(x), dt = 0; dt <= 15; dt++)
            if (X = u * Math.sin(ct), $ = E - 2 * Math.atan(x * Math.pow((1 - X) / (1 + X), T)) - ct, ct += $, Math.abs($) <= 1e-10)
              return ct;
          return -9999;
        };
        function ht() {
          var u = this.b / this.a;
          this.es = 1 - u * u, "x0" in this || (this.x0 = 0), "y0" in this || (this.y0 = 0), this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = tt(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1);
        }
        function It(u) {
          var x = u.x, T = u.y;
          if (T * W > 90 && T * W < -90 && x * W > 180 && x * W < -180)
            return null;
          var X, $;
          if (Math.abs(Math.abs(T) - E) <= M)
            return null;
          if (this.sphere)
            X = this.x0 + this.a * this.k0 * st(x - this.long0), $ = this.y0 + this.a * this.k0 * Math.log(Math.tan(C + 0.5 * T));
          else {
            var ct = Math.sin(T), dt = Tt(this.e, T, ct);
            X = this.x0 + this.a * this.k0 * st(x - this.long0), $ = this.y0 - this.a * this.k0 * Math.log(dt);
          }
          return u.x = X, u.y = $, u;
        }
        function z(u) {
          var x = u.x - this.x0, T = u.y - this.y0, X, $;
          if (this.sphere)
            $ = E - 2 * Math.atan(Math.exp(-T / (this.a * this.k0)));
          else {
            var ct = Math.exp(-T / (this.a * this.k0));
            if ($ = Ft(this.e, ct), $ === -9999)
              return null;
          }
          return X = st(this.long0 + x / (this.a * this.k0)), u.x = X, u.y = $, u;
        }
        var ft = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"], nt = {
          init: ht,
          forward: It,
          inverse: z,
          names: ft
        };
        function J() {
        }
        function Rt(u) {
          return u;
        }
        var Nt = ["longlat", "identity"], Yt = {
          init: J,
          forward: Rt,
          inverse: Rt,
          names: Nt
        }, Ht = [nt, Yt], Pt = {}, Mt = [];
        function $t(u, x) {
          var T = Mt.length;
          return u.names ? (Mt[T] = u, u.names.forEach(function(X) {
            Pt[X.toLowerCase()] = T;
          }), this) : (console.log(x), !0);
        }
        function Kt(u) {
          if (!u)
            return !1;
          var x = u.toLowerCase();
          if (typeof Pt[x] < "u" && Mt[Pt[x]])
            return Mt[Pt[x]];
        }
        function te() {
          Ht.forEach($t);
        }
        var Qt = {
          start: te,
          add: $t,
          get: Kt
        }, ee = {};
        ee.MERIT = {
          a: 6378137,
          rf: 298.257,
          ellipseName: "MERIT 1983"
        }, ee.SGS85 = {
          a: 6378136,
          rf: 298.257,
          ellipseName: "Soviet Geodetic System 85"
        }, ee.GRS80 = {
          a: 6378137,
          rf: 298.257222101,
          ellipseName: "GRS 1980(IUGG, 1980)"
        }, ee.IAU76 = {
          a: 6378140,
          rf: 298.257,
          ellipseName: "IAU 1976"
        }, ee.airy = {
          a: 6377563396e-3,
          b: 635625691e-2,
          ellipseName: "Airy 1830"
        }, ee.APL4 = {
          a: 6378137,
          rf: 298.25,
          ellipseName: "Appl. Physics. 1965"
        }, ee.NWL9D = {
          a: 6378145,
          rf: 298.25,
          ellipseName: "Naval Weapons Lab., 1965"
        }, ee.mod_airy = {
          a: 6377340189e-3,
          b: 6356034446e-3,
          ellipseName: "Modified Airy"
        }, ee.andrae = {
          a: 637710443e-2,
          rf: 300,
          ellipseName: "Andrae 1876 (Den., Iclnd.)"
        }, ee.aust_SA = {
          a: 6378160,
          rf: 298.25,
          ellipseName: "Australian Natl & S. Amer. 1969"
        }, ee.GRS67 = {
          a: 6378160,
          rf: 298.247167427,
          ellipseName: "GRS 67(IUGG 1967)"
        }, ee.bessel = {
          a: 6377397155e-3,
          rf: 299.1528128,
          ellipseName: "Bessel 1841"
        }, ee.bess_nam = {
          a: 6377483865e-3,
          rf: 299.1528128,
          ellipseName: "Bessel 1841 (Namibia)"
        }, ee.clrk66 = {
          a: 63782064e-1,
          b: 63565838e-1,
          ellipseName: "Clarke 1866"
        }, ee.clrk80 = {
          a: 6378249145e-3,
          rf: 293.4663,
          ellipseName: "Clarke 1880 mod."
        }, ee.clrk58 = {
          a: 6378293645208759e-9,
          rf: 294.2606763692654,
          ellipseName: "Clarke 1858"
        }, ee.CPM = {
          a: 63757387e-1,
          rf: 334.29,
          ellipseName: "Comm. des Poids et Mesures 1799"
        }, ee.delmbr = {
          a: 6376428,
          rf: 311.5,
          ellipseName: "Delambre 1810 (Belgium)"
        }, ee.engelis = {
          a: 637813605e-2,
          rf: 298.2566,
          ellipseName: "Engelis 1985"
        }, ee.evrst30 = {
          a: 6377276345e-3,
          rf: 300.8017,
          ellipseName: "Everest 1830"
        }, ee.evrst48 = {
          a: 6377304063e-3,
          rf: 300.8017,
          ellipseName: "Everest 1948"
        }, ee.evrst56 = {
          a: 6377301243e-3,
          rf: 300.8017,
          ellipseName: "Everest 1956"
        }, ee.evrst69 = {
          a: 6377295664e-3,
          rf: 300.8017,
          ellipseName: "Everest 1969"
        }, ee.evrstSS = {
          a: 6377298556e-3,
          rf: 300.8017,
          ellipseName: "Everest (Sabah & Sarawak)"
        }, ee.fschr60 = {
          a: 6378166,
          rf: 298.3,
          ellipseName: "Fischer (Mercury Datum) 1960"
        }, ee.fschr60m = {
          a: 6378155,
          rf: 298.3,
          ellipseName: "Fischer 1960"
        }, ee.fschr68 = {
          a: 6378150,
          rf: 298.3,
          ellipseName: "Fischer 1968"
        }, ee.helmert = {
          a: 6378200,
          rf: 298.3,
          ellipseName: "Helmert 1906"
        }, ee.hough = {
          a: 6378270,
          rf: 297,
          ellipseName: "Hough"
        }, ee.intl = {
          a: 6378388,
          rf: 297,
          ellipseName: "International 1909 (Hayford)"
        }, ee.kaula = {
          a: 6378163,
          rf: 298.24,
          ellipseName: "Kaula 1961"
        }, ee.lerch = {
          a: 6378139,
          rf: 298.257,
          ellipseName: "Lerch 1979"
        }, ee.mprts = {
          a: 6397300,
          rf: 191,
          ellipseName: "Maupertius 1738"
        }, ee.new_intl = {
          a: 63781575e-1,
          b: 63567722e-1,
          ellipseName: "New International 1967"
        }, ee.plessis = {
          a: 6376523,
          rf: 6355863,
          ellipseName: "Plessis 1817 (France)"
        }, ee.krass = {
          a: 6378245,
          rf: 298.3,
          ellipseName: "Krassovsky, 1942"
        }, ee.SEasia = {
          a: 6378155,
          b: 63567733205e-4,
          ellipseName: "Southeast Asia"
        }, ee.walbeck = {
          a: 6376896,
          b: 63558348467e-4,
          ellipseName: "Walbeck"
        }, ee.WGS60 = {
          a: 6378165,
          rf: 298.3,
          ellipseName: "WGS 60"
        }, ee.WGS66 = {
          a: 6378145,
          rf: 298.25,
          ellipseName: "WGS 66"
        }, ee.WGS7 = {
          a: 6378135,
          rf: 298.26,
          ellipseName: "WGS 72"
        };
        var Pe = ee.WGS84 = {
          a: 6378137,
          rf: 298.257223563,
          ellipseName: "WGS 84"
        };
        ee.sphere = {
          a: 6370997,
          b: 6370997,
          ellipseName: "Normal Sphere (r=6370997)"
        };
        function Ne(u, x, T, X) {
          var $ = u * u, ct = x * x, dt = ($ - ct) / $, ot = 0;
          X ? (u *= 1 - dt * (_ + dt * (p + dt * R)), $ = u * u, dt = 0) : ot = Math.sqrt(dt);
          var At = ($ - ct) / ct;
          return {
            es: dt,
            e: ot,
            ep2: At
          };
        }
        function Je(u, x, T, X, $) {
          if (!u) {
            var ct = V(ee, X);
            ct || (ct = Pe), u = ct.a, x = ct.b, T = ct.rf;
          }
          return T && !x && (x = (1 - 1 / T) * u), (T === 0 || Math.abs(u - x) < M) && ($ = !0, x = u), {
            a: u,
            b: x,
            rf: T,
            sphere: $
          };
        }
        var ve = {};
        ve.wgs84 = {
          towgs84: "0,0,0",
          ellipse: "WGS84",
          datumName: "WGS84"
        }, ve.ch1903 = {
          towgs84: "674.374,15.056,405.346",
          ellipse: "bessel",
          datumName: "swiss"
        }, ve.ggrs87 = {
          towgs84: "-199.87,74.79,246.62",
          ellipse: "GRS80",
          datumName: "Greek_Geodetic_Reference_System_1987"
        }, ve.nad83 = {
          towgs84: "0,0,0",
          ellipse: "GRS80",
          datumName: "North_American_Datum_1983"
        }, ve.nad27 = {
          nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
          ellipse: "clrk66",
          datumName: "North_American_Datum_1927"
        }, ve.potsdam = {
          towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
          ellipse: "bessel",
          datumName: "Potsdam Rauenberg 1950 DHDN"
        }, ve.carthage = {
          towgs84: "-263.0,6.0,431.0",
          ellipse: "clark80",
          datumName: "Carthage 1934 Tunisia"
        }, ve.hermannskogel = {
          towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
          ellipse: "bessel",
          datumName: "Hermannskogel"
        }, ve.osni52 = {
          towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
          ellipse: "airy",
          datumName: "Irish National"
        }, ve.ire65 = {
          towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
          ellipse: "mod_airy",
          datumName: "Ireland 1965"
        }, ve.rassadiran = {
          towgs84: "-133.63,-157.5,-158.62",
          ellipse: "intl",
          datumName: "Rassadiran"
        }, ve.nzgd49 = {
          towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
          ellipse: "intl",
          datumName: "New Zealand Geodetic Datum 1949"
        }, ve.osgb36 = {
          towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
          ellipse: "airy",
          datumName: "Airy 1830"
        }, ve.s_jtsk = {
          towgs84: "589,76,480",
          ellipse: "bessel",
          datumName: "S-JTSK (Ferro)"
        }, ve.beduaram = {
          towgs84: "-106,-87,188",
          ellipse: "clrk80",
          datumName: "Beduaram"
        }, ve.gunung_segara = {
          towgs84: "-403,684,41",
          ellipse: "bessel",
          datumName: "Gunung Segara Jakarta"
        }, ve.rnb72 = {
          towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
          ellipse: "intl",
          datumName: "Reseau National Belge 1972"
        };
        function tn(u, x, T, X, $, ct, dt) {
          var ot = {};
          return u === void 0 || u === "none" ? ot.datum_type = l : ot.datum_type = h, x && (ot.datum_params = x.map(parseFloat), (ot.datum_params[0] !== 0 || ot.datum_params[1] !== 0 || ot.datum_params[2] !== 0) && (ot.datum_type = a), ot.datum_params.length > 3 && (ot.datum_params[3] !== 0 || ot.datum_params[4] !== 0 || ot.datum_params[5] !== 0 || ot.datum_params[6] !== 0) && (ot.datum_type = o, ot.datum_params[3] *= v, ot.datum_params[4] *= v, ot.datum_params[5] *= v, ot.datum_params[6] = ot.datum_params[6] / 1e6 + 1)), dt && (ot.datum_type = c, ot.grids = dt), ot.a = T, ot.b = X, ot.es = $, ot.ep2 = ct, ot;
        }
        var dn = {};
        function Qn(u, x) {
          var T = new DataView(x), X = ci(T), $ = Ai(T, X);
          $.nSubgrids > 1 && console.log("Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored");
          var ct = ji(T, $, X), dt = { header: $, subgrids: ct };
          return dn[u] = dt, dt;
        }
        function zn(u) {
          if (u === void 0)
            return null;
          var x = u.split(",");
          return x.map(Rn);
        }
        function Rn(u) {
          if (u.length === 0)
            return null;
          var x = u[0] === "@";
          return x && (u = u.slice(1)), u === "null" ? { name: "null", mandatory: !x, grid: null, isNull: !0 } : {
            name: u,
            mandatory: !x,
            grid: dn[u] || null,
            isNull: !1
          };
        }
        function Gn(u) {
          return u / 3600 * Math.PI / 180;
        }
        function ci(u) {
          var x = u.getInt32(8, !1);
          return x === 11 ? !1 : (x = u.getInt32(8, !0), x !== 11 && console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian"), !0);
        }
        function Ai(u, x) {
          return {
            nFields: u.getInt32(8, x),
            nSubgridFields: u.getInt32(24, x),
            nSubgrids: u.getInt32(40, x),
            shiftType: ui(u, 56, 64).trim(),
            fromSemiMajorAxis: u.getFloat64(120, x),
            fromSemiMinorAxis: u.getFloat64(136, x),
            toSemiMajorAxis: u.getFloat64(152, x),
            toSemiMinorAxis: u.getFloat64(168, x)
          };
        }
        function ui(u, x, T) {
          return String.fromCharCode.apply(null, new Uint8Array(u.buffer.slice(x, T)));
        }
        function ji(u, x, T) {
          for (var X = 176, $ = [], ct = 0; ct < x.nSubgrids; ct++) {
            var dt = qi(u, X, T), ot = St(u, X, dt, T), At = Math.round(
              1 + (dt.upperLongitude - dt.lowerLongitude) / dt.longitudeInterval
            ), Dt = Math.round(
              1 + (dt.upperLatitude - dt.lowerLatitude) / dt.latitudeInterval
            );
            $.push({
              ll: [Gn(dt.lowerLongitude), Gn(dt.lowerLatitude)],
              del: [Gn(dt.longitudeInterval), Gn(dt.latitudeInterval)],
              lim: [At, Dt],
              count: dt.gridNodeCount,
              cvs: Wi(ot)
            });
          }
          return $;
        }
        function Wi(u) {
          return u.map(function(x) {
            return [Gn(x.longitudeShift), Gn(x.latitudeShift)];
          });
        }
        function qi(u, x, T) {
          return {
            name: ui(u, x + 8, x + 16).trim(),
            parent: ui(u, x + 24, x + 24 + 8).trim(),
            lowerLatitude: u.getFloat64(x + 72, T),
            upperLatitude: u.getFloat64(x + 88, T),
            lowerLongitude: u.getFloat64(x + 104, T),
            upperLongitude: u.getFloat64(x + 120, T),
            latitudeInterval: u.getFloat64(x + 136, T),
            longitudeInterval: u.getFloat64(x + 152, T),
            gridNodeCount: u.getInt32(x + 168, T)
          };
        }
        function St(u, x, T, X) {
          for (var $ = x + 176, ct = 16, dt = [], ot = 0; ot < T.gridNodeCount; ot++) {
            var At = {
              latitudeShift: u.getFloat32($ + ot * ct, X),
              longitudeShift: u.getFloat32($ + ot * ct + 4, X),
              latitudeAccuracy: u.getFloat32($ + ot * ct + 8, X),
              longitudeAccuracy: u.getFloat32($ + ot * ct + 12, X)
            };
            dt.push(At);
          }
          return dt;
        }
        function kt(u, x) {
          if (!(this instanceof kt))
            return new kt(u);
          x = x || function(Dt) {
            if (Dt)
              throw Dt;
          };
          var T = O(u);
          if (typeof T != "object") {
            x(u);
            return;
          }
          var X = kt.projections.get(T.projName);
          if (!X) {
            x(u);
            return;
          }
          if (T.datumCode && T.datumCode !== "none") {
            var $ = V(ve, T.datumCode);
            $ && (T.datum_params = T.datum_params || ($.towgs84 ? $.towgs84.split(",") : null), T.ellps = $.ellipse, T.datumName = $.datumName ? $.datumName : T.datumCode);
          }
          T.k0 = T.k0 || 1, T.axis = T.axis || "enu", T.ellps = T.ellps || "wgs84", T.lat1 = T.lat1 || T.lat0;
          var ct = Je(T.a, T.b, T.rf, T.ellps, T.sphere), dt = Ne(ct.a, ct.b, ct.rf, T.R_A), ot = zn(T.nadgrids), At = T.datum || tn(
            T.datumCode,
            T.datum_params,
            ct.a,
            ct.b,
            dt.es,
            dt.ep2,
            ot
          );
          Z(this, T), Z(this, X), this.a = ct.a, this.b = ct.b, this.rf = ct.rf, this.sphere = ct.sphere, this.es = dt.es, this.e = dt.e, this.ep2 = dt.ep2, this.datum = At, this.init(), x(null, this);
        }
        kt.projections = Qt, kt.projections.start();
        function qt(u, x) {
          return u.datum_type !== x.datum_type || u.a !== x.a || Math.abs(u.es - x.es) > 5e-11 ? !1 : u.datum_type === a ? u.datum_params[0] === x.datum_params[0] && u.datum_params[1] === x.datum_params[1] && u.datum_params[2] === x.datum_params[2] : u.datum_type === o ? u.datum_params[0] === x.datum_params[0] && u.datum_params[1] === x.datum_params[1] && u.datum_params[2] === x.datum_params[2] && u.datum_params[3] === x.datum_params[3] && u.datum_params[4] === x.datum_params[4] && u.datum_params[5] === x.datum_params[5] && u.datum_params[6] === x.datum_params[6] : !0;
        }
        function Xt(u, x, T) {
          var X = u.x, $ = u.y, ct = u.z ? u.z : 0, dt, ot, At, Dt;
          if ($ < -E && $ > -1.001 * E)
            $ = -E;
          else if ($ > E && $ < 1.001 * E)
            $ = E;
          else {
            if ($ < -E)
              return { x: -1 / 0, y: -1 / 0, z: u.z };
            if ($ > E)
              return { x: 1 / 0, y: 1 / 0, z: u.z };
          }
          return X > Math.PI && (X -= 2 * Math.PI), ot = Math.sin($), Dt = Math.cos($), At = ot * ot, dt = T / Math.sqrt(1 - x * At), {
            x: (dt + ct) * Dt * Math.cos(X),
            y: (dt + ct) * Dt * Math.sin(X),
            z: (dt * (1 - x) + ct) * ot
          };
        }
        function jt(u, x, T, X) {
          var $ = 1e-12, ct = $ * $, dt = 30, ot, At, Dt, Vt, zt, Jt, se, ne, oe, ce, ge, Ce, Le, Ze = u.x, je = u.y, $e = u.z ? u.z : 0, Nn, pn, Pi;
          if (ot = Math.sqrt(Ze * Ze + je * je), At = Math.sqrt(Ze * Ze + je * je + $e * $e), ot / T < $) {
            if (Nn = 0, At / T < $)
              return pn = E, Pi = -X, {
                x: u.x,
                y: u.y,
                z: u.z
              };
          } else
            Nn = Math.atan2(je, Ze);
          Dt = $e / At, Vt = ot / At, zt = 1 / Math.sqrt(1 - x * (2 - x) * Vt * Vt), ne = Vt * (1 - x) * zt, oe = Dt * zt, Le = 0;
          do
            Le++, se = T / Math.sqrt(1 - x * oe * oe), Pi = ot * ne + $e * oe - se * (1 - x * oe * oe), Jt = x * se / (se + Pi), zt = 1 / Math.sqrt(1 - Jt * (2 - Jt) * Vt * Vt), ce = Vt * (1 - Jt) * zt, ge = Dt * zt, Ce = ge * ne - ce * oe, ne = ce, oe = ge;
          while (Ce * Ce > ct && Le < dt);
          return pn = Math.atan(ge / Math.abs(ce)), {
            x: Nn,
            y: pn,
            z: Pi
          };
        }
        function le(u, x, T) {
          if (x === a)
            return {
              x: u.x + T[0],
              y: u.y + T[1],
              z: u.z + T[2]
            };
          if (x === o) {
            var X = T[0], $ = T[1], ct = T[2], dt = T[3], ot = T[4], At = T[5], Dt = T[6];
            return {
              x: Dt * (u.x - At * u.y + ot * u.z) + X,
              y: Dt * (At * u.x + u.y - dt * u.z) + $,
              z: Dt * (-ot * u.x + dt * u.y + u.z) + ct
            };
          }
        }
        function me(u, x, T) {
          if (x === a)
            return {
              x: u.x - T[0],
              y: u.y - T[1],
              z: u.z - T[2]
            };
          if (x === o) {
            var X = T[0], $ = T[1], ct = T[2], dt = T[3], ot = T[4], At = T[5], Dt = T[6], Vt = (u.x - X) / Dt, zt = (u.y - $) / Dt, Jt = (u.z - ct) / Dt;
            return {
              x: Vt + At * zt - ot * Jt,
              y: -At * Vt + zt + dt * Jt,
              z: ot * Vt - dt * zt + Jt
            };
          }
        }
        function ye(u) {
          return u === a || u === o;
        }
        var xe = function(u, x, T) {
          if (qt(u, x) || u.datum_type === l || x.datum_type === l)
            return T;
          var X = u.a, $ = u.es;
          if (u.datum_type === c) {
            var ct = Te(u, !1, T);
            if (ct !== 0)
              return;
            X = f, $ = m;
          }
          var dt = x.a, ot = x.b, At = x.es;
          if (x.datum_type === c && (dt = f, ot = d, At = m), $ === At && X === dt && !ye(u.datum_type) && !ye(x.datum_type))
            return T;
          if (T = Xt(T, $, X), ye(u.datum_type) && (T = le(T, u.datum_type, u.datum_params)), ye(x.datum_type) && (T = me(T, x.datum_type, x.datum_params)), T = jt(T, At, dt, ot), x.datum_type === c) {
            var Dt = Te(x, !0, T);
            if (Dt !== 0)
              return;
          }
          return T;
        };
        function Te(u, x, T) {
          if (u.grids === null || u.grids.length === 0)
            return console.log("Grid shift grids not found"), -1;
          for (var X = { x: -T.x, y: T.y }, $ = { x: Number.NaN, y: Number.NaN }, ct = [], dt = 0; dt < u.grids.length; dt++) {
            var ot = u.grids[dt];
            if (ct.push(ot.name), ot.isNull) {
              $ = X;
              break;
            }
            if (ot.grid === null) {
              if (ot.mandatory)
                return console.log("Unable to find mandatory grid '" + ot.name + "'"), -1;
              continue;
            }
            var At = ot.grid.subgrids[0], Dt = (Math.abs(At.del[1]) + Math.abs(At.del[0])) / 1e4, Vt = At.ll[0] - Dt, zt = At.ll[1] - Dt, Jt = At.ll[0] + (At.lim[0] - 1) * At.del[0] + Dt, se = At.ll[1] + (At.lim[1] - 1) * At.del[1] + Dt;
            if (!(zt > X.y || Vt > X.x || se < X.y || Jt < X.x) && ($ = Ee(X, x, At), !isNaN($.x)))
              break;
          }
          return isNaN($.x) ? (console.log("Failed to find a grid shift table for location '" + -X.x * W + " " + X.y * W + " tried: '" + ct + "'"), -1) : (T.x = -$.x, T.y = $.y, 0);
        }
        function Ee(u, x, T) {
          var X = { x: Number.NaN, y: Number.NaN };
          if (isNaN(u.x))
            return X;
          var $ = { x: u.x, y: u.y };
          $.x -= T.ll[0], $.y -= T.ll[1], $.x = st($.x - Math.PI) + Math.PI;
          var ct = we($, T);
          if (x) {
            if (isNaN(ct.x))
              return X;
            ct.x = $.x - ct.x, ct.y = $.y - ct.y;
            var dt = 9, ot = 1e-12, At, Dt;
            do {
              if (Dt = we(ct, T), isNaN(Dt.x)) {
                console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
                break;
              }
              At = { x: $.x - (Dt.x + ct.x), y: $.y - (Dt.y + ct.y) }, ct.x += At.x, ct.y += At.y;
            } while (dt-- && Math.abs(At.x) > ot && Math.abs(At.y) > ot);
            if (dt < 0)
              return console.log("Inverse grid shift iterator failed to converge."), X;
            X.x = st(ct.x + T.ll[0]), X.y = ct.y + T.ll[1];
          } else
            isNaN(ct.x) || (X.x = u.x + ct.x, X.y = u.y + ct.y);
          return X;
        }
        function we(u, x) {
          var T = { x: u.x / x.del[0], y: u.y / x.del[1] }, X = { x: Math.floor(T.x), y: Math.floor(T.y) }, $ = { x: T.x - 1 * X.x, y: T.y - 1 * X.y }, ct = { x: Number.NaN, y: Number.NaN }, dt;
          if (X.x < 0 || X.x >= x.lim[0] || X.y < 0 || X.y >= x.lim[1])
            return ct;
          dt = X.y * x.lim[0] + X.x;
          var ot = { x: x.cvs[dt][0], y: x.cvs[dt][1] };
          dt++;
          var At = { x: x.cvs[dt][0], y: x.cvs[dt][1] };
          dt += x.lim[0];
          var Dt = { x: x.cvs[dt][0], y: x.cvs[dt][1] };
          dt--;
          var Vt = { x: x.cvs[dt][0], y: x.cvs[dt][1] }, zt = $.x * $.y, Jt = $.x * (1 - $.y), se = (1 - $.x) * (1 - $.y), ne = (1 - $.x) * $.y;
          return ct.x = se * ot.x + Jt * At.x + ne * Vt.x + zt * Dt.x, ct.y = se * ot.y + Jt * At.y + ne * Vt.y + zt * Dt.y, ct;
        }
        var We = function(u, x, T) {
          var X = T.x, $ = T.y, ct = T.z || 0, dt, ot, At, Dt = {};
          for (At = 0; At < 3; At++)
            if (!(x && At === 2 && T.z === void 0))
              switch (At === 0 ? (dt = X, "ew".indexOf(u.axis[At]) !== -1 ? ot = "x" : ot = "y") : At === 1 ? (dt = $, "ns".indexOf(u.axis[At]) !== -1 ? ot = "y" : ot = "x") : (dt = ct, ot = "z"), u.axis[At]) {
                case "e":
                  Dt[ot] = dt;
                  break;
                case "w":
                  Dt[ot] = -dt;
                  break;
                case "n":
                  Dt[ot] = dt;
                  break;
                case "s":
                  Dt[ot] = -dt;
                  break;
                case "u":
                  T[ot] !== void 0 && (Dt.z = dt);
                  break;
                case "d":
                  T[ot] !== void 0 && (Dt.z = -dt);
                  break;
                default:
                  return null;
              }
          return Dt;
        }, fn = function(u) {
          var x = {
            x: u[0],
            y: u[1]
          };
          return u.length > 2 && (x.z = u[2]), u.length > 3 && (x.m = u[3]), x;
        }, Qe = function(u) {
          wn(u.x), wn(u.y);
        };
        function wn(u) {
          if (typeof Number.isFinite == "function") {
            if (Number.isFinite(u))
              return;
            throw new TypeError("coordinates must be finite numbers");
          }
          if (typeof u != "number" || u !== u || !isFinite(u))
            throw new TypeError("coordinates must be finite numbers");
        }
        function Ve(u, x) {
          return (u.datum.datum_type === a || u.datum.datum_type === o) && x.datumCode !== "WGS84" || (x.datum.datum_type === a || x.datum.datum_type === o) && u.datumCode !== "WGS84";
        }
        function Ae(u, x, T) {
          var X;
          if (Array.isArray(T) && (T = fn(T)), Qe(T), u.datum && x.datum && Ve(u, x) && (X = new kt("WGS84"), T = Ae(u, X, T), u = X), u.axis !== "enu" && (T = We(u, !1, T)), u.projName === "longlat")
            T = {
              x: T.x * P,
              y: T.y * P,
              z: T.z || 0
            };
          else if (u.to_meter && (T = {
            x: T.x * u.to_meter,
            y: T.y * u.to_meter,
            z: T.z || 0
          }), T = u.inverse(T), !T)
            return;
          if (u.from_greenwich && (T.x += u.from_greenwich), T = xe(u.datum, x.datum, T), !!T)
            return x.from_greenwich && (T = {
              x: T.x - x.from_greenwich,
              y: T.y,
              z: T.z || 0
            }), x.projName === "longlat" ? T = {
              x: T.x * W,
              y: T.y * W,
              z: T.z || 0
            } : (T = x.forward(T), x.to_meter && (T = {
              x: T.x / x.to_meter,
              y: T.y / x.to_meter,
              z: T.z || 0
            })), x.axis !== "enu" ? We(x, !0, T) : T;
        }
        var li = kt("WGS84");
        function ze(u, x, T) {
          var X, $, ct;
          return Array.isArray(T) ? (X = Ae(u, x, T) || { x: NaN, y: NaN }, T.length > 2 ? typeof u.name < "u" && u.name === "geocent" || typeof x.name < "u" && x.name === "geocent" ? typeof X.z == "number" ? [X.x, X.y, X.z].concat(T.splice(3)) : [X.x, X.y, T[2]].concat(T.splice(3)) : [X.x, X.y].concat(T.splice(2)) : [X.x, X.y]) : ($ = Ae(u, x, T), ct = Object.keys(T), ct.length === 2 || ct.forEach(function(dt) {
            if (typeof u.name < "u" && u.name === "geocent" || typeof x.name < "u" && x.name === "geocent") {
              if (dt === "x" || dt === "y" || dt === "z")
                return;
            } else if (dt === "x" || dt === "y")
              return;
            $[dt] = T[dt];
          }), $);
        }
        function On(u) {
          return u instanceof kt ? u : u.oProj ? u.oProj : kt(u);
        }
        function hn(u, x, T) {
          u = On(u);
          var X = !1, $;
          return typeof x > "u" ? (x = u, u = li, X = !0) : (typeof x.x < "u" || Array.isArray(x)) && (T = x, x = u, u = li, X = !0), x = On(x), T ? ze(u, x, T) : ($ = {
            forward: function(ct) {
              return ze(u, x, ct);
            },
            inverse: function(ct) {
              return ze(x, u, ct);
            }
          }, X && ($.oProj = x), $);
        }
        var Yn = 6, fi = "AJSAJS", en = "AFAFAF", mn = 65, rn = 73, He = 79, Vn = 86, ti = 90, Ti = {
          forward: pr,
          inverse: $r,
          toPoint: dr
        };
        function pr(u, x) {
          return x = x || 5, Kr(Xr({
            lat: u[1],
            lon: u[0]
          }), x);
        }
        function $r(u) {
          var x = Xi(yr(u.toUpperCase()));
          return x.lat && x.lon ? [x.lon, x.lat, x.lon, x.lat] : [x.left, x.bottom, x.right, x.top];
        }
        function dr(u) {
          var x = Xi(yr(u.toUpperCase()));
          return x.lat && x.lon ? [x.lon, x.lat] : [(x.left + x.right) / 2, (x.top + x.bottom) / 2];
        }
        function $i(u) {
          return u * (Math.PI / 180);
        }
        function mr(u) {
          return 180 * (u / Math.PI);
        }
        function Xr(u) {
          var x = u.lat, T = u.lon, X = 6378137, $ = 669438e-8, ct = 0.9996, dt, ot, At, Dt, Vt, zt, Jt, se = $i(x), ne = $i(T), oe, ce;
          ce = Math.floor((T + 180) / 6) + 1, T === 180 && (ce = 60), x >= 56 && x < 64 && T >= 3 && T < 12 && (ce = 32), x >= 72 && x < 84 && (T >= 0 && T < 9 ? ce = 31 : T >= 9 && T < 21 ? ce = 33 : T >= 21 && T < 33 ? ce = 35 : T >= 33 && T < 42 && (ce = 37)), dt = (ce - 1) * 6 - 180 + 3, oe = $i(dt), ot = $ / (1 - $), At = X / Math.sqrt(1 - $ * Math.sin(se) * Math.sin(se)), Dt = Math.tan(se) * Math.tan(se), Vt = ot * Math.cos(se) * Math.cos(se), zt = Math.cos(se) * (ne - oe), Jt = X * ((1 - $ / 4 - 3 * $ * $ / 64 - 5 * $ * $ * $ / 256) * se - (3 * $ / 8 + 3 * $ * $ / 32 + 45 * $ * $ * $ / 1024) * Math.sin(2 * se) + (15 * $ * $ / 256 + 45 * $ * $ * $ / 1024) * Math.sin(4 * se) - 35 * $ * $ * $ / 3072 * Math.sin(6 * se));
          var ge = ct * At * (zt + (1 - Dt + Vt) * zt * zt * zt / 6 + (5 - 18 * Dt + Dt * Dt + 72 * Vt - 58 * ot) * zt * zt * zt * zt * zt / 120) + 5e5, Ce = ct * (Jt + At * Math.tan(se) * (zt * zt / 2 + (5 - Dt + 9 * Vt + 4 * Vt * Vt) * zt * zt * zt * zt / 24 + (61 - 58 * Dt + Dt * Dt + 600 * Vt - 330 * ot) * zt * zt * zt * zt * zt * zt / 720));
          return x < 0 && (Ce += 1e7), {
            northing: Math.round(Ce),
            easting: Math.round(ge),
            zoneNumber: ce,
            zoneLetter: Yr(x)
          };
        }
        function Xi(u) {
          var x = u.northing, T = u.easting, X = u.zoneLetter, $ = u.zoneNumber;
          if ($ < 0 || $ > 60)
            return null;
          var ct = 0.9996, dt = 6378137, ot = 669438e-8, At, Dt = (1 - Math.sqrt(1 - ot)) / (1 + Math.sqrt(1 - ot)), Vt, zt, Jt, se, ne, oe, ce, ge, Ce, Le = T - 5e5, Ze = x;
          X < "N" && (Ze -= 1e7), ce = ($ - 1) * 6 - 180 + 3, At = ot / (1 - ot), oe = Ze / ct, ge = oe / (dt * (1 - ot / 4 - 3 * ot * ot / 64 - 5 * ot * ot * ot / 256)), Ce = ge + (3 * Dt / 2 - 27 * Dt * Dt * Dt / 32) * Math.sin(2 * ge) + (21 * Dt * Dt / 16 - 55 * Dt * Dt * Dt * Dt / 32) * Math.sin(4 * ge) + 151 * Dt * Dt * Dt / 96 * Math.sin(6 * ge), Vt = dt / Math.sqrt(1 - ot * Math.sin(Ce) * Math.sin(Ce)), zt = Math.tan(Ce) * Math.tan(Ce), Jt = At * Math.cos(Ce) * Math.cos(Ce), se = dt * (1 - ot) / Math.pow(1 - ot * Math.sin(Ce) * Math.sin(Ce), 1.5), ne = Le / (Vt * ct);
          var je = Ce - Vt * Math.tan(Ce) / se * (ne * ne / 2 - (5 + 3 * zt + 10 * Jt - 4 * Jt * Jt - 9 * At) * ne * ne * ne * ne / 24 + (61 + 90 * zt + 298 * Jt + 45 * zt * zt - 252 * At - 3 * Jt * Jt) * ne * ne * ne * ne * ne * ne / 720);
          je = mr(je);
          var $e = (ne - (1 + 2 * zt + Jt) * ne * ne * ne / 6 + (5 - 2 * Jt + 28 * zt - 3 * Jt * Jt + 8 * At + 24 * zt * zt) * ne * ne * ne * ne * ne / 120) / Math.cos(Ce);
          $e = ce + mr($e);
          var Nn;
          if (u.accuracy) {
            var pn = Xi({
              northing: u.northing + u.accuracy,
              easting: u.easting + u.accuracy,
              zoneLetter: u.zoneLetter,
              zoneNumber: u.zoneNumber
            });
            Nn = {
              top: pn.lat,
              right: pn.lon,
              bottom: je,
              left: $e
            };
          } else
            Nn = {
              lat: je,
              lon: $e
            };
          return Nn;
        }
        function Yr(u) {
          var x = "Z";
          return 84 >= u && u >= 72 ? x = "X" : 72 > u && u >= 64 ? x = "W" : 64 > u && u >= 56 ? x = "V" : 56 > u && u >= 48 ? x = "U" : 48 > u && u >= 40 ? x = "T" : 40 > u && u >= 32 ? x = "S" : 32 > u && u >= 24 ? x = "R" : 24 > u && u >= 16 ? x = "Q" : 16 > u && u >= 8 ? x = "P" : 8 > u && u >= 0 ? x = "N" : 0 > u && u >= -8 ? x = "M" : -8 > u && u >= -16 ? x = "L" : -16 > u && u >= -24 ? x = "K" : -24 > u && u >= -32 ? x = "J" : -32 > u && u >= -40 ? x = "H" : -40 > u && u >= -48 ? x = "G" : -48 > u && u >= -56 ? x = "F" : -56 > u && u >= -64 ? x = "E" : -64 > u && u >= -72 ? x = "D" : -72 > u && u >= -80 && (x = "C"), x;
        }
        function Kr(u, x) {
          var T = "00000" + u.easting, X = "00000" + u.northing;
          return u.zoneNumber + u.zoneLetter + Zr(u.easting, u.northing, u.zoneNumber) + T.substr(T.length - 5, x) + X.substr(X.length - 5, x);
        }
        function Zr(u, x, T) {
          var X = _r(T), $ = Math.floor(u / 1e5), ct = Math.floor(x / 1e5) % 20;
          return Jr($, ct, X);
        }
        function _r(u) {
          var x = u % Yn;
          return x === 0 && (x = Yn), x;
        }
        function Jr(u, x, T) {
          var X = T - 1, $ = fi.charCodeAt(X), ct = en.charCodeAt(X), dt = $ + u - 1, ot = ct + x, At = !1;
          dt > ti && (dt = dt - ti + mn - 1, At = !0), (dt === rn || $ < rn && dt > rn || (dt > rn || $ < rn) && At) && dt++, (dt === He || $ < He && dt > He || (dt > He || $ < He) && At) && (dt++, dt === rn && dt++), dt > ti && (dt = dt - ti + mn - 1), ot > Vn ? (ot = ot - Vn + mn - 1, At = !0) : At = !1, (ot === rn || ct < rn && ot > rn || (ot > rn || ct < rn) && At) && ot++, (ot === He || ct < He && ot > He || (ot > He || ct < He) && At) && (ot++, ot === rn && ot++), ot > Vn && (ot = ot - Vn + mn - 1);
          var Dt = String.fromCharCode(dt) + String.fromCharCode(ot);
          return Dt;
        }
        function yr(u) {
          if (u && u.length === 0)
            throw "MGRSPoint coverting from nothing";
          for (var x = u.length, T = null, X = "", $, ct = 0; !/[A-Z]/.test($ = u.charAt(ct)); ) {
            if (ct >= 2)
              throw "MGRSPoint bad conversion from: " + u;
            X += $, ct++;
          }
          var dt = parseInt(X, 10);
          if (ct === 0 || ct + 3 > x)
            throw "MGRSPoint bad conversion from: " + u;
          var ot = u.charAt(ct++);
          if (ot <= "A" || ot === "B" || ot === "Y" || ot >= "Z" || ot === "I" || ot === "O")
            throw "MGRSPoint zone letter " + ot + " not handled: " + u;
          T = u.substring(ct, ct += 2);
          for (var At = _r(dt), Dt = Qr(T.charAt(0), At), Vt = ts(T.charAt(1), At); Vt < es(ot); )
            Vt += 2e6;
          var zt = x - ct;
          if (zt % 2 !== 0)
            throw `MGRSPoint has to have an even number 
of digits after the zone letter and two 100km letters - front 
half for easting meters, second half for 
northing meters` + u;
          var Jt = zt / 2, se = 0, ne = 0, oe, ce, ge, Ce, Le;
          return Jt > 0 && (oe = 1e5 / Math.pow(10, Jt), ce = u.substring(ct, ct + Jt), se = parseFloat(ce) * oe, ge = u.substring(ct + Jt), ne = parseFloat(ge) * oe), Ce = se + Dt, Le = ne + Vt, {
            easting: Ce,
            northing: Le,
            zoneLetter: ot,
            zoneNumber: dt,
            accuracy: oe
          };
        }
        function Qr(u, x) {
          for (var T = fi.charCodeAt(x - 1), X = 1e5, $ = !1; T !== u.charCodeAt(0); ) {
            if (T++, T === rn && T++, T === He && T++, T > ti) {
              if ($)
                throw "Bad character: " + u;
              T = mn, $ = !0;
            }
            X += 1e5;
          }
          return X;
        }
        function ts(u, x) {
          if (u > "V")
            throw "MGRSPoint given invalid Northing " + u;
          for (var T = en.charCodeAt(x - 1), X = 0, $ = !1; T !== u.charCodeAt(0); ) {
            if (T++, T === rn && T++, T === He && T++, T > Vn) {
              if ($)
                throw "Bad character: " + u;
              T = mn, $ = !0;
            }
            X += 1e5;
          }
          return X;
        }
        function es(u) {
          var x;
          switch (u) {
            case "C":
              x = 11e5;
              break;
            case "D":
              x = 2e6;
              break;
            case "E":
              x = 28e5;
              break;
            case "F":
              x = 37e5;
              break;
            case "G":
              x = 46e5;
              break;
            case "H":
              x = 55e5;
              break;
            case "J":
              x = 64e5;
              break;
            case "K":
              x = 73e5;
              break;
            case "L":
              x = 82e5;
              break;
            case "M":
              x = 91e5;
              break;
            case "N":
              x = 0;
              break;
            case "P":
              x = 8e5;
              break;
            case "Q":
              x = 17e5;
              break;
            case "R":
              x = 26e5;
              break;
            case "S":
              x = 35e5;
              break;
            case "T":
              x = 44e5;
              break;
            case "U":
              x = 53e5;
              break;
            case "V":
              x = 62e5;
              break;
            case "W":
              x = 7e6;
              break;
            case "X":
              x = 79e5;
              break;
            default:
              x = -1;
          }
          if (x >= 0)
            return x;
          throw "Invalid zone letter: " + u;
        }
        function hi(u, x, T) {
          if (!(this instanceof hi))
            return new hi(u, x, T);
          if (Array.isArray(u))
            this.x = u[0], this.y = u[1], this.z = u[2] || 0;
          else if (typeof u == "object")
            this.x = u.x, this.y = u.y, this.z = u.z || 0;
          else if (typeof u == "string" && typeof x > "u") {
            var X = u.split(",");
            this.x = parseFloat(X[0], 10), this.y = parseFloat(X[1], 10), this.z = parseFloat(X[2], 10) || 0;
          } else
            this.x = u, this.y = x, this.z = T || 0;
          console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
        }
        hi.fromMGRS = function(u) {
          return new hi(dr(u));
        }, hi.prototype.toMGRS = function(u) {
          return pr([this.x, this.y], u);
        };
        var ns = 1, is = 0.25, gr = 0.046875, vr = 0.01953125, xr = 0.01068115234375, rs = 0.75, ss = 0.46875, as = 0.013020833333333334, os = 0.007120768229166667, cs = 0.3645833333333333, us = 0.005696614583333333, ls = 0.3076171875, br = function(u) {
          var x = [];
          x[0] = ns - u * (is + u * (gr + u * (vr + u * xr))), x[1] = u * (rs - u * (gr + u * (vr + u * xr)));
          var T = u * u;
          return x[2] = T * (ss - u * (as + u * os)), T *= u, x[3] = T * (cs - u * us), x[4] = T * u * ls, x;
        }, Ci = function(u, x, T, X) {
          return T *= x, x *= x, X[0] * u - T * (X[1] + x * (X[2] + x * (X[3] + x * X[4])));
        }, Yi = 20, _e = function(u, x, T) {
          for (var X = 1 / (1 - x), $ = u, ct = Yi; ct; --ct) {
            var dt = Math.sin($), ot = 1 - x * dt * dt;
            if (ot = (Ci($, dt, Math.cos($), T) - u) * (ot * Math.sqrt(ot)) * X, $ -= ot, Math.abs(ot) < M)
              return $;
          }
          return $;
        };
        function at() {
          this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.es && (this.en = br(this.es), this.ml0 = Ci(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en));
        }
        function xt(u) {
          var x = u.x, T = u.y, X = st(x - this.long0), $, ct, dt, ot = Math.sin(T), At = Math.cos(T);
          if (this.es) {
            var Vt = At * X, zt = Math.pow(Vt, 2), Jt = this.ep2 * Math.pow(At, 2), se = Math.pow(Jt, 2), ne = Math.abs(At) > M ? Math.tan(T) : 0, oe = Math.pow(ne, 2), ce = Math.pow(oe, 2);
            $ = 1 - this.es * Math.pow(ot, 2), Vt = Vt / Math.sqrt($);
            var ge = Ci(T, ot, At, this.en);
            ct = this.a * (this.k0 * Vt * (1 + zt / 6 * (1 - oe + Jt + zt / 20 * (5 - 18 * oe + ce + 14 * Jt - 58 * oe * Jt + zt / 42 * (61 + 179 * ce - ce * oe - 479 * oe))))) + this.x0, dt = this.a * (this.k0 * (ge - this.ml0 + ot * X * Vt / 2 * (1 + zt / 12 * (5 - oe + 9 * Jt + 4 * se + zt / 30 * (61 + ce - 58 * oe + 270 * Jt - 330 * oe * Jt + zt / 56 * (1385 + 543 * ce - ce * oe - 3111 * oe)))))) + this.y0;
          } else {
            var Dt = At * Math.sin(X);
            if (Math.abs(Math.abs(Dt) - 1) < M)
              return 93;
            if (ct = 0.5 * this.a * this.k0 * Math.log((1 + Dt) / (1 - Dt)) + this.x0, dt = At * Math.cos(X) / Math.sqrt(1 - Math.pow(Dt, 2)), Dt = Math.abs(dt), Dt >= 1) {
              if (Dt - 1 > M)
                return 93;
              dt = 0;
            } else
              dt = Math.acos(dt);
            T < 0 && (dt = -dt), dt = this.a * this.k0 * (dt - this.lat0) + this.y0;
          }
          return u.x = ct, u.y = dt, u;
        }
        function Ot(u) {
          var x, T, X, $, ct = (u.x - this.x0) * (1 / this.a), dt = (u.y - this.y0) * (1 / this.a);
          if (this.es)
            if (x = this.ml0 + dt / this.k0, T = _e(x, this.es, this.en), Math.abs(T) < E) {
              var zt = Math.sin(T), Jt = Math.cos(T), se = Math.abs(Jt) > M ? Math.tan(T) : 0, ne = this.ep2 * Math.pow(Jt, 2), oe = Math.pow(ne, 2), ce = Math.pow(se, 2), ge = Math.pow(ce, 2);
              x = 1 - this.es * Math.pow(zt, 2);
              var Ce = ct * Math.sqrt(x) / this.k0, Le = Math.pow(Ce, 2);
              x = x * se, X = T - x * Le / (1 - this.es) * 0.5 * (1 - Le / 12 * (5 + 3 * ce - 9 * ne * ce + ne - 4 * oe - Le / 30 * (61 + 90 * ce - 252 * ne * ce + 45 * ge + 46 * ne - Le / 56 * (1385 + 3633 * ce + 4095 * ge + 1574 * ge * ce)))), $ = st(this.long0 + Ce * (1 - Le / 6 * (1 + 2 * ce + ne - Le / 20 * (5 + 28 * ce + 24 * ge + 8 * ne * ce + 6 * ne - Le / 42 * (61 + 662 * ce + 1320 * ge + 720 * ge * ce)))) / Jt);
            } else
              X = E * gt(dt), $ = 0;
          else {
            var ot = Math.exp(ct / this.k0), At = 0.5 * (ot - 1 / ot), Dt = this.lat0 + dt / this.k0, Vt = Math.cos(Dt);
            x = Math.sqrt((1 - Math.pow(Vt, 2)) / (1 + Math.pow(At, 2))), X = Math.asin(x), dt < 0 && (X = -X), At === 0 && Vt === 0 ? $ = 0 : $ = st(Math.atan2(At, Vt) + this.long0);
          }
          return u.x = $, u.y = X, u;
        }
        var Bt = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"], Zt = {
          init: at,
          forward: xt,
          inverse: Ot,
          names: Bt
        }, pe = function(u) {
          var x = Math.exp(u);
          return x = (x - 1 / x) / 2, x;
        }, Ri = function(u, x) {
          u = Math.abs(u), x = Math.abs(x);
          var T = Math.max(u, x), X = Math.min(u, x) / (T || 1);
          return T * Math.sqrt(1 + Math.pow(X, 2));
        }, go = function(u) {
          var x = 1 + u, T = x - 1;
          return T === 0 ? u : u * Math.log(x) / T;
        }, vo = function(u) {
          var x = Math.abs(u);
          return x = go(x * (1 + x / (Ri(1, x) + 1))), u < 0 ? -x : x;
        }, Os = function(u, x) {
          for (var T = 2 * Math.cos(2 * x), X = u.length - 1, $ = u[X], ct = 0, dt; --X >= 0; )
            dt = -ct + T * $ + u[X], ct = $, $ = dt;
          return x + dt * Math.sin(2 * x);
        }, xo = function(u, x) {
          for (var T = 2 * Math.cos(x), X = u.length - 1, $ = u[X], ct = 0, dt; --X >= 0; )
            dt = -ct + T * $ + u[X], ct = $, $ = dt;
          return Math.sin(x) * dt;
        }, bo = function(u) {
          var x = Math.exp(u);
          return x = (x + 1 / x) / 2, x;
        }, Ta = function(u, x, T) {
          for (var X = Math.sin(x), $ = Math.cos(x), ct = pe(T), dt = bo(T), ot = 2 * $ * dt, At = -2 * X * ct, Dt = u.length - 1, Vt = u[Dt], zt = 0, Jt = 0, se = 0, ne, oe; --Dt >= 0; )
            ne = Jt, oe = zt, Jt = Vt, zt = se, Vt = -ne + ot * Jt - At * zt + u[Dt], se = -oe + At * Jt + ot * zt;
          return ot = X * dt, At = $ * ct, [ot * Vt - At * se, ot * se + At * Vt];
        };
        function Eo() {
          if (!this.approx && (isNaN(this.es) || this.es <= 0))
            throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
          this.approx && (Zt.init.apply(this), this.forward = Zt.forward, this.inverse = Zt.inverse), this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.cgb = [], this.cbg = [], this.utg = [], this.gtu = [];
          var u = this.es / (1 + Math.sqrt(1 - this.es)), x = u / (2 - u), T = x;
          this.cgb[0] = x * (2 + x * (-2 / 3 + x * (-2 + x * (116 / 45 + x * (26 / 45 + x * (-2854 / 675)))))), this.cbg[0] = x * (-2 + x * (2 / 3 + x * (4 / 3 + x * (-82 / 45 + x * (32 / 45 + x * (4642 / 4725)))))), T = T * x, this.cgb[1] = T * (7 / 3 + x * (-8 / 5 + x * (-227 / 45 + x * (2704 / 315 + x * (2323 / 945))))), this.cbg[1] = T * (5 / 3 + x * (-16 / 15 + x * (-13 / 9 + x * (904 / 315 + x * (-1522 / 945))))), T = T * x, this.cgb[2] = T * (56 / 15 + x * (-136 / 35 + x * (-1262 / 105 + x * (73814 / 2835)))), this.cbg[2] = T * (-26 / 15 + x * (34 / 21 + x * (8 / 5 + x * (-12686 / 2835)))), T = T * x, this.cgb[3] = T * (4279 / 630 + x * (-332 / 35 + x * (-399572 / 14175))), this.cbg[3] = T * (1237 / 630 + x * (-12 / 5 + x * (-24832 / 14175))), T = T * x, this.cgb[4] = T * (4174 / 315 + x * (-144838 / 6237)), this.cbg[4] = T * (-734 / 315 + x * (109598 / 31185)), T = T * x, this.cgb[5] = T * (601676 / 22275), this.cbg[5] = T * (444337 / 155925), T = Math.pow(x, 2), this.Qn = this.k0 / (1 + x) * (1 + T * (1 / 4 + T * (1 / 64 + T / 256))), this.utg[0] = x * (-0.5 + x * (2 / 3 + x * (-37 / 96 + x * (1 / 360 + x * (81 / 512 + x * (-96199 / 604800)))))), this.gtu[0] = x * (0.5 + x * (-2 / 3 + x * (5 / 16 + x * (41 / 180 + x * (-127 / 288 + x * (7891 / 37800)))))), this.utg[1] = T * (-1 / 48 + x * (-1 / 15 + x * (437 / 1440 + x * (-46 / 105 + x * (1118711 / 3870720))))), this.gtu[1] = T * (13 / 48 + x * (-3 / 5 + x * (557 / 1440 + x * (281 / 630 + x * (-1983433 / 1935360))))), T = T * x, this.utg[2] = T * (-17 / 480 + x * (37 / 840 + x * (209 / 4480 + x * (-5569 / 90720)))), this.gtu[2] = T * (61 / 240 + x * (-103 / 140 + x * (15061 / 26880 + x * (167603 / 181440)))), T = T * x, this.utg[3] = T * (-4397 / 161280 + x * (11 / 504 + x * (830251 / 7257600))), this.gtu[3] = T * (49561 / 161280 + x * (-179 / 168 + x * (6601661 / 7257600))), T = T * x, this.utg[4] = T * (-4583 / 161280 + x * (108847 / 3991680)), this.gtu[4] = T * (34729 / 80640 + x * (-3418889 / 1995840)), T = T * x, this.utg[5] = T * (-20648693 / 638668800), this.gtu[5] = T * (212378941 / 319334400);
          var X = Os(this.cbg, this.lat0);
          this.Zb = -this.Qn * (X + xo(this.gtu, 2 * X));
        }
        function wo(u) {
          var x = st(u.x - this.long0), T = u.y;
          T = Os(this.cbg, T);
          var X = Math.sin(T), $ = Math.cos(T), ct = Math.sin(x), dt = Math.cos(x);
          T = Math.atan2(X, dt * $), x = Math.atan2(ct * $, Ri(X, $ * dt)), x = vo(Math.tan(x));
          var ot = Ta(this.gtu, 2 * T, 2 * x);
          T = T + ot[0], x = x + ot[1];
          var At, Dt;
          return Math.abs(x) <= 2.623395162778 ? (At = this.a * (this.Qn * x) + this.x0, Dt = this.a * (this.Qn * T + this.Zb) + this.y0) : (At = 1 / 0, Dt = 1 / 0), u.x = At, u.y = Dt, u;
        }
        function Mo(u) {
          var x = (u.x - this.x0) * (1 / this.a), T = (u.y - this.y0) * (1 / this.a);
          T = (T - this.Zb) / this.Qn, x = x / this.Qn;
          var X, $;
          if (Math.abs(x) <= 2.623395162778) {
            var ct = Ta(this.utg, 2 * T, 2 * x);
            T = T + ct[0], x = x + ct[1], x = Math.atan(pe(x));
            var dt = Math.sin(T), ot = Math.cos(T), At = Math.sin(x), Dt = Math.cos(x);
            T = Math.atan2(dt * Dt, Ri(At, Dt * ot)), x = Math.atan2(At, Dt * ot), X = st(x + this.long0), $ = Os(this.cgb, T);
          } else
            X = 1 / 0, $ = 1 / 0;
          return u.x = X, u.y = $, u;
        }
        var So = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"], fs = {
          init: Eo,
          forward: wo,
          inverse: Mo,
          names: So
        }, Ao = function(u, x) {
          if (u === void 0) {
            if (u = Math.floor((st(x) + Math.PI) * 30 / Math.PI) + 1, u < 0)
              return 0;
            if (u > 60)
              return 60;
          }
          return u;
        }, To = "etmerc";
        function Co() {
          var u = Ao(this.zone, this.long0);
          if (u === void 0)
            throw new Error("unknown utm zone");
          this.lat0 = 0, this.long0 = (6 * Math.abs(u) - 183) * P, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, this.k0 = 0.9996, fs.init.apply(this), this.forward = fs.forward, this.inverse = fs.inverse;
        }
        var Ro = ["Universal Transverse Mercator System", "utm"], Io = {
          init: Co,
          names: Ro,
          dependsOn: To
        }, Ds = function(u, x) {
          return Math.pow((1 - u) / (1 + u), x);
        }, Po = 20;
        function Lo() {
          var u = Math.sin(this.lat0), x = Math.cos(this.lat0);
          x *= x, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * u * u), this.C = Math.sqrt(1 + this.es * x * x / (1 - this.es)), this.phic0 = Math.asin(u / this.C), this.ratexp = 0.5 * this.C * this.e, this.K = Math.tan(0.5 * this.phic0 + C) / (Math.pow(Math.tan(0.5 * this.lat0 + C), this.C) * Ds(this.e * u, this.ratexp));
        }
        function Oo(u) {
          var x = u.x, T = u.y;
          return u.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * T + C), this.C) * Ds(this.e * Math.sin(T), this.ratexp)) - E, u.x = this.C * x, u;
        }
        function Do(u) {
          for (var x = 1e-14, T = u.x / this.C, X = u.y, $ = Math.pow(Math.tan(0.5 * X + C) / this.K, 1 / this.C), ct = Po; ct > 0 && (X = 2 * Math.atan($ * Ds(this.e * Math.sin(u.y), -0.5 * this.e)) - E, !(Math.abs(X - u.y) < x)); --ct)
            u.y = X;
          return ct ? (u.x = T, u.y = X, u) : null;
        }
        var No = ["gauss"], Ns = {
          init: Lo,
          forward: Oo,
          inverse: Do,
          names: No
        };
        function Fo() {
          Ns.init.apply(this), this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative"));
        }
        function Uo(u) {
          var x, T, X, $;
          return u.x = st(u.x - this.long0), Ns.forward.apply(this, [u]), x = Math.sin(u.y), T = Math.cos(u.y), X = Math.cos(u.x), $ = this.k0 * this.R2 / (1 + this.sinc0 * x + this.cosc0 * T * X), u.x = $ * T * Math.sin(u.x), u.y = $ * (this.cosc0 * x - this.sinc0 * T * X), u.x = this.a * u.x + this.x0, u.y = this.a * u.y + this.y0, u;
        }
        function Bo(u) {
          var x, T, X, $, ct;
          if (u.x = (u.x - this.x0) / this.a, u.y = (u.y - this.y0) / this.a, u.x /= this.k0, u.y /= this.k0, ct = Math.sqrt(u.x * u.x + u.y * u.y)) {
            var dt = 2 * Math.atan2(ct, this.R2);
            x = Math.sin(dt), T = Math.cos(dt), $ = Math.asin(T * this.sinc0 + u.y * x * this.cosc0 / ct), X = Math.atan2(u.x * x, ct * this.cosc0 * T - u.y * this.sinc0 * x);
          } else
            $ = this.phic0, X = 0;
          return u.x = X, u.y = $, Ns.inverse.apply(this, [u]), u.x = st(u.x + this.long0), u;
        }
        var ko = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"], zo = {
          init: Fo,
          forward: Uo,
          inverse: Bo,
          names: ko
        };
        function Go(u, x, T) {
          return x *= T, Math.tan(0.5 * (E + u)) * Math.pow((1 - x) / (1 + x), 0.5 * T);
        }
        function Vo() {
          this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere ? this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= M && (this.k0 = 0.5 * (1 + gt(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= M && (this.lat0 > 0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= M && (this.k0 = 0.5 * this.cons * tt(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / Tt(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), this.ms1 = tt(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - E, this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0));
        }
        function Ho(u) {
          var x = u.x, T = u.y, X = Math.sin(T), $ = Math.cos(T), ct, dt, ot, At, Dt, Vt, zt = st(x - this.long0);
          return Math.abs(Math.abs(x - this.long0) - Math.PI) <= M && Math.abs(T + this.lat0) <= M ? (u.x = NaN, u.y = NaN, u) : this.sphere ? (ct = 2 * this.k0 / (1 + this.sinlat0 * X + this.coslat0 * $ * Math.cos(zt)), u.x = this.a * ct * $ * Math.sin(zt) + this.x0, u.y = this.a * ct * (this.coslat0 * X - this.sinlat0 * $ * Math.cos(zt)) + this.y0, u) : (dt = 2 * Math.atan(this.ssfn_(T, X, this.e)) - E, At = Math.cos(dt), ot = Math.sin(dt), Math.abs(this.coslat0) <= M ? (Dt = Tt(this.e, T * this.con, this.con * X), Vt = 2 * this.a * this.k0 * Dt / this.cons, u.x = this.x0 + Vt * Math.sin(x - this.long0), u.y = this.y0 - this.con * Vt * Math.cos(x - this.long0), u) : (Math.abs(this.sinlat0) < M ? (ct = 2 * this.a * this.k0 / (1 + At * Math.cos(zt)), u.y = ct * ot) : (ct = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * ot + this.cosX0 * At * Math.cos(zt))), u.y = ct * (this.cosX0 * ot - this.sinX0 * At * Math.cos(zt)) + this.y0), u.x = ct * At * Math.sin(zt) + this.x0, u));
        }
        function jo(u) {
          u.x -= this.x0, u.y -= this.y0;
          var x, T, X, $, ct, dt = Math.sqrt(u.x * u.x + u.y * u.y);
          if (this.sphere) {
            var ot = 2 * Math.atan(dt / (2 * this.a * this.k0));
            return x = this.long0, T = this.lat0, dt <= M ? (u.x = x, u.y = T, u) : (T = Math.asin(Math.cos(ot) * this.sinlat0 + u.y * Math.sin(ot) * this.coslat0 / dt), Math.abs(this.coslat0) < M ? this.lat0 > 0 ? x = st(this.long0 + Math.atan2(u.x, -1 * u.y)) : x = st(this.long0 + Math.atan2(u.x, u.y)) : x = st(this.long0 + Math.atan2(u.x * Math.sin(ot), dt * this.coslat0 * Math.cos(ot) - u.y * this.sinlat0 * Math.sin(ot))), u.x = x, u.y = T, u);
          } else if (Math.abs(this.coslat0) <= M) {
            if (dt <= M)
              return T = this.lat0, x = this.long0, u.x = x, u.y = T, u;
            u.x *= this.con, u.y *= this.con, X = dt * this.cons / (2 * this.a * this.k0), T = this.con * Ft(this.e, X), x = this.con * st(this.con * this.long0 + Math.atan2(u.x, -1 * u.y));
          } else
            $ = 2 * Math.atan(dt * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), x = this.long0, dt <= M ? ct = this.X0 : (ct = Math.asin(Math.cos($) * this.sinX0 + u.y * Math.sin($) * this.cosX0 / dt), x = st(this.long0 + Math.atan2(u.x * Math.sin($), dt * this.cosX0 * Math.cos($) - u.y * this.sinX0 * Math.sin($)))), T = -1 * Ft(this.e, Math.tan(0.5 * (E + ct)));
          return u.x = x, u.y = T, u;
        }
        var Wo = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"], qo = {
          init: Vo,
          forward: Ho,
          inverse: jo,
          names: Wo,
          ssfn_: Go
        };
        function $o() {
          var u = this.lat0;
          this.lambda0 = this.long0;
          var x = Math.sin(u), T = this.a, X = this.rf, $ = 1 / X, ct = 2 * $ - Math.pow($, 2), dt = this.e = Math.sqrt(ct);
          this.R = this.k0 * T * Math.sqrt(1 - ct) / (1 - ct * Math.pow(x, 2)), this.alpha = Math.sqrt(1 + ct / (1 - ct) * Math.pow(Math.cos(u), 4)), this.b0 = Math.asin(x / this.alpha);
          var ot = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)), At = Math.log(Math.tan(Math.PI / 4 + u / 2)), Dt = Math.log((1 + dt * x) / (1 - dt * x));
          this.K = ot - this.alpha * At + this.alpha * dt / 2 * Dt;
        }
        function Xo(u) {
          var x = Math.log(Math.tan(Math.PI / 4 - u.y / 2)), T = this.e / 2 * Math.log((1 + this.e * Math.sin(u.y)) / (1 - this.e * Math.sin(u.y))), X = -this.alpha * (x + T) + this.K, $ = 2 * (Math.atan(Math.exp(X)) - Math.PI / 4), ct = this.alpha * (u.x - this.lambda0), dt = Math.atan(Math.sin(ct) / (Math.sin(this.b0) * Math.tan($) + Math.cos(this.b0) * Math.cos(ct))), ot = Math.asin(Math.cos(this.b0) * Math.sin($) - Math.sin(this.b0) * Math.cos($) * Math.cos(ct));
          return u.y = this.R / 2 * Math.log((1 + Math.sin(ot)) / (1 - Math.sin(ot))) + this.y0, u.x = this.R * dt + this.x0, u;
        }
        function Yo(u) {
          for (var x = u.x - this.x0, T = u.y - this.y0, X = x / this.R, $ = 2 * (Math.atan(Math.exp(T / this.R)) - Math.PI / 4), ct = Math.asin(Math.cos(this.b0) * Math.sin($) + Math.sin(this.b0) * Math.cos($) * Math.cos(X)), dt = Math.atan(Math.sin(X) / (Math.cos(this.b0) * Math.cos(X) - Math.sin(this.b0) * Math.tan($))), ot = this.lambda0 + dt / this.alpha, At = 0, Dt = ct, Vt = -1e3, zt = 0; Math.abs(Dt - Vt) > 1e-7; ) {
            if (++zt > 20)
              return;
            At = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + ct / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(Dt)) / 2)), Vt = Dt, Dt = 2 * Math.atan(Math.exp(At)) - Math.PI / 2;
          }
          return u.x = ot, u.y = Dt, u;
        }
        var Ko = ["somerc"], Zo = {
          init: $o,
          forward: Xo,
          inverse: Yo,
          names: Ko
        }, Ki = 1e-7;
        function Jo(u) {
          var x = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"], T = typeof u.PROJECTION == "object" ? Object.keys(u.PROJECTION)[0] : u.PROJECTION;
          return "no_uoff" in u || "no_off" in u || x.indexOf(T) !== -1;
        }
        function Qo() {
          var u, x, T, X, $, ct, dt, ot, At, Dt, Vt = 0, zt, Jt = 0, se = 0, ne = 0, oe = 0, ce = 0, ge = 0;
          this.no_off = Jo(this), this.no_rot = "no_rot" in this;
          var Ce = !1;
          "alpha" in this && (Ce = !0);
          var Le = !1;
          if ("rectified_grid_angle" in this && (Le = !0), Ce && (ge = this.alpha), Le && (Vt = this.rectified_grid_angle * P), Ce || Le)
            Jt = this.longc;
          else if (se = this.long1, oe = this.lat1, ne = this.long2, ce = this.lat2, Math.abs(oe - ce) <= Ki || (u = Math.abs(oe)) <= Ki || Math.abs(u - E) <= Ki || Math.abs(Math.abs(this.lat0) - E) <= Ki || Math.abs(Math.abs(ce) - E) <= Ki)
            throw new Error();
          var Ze = 1 - this.es;
          x = Math.sqrt(Ze), Math.abs(this.lat0) > M ? (ot = Math.sin(this.lat0), T = Math.cos(this.lat0), u = 1 - this.es * ot * ot, this.B = T * T, this.B = Math.sqrt(1 + this.es * this.B * this.B / Ze), this.A = this.B * this.k0 * x / u, X = this.B * x / (T * Math.sqrt(u)), $ = X * X - 1, $ <= 0 ? $ = 0 : ($ = Math.sqrt($), this.lat0 < 0 && ($ = -$)), this.E = $ += X, this.E *= Math.pow(Tt(this.e, this.lat0, ot), this.B)) : (this.B = 1 / x, this.A = this.k0, this.E = X = $ = 1), Ce || Le ? (Ce ? (zt = Math.asin(Math.sin(ge) / X), Le || (Vt = ge)) : (zt = Vt, ge = Math.asin(X * Math.sin(zt))), this.lam0 = Jt - Math.asin(0.5 * ($ - 1 / $) * Math.tan(zt)) / this.B) : (ct = Math.pow(Tt(this.e, oe, Math.sin(oe)), this.B), dt = Math.pow(Tt(this.e, ce, Math.sin(ce)), this.B), $ = this.E / ct, At = (dt - ct) / (dt + ct), Dt = this.E * this.E, Dt = (Dt - dt * ct) / (Dt + dt * ct), u = se - ne, u < -Math.pi ? ne -= D : u > Math.pi && (ne += D), this.lam0 = st(0.5 * (se + ne) - Math.atan(Dt * Math.tan(0.5 * this.B * (se - ne)) / At) / this.B), zt = Math.atan(2 * Math.sin(this.B * st(se - this.lam0)) / ($ - 1 / $)), Vt = ge = Math.asin(X * Math.sin(zt))), this.singam = Math.sin(zt), this.cosgam = Math.cos(zt), this.sinrot = Math.sin(Vt), this.cosrot = Math.cos(Vt), this.rB = 1 / this.B, this.ArB = this.A * this.rB, this.BrA = 1 / this.ArB, this.no_off ? this.u_0 = 0 : (this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(X * X - 1) / Math.cos(ge))), this.lat0 < 0 && (this.u_0 = -this.u_0)), $ = 0.5 * zt, this.v_pole_n = this.ArB * Math.log(Math.tan(C - $)), this.v_pole_s = this.ArB * Math.log(Math.tan(C + $));
        }
        function tc(u) {
          var x = {}, T, X, $, ct, dt, ot, At, Dt;
          if (u.x = u.x - this.lam0, Math.abs(Math.abs(u.y) - E) > M) {
            if (dt = this.E / Math.pow(Tt(this.e, u.y, Math.sin(u.y)), this.B), ot = 1 / dt, T = 0.5 * (dt - ot), X = 0.5 * (dt + ot), ct = Math.sin(this.B * u.x), $ = (T * this.singam - ct * this.cosgam) / X, Math.abs(Math.abs($) - 1) < M)
              throw new Error();
            Dt = 0.5 * this.ArB * Math.log((1 - $) / (1 + $)), ot = Math.cos(this.B * u.x), Math.abs(ot) < Ki ? At = this.A * u.x : At = this.ArB * Math.atan2(T * this.cosgam + ct * this.singam, ot);
          } else
            Dt = u.y > 0 ? this.v_pole_n : this.v_pole_s, At = this.ArB * u.y;
          return this.no_rot ? (x.x = At, x.y = Dt) : (At -= this.u_0, x.x = Dt * this.cosrot + At * this.sinrot, x.y = At * this.cosrot - Dt * this.sinrot), x.x = this.a * x.x + this.x0, x.y = this.a * x.y + this.y0, x;
        }
        function ec(u) {
          var x, T, X, $, ct, dt, ot, At = {};
          if (u.x = (u.x - this.x0) * (1 / this.a), u.y = (u.y - this.y0) * (1 / this.a), this.no_rot ? (T = u.y, x = u.x) : (T = u.x * this.cosrot - u.y * this.sinrot, x = u.y * this.cosrot + u.x * this.sinrot + this.u_0), X = Math.exp(-this.BrA * T), $ = 0.5 * (X - 1 / X), ct = 0.5 * (X + 1 / X), dt = Math.sin(this.BrA * x), ot = (dt * this.cosgam + $ * this.singam) / ct, Math.abs(Math.abs(ot) - 1) < M)
            At.x = 0, At.y = ot < 0 ? -E : E;
          else {
            if (At.y = this.E / Math.sqrt((1 + ot) / (1 - ot)), At.y = Ft(this.e, Math.pow(At.y, 1 / this.B)), At.y === 1 / 0)
              throw new Error();
            At.x = -this.rB * Math.atan2($ * this.cosgam - dt * this.singam, Math.cos(this.BrA * x));
          }
          return At.x += this.lam0, At;
        }
        var nc = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"], ic = {
          init: Qo,
          forward: tc,
          inverse: ec,
          names: nc
        };
        function rc() {
          if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < M)) {
            var u = this.b / this.a;
            this.e = Math.sqrt(1 - u * u);
            var x = Math.sin(this.lat1), T = Math.cos(this.lat1), X = tt(this.e, x, T), $ = Tt(this.e, this.lat1, x), ct = Math.sin(this.lat2), dt = Math.cos(this.lat2), ot = tt(this.e, ct, dt), At = Tt(this.e, this.lat2, ct), Dt = Tt(this.e, this.lat0, Math.sin(this.lat0));
            Math.abs(this.lat1 - this.lat2) > M ? this.ns = Math.log(X / ot) / Math.log($ / At) : this.ns = x, isNaN(this.ns) && (this.ns = x), this.f0 = X / (this.ns * Math.pow($, this.ns)), this.rh = this.a * this.f0 * Math.pow(Dt, this.ns), this.title || (this.title = "Lambert Conformal Conic");
          }
        }
        function sc(u) {
          var x = u.x, T = u.y;
          Math.abs(2 * Math.abs(T) - Math.PI) <= M && (T = gt(T) * (E - 2 * M));
          var X = Math.abs(Math.abs(T) - E), $, ct;
          if (X > M)
            $ = Tt(this.e, T, Math.sin(T)), ct = this.a * this.f0 * Math.pow($, this.ns);
          else {
            if (X = T * this.ns, X <= 0)
              return null;
            ct = 0;
          }
          var dt = this.ns * st(x - this.long0);
          return u.x = this.k0 * (ct * Math.sin(dt)) + this.x0, u.y = this.k0 * (this.rh - ct * Math.cos(dt)) + this.y0, u;
        }
        function ac(u) {
          var x, T, X, $, ct, dt = (u.x - this.x0) / this.k0, ot = this.rh - (u.y - this.y0) / this.k0;
          this.ns > 0 ? (x = Math.sqrt(dt * dt + ot * ot), T = 1) : (x = -Math.sqrt(dt * dt + ot * ot), T = -1);
          var At = 0;
          if (x !== 0 && (At = Math.atan2(T * dt, T * ot)), x !== 0 || this.ns > 0) {
            if (T = 1 / this.ns, X = Math.pow(x / (this.a * this.f0), T), $ = Ft(this.e, X), $ === -9999)
              return null;
          } else
            $ = -E;
          return ct = st(At / this.ns + this.long0), u.x = ct, u.y = $, u;
        }
        var Fs = [
          "Lambert Tangential Conformal Conic Projection",
          "Lambert_Conformal_Conic",
          "Lambert_Conformal_Conic_1SP",
          "Lambert_Conformal_Conic_2SP",
          "lcc"
        ], Ie = {
          init: rc,
          forward: sc,
          inverse: ac,
          names: Fs
        };
        function et() {
          this.a = 6377397155e-3, this.es = 0.006674372230614, this.e = Math.sqrt(this.es), this.lat0 || (this.lat0 = 0.863937979737193), this.long0 || (this.long0 = 0.7417649320975901 - 0.308341501185665), this.k0 || (this.k0 = 0.9999), this.s45 = 0.785398163397448, this.s90 = 2 * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(this.e2), this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)), this.uq = 1.04216856380474, this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa), this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2), this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g, this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)), this.s0 = 1.37008346281555, this.n = Math.sin(this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), this.ad = this.s90 - this.uq;
        }
        function bt(u) {
          var x, T, X, $, ct, dt, ot, At = u.x, Dt = u.y, Vt = st(At - this.long0);
          return x = Math.pow((1 + this.e * Math.sin(Dt)) / (1 - this.e * Math.sin(Dt)), this.alfa * this.e / 2), T = 2 * (Math.atan(this.k * Math.pow(Math.tan(Dt / 2 + this.s45), this.alfa) / x) - this.s45), X = -Vt * this.alfa, $ = Math.asin(Math.cos(this.ad) * Math.sin(T) + Math.sin(this.ad) * Math.cos(T) * Math.cos(X)), ct = Math.asin(Math.cos(T) * Math.sin(X) / Math.cos($)), dt = this.n * ct, ot = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan($ / 2 + this.s45), this.n), u.y = ot * Math.cos(dt) / 1, u.x = ot * Math.sin(dt) / 1, this.czech || (u.y *= -1, u.x *= -1), u;
        }
        function Ut(u) {
          var x, T, X, $, ct, dt, ot, At, Dt = u.x;
          u.x = u.y, u.y = Dt, this.czech || (u.y *= -1, u.x *= -1), dt = Math.sqrt(u.x * u.x + u.y * u.y), ct = Math.atan2(u.y, u.x), $ = ct / Math.sin(this.s0), X = 2 * (Math.atan(Math.pow(this.ro0 / dt, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45), x = Math.asin(Math.cos(this.ad) * Math.sin(X) - Math.sin(this.ad) * Math.cos(X) * Math.cos($)), T = Math.asin(Math.cos(X) * Math.sin($) / Math.cos(x)), u.x = this.long0 - T / this.alfa, ot = x, At = 0;
          var Vt = 0;
          do
            u.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(x / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(ot)) / (1 - this.e * Math.sin(ot)), this.e / 2)) - this.s45), Math.abs(ot - u.y) < 1e-10 && (At = 1), ot = u.y, Vt += 1;
          while (At === 0 && Vt < 15);
          return Vt >= 15 ? null : u;
        }
        var re = ["Krovak", "krovak"], Me = {
          init: et,
          forward: bt,
          inverse: Ut,
          names: re
        }, be = function(u, x, T, X, $) {
          return u * $ - x * Math.sin(2 * $) + T * Math.sin(4 * $) - X * Math.sin(6 * $);
        }, ei = function(u) {
          return 1 - 0.25 * u * (1 + u / 16 * (3 + 1.25 * u));
        }, Er = function(u) {
          return 0.375 * u * (1 + 0.25 * u * (1 + 0.46875 * u));
        }, Zi = function(u) {
          return 0.05859375 * u * u * (1 + 0.75 * u);
        }, Ji = function(u) {
          return u * u * u * (35 / 3072);
        }, Ii = function(u, x, T) {
          var X = x * T;
          return u / Math.sqrt(1 - X * X);
        }, Us = function(u) {
          return Math.abs(u) < E ? u : u - gt(u) * Math.PI;
        }, oc = function(u, x, T, X, $) {
          var ct, dt;
          ct = u / x;
          for (var ot = 0; ot < 15; ot++)
            if (dt = (u - (x * ct - T * Math.sin(2 * ct) + X * Math.sin(4 * ct) - $ * Math.sin(6 * ct))) / (x - 2 * T * Math.cos(2 * ct) + 4 * X * Math.cos(4 * ct) - 6 * $ * Math.cos(6 * ct)), ct += dt, Math.abs(dt) <= 1e-10)
              return ct;
          return NaN;
        };
        function T_() {
          this.sphere || (this.e0 = ei(this.es), this.e1 = Er(this.es), this.e2 = Zi(this.es), this.e3 = Ji(this.es), this.ml0 = this.a * be(this.e0, this.e1, this.e2, this.e3, this.lat0));
        }
        function C_(u) {
          var x, T, X = u.x, $ = u.y;
          if (X = st(X - this.long0), this.sphere)
            x = this.a * Math.asin(Math.cos($) * Math.sin(X)), T = this.a * (Math.atan2(Math.tan($), Math.cos(X)) - this.lat0);
          else {
            var ct = Math.sin($), dt = Math.cos($), ot = Ii(this.a, this.e, ct), At = Math.tan($) * Math.tan($), Dt = X * Math.cos($), Vt = Dt * Dt, zt = this.es * dt * dt / (1 - this.es), Jt = this.a * be(this.e0, this.e1, this.e2, this.e3, $);
            x = ot * Dt * (1 - Vt * At * (1 / 6 - (8 - At + 8 * zt) * Vt / 120)), T = Jt - this.ml0 + ot * ct / dt * Vt * (0.5 + (5 - At + 6 * zt) * Vt / 24);
          }
          return u.x = x + this.x0, u.y = T + this.y0, u;
        }
        function R_(u) {
          u.x -= this.x0, u.y -= this.y0;
          var x = u.x / this.a, T = u.y / this.a, X, $;
          if (this.sphere) {
            var ct = T + this.lat0;
            X = Math.asin(Math.sin(ct) * Math.cos(x)), $ = Math.atan2(Math.tan(x), Math.cos(ct));
          } else {
            var dt = this.ml0 / this.a + T, ot = oc(dt, this.e0, this.e1, this.e2, this.e3);
            if (Math.abs(Math.abs(ot) - E) <= M)
              return u.x = this.long0, u.y = E, T < 0 && (u.y *= -1), u;
            var At = Ii(this.a, this.e, Math.sin(ot)), Dt = At * At * At / this.a / this.a * (1 - this.es), Vt = Math.pow(Math.tan(ot), 2), zt = x * this.a / At, Jt = zt * zt;
            X = ot - At * Math.tan(ot) / Dt * zt * zt * (0.5 - (1 + 3 * Vt) * zt * zt / 24), $ = zt * (1 - Jt * (Vt / 3 + (1 + 3 * Vt) * Vt * Jt / 15)) / Math.cos(ot);
          }
          return u.x = st($ + this.long0), u.y = Us(X), u;
        }
        var I_ = ["Cassini", "Cassini_Soldner", "cass"], P_ = {
          init: T_,
          forward: C_,
          inverse: R_,
          names: I_
        }, wr = function(u, x) {
          var T;
          return u > 1e-7 ? (T = u * x, (1 - u * u) * (x / (1 - T * T) - 0.5 / u * Math.log((1 - T) / (1 + T)))) : 2 * x;
        }, L_ = 1, O_ = 2, D_ = 3, N_ = 4;
        function F_() {
          var u = Math.abs(this.lat0);
          if (Math.abs(u - E) < M ? this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE : Math.abs(u) < M ? this.mode = this.EQUIT : this.mode = this.OBLIQ, this.es > 0) {
            var x;
            switch (this.qp = wr(this.e, 1), this.mmf = 0.5 / (1 - this.es), this.apa = W_(this.es), this.mode) {
              case this.N_POLE:
                this.dd = 1;
                break;
              case this.S_POLE:
                this.dd = 1;
                break;
              case this.EQUIT:
                this.rq = Math.sqrt(0.5 * this.qp), this.dd = 1 / this.rq, this.xmf = 1, this.ymf = 0.5 * this.qp;
                break;
              case this.OBLIQ:
                this.rq = Math.sqrt(0.5 * this.qp), x = Math.sin(this.lat0), this.sinb1 = wr(this.e, x) / this.qp, this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * x * x) * this.rq * this.cosb1), this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd;
                break;
            }
          } else
            this.mode === this.OBLIQ && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0));
        }
        function U_(u) {
          var x, T, X, $, ct, dt, ot, At, Dt, Vt, zt = u.x, Jt = u.y;
          if (zt = st(zt - this.long0), this.sphere) {
            if (ct = Math.sin(Jt), Vt = Math.cos(Jt), X = Math.cos(zt), this.mode === this.OBLIQ || this.mode === this.EQUIT) {
              if (T = this.mode === this.EQUIT ? 1 + Vt * X : 1 + this.sinph0 * ct + this.cosph0 * Vt * X, T <= M)
                return null;
              T = Math.sqrt(2 / T), x = T * Vt * Math.sin(zt), T *= this.mode === this.EQUIT ? ct : this.cosph0 * ct - this.sinph0 * Vt * X;
            } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
              if (this.mode === this.N_POLE && (X = -X), Math.abs(Jt + this.lat0) < M)
                return null;
              T = C - Jt * 0.5, T = 2 * (this.mode === this.S_POLE ? Math.cos(T) : Math.sin(T)), x = T * Math.sin(zt), T *= X;
            }
          } else {
            switch (ot = 0, At = 0, Dt = 0, X = Math.cos(zt), $ = Math.sin(zt), ct = Math.sin(Jt), dt = wr(this.e, ct), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (ot = dt / this.qp, At = Math.sqrt(1 - ot * ot)), this.mode) {
              case this.OBLIQ:
                Dt = 1 + this.sinb1 * ot + this.cosb1 * At * X;
                break;
              case this.EQUIT:
                Dt = 1 + At * X;
                break;
              case this.N_POLE:
                Dt = E + Jt, dt = this.qp - dt;
                break;
              case this.S_POLE:
                Dt = Jt - E, dt = this.qp + dt;
                break;
            }
            if (Math.abs(Dt) < M)
              return null;
            switch (this.mode) {
              case this.OBLIQ:
              case this.EQUIT:
                Dt = Math.sqrt(2 / Dt), this.mode === this.OBLIQ ? T = this.ymf * Dt * (this.cosb1 * ot - this.sinb1 * At * X) : T = (Dt = Math.sqrt(2 / (1 + At * X))) * ot * this.ymf, x = this.xmf * Dt * At * $;
                break;
              case this.N_POLE:
              case this.S_POLE:
                dt >= 0 ? (x = (Dt = Math.sqrt(dt)) * $, T = X * (this.mode === this.S_POLE ? Dt : -Dt)) : x = T = 0;
                break;
            }
          }
          return u.x = this.a * x + this.x0, u.y = this.a * T + this.y0, u;
        }
        function B_(u) {
          u.x -= this.x0, u.y -= this.y0;
          var x = u.x / this.a, T = u.y / this.a, X, $, ct, dt, ot, At, Dt;
          if (this.sphere) {
            var Vt = 0, zt, Jt = 0;
            if (zt = Math.sqrt(x * x + T * T), $ = zt * 0.5, $ > 1)
              return null;
            switch ($ = 2 * Math.asin($), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (Jt = Math.sin($), Vt = Math.cos($)), this.mode) {
              case this.EQUIT:
                $ = Math.abs(zt) <= M ? 0 : Math.asin(T * Jt / zt), x *= Jt, T = Vt * zt;
                break;
              case this.OBLIQ:
                $ = Math.abs(zt) <= M ? this.lat0 : Math.asin(Vt * this.sinph0 + T * Jt * this.cosph0 / zt), x *= Jt * this.cosph0, T = (Vt - Math.sin($) * this.sinph0) * zt;
                break;
              case this.N_POLE:
                T = -T, $ = E - $;
                break;
              case this.S_POLE:
                $ -= E;
                break;
            }
            X = T === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(x, T);
          } else {
            if (Dt = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) {
              if (x /= this.dd, T *= this.dd, At = Math.sqrt(x * x + T * T), At < M)
                return u.x = this.long0, u.y = this.lat0, u;
              dt = 2 * Math.asin(0.5 * At / this.rq), ct = Math.cos(dt), x *= dt = Math.sin(dt), this.mode === this.OBLIQ ? (Dt = ct * this.sinb1 + T * dt * this.cosb1 / At, ot = this.qp * Dt, T = At * this.cosb1 * ct - T * this.sinb1 * dt) : (Dt = T * dt / At, ot = this.qp * Dt, T = At * ct);
            } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
              if (this.mode === this.N_POLE && (T = -T), ot = x * x + T * T, !ot)
                return u.x = this.long0, u.y = this.lat0, u;
              Dt = 1 - ot / this.qp, this.mode === this.S_POLE && (Dt = -Dt);
            }
            X = Math.atan2(x, T), $ = q_(Math.asin(Dt), this.apa);
          }
          return u.x = st(this.long0 + X), u.y = $, u;
        }
        var k_ = 0.3333333333333333, z_ = 0.17222222222222222, G_ = 0.10257936507936508, V_ = 0.06388888888888888, H_ = 0.0664021164021164, j_ = 0.016415012942191543;
        function W_(u) {
          var x, T = [];
          return T[0] = u * k_, x = u * u, T[0] += x * z_, T[1] = x * V_, x *= u, T[0] += x * G_, T[1] += x * H_, T[2] = x * j_, T;
        }
        function q_(u, x) {
          var T = u + u;
          return u + x[0] * Math.sin(T) + x[1] * Math.sin(T + T) + x[2] * Math.sin(T + T + T);
        }
        var $_ = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"], X_ = {
          init: F_,
          forward: U_,
          inverse: B_,
          names: $_,
          S_POLE: L_,
          N_POLE: O_,
          EQUIT: D_,
          OBLIQ: N_
        }, Mr = function(u) {
          return Math.abs(u) > 1 && (u = u > 1 ? 1 : -1), Math.asin(u);
        };
        function Y_() {
          Math.abs(this.lat1 + this.lat2) < M || (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = tt(this.e3, this.sin_po, this.cos_po), this.qs1 = wr(this.e3, this.sin_po, this.cos_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = tt(this.e3, this.sin_po, this.cos_po), this.qs2 = wr(this.e3, this.sin_po, this.cos_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = wr(this.e3, this.sin_po, this.cos_po), Math.abs(this.lat1 - this.lat2) > M ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0);
        }
        function K_(u) {
          var x = u.x, T = u.y;
          this.sin_phi = Math.sin(T), this.cos_phi = Math.cos(T);
          var X = wr(this.e3, this.sin_phi, this.cos_phi), $ = this.a * Math.sqrt(this.c - this.ns0 * X) / this.ns0, ct = this.ns0 * st(x - this.long0), dt = $ * Math.sin(ct) + this.x0, ot = this.rh - $ * Math.cos(ct) + this.y0;
          return u.x = dt, u.y = ot, u;
        }
        function Z_(u) {
          var x, T, X, $, ct, dt;
          return u.x -= this.x0, u.y = this.rh - u.y + this.y0, this.ns0 >= 0 ? (x = Math.sqrt(u.x * u.x + u.y * u.y), X = 1) : (x = -Math.sqrt(u.x * u.x + u.y * u.y), X = -1), $ = 0, x !== 0 && ($ = Math.atan2(X * u.x, X * u.y)), X = x * this.ns0 / this.a, this.sphere ? dt = Math.asin((this.c - X * X) / (2 * this.ns0)) : (T = (this.c - X * X) / this.ns0, dt = this.phi1z(this.e3, T)), ct = st($ / this.ns0 + this.long0), u.x = ct, u.y = dt, u;
        }
        function J_(u, x) {
          var T, X, $, ct, dt, ot = Mr(0.5 * x);
          if (u < M)
            return ot;
          for (var At = u * u, Dt = 1; Dt <= 25; Dt++)
            if (T = Math.sin(ot), X = Math.cos(ot), $ = u * T, ct = 1 - $ * $, dt = 0.5 * ct * ct / X * (x / (1 - At) - T / ct + 0.5 / u * Math.log((1 - $) / (1 + $))), ot = ot + dt, Math.abs(dt) <= 1e-7)
              return ot;
          return null;
        }
        var Q_ = ["Albers_Conic_Equal_Area", "Albers", "aea"], t0 = {
          init: Y_,
          forward: K_,
          inverse: Z_,
          names: Q_,
          phi1z: J_
        };
        function e0() {
          this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0), this.infinity_dist = 1e3 * this.a, this.rc = 1;
        }
        function n0(u) {
          var x, T, X, $, ct, dt, ot, At, Dt = u.x, Vt = u.y;
          return X = st(Dt - this.long0), x = Math.sin(Vt), T = Math.cos(Vt), $ = Math.cos(X), dt = this.sin_p14 * x + this.cos_p14 * T * $, ct = 1, dt > 0 || Math.abs(dt) <= M ? (ot = this.x0 + this.a * ct * T * Math.sin(X) / dt, At = this.y0 + this.a * ct * (this.cos_p14 * x - this.sin_p14 * T * $) / dt) : (ot = this.x0 + this.infinity_dist * T * Math.sin(X), At = this.y0 + this.infinity_dist * (this.cos_p14 * x - this.sin_p14 * T * $)), u.x = ot, u.y = At, u;
        }
        function i0(u) {
          var x, T, X, $, ct, dt;
          return u.x = (u.x - this.x0) / this.a, u.y = (u.y - this.y0) / this.a, u.x /= this.k0, u.y /= this.k0, (x = Math.sqrt(u.x * u.x + u.y * u.y)) ? ($ = Math.atan2(x, this.rc), T = Math.sin($), X = Math.cos($), dt = Mr(X * this.sin_p14 + u.y * T * this.cos_p14 / x), ct = Math.atan2(u.x * T, x * this.cos_p14 * X - u.y * this.sin_p14 * T), ct = st(this.long0 + ct)) : (dt = this.phic0, ct = 0), u.x = ct, u.y = dt, u;
        }
        var r0 = ["gnom"], s0 = {
          init: e0,
          forward: n0,
          inverse: i0,
          names: r0
        }, a0 = function(u, x) {
          var T = 1 - (1 - u * u) / (2 * u) * Math.log((1 - u) / (1 + u));
          if (Math.abs(Math.abs(x) - T) < 1e-6)
            return x < 0 ? -1 * E : E;
          for (var X = Math.asin(0.5 * x), $, ct, dt, ot, At = 0; At < 30; At++)
            if (ct = Math.sin(X), dt = Math.cos(X), ot = u * ct, $ = Math.pow(1 - ot * ot, 2) / (2 * dt) * (x / (1 - u * u) - ct / (1 - ot * ot) + 0.5 / u * Math.log((1 - ot) / (1 + ot))), X += $, Math.abs($) <= 1e-10)
              return X;
          return NaN;
        };
        function o0() {
          this.sphere || (this.k0 = tt(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)));
        }
        function c0(u) {
          var x = u.x, T = u.y, X, $, ct = st(x - this.long0);
          if (this.sphere)
            X = this.x0 + this.a * ct * Math.cos(this.lat_ts), $ = this.y0 + this.a * Math.sin(T) / Math.cos(this.lat_ts);
          else {
            var dt = wr(this.e, Math.sin(T));
            X = this.x0 + this.a * this.k0 * ct, $ = this.y0 + this.a * dt * 0.5 / this.k0;
          }
          return u.x = X, u.y = $, u;
        }
        function u0(u) {
          u.x -= this.x0, u.y -= this.y0;
          var x, T;
          return this.sphere ? (x = st(this.long0 + u.x / this.a / Math.cos(this.lat_ts)), T = Math.asin(u.y / this.a * Math.cos(this.lat_ts))) : (T = a0(this.e, 2 * u.y * this.k0 / this.a), x = st(this.long0 + u.x / (this.a * this.k0))), u.x = x, u.y = T, u;
        }
        var l0 = ["cea"], f0 = {
          init: o0,
          forward: c0,
          inverse: u0,
          names: l0
        };
        function h0() {
          this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Equidistant Cylindrical (Plate Carre)", this.rc = Math.cos(this.lat_ts);
        }
        function p0(u) {
          var x = u.x, T = u.y, X = st(x - this.long0), $ = Us(T - this.lat0);
          return u.x = this.x0 + this.a * X * this.rc, u.y = this.y0 + this.a * $, u;
        }
        function d0(u) {
          var x = u.x, T = u.y;
          return u.x = st(this.long0 + (x - this.x0) / (this.a * this.rc)), u.y = Us(this.lat0 + (T - this.y0) / this.a), u;
        }
        var m0 = ["Equirectangular", "Equidistant_Cylindrical", "eqc"], _0 = {
          init: h0,
          forward: p0,
          inverse: d0,
          names: m0
        }, Of = 20;
        function y0() {
          this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = ei(this.es), this.e1 = Er(this.es), this.e2 = Zi(this.es), this.e3 = Ji(this.es), this.ml0 = this.a * be(this.e0, this.e1, this.e2, this.e3, this.lat0);
        }
        function g0(u) {
          var x = u.x, T = u.y, X, $, ct, dt = st(x - this.long0);
          if (ct = dt * Math.sin(T), this.sphere)
            Math.abs(T) <= M ? (X = this.a * dt, $ = -1 * this.a * this.lat0) : (X = this.a * Math.sin(ct) / Math.tan(T), $ = this.a * (Us(T - this.lat0) + (1 - Math.cos(ct)) / Math.tan(T)));
          else if (Math.abs(T) <= M)
            X = this.a * dt, $ = -1 * this.ml0;
          else {
            var ot = Ii(this.a, this.e, Math.sin(T)) / Math.tan(T);
            X = ot * Math.sin(ct), $ = this.a * be(this.e0, this.e1, this.e2, this.e3, T) - this.ml0 + ot * (1 - Math.cos(ct));
          }
          return u.x = X + this.x0, u.y = $ + this.y0, u;
        }
        function v0(u) {
          var x, T, X, $, ct, dt, ot, At, Dt;
          if (X = u.x - this.x0, $ = u.y - this.y0, this.sphere)
            if (Math.abs($ + this.a * this.lat0) <= M)
              x = st(X / this.a + this.long0), T = 0;
            else {
              dt = this.lat0 + $ / this.a, ot = X * X / this.a / this.a + dt * dt, At = dt;
              var Vt;
              for (ct = Of; ct; --ct)
                if (Vt = Math.tan(At), Dt = -1 * (dt * (At * Vt + 1) - At - 0.5 * (At * At + ot) * Vt) / ((At - dt) / Vt - 1), At += Dt, Math.abs(Dt) <= M) {
                  T = At;
                  break;
                }
              x = st(this.long0 + Math.asin(X * Math.tan(At) / this.a) / Math.sin(T));
            }
          else if (Math.abs($ + this.ml0) <= M)
            T = 0, x = st(this.long0 + X / this.a);
          else {
            dt = (this.ml0 + $) / this.a, ot = X * X / this.a / this.a + dt * dt, At = dt;
            var zt, Jt, se, ne, oe;
            for (ct = Of; ct; --ct)
              if (oe = this.e * Math.sin(At), zt = Math.sqrt(1 - oe * oe) * Math.tan(At), Jt = this.a * be(this.e0, this.e1, this.e2, this.e3, At), se = this.e0 - 2 * this.e1 * Math.cos(2 * At) + 4 * this.e2 * Math.cos(4 * At) - 6 * this.e3 * Math.cos(6 * At), ne = Jt / this.a, Dt = (dt * (zt * ne + 1) - ne - 0.5 * zt * (ne * ne + ot)) / (this.es * Math.sin(2 * At) * (ne * ne + ot - 2 * dt * ne) / (4 * zt) + (dt - ne) * (zt * se - 2 / Math.sin(2 * At)) - se), At -= Dt, Math.abs(Dt) <= M) {
                T = At;
                break;
              }
            zt = Math.sqrt(1 - this.es * Math.pow(Math.sin(T), 2)) * Math.tan(T), x = st(this.long0 + Math.asin(X * zt / this.a) / Math.sin(T));
          }
          return u.x = x, u.y = T, u;
        }
        var x0 = ["Polyconic", "poly"], b0 = {
          init: y0,
          forward: g0,
          inverse: v0,
          names: x0
        };
        function E0() {
          this.A = [], this.A[1] = 0.6399175073, this.A[2] = -0.1358797613, this.A[3] = 0.063294409, this.A[4] = -0.02526853, this.A[5] = 0.0117879, this.A[6] = -55161e-7, this.A[7] = 26906e-7, this.A[8] = -1333e-6, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], this.B_re[1] = 0.7557853228, this.B_im[1] = 0, this.B_re[2] = 0.249204646, this.B_im[2] = 3371507e-9, this.B_re[3] = -1541739e-9, this.B_im[3] = 0.04105856, this.B_re[4] = -0.10162907, this.B_im[4] = 0.01727609, this.B_re[5] = -0.26623489, this.B_im[5] = -0.36249218, this.B_re[6] = -0.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -0.577245789, this.C_im[2] = -7809598e-9, this.C_re[3] = 0.508307513, this.C_im[3] = -0.112208952, this.C_re[4] = -0.15094762, this.C_im[4] = 0.18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, this.D[2] = 0.5185406398, this.D[3] = -0.03333098, this.D[4] = -0.1052906, this.D[5] = -0.0368594, this.D[6] = 7317e-6, this.D[7] = 0.0122, this.D[8] = 394e-5, this.D[9] = -13e-4;
        }
        function w0(u) {
          var x, T = u.x, X = u.y, $ = X - this.lat0, ct = T - this.long0, dt = $ / v * 1e-5, ot = ct, At = 1, Dt = 0;
          for (x = 1; x <= 10; x++)
            At = At * dt, Dt = Dt + this.A[x] * At;
          var Vt = Dt, zt = ot, Jt = 1, se = 0, ne, oe, ce = 0, ge = 0;
          for (x = 1; x <= 6; x++)
            ne = Jt * Vt - se * zt, oe = se * Vt + Jt * zt, Jt = ne, se = oe, ce = ce + this.B_re[x] * Jt - this.B_im[x] * se, ge = ge + this.B_im[x] * Jt + this.B_re[x] * se;
          return u.x = ge * this.a + this.x0, u.y = ce * this.a + this.y0, u;
        }
        function M0(u) {
          var x, T = u.x, X = u.y, $ = T - this.x0, ct = X - this.y0, dt = ct / this.a, ot = $ / this.a, At = 1, Dt = 0, Vt, zt, Jt = 0, se = 0;
          for (x = 1; x <= 6; x++)
            Vt = At * dt - Dt * ot, zt = Dt * dt + At * ot, At = Vt, Dt = zt, Jt = Jt + this.C_re[x] * At - this.C_im[x] * Dt, se = se + this.C_im[x] * At + this.C_re[x] * Dt;
          for (var ne = 0; ne < this.iterations; ne++) {
            var oe = Jt, ce = se, ge, Ce, Le = dt, Ze = ot;
            for (x = 2; x <= 6; x++)
              ge = oe * Jt - ce * se, Ce = ce * Jt + oe * se, oe = ge, ce = Ce, Le = Le + (x - 1) * (this.B_re[x] * oe - this.B_im[x] * ce), Ze = Ze + (x - 1) * (this.B_im[x] * oe + this.B_re[x] * ce);
            oe = 1, ce = 0;
            var je = this.B_re[1], $e = this.B_im[1];
            for (x = 2; x <= 6; x++)
              ge = oe * Jt - ce * se, Ce = ce * Jt + oe * se, oe = ge, ce = Ce, je = je + x * (this.B_re[x] * oe - this.B_im[x] * ce), $e = $e + x * (this.B_im[x] * oe + this.B_re[x] * ce);
            var Nn = je * je + $e * $e;
            Jt = (Le * je + Ze * $e) / Nn, se = (Ze * je - Le * $e) / Nn;
          }
          var pn = Jt, Pi = se, hs = 1, ps = 0;
          for (x = 1; x <= 9; x++)
            hs = hs * pn, ps = ps + this.D[x] * hs;
          var lc = this.lat0 + ps * v * 1e5, Oy = this.long0 + Pi;
          return u.x = Oy, u.y = lc, u;
        }
        var S0 = ["New_Zealand_Map_Grid", "nzmg"], A0 = {
          init: E0,
          forward: w0,
          inverse: M0,
          names: S0
        };
        function T0() {
        }
        function C0(u) {
          var x = u.x, T = u.y, X = st(x - this.long0), $ = this.x0 + this.a * X, ct = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + T / 2.5)) * 1.25;
          return u.x = $, u.y = ct, u;
        }
        function R0(u) {
          u.x -= this.x0, u.y -= this.y0;
          var x = st(this.long0 + u.x / this.a), T = 2.5 * (Math.atan(Math.exp(0.8 * u.y / this.a)) - Math.PI / 4);
          return u.x = x, u.y = T, u;
        }
        var I0 = ["Miller_Cylindrical", "mill"], P0 = {
          init: T0,
          forward: C0,
          inverse: R0,
          names: I0
        }, L0 = 20;
        function O0() {
          this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = br(this.es);
        }
        function D0(u) {
          var x, T, X = u.x, $ = u.y;
          if (X = st(X - this.long0), this.sphere) {
            if (!this.m)
              $ = this.n !== 1 ? Math.asin(this.n * Math.sin($)) : $;
            else
              for (var ct = this.n * Math.sin($), dt = L0; dt; --dt) {
                var ot = (this.m * $ + Math.sin($) - ct) / (this.m + Math.cos($));
                if ($ -= ot, Math.abs(ot) < M)
                  break;
              }
            x = this.a * this.C_x * X * (this.m + Math.cos($)), T = this.a * this.C_y * $;
          } else {
            var At = Math.sin($), Dt = Math.cos($);
            T = this.a * Ci($, At, Dt, this.en), x = this.a * X * Dt / Math.sqrt(1 - this.es * At * At);
          }
          return u.x = x, u.y = T, u;
        }
        function N0(u) {
          var x, T, X, $;
          return u.x -= this.x0, X = u.x / this.a, u.y -= this.y0, x = u.y / this.a, this.sphere ? (x /= this.C_y, X = X / (this.C_x * (this.m + Math.cos(x))), this.m ? x = Mr((this.m * x + Math.sin(x)) / this.n) : this.n !== 1 && (x = Mr(Math.sin(x) / this.n)), X = st(X + this.long0), x = Us(x)) : (x = _e(u.y / this.a, this.es, this.en), $ = Math.abs(x), $ < E ? ($ = Math.sin(x), T = this.long0 + u.x * Math.sqrt(1 - this.es * $ * $) / (this.a * Math.cos(x)), X = st(T)) : $ - M < E && (X = this.long0)), u.x = X, u.y = x, u;
        }
        var F0 = ["Sinusoidal", "sinu"], U0 = {
          init: O0,
          forward: D0,
          inverse: N0,
          names: F0
        };
        function B0() {
        }
        function k0(u) {
          for (var x = u.x, T = u.y, X = st(x - this.long0), $ = T, ct = Math.PI * Math.sin(T); ; ) {
            var dt = -($ + Math.sin($) - ct) / (1 + Math.cos($));
            if ($ += dt, Math.abs(dt) < M)
              break;
          }
          $ /= 2, Math.PI / 2 - Math.abs(T) < M && (X = 0);
          var ot = 0.900316316158 * this.a * X * Math.cos($) + this.x0, At = 1.4142135623731 * this.a * Math.sin($) + this.y0;
          return u.x = ot, u.y = At, u;
        }
        function z0(u) {
          var x, T;
          u.x -= this.x0, u.y -= this.y0, T = u.y / (1.4142135623731 * this.a), Math.abs(T) > 0.999999999999 && (T = 0.999999999999), x = Math.asin(T);
          var X = st(this.long0 + u.x / (0.900316316158 * this.a * Math.cos(x)));
          X < -Math.PI && (X = -Math.PI), X > Math.PI && (X = Math.PI), T = (2 * x + Math.sin(2 * x)) / Math.PI, Math.abs(T) > 1 && (T = 1);
          var $ = Math.asin(T);
          return u.x = X, u.y = $, u;
        }
        var G0 = ["Mollweide", "moll"], V0 = {
          init: B0,
          forward: k0,
          inverse: z0,
          names: G0
        };
        function H0() {
          Math.abs(this.lat1 + this.lat2) < M || (this.lat2 = this.lat2 || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = ei(this.es), this.e1 = Er(this.es), this.e2 = Zi(this.es), this.e3 = Ji(this.es), this.sinphi = Math.sin(this.lat1), this.cosphi = Math.cos(this.lat1), this.ms1 = tt(this.e, this.sinphi, this.cosphi), this.ml1 = be(this.e0, this.e1, this.e2, this.e3, this.lat1), Math.abs(this.lat1 - this.lat2) < M ? this.ns = this.sinphi : (this.sinphi = Math.sin(this.lat2), this.cosphi = Math.cos(this.lat2), this.ms2 = tt(this.e, this.sinphi, this.cosphi), this.ml2 = be(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = be(this.e0, this.e1, this.e2, this.e3, this.lat0), this.rh = this.a * (this.g - this.ml0));
        }
        function j0(u) {
          var x = u.x, T = u.y, X;
          if (this.sphere)
            X = this.a * (this.g - T);
          else {
            var $ = be(this.e0, this.e1, this.e2, this.e3, T);
            X = this.a * (this.g - $);
          }
          var ct = this.ns * st(x - this.long0), dt = this.x0 + X * Math.sin(ct), ot = this.y0 + this.rh - X * Math.cos(ct);
          return u.x = dt, u.y = ot, u;
        }
        function W0(u) {
          u.x -= this.x0, u.y = this.rh - u.y + this.y0;
          var x, T, X, $;
          this.ns >= 0 ? (T = Math.sqrt(u.x * u.x + u.y * u.y), x = 1) : (T = -Math.sqrt(u.x * u.x + u.y * u.y), x = -1);
          var ct = 0;
          if (T !== 0 && (ct = Math.atan2(x * u.x, x * u.y)), this.sphere)
            return $ = st(this.long0 + ct / this.ns), X = Us(this.g - T / this.a), u.x = $, u.y = X, u;
          var dt = this.g - T / this.a;
          return X = oc(dt, this.e0, this.e1, this.e2, this.e3), $ = st(this.long0 + ct / this.ns), u.x = $, u.y = X, u;
        }
        var q0 = ["Equidistant_Conic", "eqdc"], $0 = {
          init: H0,
          forward: j0,
          inverse: W0,
          names: q0
        };
        function X0() {
          this.R = this.a;
        }
        function Y0(u) {
          var x = u.x, T = u.y, X = st(x - this.long0), $, ct;
          Math.abs(T) <= M && ($ = this.x0 + this.R * X, ct = this.y0);
          var dt = Mr(2 * Math.abs(T / Math.PI));
          (Math.abs(X) <= M || Math.abs(Math.abs(T) - E) <= M) && ($ = this.x0, T >= 0 ? ct = this.y0 + Math.PI * this.R * Math.tan(0.5 * dt) : ct = this.y0 + Math.PI * this.R * -Math.tan(0.5 * dt));
          var ot = 0.5 * Math.abs(Math.PI / X - X / Math.PI), At = ot * ot, Dt = Math.sin(dt), Vt = Math.cos(dt), zt = Vt / (Dt + Vt - 1), Jt = zt * zt, se = zt * (2 / Dt - 1), ne = se * se, oe = Math.PI * this.R * (ot * (zt - ne) + Math.sqrt(At * (zt - ne) * (zt - ne) - (ne + At) * (Jt - ne))) / (ne + At);
          X < 0 && (oe = -oe), $ = this.x0 + oe;
          var ce = At + zt;
          return oe = Math.PI * this.R * (se * ce - ot * Math.sqrt((ne + At) * (At + 1) - ce * ce)) / (ne + At), T >= 0 ? ct = this.y0 + oe : ct = this.y0 - oe, u.x = $, u.y = ct, u;
        }
        function K0(u) {
          var x, T, X, $, ct, dt, ot, At, Dt, Vt, zt, Jt, se;
          return u.x -= this.x0, u.y -= this.y0, zt = Math.PI * this.R, X = u.x / zt, $ = u.y / zt, ct = X * X + $ * $, dt = -Math.abs($) * (1 + ct), ot = dt - 2 * $ * $ + X * X, At = -2 * dt + 1 + 2 * $ * $ + ct * ct, se = $ * $ / At + (2 * ot * ot * ot / At / At / At - 9 * dt * ot / At / At) / 27, Dt = (dt - ot * ot / 3 / At) / At, Vt = 2 * Math.sqrt(-Dt / 3), zt = 3 * se / Dt / Vt, Math.abs(zt) > 1 && (zt >= 0 ? zt = 1 : zt = -1), Jt = Math.acos(zt) / 3, u.y >= 0 ? T = (-Vt * Math.cos(Jt + Math.PI / 3) - ot / 3 / At) * Math.PI : T = -(-Vt * Math.cos(Jt + Math.PI / 3) - ot / 3 / At) * Math.PI, Math.abs(X) < M ? x = this.long0 : x = st(this.long0 + Math.PI * (ct - 1 + Math.sqrt(1 + 2 * (X * X - $ * $) + ct * ct)) / 2 / X), u.x = x, u.y = T, u;
        }
        var Z0 = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"], J0 = {
          init: X0,
          forward: Y0,
          inverse: K0,
          names: Z0
        };
        function Q0() {
          this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0);
        }
        function ty(u) {
          var x = u.x, T = u.y, X = Math.sin(u.y), $ = Math.cos(u.y), ct = st(x - this.long0), dt, ot, At, Dt, Vt, zt, Jt, se, ne, oe, ce, ge, Ce, Le, Ze, je, $e, Nn, pn, Pi, hs, ps, lc;
          return this.sphere ? Math.abs(this.sin_p12 - 1) <= M ? (u.x = this.x0 + this.a * (E - T) * Math.sin(ct), u.y = this.y0 - this.a * (E - T) * Math.cos(ct), u) : Math.abs(this.sin_p12 + 1) <= M ? (u.x = this.x0 + this.a * (E + T) * Math.sin(ct), u.y = this.y0 + this.a * (E + T) * Math.cos(ct), u) : (Nn = this.sin_p12 * X + this.cos_p12 * $ * Math.cos(ct), je = Math.acos(Nn), $e = je ? je / Math.sin(je) : 1, u.x = this.x0 + this.a * $e * $ * Math.sin(ct), u.y = this.y0 + this.a * $e * (this.cos_p12 * X - this.sin_p12 * $ * Math.cos(ct)), u) : (dt = ei(this.es), ot = Er(this.es), At = Zi(this.es), Dt = Ji(this.es), Math.abs(this.sin_p12 - 1) <= M ? (Vt = this.a * be(dt, ot, At, Dt, E), zt = this.a * be(dt, ot, At, Dt, T), u.x = this.x0 + (Vt - zt) * Math.sin(ct), u.y = this.y0 - (Vt - zt) * Math.cos(ct), u) : Math.abs(this.sin_p12 + 1) <= M ? (Vt = this.a * be(dt, ot, At, Dt, E), zt = this.a * be(dt, ot, At, Dt, T), u.x = this.x0 + (Vt + zt) * Math.sin(ct), u.y = this.y0 + (Vt + zt) * Math.cos(ct), u) : (Jt = X / $, se = Ii(this.a, this.e, this.sin_p12), ne = Ii(this.a, this.e, X), oe = Math.atan((1 - this.es) * Jt + this.es * se * this.sin_p12 / (ne * $)), ce = Math.atan2(Math.sin(ct), this.cos_p12 * Math.tan(oe) - this.sin_p12 * Math.cos(ct)), ce === 0 ? pn = Math.asin(this.cos_p12 * Math.sin(oe) - this.sin_p12 * Math.cos(oe)) : Math.abs(Math.abs(ce) - Math.PI) <= M ? pn = -Math.asin(this.cos_p12 * Math.sin(oe) - this.sin_p12 * Math.cos(oe)) : pn = Math.asin(Math.sin(ct) * Math.cos(oe) / Math.sin(ce)), ge = this.e * this.sin_p12 / Math.sqrt(1 - this.es), Ce = this.e * this.cos_p12 * Math.cos(ce) / Math.sqrt(1 - this.es), Le = ge * Ce, Ze = Ce * Ce, Pi = pn * pn, hs = Pi * pn, ps = hs * pn, lc = ps * pn, je = se * pn * (1 - Pi * Ze * (1 - Ze) / 6 + hs / 8 * Le * (1 - 2 * Ze) + ps / 120 * (Ze * (4 - 7 * Ze) - 3 * ge * ge * (1 - 7 * Ze)) - lc / 48 * Le), u.x = this.x0 + je * Math.sin(ce), u.y = this.y0 + je * Math.cos(ce), u));
        }
        function ey(u) {
          u.x -= this.x0, u.y -= this.y0;
          var x, T, X, $, ct, dt, ot, At, Dt, Vt, zt, Jt, se, ne, oe, ce, ge, Ce, Le, Ze, je, $e, Nn, pn;
          return this.sphere ? (x = Math.sqrt(u.x * u.x + u.y * u.y), x > 2 * E * this.a ? void 0 : (T = x / this.a, X = Math.sin(T), $ = Math.cos(T), ct = this.long0, Math.abs(x) <= M ? dt = this.lat0 : (dt = Mr($ * this.sin_p12 + u.y * X * this.cos_p12 / x), ot = Math.abs(this.lat0) - E, Math.abs(ot) <= M ? this.lat0 >= 0 ? ct = st(this.long0 + Math.atan2(u.x, -u.y)) : ct = st(this.long0 - Math.atan2(-u.x, u.y)) : ct = st(this.long0 + Math.atan2(u.x * X, x * this.cos_p12 * $ - u.y * this.sin_p12 * X))), u.x = ct, u.y = dt, u)) : (At = ei(this.es), Dt = Er(this.es), Vt = Zi(this.es), zt = Ji(this.es), Math.abs(this.sin_p12 - 1) <= M ? (Jt = this.a * be(At, Dt, Vt, zt, E), x = Math.sqrt(u.x * u.x + u.y * u.y), se = Jt - x, dt = oc(se / this.a, At, Dt, Vt, zt), ct = st(this.long0 + Math.atan2(u.x, -1 * u.y)), u.x = ct, u.y = dt, u) : Math.abs(this.sin_p12 + 1) <= M ? (Jt = this.a * be(At, Dt, Vt, zt, E), x = Math.sqrt(u.x * u.x + u.y * u.y), se = x - Jt, dt = oc(se / this.a, At, Dt, Vt, zt), ct = st(this.long0 + Math.atan2(u.x, u.y)), u.x = ct, u.y = dt, u) : (x = Math.sqrt(u.x * u.x + u.y * u.y), ce = Math.atan2(u.x, u.y), ne = Ii(this.a, this.e, this.sin_p12), ge = Math.cos(ce), Ce = this.e * this.cos_p12 * ge, Le = -Ce * Ce / (1 - this.es), Ze = 3 * this.es * (1 - Le) * this.sin_p12 * this.cos_p12 * ge / (1 - this.es), je = x / ne, $e = je - Le * (1 + Le) * Math.pow(je, 3) / 6 - Ze * (1 + 3 * Le) * Math.pow(je, 4) / 24, Nn = 1 - Le * $e * $e / 2 - je * $e * $e * $e / 6, oe = Math.asin(this.sin_p12 * Math.cos($e) + this.cos_p12 * Math.sin($e) * ge), ct = st(this.long0 + Math.asin(Math.sin(ce) * Math.sin($e) / Math.cos(oe))), pn = Math.sin(oe), dt = Math.atan2((pn - this.es * Nn * this.sin_p12) * Math.tan(oe), pn * (1 - this.es)), u.x = ct, u.y = dt, u));
        }
        var ny = ["Azimuthal_Equidistant", "aeqd"], iy = {
          init: Q0,
          forward: ty,
          inverse: ey,
          names: ny
        };
        function ry() {
          this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0);
        }
        function sy(u) {
          var x, T, X, $, ct, dt, ot, At, Dt = u.x, Vt = u.y;
          return X = st(Dt - this.long0), x = Math.sin(Vt), T = Math.cos(Vt), $ = Math.cos(X), dt = this.sin_p14 * x + this.cos_p14 * T * $, ct = 1, (dt > 0 || Math.abs(dt) <= M) && (ot = this.a * ct * T * Math.sin(X), At = this.y0 + this.a * ct * (this.cos_p14 * x - this.sin_p14 * T * $)), u.x = ot, u.y = At, u;
        }
        function ay(u) {
          var x, T, X, $, ct, dt, ot;
          return u.x -= this.x0, u.y -= this.y0, x = Math.sqrt(u.x * u.x + u.y * u.y), T = Mr(x / this.a), X = Math.sin(T), $ = Math.cos(T), dt = this.long0, Math.abs(x) <= M ? (ot = this.lat0, u.x = dt, u.y = ot, u) : (ot = Mr($ * this.sin_p14 + u.y * X * this.cos_p14 / x), ct = Math.abs(this.lat0) - E, Math.abs(ct) <= M ? (this.lat0 >= 0 ? dt = st(this.long0 + Math.atan2(u.x, -u.y)) : dt = st(this.long0 - Math.atan2(-u.x, u.y)), u.x = dt, u.y = ot, u) : (dt = st(this.long0 + Math.atan2(u.x * X, x * this.cos_p14 * $ - u.y * this.sin_p14 * X)), u.x = dt, u.y = ot, u));
        }
        var oy = ["ortho"], cy = {
          init: ry,
          forward: sy,
          inverse: ay,
          names: oy
        }, an = {
          FRONT: 1,
          RIGHT: 2,
          BACK: 3,
          LEFT: 4,
          TOP: 5,
          BOTTOM: 6
        }, qe = {
          AREA_0: 1,
          AREA_1: 2,
          AREA_2: 3,
          AREA_3: 4
        };
        function uy() {
          this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Quadrilateralized Spherical Cube", this.lat0 >= E - C / 2 ? this.face = an.TOP : this.lat0 <= -(E - C / 2) ? this.face = an.BOTTOM : Math.abs(this.long0) <= C ? this.face = an.FRONT : Math.abs(this.long0) <= E + C ? this.face = this.long0 > 0 ? an.RIGHT : an.LEFT : this.face = an.BACK, this.es !== 0 && (this.one_minus_f = 1 - (this.a - this.b) / this.a, this.one_minus_f_squared = this.one_minus_f * this.one_minus_f);
        }
        function ly(u) {
          var x = { x: 0, y: 0 }, T, X, $, ct, dt, ot, At = { value: 0 };
          if (u.x -= this.long0, this.es !== 0 ? T = Math.atan(this.one_minus_f_squared * Math.tan(u.y)) : T = u.y, X = u.x, this.face === an.TOP)
            ct = E - T, X >= C && X <= E + C ? (At.value = qe.AREA_0, $ = X - E) : X > E + C || X <= -(E + C) ? (At.value = qe.AREA_1, $ = X > 0 ? X - N : X + N) : X > -(E + C) && X <= -C ? (At.value = qe.AREA_2, $ = X + E) : (At.value = qe.AREA_3, $ = X);
          else if (this.face === an.BOTTOM)
            ct = E + T, X >= C && X <= E + C ? (At.value = qe.AREA_0, $ = -X + E) : X < C && X >= -C ? (At.value = qe.AREA_1, $ = -X) : X < -C && X >= -(E + C) ? (At.value = qe.AREA_2, $ = -X - E) : (At.value = qe.AREA_3, $ = X > 0 ? -X + N : -X - N);
          else {
            var Dt, Vt, zt, Jt, se, ne, oe;
            this.face === an.RIGHT ? X = Bs(X, +E) : this.face === an.BACK ? X = Bs(X, +N) : this.face === an.LEFT && (X = Bs(X, -E)), Jt = Math.sin(T), se = Math.cos(T), ne = Math.sin(X), oe = Math.cos(X), Dt = se * oe, Vt = se * ne, zt = Jt, this.face === an.FRONT ? (ct = Math.acos(Dt), $ = cc(ct, zt, Vt, At)) : this.face === an.RIGHT ? (ct = Math.acos(Vt), $ = cc(ct, zt, -Dt, At)) : this.face === an.BACK ? (ct = Math.acos(-Dt), $ = cc(ct, zt, -Vt, At)) : this.face === an.LEFT ? (ct = Math.acos(-Vt), $ = cc(ct, zt, Dt, At)) : (ct = $ = 0, At.value = qe.AREA_0);
          }
          return ot = Math.atan(12 / N * ($ + Math.acos(Math.sin($) * Math.cos(C)) - E)), dt = Math.sqrt((1 - Math.cos(ct)) / (Math.cos(ot) * Math.cos(ot)) / (1 - Math.cos(Math.atan(1 / Math.cos($))))), At.value === qe.AREA_1 ? ot += E : At.value === qe.AREA_2 ? ot += N : At.value === qe.AREA_3 && (ot += 1.5 * N), x.x = dt * Math.cos(ot), x.y = dt * Math.sin(ot), x.x = x.x * this.a + this.x0, x.y = x.y * this.a + this.y0, u.x = x.x, u.y = x.y, u;
        }
        function fy(u) {
          var x = { lam: 0, phi: 0 }, T, X, $, ct, dt, ot, At, Dt, Vt, zt = { value: 0 };
          if (u.x = (u.x - this.x0) / this.a, u.y = (u.y - this.y0) / this.a, X = Math.atan(Math.sqrt(u.x * u.x + u.y * u.y)), T = Math.atan2(u.y, u.x), u.x >= 0 && u.x >= Math.abs(u.y) ? zt.value = qe.AREA_0 : u.y >= 0 && u.y >= Math.abs(u.x) ? (zt.value = qe.AREA_1, T -= E) : u.x < 0 && -u.x >= Math.abs(u.y) ? (zt.value = qe.AREA_2, T = T < 0 ? T + N : T - N) : (zt.value = qe.AREA_3, T += E), Vt = N / 12 * Math.tan(T), dt = Math.sin(Vt) / (Math.cos(Vt) - 1 / Math.sqrt(2)), ot = Math.atan(dt), $ = Math.cos(T), ct = Math.tan(X), At = 1 - $ * $ * ct * ct * (1 - Math.cos(Math.atan(1 / Math.cos(ot)))), At < -1 ? At = -1 : At > 1 && (At = 1), this.face === an.TOP)
            Dt = Math.acos(At), x.phi = E - Dt, zt.value === qe.AREA_0 ? x.lam = ot + E : zt.value === qe.AREA_1 ? x.lam = ot < 0 ? ot + N : ot - N : zt.value === qe.AREA_2 ? x.lam = ot - E : x.lam = ot;
          else if (this.face === an.BOTTOM)
            Dt = Math.acos(At), x.phi = Dt - E, zt.value === qe.AREA_0 ? x.lam = -ot + E : zt.value === qe.AREA_1 ? x.lam = -ot : zt.value === qe.AREA_2 ? x.lam = -ot - E : x.lam = ot < 0 ? -ot - N : -ot + N;
          else {
            var Jt, se, ne;
            Jt = At, Vt = Jt * Jt, Vt >= 1 ? ne = 0 : ne = Math.sqrt(1 - Vt) * Math.sin(ot), Vt += ne * ne, Vt >= 1 ? se = 0 : se = Math.sqrt(1 - Vt), zt.value === qe.AREA_1 ? (Vt = se, se = -ne, ne = Vt) : zt.value === qe.AREA_2 ? (se = -se, ne = -ne) : zt.value === qe.AREA_3 && (Vt = se, se = ne, ne = -Vt), this.face === an.RIGHT ? (Vt = Jt, Jt = -se, se = Vt) : this.face === an.BACK ? (Jt = -Jt, se = -se) : this.face === an.LEFT && (Vt = Jt, Jt = se, se = -Vt), x.phi = Math.acos(-ne) - E, x.lam = Math.atan2(se, Jt), this.face === an.RIGHT ? x.lam = Bs(x.lam, -E) : this.face === an.BACK ? x.lam = Bs(x.lam, -N) : this.face === an.LEFT && (x.lam = Bs(x.lam, +E));
          }
          if (this.es !== 0) {
            var oe, ce, ge;
            oe = x.phi < 0 ? 1 : 0, ce = Math.tan(x.phi), ge = this.b / Math.sqrt(ce * ce + this.one_minus_f_squared), x.phi = Math.atan(Math.sqrt(this.a * this.a - ge * ge) / (this.one_minus_f * ge)), oe && (x.phi = -x.phi);
          }
          return x.lam += this.long0, u.x = x.lam, u.y = x.phi, u;
        }
        function cc(u, x, T, X) {
          var $;
          return u < M ? (X.value = qe.AREA_0, $ = 0) : ($ = Math.atan2(x, T), Math.abs($) <= C ? X.value = qe.AREA_0 : $ > C && $ <= E + C ? (X.value = qe.AREA_1, $ -= E) : $ > E + C || $ <= -(E + C) ? (X.value = qe.AREA_2, $ = $ >= 0 ? $ - N : $ + N) : (X.value = qe.AREA_3, $ += E)), $;
        }
        function Bs(u, x) {
          var T = u + x;
          return T < -N ? T += D : T > +N && (T -= D), T;
        }
        var hy = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"], py = {
          init: uy,
          forward: ly,
          inverse: fy,
          names: hy
        }, wu = [
          [1, 22199e-21, -715515e-10, 31103e-10],
          [0.9986, -482243e-9, -24897e-9, -13309e-10],
          [0.9954, -83103e-8, -448605e-10, -986701e-12],
          [0.99, -135364e-8, -59661e-9, 36777e-10],
          [0.9822, -167442e-8, -449547e-11, -572411e-11],
          [0.973, -214868e-8, -903571e-10, 18736e-12],
          [0.96, -305085e-8, -900761e-10, 164917e-11],
          [0.9427, -382792e-8, -653386e-10, -26154e-10],
          [0.9216, -467746e-8, -10457e-8, 481243e-11],
          [0.8962, -536223e-8, -323831e-10, -543432e-11],
          [0.8679, -609363e-8, -113898e-9, 332484e-11],
          [0.835, -698325e-8, -640253e-10, 934959e-12],
          [0.7986, -755338e-8, -500009e-10, 935324e-12],
          [0.7597, -798324e-8, -35971e-9, -227626e-11],
          [0.7186, -851367e-8, -701149e-10, -86303e-10],
          [0.6732, -986209e-8, -199569e-9, 191974e-10],
          [0.6213, -0.010418, 883923e-10, 624051e-11],
          [0.5722, -906601e-8, 182e-6, 624051e-11],
          [0.5322, -677797e-8, 275608e-9, 624051e-11]
        ], Ca = [
          [-520417e-23, 0.0124, 121431e-23, -845284e-16],
          [0.062, 0.0124, -126793e-14, 422642e-15],
          [0.124, 0.0124, 507171e-14, -160604e-14],
          [0.186, 0.0123999, -190189e-13, 600152e-14],
          [0.248, 0.0124002, 710039e-13, -224e-10],
          [0.31, 0.0123992, -264997e-12, 835986e-13],
          [0.372, 0.0124029, 988983e-12, -311994e-12],
          [0.434, 0.0123893, -369093e-11, -435621e-12],
          [0.4958, 0.0123198, -102252e-10, -345523e-12],
          [0.5571, 0.0121916, -154081e-10, -582288e-12],
          [0.6176, 0.0119938, -241424e-10, -525327e-12],
          [0.6769, 0.011713, -320223e-10, -516405e-12],
          [0.7346, 0.0113541, -397684e-10, -609052e-12],
          [0.7903, 0.0109107, -489042e-10, -104739e-11],
          [0.8435, 0.0103431, -64615e-9, -140374e-14],
          [0.8936, 969686e-8, -64636e-9, -8547e-9],
          [0.9394, 840947e-8, -192841e-9, -42106e-10],
          [0.9761, 616527e-8, -256e-6, -42106e-10],
          [1, 328947e-8, -319159e-9, -42106e-10]
        ], Df = 0.8487, Nf = 1.3523, Ff = W / 5, dy = 1 / Ff, ks = 18, uc = function(u, x) {
          return u[0] + x * (u[1] + x * (u[2] + x * u[3]));
        }, my = function(u, x) {
          return u[1] + x * (2 * u[2] + x * 3 * u[3]);
        };
        function _y(u, x, T, X) {
          for (var $ = x; X; --X) {
            var ct = u($);
            if ($ -= ct, Math.abs(ct) < T)
              break;
          }
          return $;
        }
        function yy() {
          this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.long0 = this.long0 || 0, this.es = 0, this.title = this.title || "Robinson";
        }
        function gy(u) {
          var x = st(u.x - this.long0), T = Math.abs(u.y), X = Math.floor(T * Ff);
          X < 0 ? X = 0 : X >= ks && (X = ks - 1), T = W * (T - dy * X);
          var $ = {
            x: uc(wu[X], T) * x,
            y: uc(Ca[X], T)
          };
          return u.y < 0 && ($.y = -$.y), $.x = $.x * this.a * Df + this.x0, $.y = $.y * this.a * Nf + this.y0, $;
        }
        function vy(u) {
          var x = {
            x: (u.x - this.x0) / (this.a * Df),
            y: Math.abs(u.y - this.y0) / (this.a * Nf)
          };
          if (x.y >= 1)
            x.x /= wu[ks][0], x.y = u.y < 0 ? -E : E;
          else {
            var T = Math.floor(x.y * ks);
            for (T < 0 ? T = 0 : T >= ks && (T = ks - 1); ; )
              if (Ca[T][0] > x.y)
                --T;
              else if (Ca[T + 1][0] <= x.y)
                ++T;
              else
                break;
            var X = Ca[T], $ = 5 * (x.y - X[0]) / (Ca[T + 1][0] - X[0]);
            $ = _y(function(ct) {
              return (uc(X, ct) - x.y) / my(X, ct);
            }, $, M, 100), x.x /= uc(wu[T], $), x.y = (5 * T + $) * P, u.y < 0 && (x.y = -x.y);
          }
          return x.x = st(x.x + this.long0), x;
        }
        var xy = ["Robinson", "robin"], by = {
          init: yy,
          forward: gy,
          inverse: vy,
          names: xy
        };
        function Ey() {
          this.name = "geocent";
        }
        function wy(u) {
          var x = Xt(u, this.es, this.a);
          return x;
        }
        function My(u) {
          var x = jt(u, this.es, this.a, this.b);
          return x;
        }
        var Sy = ["Geocentric", "geocentric", "geocent", "Geocent"], Ay = {
          init: Ey,
          forward: wy,
          inverse: My,
          names: Sy
        }, Dn = {
          N_POLE: 0,
          S_POLE: 1,
          EQUIT: 2,
          OBLIQ: 3
        }, Ra = {
          h: { def: 1e5, num: !0 },
          // default is Karman line, no default in PROJ.7
          azi: { def: 0, num: !0, degrees: !0 },
          // default is North
          tilt: { def: 0, num: !0, degrees: !0 },
          // default is Nadir
          long0: { def: 0, num: !0 },
          // default is Greenwich, conversion to rad is automatic
          lat0: { def: 0, num: !0 }
          // default is Equator, conversion to rad is automatic
        };
        function Ty() {
          if (Object.keys(Ra).forEach((function(T) {
            if (typeof this[T] > "u")
              this[T] = Ra[T].def;
            else {
              if (Ra[T].num && isNaN(this[T]))
                throw new Error("Invalid parameter value, must be numeric " + T + " = " + this[T]);
              Ra[T].num && (this[T] = parseFloat(this[T]));
            }
            Ra[T].degrees && (this[T] = this[T] * P);
          }).bind(this)), Math.abs(Math.abs(this.lat0) - E) < M ? this.mode = this.lat0 < 0 ? Dn.S_POLE : Dn.N_POLE : Math.abs(this.lat0) < M ? this.mode = Dn.EQUIT : (this.mode = Dn.OBLIQ, this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0)), this.pn1 = this.h / this.a, this.pn1 <= 0 || this.pn1 > 1e10)
            throw new Error("Invalid height");
          this.p = 1 + this.pn1, this.rp = 1 / this.p, this.h1 = 1 / this.pn1, this.pfact = (this.p + 1) * this.h1, this.es = 0;
          var u = this.tilt, x = this.azi;
          this.cg = Math.cos(x), this.sg = Math.sin(x), this.cw = Math.cos(u), this.sw = Math.sin(u);
        }
        function Cy(u) {
          u.x -= this.long0;
          var x = Math.sin(u.y), T = Math.cos(u.y), X = Math.cos(u.x), $, ct;
          switch (this.mode) {
            case Dn.OBLIQ:
              ct = this.sinph0 * x + this.cosph0 * T * X;
              break;
            case Dn.EQUIT:
              ct = T * X;
              break;
            case Dn.S_POLE:
              ct = -x;
              break;
            case Dn.N_POLE:
              ct = x;
              break;
          }
          switch (ct = this.pn1 / (this.p - ct), $ = ct * T * Math.sin(u.x), this.mode) {
            case Dn.OBLIQ:
              ct *= this.cosph0 * x - this.sinph0 * T * X;
              break;
            case Dn.EQUIT:
              ct *= x;
              break;
            case Dn.N_POLE:
              ct *= -(T * X);
              break;
            case Dn.S_POLE:
              ct *= T * X;
              break;
          }
          var dt, ot;
          return dt = ct * this.cg + $ * this.sg, ot = 1 / (dt * this.sw * this.h1 + this.cw), $ = ($ * this.cg - ct * this.sg) * this.cw * ot, ct = dt * ot, u.x = $ * this.a, u.y = ct * this.a, u;
        }
        function Ry(u) {
          u.x /= this.a, u.y /= this.a;
          var x = { x: u.x, y: u.y }, T, X, $;
          $ = 1 / (this.pn1 - u.y * this.sw), T = this.pn1 * u.x * $, X = this.pn1 * u.y * this.cw * $, u.x = T * this.cg + X * this.sg, u.y = X * this.cg - T * this.sg;
          var ct = Ri(u.x, u.y);
          if (Math.abs(ct) < M)
            x.x = 0, x.y = u.y;
          else {
            var dt, ot;
            switch (ot = 1 - ct * ct * this.pfact, ot = (this.p - Math.sqrt(ot)) / (this.pn1 / ct + ct / this.pn1), dt = Math.sqrt(1 - ot * ot), this.mode) {
              case Dn.OBLIQ:
                x.y = Math.asin(dt * this.sinph0 + u.y * ot * this.cosph0 / ct), u.y = (dt - this.sinph0 * Math.sin(x.y)) * ct, u.x *= ot * this.cosph0;
                break;
              case Dn.EQUIT:
                x.y = Math.asin(u.y * ot / ct), u.y = dt * ct, u.x *= ot;
                break;
              case Dn.N_POLE:
                x.y = Math.asin(dt), u.y = -u.y;
                break;
              case Dn.S_POLE:
                x.y = -Math.asin(dt);
                break;
            }
            x.x = Math.atan2(u.x, u.y);
          }
          return u.x = x.x + this.long0, u.y = x.y, u;
        }
        var Iy = ["Tilted_Perspective", "tpers"], Py = {
          init: Ty,
          forward: Cy,
          inverse: Ry,
          names: Iy
        }, Ly = function(u) {
          u.Proj.projections.add(Zt), u.Proj.projections.add(fs), u.Proj.projections.add(Io), u.Proj.projections.add(zo), u.Proj.projections.add(qo), u.Proj.projections.add(Zo), u.Proj.projections.add(ic), u.Proj.projections.add(Ie), u.Proj.projections.add(Me), u.Proj.projections.add(P_), u.Proj.projections.add(X_), u.Proj.projections.add(t0), u.Proj.projections.add(s0), u.Proj.projections.add(f0), u.Proj.projections.add(_0), u.Proj.projections.add(b0), u.Proj.projections.add(A0), u.Proj.projections.add(P0), u.Proj.projections.add(U0), u.Proj.projections.add(V0), u.Proj.projections.add($0), u.Proj.projections.add(J0), u.Proj.projections.add(iy), u.Proj.projections.add(cy), u.Proj.projections.add(py), u.Proj.projections.add(by), u.Proj.projections.add(Ay), u.Proj.projections.add(Py);
        };
        return hn.defaultDatum = "WGS84", hn.Proj = kt, hn.WGS84 = new hn.Proj("WGS84"), hn.Point = hi, hn.toPoint = fn, hn.defs = Et, hn.nadgrid = Qn, hn.transform = Ae, hn.mgrs = Ti, hn.version = "2.7.4", Ly(hn), hn;
      });
    }, {}], 18: [function(e, i, r) {
      /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
      var s = e("buffer"), a = s.Buffer;
      function o(h, l) {
        for (var f in h)
          l[f] = h[f];
      }
      a.from && a.alloc && a.allocUnsafe && a.allocUnsafeSlow ? i.exports = s : (o(s, r), r.Buffer = c);
      function c(h, l, f) {
        return a(h, l, f);
      }
      c.prototype = Object.create(a.prototype), o(a, c), c.from = function(h, l, f) {
        if (typeof h == "number")
          throw new TypeError("Argument must not be a number");
        return a(h, l, f);
      }, c.alloc = function(h, l, f) {
        if (typeof h != "number")
          throw new TypeError("Argument must be a number");
        var d = a(h);
        return l !== void 0 ? typeof f == "string" ? d.fill(l, f) : d.fill(l) : d.fill(0), d;
      }, c.allocUnsafe = function(h) {
        if (typeof h != "number")
          throw new TypeError("Argument must be a number");
        return a(h);
      }, c.allocUnsafeSlow = function(h) {
        if (typeof h != "number")
          throw new TypeError("Argument must be a number");
        return s.SlowBuffer(h);
      };
    }, { buffer: 8 }], 19: [function(e, i, r) {
      var s = e("safe-buffer").Buffer, a = s.isEncoding || function(C) {
        switch (C = "" + C, C && C.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return !0;
          default:
            return !1;
        }
      };
      function o(C) {
        if (!C)
          return "utf8";
        for (var D; ; )
          switch (C) {
            case "utf8":
            case "utf-8":
              return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return "utf16le";
            case "latin1":
            case "binary":
              return "latin1";
            case "base64":
            case "ascii":
            case "hex":
              return C;
            default:
              if (D)
                return;
              C = ("" + C).toLowerCase(), D = !0;
          }
      }
      function c(C) {
        var D = o(C);
        if (typeof D != "string" && (s.isEncoding === a || !a(C)))
          throw new Error("Unknown encoding: " + C);
        return D || C;
      }
      r.StringDecoder = h;
      function h(C) {
        this.encoding = c(C);
        var D;
        switch (this.encoding) {
          case "utf16le":
            this.text = _, this.end = p, D = 4;
            break;
          case "utf8":
            this.fillLast = m, D = 4;
            break;
          case "base64":
            this.text = R, this.end = M, D = 3;
            break;
          default:
            this.write = P, this.end = W;
            return;
        }
        this.lastNeed = 0, this.lastTotal = 0, this.lastChar = s.allocUnsafe(D);
      }
      h.prototype.write = function(C) {
        if (C.length === 0)
          return "";
        var D, N;
        if (this.lastNeed) {
          if (D = this.fillLast(C), D === void 0)
            return "";
          N = this.lastNeed, this.lastNeed = 0;
        } else
          N = 0;
        return N < C.length ? D ? D + this.text(C, N) : this.text(C, N) : D || "";
      }, h.prototype.end = E, h.prototype.text = v, h.prototype.fillLast = function(C) {
        if (this.lastNeed <= C.length)
          return C.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        C.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, C.length), this.lastNeed -= C.length;
      };
      function l(C) {
        return C <= 127 ? 0 : C >> 5 === 6 ? 2 : C >> 4 === 14 ? 3 : C >> 3 === 30 ? 4 : C >> 6 === 2 ? -1 : -2;
      }
      function f(C, D, N) {
        var A = D.length - 1;
        if (A < N)
          return 0;
        var I = l(D[A]);
        return I >= 0 ? (I > 0 && (C.lastNeed = I - 1), I) : --A < N || I === -2 ? 0 : (I = l(D[A]), I >= 0 ? (I > 0 && (C.lastNeed = I - 2), I) : --A < N || I === -2 ? 0 : (I = l(D[A]), I >= 0 ? (I > 0 && (I === 2 ? I = 0 : C.lastNeed = I - 3), I) : 0));
      }
      function d(C, D, N) {
        if ((D[0] & 192) !== 128)
          return C.lastNeed = 0, "�";
        if (C.lastNeed > 1 && D.length > 1) {
          if ((D[1] & 192) !== 128)
            return C.lastNeed = 1, "�";
          if (C.lastNeed > 2 && D.length > 2 && (D[2] & 192) !== 128)
            return C.lastNeed = 2, "�";
        }
      }
      function m(C) {
        var D = this.lastTotal - this.lastNeed, N = d(this, C);
        if (N !== void 0)
          return N;
        if (this.lastNeed <= C.length)
          return C.copy(this.lastChar, D, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        C.copy(this.lastChar, D, 0, C.length), this.lastNeed -= C.length;
      }
      function v(C, D) {
        var N = f(this, C, D);
        if (!this.lastNeed)
          return C.toString("utf8", D);
        this.lastTotal = N;
        var A = C.length - (N - this.lastNeed);
        return C.copy(this.lastChar, 0, A), C.toString("utf8", D, A);
      }
      function E(C) {
        var D = C && C.length ? this.write(C) : "";
        return this.lastNeed ? D + "�" : D;
      }
      function _(C, D) {
        if ((C.length - D) % 2 === 0) {
          var N = C.toString("utf16le", D);
          if (N) {
            var A = N.charCodeAt(N.length - 1);
            if (A >= 55296 && A <= 56319)
              return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = C[C.length - 2], this.lastChar[1] = C[C.length - 1], N.slice(0, -1);
          }
          return N;
        }
        return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = C[C.length - 1], C.toString("utf16le", D, C.length - 1);
      }
      function p(C) {
        var D = C && C.length ? this.write(C) : "";
        if (this.lastNeed) {
          var N = this.lastTotal - this.lastNeed;
          return D + this.lastChar.toString("utf16le", 0, N);
        }
        return D;
      }
      function R(C, D) {
        var N = (C.length - D) % 3;
        return N === 0 ? C.toString("base64", D) : (this.lastNeed = 3 - N, this.lastTotal = 3, N === 1 ? this.lastChar[0] = C[C.length - 1] : (this.lastChar[0] = C[C.length - 2], this.lastChar[1] = C[C.length - 1]), C.toString("base64", D, C.length - N));
      }
      function M(C) {
        var D = C && C.length ? this.write(C) : "";
        return this.lastNeed ? D + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : D;
      }
      function P(C) {
        return C.toString(this.encoding);
      }
      function W(C) {
        return C && C.length ? this.write(C) : "";
      }
    }, { "safe-buffer": 18 }], 20: [function(e, i, r) {
      i.exports = e("./lib/encoding.js");
    }, { "./lib/encoding.js": 21 }], 21: [function(e, i, r) {
      (function(s) {
        typeof i < "u" && i.exports && !s["encoding-indexes"] && e("./encoding-indexes.js");
        function a(g, S, O) {
          return S <= g && g <= O;
        }
        function o(g, S) {
          return g.indexOf(S) !== -1;
        }
        var c = Math.floor;
        function h(g) {
          if (g === void 0)
            return {};
          if (g === Object(g))
            return g;
          throw TypeError("Could not convert argument to dictionary");
        }
        function l(g) {
          for (var S = String(g), O = S.length, Z = 0, tt = []; Z < O; ) {
            var gt = S.charCodeAt(Z);
            if (gt < 55296 || gt > 57343)
              tt.push(gt);
            else if (56320 <= gt && gt <= 57343)
              tt.push(65533);
            else if (55296 <= gt && gt <= 56319)
              if (Z === O - 1)
                tt.push(65533);
              else {
                var st = S.charCodeAt(Z + 1);
                if (56320 <= st && st <= 57343) {
                  var Tt = gt & 1023, Ft = st & 1023;
                  tt.push(65536 + (Tt << 10) + Ft), Z += 1;
                } else
                  tt.push(65533);
              }
            Z += 1;
          }
          return tt;
        }
        function f(g) {
          for (var S = "", O = 0; O < g.length; ++O) {
            var Z = g[O];
            Z <= 65535 ? S += String.fromCharCode(Z) : (Z -= 65536, S += String.fromCharCode(
              (Z >> 10) + 55296,
              (Z & 1023) + 56320
            ));
          }
          return S;
        }
        function d(g) {
          return 0 <= g && g <= 127;
        }
        var m = d, v = -1;
        function E(g) {
          this.tokens = [].slice.call(g), this.tokens.reverse();
        }
        E.prototype = {
          /**
           * @return {boolean} True if end-of-stream has been hit.
           */
          endOfStream: function() {
            return !this.tokens.length;
          },
          /**
           * When a token is read from a stream, the first token in the
           * stream must be returned and subsequently removed, and
           * end-of-stream must be returned otherwise.
           *
           * @return {number} Get the next token from the stream, or
           * end_of_stream.
           */
          read: function() {
            return this.tokens.length ? this.tokens.pop() : v;
          },
          /**
           * When one or more tokens are prepended to a stream, those tokens
           * must be inserted, in given order, before the first token in the
           * stream.
           *
           * @param {(number|!Array.<number>)} token The token(s) to prepend to the
           * stream.
           */
          prepend: function(g) {
            if (Array.isArray(g))
              for (var S = (
                /**@type {!Array.<number>}*/
                g
              ); S.length; )
                this.tokens.push(S.pop());
            else
              this.tokens.push(g);
          },
          /**
           * When one or more tokens are pushed to a stream, those tokens
           * must be inserted, in given order, after the last token in the
           * stream.
           *
           * @param {(number|!Array.<number>)} token The tokens(s) to push to the
           * stream.
           */
          push: function(g) {
            if (Array.isArray(g))
              for (var S = (
                /**@type {!Array.<number>}*/
                g
              ); S.length; )
                this.tokens.unshift(S.shift());
            else
              this.tokens.unshift(g);
          }
        };
        var _ = -1;
        function p(g, S) {
          if (g)
            throw TypeError("Decoder error");
          return S || 65533;
        }
        function R(g) {
          throw TypeError("The code point " + g + " could not be encoded.");
        }
        function M(g) {
          return g = String(g).trim().toLowerCase(), Object.prototype.hasOwnProperty.call(W, g) ? W[g] : null;
        }
        var P = [
          {
            encodings: [
              {
                labels: [
                  "unicode-1-1-utf-8",
                  "utf-8",
                  "utf8"
                ],
                name: "UTF-8"
              }
            ],
            heading: "The Encoding"
          },
          {
            encodings: [
              {
                labels: [
                  "866",
                  "cp866",
                  "csibm866",
                  "ibm866"
                ],
                name: "IBM866"
              },
              {
                labels: [
                  "csisolatin2",
                  "iso-8859-2",
                  "iso-ir-101",
                  "iso8859-2",
                  "iso88592",
                  "iso_8859-2",
                  "iso_8859-2:1987",
                  "l2",
                  "latin2"
                ],
                name: "ISO-8859-2"
              },
              {
                labels: [
                  "csisolatin3",
                  "iso-8859-3",
                  "iso-ir-109",
                  "iso8859-3",
                  "iso88593",
                  "iso_8859-3",
                  "iso_8859-3:1988",
                  "l3",
                  "latin3"
                ],
                name: "ISO-8859-3"
              },
              {
                labels: [
                  "csisolatin4",
                  "iso-8859-4",
                  "iso-ir-110",
                  "iso8859-4",
                  "iso88594",
                  "iso_8859-4",
                  "iso_8859-4:1988",
                  "l4",
                  "latin4"
                ],
                name: "ISO-8859-4"
              },
              {
                labels: [
                  "csisolatincyrillic",
                  "cyrillic",
                  "iso-8859-5",
                  "iso-ir-144",
                  "iso8859-5",
                  "iso88595",
                  "iso_8859-5",
                  "iso_8859-5:1988"
                ],
                name: "ISO-8859-5"
              },
              {
                labels: [
                  "arabic",
                  "asmo-708",
                  "csiso88596e",
                  "csiso88596i",
                  "csisolatinarabic",
                  "ecma-114",
                  "iso-8859-6",
                  "iso-8859-6-e",
                  "iso-8859-6-i",
                  "iso-ir-127",
                  "iso8859-6",
                  "iso88596",
                  "iso_8859-6",
                  "iso_8859-6:1987"
                ],
                name: "ISO-8859-6"
              },
              {
                labels: [
                  "csisolatingreek",
                  "ecma-118",
                  "elot_928",
                  "greek",
                  "greek8",
                  "iso-8859-7",
                  "iso-ir-126",
                  "iso8859-7",
                  "iso88597",
                  "iso_8859-7",
                  "iso_8859-7:1987",
                  "sun_eu_greek"
                ],
                name: "ISO-8859-7"
              },
              {
                labels: [
                  "csiso88598e",
                  "csisolatinhebrew",
                  "hebrew",
                  "iso-8859-8",
                  "iso-8859-8-e",
                  "iso-ir-138",
                  "iso8859-8",
                  "iso88598",
                  "iso_8859-8",
                  "iso_8859-8:1988",
                  "visual"
                ],
                name: "ISO-8859-8"
              },
              {
                labels: [
                  "csiso88598i",
                  "iso-8859-8-i",
                  "logical"
                ],
                name: "ISO-8859-8-I"
              },
              {
                labels: [
                  "csisolatin6",
                  "iso-8859-10",
                  "iso-ir-157",
                  "iso8859-10",
                  "iso885910",
                  "l6",
                  "latin6"
                ],
                name: "ISO-8859-10"
              },
              {
                labels: [
                  "iso-8859-13",
                  "iso8859-13",
                  "iso885913"
                ],
                name: "ISO-8859-13"
              },
              {
                labels: [
                  "iso-8859-14",
                  "iso8859-14",
                  "iso885914"
                ],
                name: "ISO-8859-14"
              },
              {
                labels: [
                  "csisolatin9",
                  "iso-8859-15",
                  "iso8859-15",
                  "iso885915",
                  "iso_8859-15",
                  "l9"
                ],
                name: "ISO-8859-15"
              },
              {
                labels: [
                  "iso-8859-16"
                ],
                name: "ISO-8859-16"
              },
              {
                labels: [
                  "cskoi8r",
                  "koi",
                  "koi8",
                  "koi8-r",
                  "koi8_r"
                ],
                name: "KOI8-R"
              },
              {
                labels: [
                  "koi8-ru",
                  "koi8-u"
                ],
                name: "KOI8-U"
              },
              {
                labels: [
                  "csmacintosh",
                  "mac",
                  "macintosh",
                  "x-mac-roman"
                ],
                name: "macintosh"
              },
              {
                labels: [
                  "dos-874",
                  "iso-8859-11",
                  "iso8859-11",
                  "iso885911",
                  "tis-620",
                  "windows-874"
                ],
                name: "windows-874"
              },
              {
                labels: [
                  "cp1250",
                  "windows-1250",
                  "x-cp1250"
                ],
                name: "windows-1250"
              },
              {
                labels: [
                  "cp1251",
                  "windows-1251",
                  "x-cp1251"
                ],
                name: "windows-1251"
              },
              {
                labels: [
                  "ansi_x3.4-1968",
                  "ascii",
                  "cp1252",
                  "cp819",
                  "csisolatin1",
                  "ibm819",
                  "iso-8859-1",
                  "iso-ir-100",
                  "iso8859-1",
                  "iso88591",
                  "iso_8859-1",
                  "iso_8859-1:1987",
                  "l1",
                  "latin1",
                  "us-ascii",
                  "windows-1252",
                  "x-cp1252"
                ],
                name: "windows-1252"
              },
              {
                labels: [
                  "cp1253",
                  "windows-1253",
                  "x-cp1253"
                ],
                name: "windows-1253"
              },
              {
                labels: [
                  "cp1254",
                  "csisolatin5",
                  "iso-8859-9",
                  "iso-ir-148",
                  "iso8859-9",
                  "iso88599",
                  "iso_8859-9",
                  "iso_8859-9:1989",
                  "l5",
                  "latin5",
                  "windows-1254",
                  "x-cp1254"
                ],
                name: "windows-1254"
              },
              {
                labels: [
                  "cp1255",
                  "windows-1255",
                  "x-cp1255"
                ],
                name: "windows-1255"
              },
              {
                labels: [
                  "cp1256",
                  "windows-1256",
                  "x-cp1256"
                ],
                name: "windows-1256"
              },
              {
                labels: [
                  "cp1257",
                  "windows-1257",
                  "x-cp1257"
                ],
                name: "windows-1257"
              },
              {
                labels: [
                  "cp1258",
                  "windows-1258",
                  "x-cp1258"
                ],
                name: "windows-1258"
              },
              {
                labels: [
                  "x-mac-cyrillic",
                  "x-mac-ukrainian"
                ],
                name: "x-mac-cyrillic"
              }
            ],
            heading: "Legacy single-byte encodings"
          },
          {
            encodings: [
              {
                labels: [
                  "chinese",
                  "csgb2312",
                  "csiso58gb231280",
                  "gb2312",
                  "gb_2312",
                  "gb_2312-80",
                  "gbk",
                  "iso-ir-58",
                  "x-gbk"
                ],
                name: "GBK"
              },
              {
                labels: [
                  "gb18030"
                ],
                name: "gb18030"
              }
            ],
            heading: "Legacy multi-byte Chinese (simplified) encodings"
          },
          {
            encodings: [
              {
                labels: [
                  "big5",
                  "big5-hkscs",
                  "cn-big5",
                  "csbig5",
                  "x-x-big5"
                ],
                name: "Big5"
              }
            ],
            heading: "Legacy multi-byte Chinese (traditional) encodings"
          },
          {
            encodings: [
              {
                labels: [
                  "cseucpkdfmtjapanese",
                  "euc-jp",
                  "x-euc-jp"
                ],
                name: "EUC-JP"
              },
              {
                labels: [
                  "csiso2022jp",
                  "iso-2022-jp"
                ],
                name: "ISO-2022-JP"
              },
              {
                labels: [
                  "csshiftjis",
                  "ms932",
                  "ms_kanji",
                  "shift-jis",
                  "shift_jis",
                  "sjis",
                  "windows-31j",
                  "x-sjis"
                ],
                name: "Shift_JIS"
              }
            ],
            heading: "Legacy multi-byte Japanese encodings"
          },
          {
            encodings: [
              {
                labels: [
                  "cseuckr",
                  "csksc56011987",
                  "euc-kr",
                  "iso-ir-149",
                  "korean",
                  "ks_c_5601-1987",
                  "ks_c_5601-1989",
                  "ksc5601",
                  "ksc_5601",
                  "windows-949"
                ],
                name: "EUC-KR"
              }
            ],
            heading: "Legacy multi-byte Korean encodings"
          },
          {
            encodings: [
              {
                labels: [
                  "csiso2022kr",
                  "hz-gb-2312",
                  "iso-2022-cn",
                  "iso-2022-cn-ext",
                  "iso-2022-kr"
                ],
                name: "replacement"
              },
              {
                labels: [
                  "utf-16be"
                ],
                name: "UTF-16BE"
              },
              {
                labels: [
                  "utf-16",
                  "utf-16le"
                ],
                name: "UTF-16LE"
              },
              {
                labels: [
                  "x-user-defined"
                ],
                name: "x-user-defined"
              }
            ],
            heading: "Legacy miscellaneous encodings"
          }
        ], W = {};
        P.forEach(function(g) {
          g.encodings.forEach(function(S) {
            S.labels.forEach(function(O) {
              W[O] = S;
            });
          });
        });
        var C = {}, D = {};
        function N(g, S) {
          return S && S[g] || null;
        }
        function A(g, S) {
          var O = S.indexOf(g);
          return O === -1 ? null : O;
        }
        function I(g) {
          if (!("encoding-indexes" in s))
            throw Error("Indexes missing. Did you forget to include encoding-indexes.js first?");
          return s["encoding-indexes"][g];
        }
        function it(g) {
          if (g > 39419 && g < 189e3 || g > 1237575)
            return null;
          if (g === 7457)
            return 59335;
          var S = 0, O = 0, Z = I("gb18030-ranges"), tt;
          for (tt = 0; tt < Z.length; ++tt) {
            var gt = Z[tt];
            if (gt[0] <= g)
              S = gt[0], O = gt[1];
            else
              break;
          }
          return O + g - S;
        }
        function V(g) {
          if (g === 59335)
            return 7457;
          var S = 0, O = 0, Z = I("gb18030-ranges"), tt;
          for (tt = 0; tt < Z.length; ++tt) {
            var gt = Z[tt];
            if (gt[1] <= g)
              S = gt[1], O = gt[0];
            else
              break;
          }
          return O + g - S;
        }
        function mt(g) {
          k = k || I("jis0208").map(function(O, Z) {
            return a(Z, 8272, 8835) ? null : O;
          });
          var S = k;
          return S.indexOf(g);
        }
        var k;
        function B(g) {
          G = G || I("big5").map(function(O, Z) {
            return Z < 32 * 157 ? null : O;
          });
          var S = G;
          return g === 9552 || g === 9566 || g === 9569 || g === 9578 || g === 21313 || g === 21317 ? S.lastIndexOf(g) : A(g, S);
        }
        var G, H = "utf-8";
        function w(g, S) {
          if (!(this instanceof w))
            throw TypeError("Called as a function. Did you forget 'new'?");
          g = g !== void 0 ? String(g) : H, S = h(S), this._encoding = null, this._decoder = null, this._ignoreBOM = !1, this._BOMseen = !1, this._error_mode = "replacement", this._do_not_flush = !1;
          var O = M(g);
          if (O === null || O.name === "replacement")
            throw RangeError("Unknown encoding: " + g);
          if (!D[O.name])
            throw Error("Decoder not present. Did you forget to include encoding-indexes.js first?");
          var Z = this;
          return Z._encoding = O, S.fatal && (Z._error_mode = "fatal"), S.ignoreBOM && (Z._ignoreBOM = !0), Object.defineProperty || (this.encoding = Z._encoding.name.toLowerCase(), this.fatal = Z._error_mode === "fatal", this.ignoreBOM = Z._ignoreBOM), Z;
        }
        Object.defineProperty && (Object.defineProperty(w.prototype, "encoding", {
          /** @this {TextDecoder} */
          get: function() {
            return this._encoding.name.toLowerCase();
          }
        }), Object.defineProperty(w.prototype, "fatal", {
          /** @this {TextDecoder} */
          get: function() {
            return this._error_mode === "fatal";
          }
        }), Object.defineProperty(w.prototype, "ignoreBOM", {
          /** @this {TextDecoder} */
          get: function() {
            return this._ignoreBOM;
          }
        })), w.prototype.decode = function(S, O) {
          var Z;
          typeof S == "object" && S instanceof ArrayBuffer ? Z = new Uint8Array(S) : typeof S == "object" && "buffer" in S && S.buffer instanceof ArrayBuffer ? Z = new Uint8Array(
            S.buffer,
            S.byteOffset,
            S.byteLength
          ) : Z = new Uint8Array(0), O = h(O), this._do_not_flush || (this._decoder = D[this._encoding.name]({
            fatal: this._error_mode === "fatal"
          }), this._BOMseen = !1), this._do_not_flush = !!O.stream;
          for (var tt = new E(Z), gt = [], st; ; ) {
            var Tt = tt.read();
            if (Tt === v || (st = this._decoder.handler(tt, Tt), st === _))
              break;
            st !== null && (Array.isArray(st) ? gt.push.apply(
              gt,
              /**@type {!Array.<number>}*/
              st
            ) : gt.push(st));
          }
          if (!this._do_not_flush) {
            do {
              if (st = this._decoder.handler(tt, tt.read()), st === _)
                break;
              st !== null && (Array.isArray(st) ? gt.push.apply(
                gt,
                /**@type {!Array.<number>}*/
                st
              ) : gt.push(st));
            } while (!tt.endOfStream());
            this._decoder = null;
          }
          function Ft(ht) {
            return o(["UTF-8", "UTF-16LE", "UTF-16BE"], this._encoding.name) && !this._ignoreBOM && !this._BOMseen && (ht.length > 0 && ht[0] === 65279 ? (this._BOMseen = !0, ht.shift()) : ht.length > 0 && (this._BOMseen = !0)), f(ht);
          }
          return Ft.call(this, gt);
        };
        function ut(g, S) {
          if (!(this instanceof ut))
            throw TypeError("Called as a function. Did you forget 'new'?");
          S = h(S), this._encoding = null, this._encoder = null, this._do_not_flush = !1, this._fatal = S.fatal ? "fatal" : "replacement";
          var O = this;
          if (S.NONSTANDARD_allowLegacyEncoding) {
            g = g !== void 0 ? String(g) : H;
            var Z = M(g);
            if (Z === null || Z.name === "replacement")
              throw RangeError("Unknown encoding: " + g);
            if (!C[Z.name])
              throw Error("Encoder not present. Did you forget to include encoding-indexes.js first?");
            O._encoding = Z;
          } else
            O._encoding = M("utf-8"), g !== void 0 && "console" in s && console.warn("TextEncoder constructor called with encoding label, which is ignored.");
          return Object.defineProperty || (this.encoding = O._encoding.name.toLowerCase()), O;
        }
        Object.defineProperty && Object.defineProperty(ut.prototype, "encoding", {
          /** @this {TextEncoder} */
          get: function() {
            return this._encoding.name.toLowerCase();
          }
        }), ut.prototype.encode = function(S, O) {
          S = S === void 0 ? "" : String(S), O = h(O), this._do_not_flush || (this._encoder = C[this._encoding.name]({
            fatal: this._fatal === "fatal"
          })), this._do_not_flush = !!O.stream;
          for (var Z = new E(l(S)), tt = [], gt; ; ) {
            var st = Z.read();
            if (st === v || (gt = this._encoder.handler(Z, st), gt === _))
              break;
            Array.isArray(gt) ? tt.push.apply(
              tt,
              /**@type {!Array.<number>}*/
              gt
            ) : tt.push(gt);
          }
          if (!this._do_not_flush) {
            for (; gt = this._encoder.handler(Z, Z.read()), gt !== _; )
              Array.isArray(gt) ? tt.push.apply(
                tt,
                /**@type {!Array.<number>}*/
                gt
              ) : tt.push(gt);
            this._encoder = null;
          }
          return new Uint8Array(tt);
        };
        function pt(g) {
          var S = g.fatal, O = 0, Z = 0, tt = 0, gt = 128, st = 191;
          this.handler = function(Tt, Ft) {
            if (Ft === v && tt !== 0)
              return tt = 0, p(S);
            if (Ft === v)
              return _;
            if (tt === 0) {
              if (a(Ft, 0, 127))
                return Ft;
              if (a(Ft, 194, 223))
                tt = 1, O = Ft & 31;
              else if (a(Ft, 224, 239))
                Ft === 224 && (gt = 160), Ft === 237 && (st = 159), tt = 2, O = Ft & 15;
              else if (a(Ft, 240, 244))
                Ft === 240 && (gt = 144), Ft === 244 && (st = 143), tt = 3, O = Ft & 7;
              else
                return p(S);
              return null;
            }
            if (!a(Ft, gt, st))
              return O = tt = Z = 0, gt = 128, st = 191, Tt.prepend(Ft), p(S);
            if (gt = 128, st = 191, O = O << 6 | Ft & 63, Z += 1, Z !== tt)
              return null;
            var ht = O;
            return O = tt = Z = 0, ht;
          };
        }
        function _t(g) {
          g.fatal, this.handler = function(S, O) {
            if (O === v)
              return _;
            if (m(O))
              return O;
            var Z, tt;
            a(O, 128, 2047) ? (Z = 1, tt = 192) : a(O, 2048, 65535) ? (Z = 2, tt = 224) : a(O, 65536, 1114111) && (Z = 3, tt = 240);
            for (var gt = [(O >> 6 * Z) + tt]; Z > 0; ) {
              var st = O >> 6 * (Z - 1);
              gt.push(128 | st & 63), Z -= 1;
            }
            return gt;
          };
        }
        C["UTF-8"] = function(g) {
          return new _t(g);
        }, D["UTF-8"] = function(g) {
          return new pt(g);
        };
        function vt(g, S) {
          var O = S.fatal;
          this.handler = function(Z, tt) {
            if (tt === v)
              return _;
            if (d(tt))
              return tt;
            var gt = g[tt - 128];
            return gt === null ? p(O) : gt;
          };
        }
        function F(g, S) {
          S.fatal, this.handler = function(O, Z) {
            if (Z === v)
              return _;
            if (m(Z))
              return Z;
            var tt = A(Z, g);
            return tt === null && R(Z), tt + 128;
          };
        }
        (function() {
          "encoding-indexes" in s && P.forEach(function(g) {
            g.heading === "Legacy single-byte encodings" && g.encodings.forEach(function(S) {
              var O = S.name, Z = I(O.toLowerCase());
              D[O] = function(tt) {
                return new vt(Z, tt);
              }, C[O] = function(tt) {
                return new F(Z, tt);
              };
            });
          });
        })(), D.GBK = function(g) {
          return new rt(g);
        }, C.GBK = function(g) {
          return new b(g, !0);
        };
        function rt(g) {
          var S = g.fatal, O = 0, Z = 0, tt = 0;
          this.handler = function(gt, st) {
            if (st === v && O === 0 && Z === 0 && tt === 0)
              return _;
            st === v && (O !== 0 || Z !== 0 || tt !== 0) && (O = 0, Z = 0, tt = 0, p(S));
            var Tt;
            if (tt !== 0) {
              Tt = null, a(st, 48, 57) && (Tt = it(
                (((O - 129) * 10 + Z - 48) * 126 + tt - 129) * 10 + st - 48
              ));
              var Ft = [Z, tt, st];
              return O = 0, Z = 0, tt = 0, Tt === null ? (gt.prepend(Ft), p(S)) : Tt;
            }
            if (Z !== 0)
              return a(st, 129, 254) ? (tt = st, null) : (gt.prepend([Z, st]), O = 0, Z = 0, p(S));
            if (O !== 0) {
              if (a(st, 48, 57))
                return Z = st, null;
              var ht = O, It = null;
              O = 0;
              var z = st < 127 ? 64 : 65;
              return (a(st, 64, 126) || a(st, 128, 254)) && (It = (ht - 129) * 190 + (st - z)), Tt = It === null ? null : N(It, I("gb18030")), Tt === null && d(st) && gt.prepend(st), Tt === null ? p(S) : Tt;
            }
            return d(st) ? st : st === 128 ? 8364 : a(st, 129, 254) ? (O = st, null) : p(S);
          };
        }
        function b(g, S) {
          g.fatal, this.handler = function(O, Z) {
            if (Z === v)
              return _;
            if (m(Z))
              return Z;
            if (Z === 58853)
              return R(Z);
            if (S && Z === 8364)
              return 128;
            var tt = A(Z, I("gb18030"));
            if (tt !== null) {
              var gt = c(tt / 190) + 129, st = tt % 190, Tt = st < 63 ? 64 : 65;
              return [gt, st + Tt];
            }
            if (S)
              return R(Z);
            tt = V(Z);
            var Ft = c(tt / 10 / 126 / 10);
            tt = tt - Ft * 10 * 126 * 10;
            var ht = c(tt / 10 / 126);
            tt = tt - ht * 10 * 126;
            var It = c(tt / 10), z = tt - It * 10;
            return [
              Ft + 129,
              ht + 48,
              It + 129,
              z + 48
            ];
          };
        }
        C.gb18030 = function(g) {
          return new b(g);
        }, D.gb18030 = function(g) {
          return new rt(g);
        };
        function lt(g) {
          var S = g.fatal, O = 0;
          this.handler = function(Z, tt) {
            if (tt === v && O !== 0)
              return O = 0, p(S);
            if (tt === v && O === 0)
              return _;
            if (O !== 0) {
              var gt = O, st = null;
              O = 0;
              var Tt = tt < 127 ? 64 : 98;
              switch ((a(tt, 64, 126) || a(tt, 161, 254)) && (st = (gt - 129) * 157 + (tt - Tt)), st) {
                case 1133:
                  return [202, 772];
                case 1135:
                  return [202, 780];
                case 1164:
                  return [234, 772];
                case 1166:
                  return [234, 780];
              }
              var Ft = st === null ? null : N(st, I("big5"));
              return Ft === null && d(tt) && Z.prepend(tt), Ft === null ? p(S) : Ft;
            }
            return d(tt) ? tt : a(tt, 129, 254) ? (O = tt, null) : p(S);
          };
        }
        function q(g) {
          g.fatal, this.handler = function(S, O) {
            if (O === v)
              return _;
            if (m(O))
              return O;
            var Z = B(O);
            if (Z === null)
              return R(O);
            var tt = c(Z / 157) + 129;
            if (tt < 161)
              return R(O);
            var gt = Z % 157, st = gt < 63 ? 64 : 98;
            return [tt, gt + st];
          };
        }
        C.Big5 = function(g) {
          return new q(g);
        }, D.Big5 = function(g) {
          return new lt(g);
        };
        function U(g) {
          var S = g.fatal, O = !1, Z = 0;
          this.handler = function(tt, gt) {
            if (gt === v && Z !== 0)
              return Z = 0, p(S);
            if (gt === v && Z === 0)
              return _;
            if (Z === 142 && a(gt, 161, 223))
              return Z = 0, 65216 + gt;
            if (Z === 143 && a(gt, 161, 254))
              return O = !0, Z = gt, null;
            if (Z !== 0) {
              var st = Z;
              Z = 0;
              var Tt = null;
              return a(st, 161, 254) && a(gt, 161, 254) && (Tt = N(
                (st - 161) * 94 + (gt - 161),
                I(O ? "jis0212" : "jis0208")
              )), O = !1, a(gt, 161, 254) || tt.prepend(gt), Tt === null ? p(S) : Tt;
            }
            return d(gt) ? gt : gt === 142 || gt === 143 || a(gt, 161, 254) ? (Z = gt, null) : p(S);
          };
        }
        function L(g) {
          g.fatal, this.handler = function(S, O) {
            if (O === v)
              return _;
            if (m(O))
              return O;
            if (O === 165)
              return 92;
            if (O === 8254)
              return 126;
            if (a(O, 65377, 65439))
              return [142, O - 65377 + 161];
            O === 8722 && (O = 65293);
            var Z = A(O, I("jis0208"));
            if (Z === null)
              return R(O);
            var tt = c(Z / 94) + 161, gt = Z % 94 + 161;
            return [tt, gt];
          };
        }
        C["EUC-JP"] = function(g) {
          return new L(g);
        }, D["EUC-JP"] = function(g) {
          return new U(g);
        };
        function j(g) {
          var S = g.fatal, O = {
            ASCII: 0,
            Roman: 1,
            Katakana: 2,
            LeadByte: 3,
            TrailByte: 4,
            EscapeStart: 5,
            Escape: 6
          }, Z = O.ASCII, tt = O.ASCII, gt = 0, st = !1;
          this.handler = function(Tt, Ft) {
            switch (Z) {
              default:
              case O.ASCII:
                return Ft === 27 ? (Z = O.EscapeStart, null) : a(Ft, 0, 127) && Ft !== 14 && Ft !== 15 && Ft !== 27 ? (st = !1, Ft) : Ft === v ? _ : (st = !1, p(S));
              case O.Roman:
                return Ft === 27 ? (Z = O.EscapeStart, null) : Ft === 92 ? (st = !1, 165) : Ft === 126 ? (st = !1, 8254) : a(Ft, 0, 127) && Ft !== 14 && Ft !== 15 && Ft !== 27 && Ft !== 92 && Ft !== 126 ? (st = !1, Ft) : Ft === v ? _ : (st = !1, p(S));
              case O.Katakana:
                return Ft === 27 ? (Z = O.EscapeStart, null) : a(Ft, 33, 95) ? (st = !1, 65344 + Ft) : Ft === v ? _ : (st = !1, p(S));
              case O.LeadByte:
                return Ft === 27 ? (Z = O.EscapeStart, null) : a(Ft, 33, 126) ? (st = !1, gt = Ft, Z = O.TrailByte, null) : Ft === v ? _ : (st = !1, p(S));
              case O.TrailByte:
                if (Ft === 27)
                  return Z = O.EscapeStart, p(S);
                if (a(Ft, 33, 126)) {
                  Z = O.LeadByte;
                  var ht = (gt - 33) * 94 + Ft - 33, It = N(ht, I("jis0208"));
                  return It === null ? p(S) : It;
                }
                return Ft === v ? (Z = O.LeadByte, Tt.prepend(Ft), p(S)) : (Z = O.LeadByte, p(S));
              case O.EscapeStart:
                return Ft === 36 || Ft === 40 ? (gt = Ft, Z = O.Escape, null) : (Tt.prepend(Ft), st = !1, Z = tt, p(S));
              case O.Escape:
                var z = gt;
                gt = 0;
                var ft = null;
                if (z === 40 && Ft === 66 && (ft = O.ASCII), z === 40 && Ft === 74 && (ft = O.Roman), z === 40 && Ft === 73 && (ft = O.Katakana), z === 36 && (Ft === 64 || Ft === 66) && (ft = O.LeadByte), ft !== null) {
                  Z = Z = ft;
                  var nt = st;
                  return st = !0, nt ? p(S) : null;
                }
                return Tt.prepend([z, Ft]), st = !1, Z = tt, p(S);
            }
          };
        }
        function Y(g) {
          g.fatal;
          var S = {
            ASCII: 0,
            Roman: 1,
            jis0208: 2
          }, O = S.ASCII;
          this.handler = function(Z, tt) {
            if (tt === v && O !== S.ASCII)
              return Z.prepend(tt), O = S.ASCII, [27, 40, 66];
            if (tt === v && O === S.ASCII)
              return _;
            if ((O === S.ASCII || O === S.Roman) && (tt === 14 || tt === 15 || tt === 27))
              return R(65533);
            if (O === S.ASCII && m(tt))
              return tt;
            if (O === S.Roman && (m(tt) && tt !== 92 && tt !== 126 || tt == 165 || tt == 8254)) {
              if (m(tt))
                return tt;
              if (tt === 165)
                return 92;
              if (tt === 8254)
                return 126;
            }
            if (m(tt) && O !== S.ASCII)
              return Z.prepend(tt), O = S.ASCII, [27, 40, 66];
            if ((tt === 165 || tt === 8254) && O !== S.Roman)
              return Z.prepend(tt), O = S.Roman, [27, 40, 74];
            tt === 8722 && (tt = 65293);
            var gt = A(tt, I("jis0208"));
            if (gt === null)
              return R(tt);
            if (O !== S.jis0208)
              return Z.prepend(tt), O = S.jis0208, [27, 36, 66];
            var st = c(gt / 94) + 33, Tt = gt % 94 + 33;
            return [st, Tt];
          };
        }
        C["ISO-2022-JP"] = function(g) {
          return new Y(g);
        }, D["ISO-2022-JP"] = function(g) {
          return new j(g);
        };
        function K(g) {
          var S = g.fatal, O = 0;
          this.handler = function(Z, tt) {
            if (tt === v && O !== 0)
              return O = 0, p(S);
            if (tt === v && O === 0)
              return _;
            if (O !== 0) {
              var gt = O, st = null;
              O = 0;
              var Tt = tt < 127 ? 64 : 65, Ft = gt < 160 ? 129 : 193;
              if ((a(tt, 64, 126) || a(tt, 128, 252)) && (st = (gt - Ft) * 188 + tt - Tt), a(st, 8836, 10715))
                return 48508 + st;
              var ht = st === null ? null : N(st, I("jis0208"));
              return ht === null && d(tt) && Z.prepend(tt), ht === null ? p(S) : ht;
            }
            return d(tt) || tt === 128 ? tt : a(tt, 161, 223) ? 65216 + tt : a(tt, 129, 159) || a(tt, 224, 252) ? (O = tt, null) : p(S);
          };
        }
        function yt(g) {
          g.fatal, this.handler = function(S, O) {
            if (O === v)
              return _;
            if (m(O) || O === 128)
              return O;
            if (O === 165)
              return 92;
            if (O === 8254)
              return 126;
            if (a(O, 65377, 65439))
              return O - 65377 + 161;
            O === 8722 && (O = 65293);
            var Z = mt(O);
            if (Z === null)
              return R(O);
            var tt = c(Z / 188), gt = tt < 31 ? 129 : 193, st = Z % 188, Tt = st < 63 ? 64 : 65;
            return [tt + gt, st + Tt];
          };
        }
        C.Shift_JIS = function(g) {
          return new yt(g);
        }, D.Shift_JIS = function(g) {
          return new K(g);
        };
        function Et(g) {
          var S = g.fatal, O = 0;
          this.handler = function(Z, tt) {
            if (tt === v && O !== 0)
              return O = 0, p(S);
            if (tt === v && O === 0)
              return _;
            if (O !== 0) {
              var gt = O, st = null;
              O = 0, a(tt, 65, 254) && (st = (gt - 129) * 190 + (tt - 65));
              var Tt = st === null ? null : N(st, I("euc-kr"));
              return st === null && d(tt) && Z.prepend(tt), Tt === null ? p(S) : Tt;
            }
            return d(tt) ? tt : a(tt, 129, 254) ? (O = tt, null) : p(S);
          };
        }
        function Ct(g) {
          g.fatal, this.handler = function(S, O) {
            if (O === v)
              return _;
            if (m(O))
              return O;
            var Z = A(O, I("euc-kr"));
            if (Z === null)
              return R(O);
            var tt = c(Z / 190) + 129, gt = Z % 190 + 65;
            return [tt, gt];
          };
        }
        C["EUC-KR"] = function(g) {
          return new Ct(g);
        }, D["EUC-KR"] = function(g) {
          return new Et(g);
        };
        function Lt(g, S) {
          var O = g >> 8, Z = g & 255;
          return S ? [O, Z] : [Z, O];
        }
        function Wt(g, S) {
          var O = S.fatal, Z = null, tt = null;
          this.handler = function(gt, st) {
            if (st === v && (Z !== null || tt !== null))
              return p(O);
            if (st === v && Z === null && tt === null)
              return _;
            if (Z === null)
              return Z = st, null;
            var Tt;
            if (g ? Tt = (Z << 8) + st : Tt = (st << 8) + Z, Z = null, tt !== null) {
              var Ft = tt;
              return tt = null, a(Tt, 56320, 57343) ? 65536 + (Ft - 55296) * 1024 + (Tt - 56320) : (gt.prepend(Lt(Tt, g)), p(O));
            }
            return a(Tt, 55296, 56319) ? (tt = Tt, null) : a(Tt, 56320, 57343) ? p(O) : Tt;
          };
        }
        function wt(g, S) {
          S.fatal, this.handler = function(O, Z) {
            if (Z === v)
              return _;
            if (a(Z, 0, 65535))
              return Lt(Z, g);
            var tt = Lt(
              (Z - 65536 >> 10) + 55296,
              g
            ), gt = Lt(
              (Z - 65536 & 1023) + 56320,
              g
            );
            return tt.concat(gt);
          };
        }
        C["UTF-16BE"] = function(g) {
          return new wt(!0, g);
        }, D["UTF-16BE"] = function(g) {
          return new Wt(!0, g);
        }, C["UTF-16LE"] = function(g) {
          return new wt(!1, g);
        }, D["UTF-16LE"] = function(g) {
          return new Wt(!1, g);
        };
        function Q(g) {
          g.fatal, this.handler = function(S, O) {
            return O === v ? _ : d(O) ? O : 63360 + O - 128;
          };
        }
        function y(g) {
          g.fatal, this.handler = function(S, O) {
            return O === v ? _ : m(O) ? O : a(O, 63360, 63487) ? O - 63360 + 128 : R(O);
          };
        }
        C["x-user-defined"] = function(g) {
          return new y(g);
        }, D["x-user-defined"] = function(g) {
          return new Q(g);
        }, s.TextEncoder || (s.TextEncoder = ut), s.TextDecoder || (s.TextDecoder = w), typeof i < "u" && i.exports && (i.exports = {
          TextEncoder: s.TextEncoder,
          TextDecoder: s.TextDecoder,
          EncodingIndexes: s["encoding-indexes"]
        });
      })(this || {});
    }, { "./encoding-indexes.js": 7 }], 22: [function(e, i, r) {
      (function(s, a) {
        (function() {
          var o = e("process/browser.js").nextTick, c = Function.prototype.apply, h = Array.prototype.slice, l = {}, f = 0;
          r.setTimeout = function() {
            return new d(c.call(setTimeout, window, arguments), clearTimeout);
          }, r.setInterval = function() {
            return new d(c.call(setInterval, window, arguments), clearInterval);
          }, r.clearTimeout = r.clearInterval = function(m) {
            m.close();
          };
          function d(m, v) {
            this._id = m, this._clearFn = v;
          }
          d.prototype.unref = d.prototype.ref = function() {
          }, d.prototype.close = function() {
            this._clearFn.call(window, this._id);
          }, r.enroll = function(m, v) {
            clearTimeout(m._idleTimeoutId), m._idleTimeout = v;
          }, r.unenroll = function(m) {
            clearTimeout(m._idleTimeoutId), m._idleTimeout = -1;
          }, r._unrefActive = r.active = function(m) {
            clearTimeout(m._idleTimeoutId);
            var v = m._idleTimeout;
            v >= 0 && (m._idleTimeoutId = setTimeout(function() {
              m._onTimeout && m._onTimeout();
            }, v));
          }, r.setImmediate = typeof s == "function" ? s : function(m) {
            var v = f++, E = arguments.length < 2 ? !1 : h.call(arguments, 1);
            return l[v] = !0, o(function() {
              l[v] && (E ? m.apply(null, E) : m.call(null), r.clearImmediate(v));
            }), v;
          }, r.clearImmediate = typeof a == "function" ? a : function(m) {
            delete l[m];
          };
        }).call(this);
      }).call(this, e("timers").setImmediate, e("timers").clearImmediate);
    }, { "process/browser.js": 16, timers: 22 }], 23: [function(e, i, r) {
      (function(s) {
        (function() {
          let a = e("proj4");
          a.default && (a = a.default);
          const o = e("./unzip"), c = e("./binaryajax"), h = e("./parseShp"), l = e("parsedbf"), f = e("lie"), d = e("lru-cache"), m = e("buffer").Buffer, v = s.URL, E = new d({
            max: 20
          });
          function _(D) {
            if (!D)
              throw new Error("forgot to pass buffer");
            if (m.isBuffer(D))
              return D;
            if (p(D))
              return m.from(D);
            if (p(D.buffer))
              return D.BYTES_PER_ELEMENT === 1 ? m.from(D) : m.from(D.buffer);
          }
          function p(D) {
            return D instanceof s.ArrayBuffer || Object.prototype.toString.call(D) === "[object ArrayBuffer]";
          }
          function R(D, N) {
            return typeof D == "string" && E.has(D) ? f.resolve(E.get(D)) : R.getShapefile(D, N).then(function(A) {
              return typeof D == "string" && E.set(D, A), A;
            });
          }
          R.combine = function([D, N]) {
            const A = {};
            A.type = "FeatureCollection", A.features = [];
            let I = 0;
            const it = D.length;
            for (N || (N = []); I < it; )
              A.features.push({
                type: "Feature",
                geometry: D[I],
                properties: N[I] || {}
              }), I++;
            return A;
          }, R.parseZip = async function(D, N) {
            let A;
            D = _(D);
            const I = await o(D), it = [];
            N = N || [];
            for (A in I)
              A.indexOf("__MACOSX") === -1 && (A.slice(-3).toLowerCase() === "shp" ? (it.push(A.slice(0, -4)), I[A.slice(0, -3) + A.slice(-3).toLowerCase()] = I[A]) : A.slice(-3).toLowerCase() === "prj" ? I[A.slice(0, -3) + A.slice(-3).toLowerCase()] = a(I[A]) : A.slice(-4).toLowerCase() === "json" || N.indexOf(A.split(".").pop()) > -1 ? it.push(A.slice(0, -3) + A.slice(-3).toLowerCase()) : (A.slice(-3).toLowerCase() === "dbf" || A.slice(-3).toLowerCase() === "cpg") && (I[A.slice(0, -3) + A.slice(-3).toLowerCase()] = I[A]));
            if (!it.length)
              throw new Error("no layers founds");
            const V = it.map(function(mt) {
              let k, B;
              const G = mt.lastIndexOf(".");
              return G > -1 && mt.slice(G).indexOf("json") > -1 ? (k = JSON.parse(I[mt]), k.fileName = mt.slice(0, G)) : N.indexOf(mt.slice(G + 1)) > -1 ? (k = I[mt], k.fileName = mt) : (I[mt + ".dbf"] && (B = l(I[mt + ".dbf"], I[mt + ".cpg"])), k = R.combine([h(I[mt + ".shp"], I[mt + ".prj"]), B]), k.fileName = mt), k;
            });
            return V.length === 1 ? V[0] : V;
          };
          async function M(D, N) {
            const A = await c(D);
            return R.parseZip(A, N);
          }
          const P = async (D) => {
            const N = await f.all([
              c(D, "shp"),
              c(D, "prj")
            ]);
            let A = !1;
            try {
              N[1] && (A = a(N[1]));
            } catch {
              A = !1;
            }
            return h(N[0], A);
          }, W = async (D) => {
            const [N, A] = await f.all([
              c(D, "dbf"),
              c(D, "cpg")
            ]);
            if (N)
              return l(N, A);
          }, C = (D, N) => new v(D).pathname.slice(-4).toLowerCase() === N;
          R.getShapefile = async function(D, N) {
            if (typeof D != "string")
              return R.parseZip(D);
            if (C(D, ".zip"))
              return M(D, N);
            const A = await f.all([
              P(D),
              W(D)
            ]);
            return R.combine(A);
          }, R.parseShp = function(D, N) {
            if (D = _(D), m.isBuffer(N) && (N = N.toString()), typeof N == "string")
              try {
                N = a(N);
              } catch {
                N = !1;
              }
            return h(D, N);
          }, R.parseDbf = function(D, N) {
            return D = _(D), l(D, N);
          }, i.exports = R;
        }).call(this);
      }).call(this, typeof cn < "u" ? cn : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "./binaryajax": 2, "./parseShp": 4, "./unzip": 5, buffer: 8, lie: 12, "lru-cache": 13, parsedbf: 15, proj4: 17 }] }, {}, [23])(23);
  });
})(ud);
var Uy = ud.exports;
const By = /* @__PURE__ */ Wl(Uy);
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const ql = "160", ky = 0, Uf = 1, zy = 2, ld = 1, Gy = 2, rr = 3, Hr = 0, Zn = 1, Mi = 2, kr = 0, ha = 1, Bf = 2, kf = 3, zf = 4, Vy = 5, Es = 100, Hy = 101, jy = 102, Gf = 103, Vf = 104, Wy = 200, qy = 201, $y = 202, Xy = 203, yl = 204, gl = 205, Yy = 206, Ky = 207, Zy = 208, Jy = 209, Qy = 210, tg = 211, eg = 212, ng = 213, ig = 214, rg = 0, sg = 1, ag = 2, tu = 3, og = 4, cg = 5, ug = 6, lg = 7, fd = 0, fg = 1, hg = 2, zr = 0, pg = 1, dg = 2, mg = 3, _g = 4, yg = 5, gg = 6, hd = 300, ma = 301, _a = 302, vl = 303, xl = 304, lu = 306, eu = 1e3, _i = 1001, nu = 1002, Bn = 1003, bl = 1004, Xc = 1005, ri = 1006, pd = 1007, ya = 1008, Gr = 1009, vg = 1010, xg = 1011, $l = 1012, dd = 1013, Nr = 1014, Fr = 1015, Za = 1016, md = 1017, _d = 1018, Ms = 1020, bg = 1021, yi = 1023, Eg = 1024, wg = 1025, Ss = 1026, ga = 1027, Mg = 1028, yd = 1029, Sg = 1030, gd = 1031, vd = 1033, Mu = 33776, Su = 33777, Au = 33778, Tu = 33779, Hf = 35840, jf = 35841, Wf = 35842, qf = 35843, xd = 36196, $f = 37492, Xf = 37496, Yf = 37808, Kf = 37809, Zf = 37810, Jf = 37811, Qf = 37812, th = 37813, eh = 37814, nh = 37815, ih = 37816, rh = 37817, sh = 37818, ah = 37819, oh = 37820, ch = 37821, Cu = 36492, uh = 36494, lh = 36495, Ag = 36283, fh = 36284, hh = 36285, ph = 36286, Tg = 2300, Cg = 2301, bd = 3e3, As = 3001, Rg = 3200, Ig = 3201, Ed = 0, Pg = 1, si = "", yn = "srgb", lr = "srgb-linear", Xl = "display-p3", fu = "display-p3-linear", iu = "linear", nn = "srgb", ru = "rec709", su = "p3", zs = 7680, dh = 519, Lg = 512, Og = 513, Dg = 514, wd = 515, Ng = 516, Fg = 517, Ug = 518, Bg = 519, mh = 35044, _h = "300 es", El = 1035, cr = 2e3, au = 2001;
class Is {
  addEventListener(t, e) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[t] === void 0 && (i[t] = []), i[t].indexOf(e) === -1 && i[t].push(e);
  }
  hasEventListener(t, e) {
    if (this._listeners === void 0)
      return !1;
    const i = this._listeners;
    return i[t] !== void 0 && i[t].indexOf(e) !== -1;
  }
  removeEventListener(t, e) {
    if (this._listeners === void 0)
      return;
    const r = this._listeners[t];
    if (r !== void 0) {
      const s = r.indexOf(e);
      s !== -1 && r.splice(s, 1);
    }
  }
  dispatchEvent(t) {
    if (this._listeners === void 0)
      return;
    const i = this._listeners[t.type];
    if (i !== void 0) {
      t.target = this;
      const r = i.slice(0);
      for (let s = 0, a = r.length; s < a; s++)
        r[s].call(this, t);
      t.target = null;
    }
  }
}
const Fn = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let yh = 1234567;
const Va = Math.PI / 180, Ja = 180 / Math.PI;
function Ps() {
  const n = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
  return (Fn[n & 255] + Fn[n >> 8 & 255] + Fn[n >> 16 & 255] + Fn[n >> 24 & 255] + "-" + Fn[t & 255] + Fn[t >> 8 & 255] + "-" + Fn[t >> 16 & 15 | 64] + Fn[t >> 24 & 255] + "-" + Fn[e & 63 | 128] + Fn[e >> 8 & 255] + "-" + Fn[e >> 16 & 255] + Fn[e >> 24 & 255] + Fn[i & 255] + Fn[i >> 8 & 255] + Fn[i >> 16 & 255] + Fn[i >> 24 & 255]).toLowerCase();
}
function An(n, t, e) {
  return Math.max(t, Math.min(e, n));
}
function Yl(n, t) {
  return (n % t + t) % t;
}
function kg(n, t, e, i, r) {
  return i + (n - t) * (r - i) / (e - t);
}
function zg(n, t, e) {
  return n !== t ? (e - n) / (t - n) : 0;
}
function Ha(n, t, e) {
  return (1 - e) * n + e * t;
}
function Gg(n, t, e, i) {
  return Ha(n, t, 1 - Math.exp(-e * i));
}
function Vg(n, t = 1) {
  return t - Math.abs(Yl(n, t * 2) - t);
}
function Hg(n, t, e) {
  return n <= t ? 0 : n >= e ? 1 : (n = (n - t) / (e - t), n * n * (3 - 2 * n));
}
function jg(n, t, e) {
  return n <= t ? 0 : n >= e ? 1 : (n = (n - t) / (e - t), n * n * n * (n * (n * 6 - 15) + 10));
}
function Wg(n, t) {
  return n + Math.floor(Math.random() * (t - n + 1));
}
function qg(n, t) {
  return n + Math.random() * (t - n);
}
function $g(n) {
  return n * (0.5 - Math.random());
}
function Xg(n) {
  n !== void 0 && (yh = n);
  let t = yh += 1831565813;
  return t = Math.imul(t ^ t >>> 15, t | 1), t ^= t + Math.imul(t ^ t >>> 7, t | 61), ((t ^ t >>> 14) >>> 0) / 4294967296;
}
function Yg(n) {
  return n * Va;
}
function Kg(n) {
  return n * Ja;
}
function wl(n) {
  return (n & n - 1) === 0 && n !== 0;
}
function Zg(n) {
  return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
}
function ou(n) {
  return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
}
function Jg(n, t, e, i, r) {
  const s = Math.cos, a = Math.sin, o = s(e / 2), c = a(e / 2), h = s((t + i) / 2), l = a((t + i) / 2), f = s((t - i) / 2), d = a((t - i) / 2), m = s((i - t) / 2), v = a((i - t) / 2);
  switch (r) {
    case "XYX":
      n.set(o * l, c * f, c * d, o * h);
      break;
    case "YZY":
      n.set(c * d, o * l, c * f, o * h);
      break;
    case "ZXZ":
      n.set(c * f, c * d, o * l, o * h);
      break;
    case "XZX":
      n.set(o * l, c * v, c * m, o * h);
      break;
    case "YXY":
      n.set(c * m, o * l, c * v, o * h);
      break;
    case "ZYZ":
      n.set(c * v, c * m, o * l, o * h);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r);
  }
}
function aa(n, t) {
  switch (t.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return n / 4294967295;
    case Uint16Array:
      return n / 65535;
    case Uint8Array:
      return n / 255;
    case Int32Array:
      return Math.max(n / 2147483647, -1);
    case Int16Array:
      return Math.max(n / 32767, -1);
    case Int8Array:
      return Math.max(n / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Hn(n, t) {
  switch (t.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return Math.round(n * 4294967295);
    case Uint16Array:
      return Math.round(n * 65535);
    case Uint8Array:
      return Math.round(n * 255);
    case Int32Array:
      return Math.round(n * 2147483647);
    case Int16Array:
      return Math.round(n * 32767);
    case Int8Array:
      return Math.round(n * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const Ml = {
  DEG2RAD: Va,
  RAD2DEG: Ja,
  generateUUID: Ps,
  clamp: An,
  euclideanModulo: Yl,
  mapLinear: kg,
  inverseLerp: zg,
  lerp: Ha,
  damp: Gg,
  pingpong: Vg,
  smoothstep: Hg,
  smootherstep: jg,
  randInt: Wg,
  randFloat: qg,
  randFloatSpread: $g,
  seededRandom: Xg,
  degToRad: Yg,
  radToDeg: Kg,
  isPowerOfTwo: wl,
  ceilPowerOfTwo: Zg,
  floorPowerOfTwo: ou,
  setQuaternionFromProperEuler: Jg,
  normalize: Hn,
  denormalize: aa
};
class fe {
  constructor(t = 0, e = 0) {
    fe.prototype.isVector2 = !0, this.x = t, this.y = e;
  }
  get width() {
    return this.x;
  }
  set width(t) {
    this.x = t;
  }
  get height() {
    return this.y;
  }
  set height(t) {
    this.y = t;
  }
  set(t, e) {
    return this.x = t, this.y = e, this;
  }
  setScalar(t) {
    return this.x = t, this.y = t, this;
  }
  setX(t) {
    return this.x = t, this;
  }
  setY(t) {
    return this.y = t, this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(t) {
    return this.x = t.x, this.y = t.y, this;
  }
  add(t) {
    return this.x += t.x, this.y += t.y, this;
  }
  addScalar(t) {
    return this.x += t, this.y += t, this;
  }
  addVectors(t, e) {
    return this.x = t.x + e.x, this.y = t.y + e.y, this;
  }
  addScaledVector(t, e) {
    return this.x += t.x * e, this.y += t.y * e, this;
  }
  sub(t) {
    return this.x -= t.x, this.y -= t.y, this;
  }
  subScalar(t) {
    return this.x -= t, this.y -= t, this;
  }
  subVectors(t, e) {
    return this.x = t.x - e.x, this.y = t.y - e.y, this;
  }
  multiply(t) {
    return this.x *= t.x, this.y *= t.y, this;
  }
  multiplyScalar(t) {
    return this.x *= t, this.y *= t, this;
  }
  divide(t) {
    return this.x /= t.x, this.y /= t.y, this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  applyMatrix3(t) {
    const e = this.x, i = this.y, r = t.elements;
    return this.x = r[0] * e + r[3] * i + r[6], this.y = r[1] * e + r[4] * i + r[7], this;
  }
  min(t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this;
  }
  max(t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this;
  }
  clamp(t, e) {
    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this;
  }
  clampScalar(t, e) {
    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this;
  }
  clampLength(t, e) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y;
  }
  cross(t) {
    return this.x * t.y - this.y * t.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(t) {
    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
    if (e === 0)
      return Math.PI / 2;
    const i = this.dot(t) / e;
    return Math.acos(An(i, -1, 1));
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t));
  }
  distanceToSquared(t) {
    const e = this.x - t.x, i = this.y - t.y;
    return e * e + i * i;
  }
  manhattanDistanceTo(t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this;
  }
  lerpVectors(t, e, i) {
    return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y;
  }
  fromArray(t, e = 0) {
    return this.x = t[e], this.y = t[e + 1], this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this.x, t[e + 1] = this.y, t;
  }
  fromBufferAttribute(t, e) {
    return this.x = t.getX(e), this.y = t.getY(e), this;
  }
  rotateAround(t, e) {
    const i = Math.cos(e), r = Math.sin(e), s = this.x - t.x, a = this.y - t.y;
    return this.x = s * i - a * r + t.x, this.y = s * r + a * i + t.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Oe {
  constructor(t, e, i, r, s, a, o, c, h) {
    Oe.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], t !== void 0 && this.set(t, e, i, r, s, a, o, c, h);
  }
  set(t, e, i, r, s, a, o, c, h) {
    const l = this.elements;
    return l[0] = t, l[1] = r, l[2] = o, l[3] = e, l[4] = s, l[5] = c, l[6] = i, l[7] = a, l[8] = h, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(t) {
    const e = this.elements, i = t.elements;
    return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this;
  }
  extractBasis(t, e, i) {
    return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(t) {
    const e = t.elements;
    return this.set(
      e[0],
      e[4],
      e[8],
      e[1],
      e[5],
      e[9],
      e[2],
      e[6],
      e[10]
    ), this;
  }
  multiply(t) {
    return this.multiplyMatrices(this, t);
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this);
  }
  multiplyMatrices(t, e) {
    const i = t.elements, r = e.elements, s = this.elements, a = i[0], o = i[3], c = i[6], h = i[1], l = i[4], f = i[7], d = i[2], m = i[5], v = i[8], E = r[0], _ = r[3], p = r[6], R = r[1], M = r[4], P = r[7], W = r[2], C = r[5], D = r[8];
    return s[0] = a * E + o * R + c * W, s[3] = a * _ + o * M + c * C, s[6] = a * p + o * P + c * D, s[1] = h * E + l * R + f * W, s[4] = h * _ + l * M + f * C, s[7] = h * p + l * P + f * D, s[2] = d * E + m * R + v * W, s[5] = d * _ + m * M + v * C, s[8] = d * p + m * P + v * D, this;
  }
  multiplyScalar(t) {
    const e = this.elements;
    return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this;
  }
  determinant() {
    const t = this.elements, e = t[0], i = t[1], r = t[2], s = t[3], a = t[4], o = t[5], c = t[6], h = t[7], l = t[8];
    return e * a * l - e * o * h - i * s * l + i * o * c + r * s * h - r * a * c;
  }
  invert() {
    const t = this.elements, e = t[0], i = t[1], r = t[2], s = t[3], a = t[4], o = t[5], c = t[6], h = t[7], l = t[8], f = l * a - o * h, d = o * c - l * s, m = h * s - a * c, v = e * f + i * d + r * m;
    if (v === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const E = 1 / v;
    return t[0] = f * E, t[1] = (r * h - l * i) * E, t[2] = (o * i - r * a) * E, t[3] = d * E, t[4] = (l * e - r * c) * E, t[5] = (r * s - o * e) * E, t[6] = m * E, t[7] = (i * c - h * e) * E, t[8] = (a * e - i * s) * E, this;
  }
  transpose() {
    let t;
    const e = this.elements;
    return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this;
  }
  getNormalMatrix(t) {
    return this.setFromMatrix4(t).invert().transpose();
  }
  transposeIntoArray(t) {
    const e = this.elements;
    return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this;
  }
  setUvTransform(t, e, i, r, s, a, o) {
    const c = Math.cos(s), h = Math.sin(s);
    return this.set(
      i * c,
      i * h,
      -i * (c * a + h * o) + a + t,
      -r * h,
      r * c,
      -r * (-h * a + c * o) + o + e,
      0,
      0,
      1
    ), this;
  }
  //
  scale(t, e) {
    return this.premultiply(Ru.makeScale(t, e)), this;
  }
  rotate(t) {
    return this.premultiply(Ru.makeRotation(-t)), this;
  }
  translate(t, e) {
    return this.premultiply(Ru.makeTranslation(t, e)), this;
  }
  // for 2D Transforms
  makeTranslation(t, e) {
    return t.isVector2 ? this.set(
      1,
      0,
      t.x,
      0,
      1,
      t.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      t,
      0,
      1,
      e,
      0,
      0,
      1
    ), this;
  }
  makeRotation(t) {
    const e = Math.cos(t), i = Math.sin(t);
    return this.set(
      e,
      -i,
      0,
      i,
      e,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(t, e) {
    return this.set(
      t,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(t) {
    const e = this.elements, i = t.elements;
    for (let r = 0; r < 9; r++)
      if (e[r] !== i[r])
        return !1;
    return !0;
  }
  fromArray(t, e = 0) {
    for (let i = 0; i < 9; i++)
      this.elements[i] = t[i + e];
    return this;
  }
  toArray(t = [], e = 0) {
    const i = this.elements;
    return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const Ru = /* @__PURE__ */ new Oe();
function Md(n) {
  for (let t = n.length - 1; t >= 0; --t)
    if (n[t] >= 65535)
      return !0;
  return !1;
}
function cu(n) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", n);
}
function Qg() {
  const n = cu("canvas");
  return n.style.display = "block", n;
}
const gh = {};
function ja(n) {
  n in gh || (gh[n] = !0, console.warn(n));
}
const vh = /* @__PURE__ */ new Oe().set(
  0.8224621,
  0.177538,
  0,
  0.0331941,
  0.9668058,
  0,
  0.0170827,
  0.0723974,
  0.9105199
), xh = /* @__PURE__ */ new Oe().set(
  1.2249401,
  -0.2249404,
  0,
  -0.0420569,
  1.0420571,
  0,
  -0.0196376,
  -0.0786361,
  1.0982735
), fc = {
  [lr]: {
    transfer: iu,
    primaries: ru,
    toReference: (n) => n,
    fromReference: (n) => n
  },
  [yn]: {
    transfer: nn,
    primaries: ru,
    toReference: (n) => n.convertSRGBToLinear(),
    fromReference: (n) => n.convertLinearToSRGB()
  },
  [fu]: {
    transfer: iu,
    primaries: su,
    toReference: (n) => n.applyMatrix3(xh),
    fromReference: (n) => n.applyMatrix3(vh)
  },
  [Xl]: {
    transfer: nn,
    primaries: su,
    toReference: (n) => n.convertSRGBToLinear().applyMatrix3(xh),
    fromReference: (n) => n.applyMatrix3(vh).convertLinearToSRGB()
  }
}, tv = /* @__PURE__ */ new Set([lr, fu]), Ke = {
  enabled: !0,
  _workingColorSpace: lr,
  get workingColorSpace() {
    return this._workingColorSpace;
  },
  set workingColorSpace(n) {
    if (!tv.has(n))
      throw new Error(`Unsupported working color space, "${n}".`);
    this._workingColorSpace = n;
  },
  convert: function(n, t, e) {
    if (this.enabled === !1 || t === e || !t || !e)
      return n;
    const i = fc[t].toReference, r = fc[e].fromReference;
    return r(i(n));
  },
  fromWorkingColorSpace: function(n, t) {
    return this.convert(n, this._workingColorSpace, t);
  },
  toWorkingColorSpace: function(n, t) {
    return this.convert(n, t, this._workingColorSpace);
  },
  getPrimaries: function(n) {
    return fc[n].primaries;
  },
  getTransfer: function(n) {
    return n === si ? iu : fc[n].transfer;
  }
};
function pa(n) {
  return n < 0.04045 ? n * 0.0773993808 : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
}
function Iu(n) {
  return n < 31308e-7 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055;
}
let Gs;
class Sd {
  static getDataURL(t) {
    if (/^data:/i.test(t.src) || typeof HTMLCanvasElement > "u")
      return t.src;
    let e;
    if (t instanceof HTMLCanvasElement)
      e = t;
    else {
      Gs === void 0 && (Gs = cu("canvas")), Gs.width = t.width, Gs.height = t.height;
      const i = Gs.getContext("2d");
      t instanceof ImageData ? i.putImageData(t, 0, 0) : i.drawImage(t, 0, 0, t.width, t.height), e = Gs;
    }
    return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", 0.6)) : e.toDataURL("image/png");
  }
  static sRGBToLinear(t) {
    if (typeof HTMLImageElement < "u" && t instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap) {
      const e = cu("canvas");
      e.width = t.width, e.height = t.height;
      const i = e.getContext("2d");
      i.drawImage(t, 0, 0, t.width, t.height);
      const r = i.getImageData(0, 0, t.width, t.height), s = r.data;
      for (let a = 0; a < s.length; a++)
        s[a] = pa(s[a] / 255) * 255;
      return i.putImageData(r, 0, 0), e;
    } else if (t.data) {
      const e = t.data.slice(0);
      for (let i = 0; i < e.length; i++)
        e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[i] = Math.floor(pa(e[i] / 255) * 255) : e[i] = pa(e[i]);
      return {
        data: e,
        width: t.width,
        height: t.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t;
  }
}
let ev = 0;
class Kl {
  constructor(t = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: ev++ }), this.uuid = Ps(), this.data = t, this.version = 0;
  }
  set needsUpdate(t) {
    t === !0 && this.version++;
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == "string";
    if (!e && t.images[this.uuid] !== void 0)
      return t.images[this.uuid];
    const i = {
      uuid: this.uuid,
      url: ""
    }, r = this.data;
    if (r !== null) {
      let s;
      if (Array.isArray(r)) {
        s = [];
        for (let a = 0, o = r.length; a < o; a++)
          r[a].isDataTexture ? s.push(Pu(r[a].image)) : s.push(Pu(r[a]));
      } else
        s = Pu(r);
      i.url = s;
    }
    return e || (t.images[this.uuid] = i), i;
  }
}
function Pu(n) {
  return typeof HTMLImageElement < "u" && n instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && n instanceof ImageBitmap ? Sd.getDataURL(n) : n.data ? {
    data: Array.from(n.data),
    width: n.width,
    height: n.height,
    type: n.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let nv = 0;
class qn extends Is {
  constructor(t = qn.DEFAULT_IMAGE, e = qn.DEFAULT_MAPPING, i = _i, r = _i, s = ri, a = ya, o = yi, c = Gr, h = qn.DEFAULT_ANISOTROPY, l = si) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: nv++ }), this.uuid = Ps(), this.name = "", this.source = new Kl(t), this.mipmaps = [], this.mapping = e, this.channel = 0, this.wrapS = i, this.wrapT = r, this.magFilter = s, this.minFilter = a, this.anisotropy = h, this.format = o, this.internalFormat = null, this.type = c, this.offset = new fe(0, 0), this.repeat = new fe(1, 1), this.center = new fe(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Oe(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, typeof l == "string" ? this.colorSpace = l : (ja("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = l === As ? yn : si), this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1;
  }
  get image() {
    return this.source.data;
  }
  set image(t = null) {
    this.source.data = t;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.channel = t.channel, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.colorSpace = t.colorSpace, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = !0, this;
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == "string";
    if (!e && t.textures[this.uuid] !== void 0)
      return t.textures[this.uuid];
    const i = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(t).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (i.userData = this.userData), e || (t.textures[this.uuid] = i), i;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(t) {
    if (this.mapping !== hd)
      return t;
    if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1)
      switch (this.wrapS) {
        case eu:
          t.x = t.x - Math.floor(t.x);
          break;
        case _i:
          t.x = t.x < 0 ? 0 : 1;
          break;
        case nu:
          Math.abs(Math.floor(t.x) % 2) === 1 ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);
          break;
      }
    if (t.y < 0 || t.y > 1)
      switch (this.wrapT) {
        case eu:
          t.y = t.y - Math.floor(t.y);
          break;
        case _i:
          t.y = t.y < 0 ? 0 : 1;
          break;
        case nu:
          Math.abs(Math.floor(t.y) % 2) === 1 ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
          break;
      }
    return this.flipY && (t.y = 1 - t.y), t;
  }
  set needsUpdate(t) {
    t === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  get encoding() {
    return ja("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace === yn ? As : bd;
  }
  set encoding(t) {
    ja("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = t === As ? yn : si;
  }
}
qn.DEFAULT_IMAGE = null;
qn.DEFAULT_MAPPING = hd;
qn.DEFAULT_ANISOTROPY = 1;
class In {
  constructor(t = 0, e = 0, i = 0, r = 1) {
    In.prototype.isVector4 = !0, this.x = t, this.y = e, this.z = i, this.w = r;
  }
  get width() {
    return this.z;
  }
  set width(t) {
    this.z = t;
  }
  get height() {
    return this.w;
  }
  set height(t) {
    this.w = t;
  }
  set(t, e, i, r) {
    return this.x = t, this.y = e, this.z = i, this.w = r, this;
  }
  setScalar(t) {
    return this.x = t, this.y = t, this.z = t, this.w = t, this;
  }
  setX(t) {
    return this.x = t, this;
  }
  setY(t) {
    return this.y = t, this;
  }
  setZ(t) {
    return this.z = t, this;
  }
  setW(t) {
    return this.w = t, this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      case 3:
        this.w = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(t) {
    return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w !== void 0 ? t.w : 1, this;
  }
  add(t) {
    return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this;
  }
  addScalar(t) {
    return this.x += t, this.y += t, this.z += t, this.w += t, this;
  }
  addVectors(t, e) {
    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this;
  }
  addScaledVector(t, e) {
    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this;
  }
  sub(t) {
    return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this;
  }
  subScalar(t) {
    return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this;
  }
  subVectors(t, e) {
    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this;
  }
  multiply(t) {
    return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this;
  }
  multiplyScalar(t) {
    return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this;
  }
  applyMatrix4(t) {
    const e = this.x, i = this.y, r = this.z, s = this.w, a = t.elements;
    return this.x = a[0] * e + a[4] * i + a[8] * r + a[12] * s, this.y = a[1] * e + a[5] * i + a[9] * r + a[13] * s, this.z = a[2] * e + a[6] * i + a[10] * r + a[14] * s, this.w = a[3] * e + a[7] * i + a[11] * r + a[15] * s, this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  setAxisAngleFromQuaternion(t) {
    this.w = 2 * Math.acos(t.w);
    const e = Math.sqrt(1 - t.w * t.w);
    return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this;
  }
  setAxisAngleFromRotationMatrix(t) {
    let e, i, r, s;
    const c = t.elements, h = c[0], l = c[4], f = c[8], d = c[1], m = c[5], v = c[9], E = c[2], _ = c[6], p = c[10];
    if (Math.abs(l - d) < 0.01 && Math.abs(f - E) < 0.01 && Math.abs(v - _) < 0.01) {
      if (Math.abs(l + d) < 0.1 && Math.abs(f + E) < 0.1 && Math.abs(v + _) < 0.1 && Math.abs(h + m + p - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      e = Math.PI;
      const M = (h + 1) / 2, P = (m + 1) / 2, W = (p + 1) / 2, C = (l + d) / 4, D = (f + E) / 4, N = (v + _) / 4;
      return M > P && M > W ? M < 0.01 ? (i = 0, r = 0.707106781, s = 0.707106781) : (i = Math.sqrt(M), r = C / i, s = D / i) : P > W ? P < 0.01 ? (i = 0.707106781, r = 0, s = 0.707106781) : (r = Math.sqrt(P), i = C / r, s = N / r) : W < 0.01 ? (i = 0.707106781, r = 0.707106781, s = 0) : (s = Math.sqrt(W), i = D / s, r = N / s), this.set(i, r, s, e), this;
    }
    let R = Math.sqrt((_ - v) * (_ - v) + (f - E) * (f - E) + (d - l) * (d - l));
    return Math.abs(R) < 1e-3 && (R = 1), this.x = (_ - v) / R, this.y = (f - E) / R, this.z = (d - l) / R, this.w = Math.acos((h + m + p - 1) / 2), this;
  }
  min(t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this;
  }
  max(t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this;
  }
  clamp(t, e) {
    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this;
  }
  clampScalar(t, e) {
    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this;
  }
  clampLength(t, e) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this;
  }
  lerpVectors(t, e, i) {
    return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this.z = t.z + (e.z - t.z) * i, this.w = t.w + (e.w - t.w) * i, this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
  }
  fromArray(t, e = 0) {
    return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t;
  }
  fromBufferAttribute(t, e) {
    return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class iv extends Is {
  constructor(t = 1, e = 1, i = {}) {
    super(), this.isRenderTarget = !0, this.width = t, this.height = e, this.depth = 1, this.scissor = new In(0, 0, t, e), this.scissorTest = !1, this.viewport = new In(0, 0, t, e);
    const r = { width: t, height: e, depth: 1 };
    i.encoding !== void 0 && (ja("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."), i.colorSpace = i.encoding === As ? yn : si), i = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: ri,
      depthBuffer: !0,
      stencilBuffer: !1,
      depthTexture: null,
      samples: 0
    }, i), this.texture = new qn(r, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = i.generateMipmaps, this.texture.internalFormat = i.internalFormat, this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.depthTexture = i.depthTexture, this.samples = i.samples;
  }
  setSize(t, e, i = 1) {
    (this.width !== t || this.height !== e || this.depth !== i) && (this.width = t, this.height = e, this.depth = i, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = i, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    this.width = t.width, this.height = t.height, this.depth = t.depth, this.scissor.copy(t.scissor), this.scissorTest = t.scissorTest, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.texture.isRenderTargetTexture = !0;
    const e = Object.assign({}, t.texture.image);
    return this.texture.source = new Kl(e), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, t.depthTexture !== null && (this.depthTexture = t.depthTexture.clone()), this.samples = t.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Cs extends iv {
  constructor(t = 1, e = 1, i = {}) {
    super(t, e, i), this.isWebGLRenderTarget = !0;
  }
}
class Ad extends qn {
  constructor(t = null, e = 1, i = 1, r = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: t, width: e, height: i, depth: r }, this.magFilter = Bn, this.minFilter = Bn, this.wrapR = _i, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class rv extends qn {
  constructor(t = null, e = 1, i = 1, r = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: t, width: e, height: i, depth: r }, this.magFilter = Bn, this.minFilter = Bn, this.wrapR = _i, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
let Ea = class {
  constructor(t = 0, e = 0, i = 0, r = 1) {
    this.isQuaternion = !0, this._x = t, this._y = e, this._z = i, this._w = r;
  }
  static slerpFlat(t, e, i, r, s, a, o) {
    let c = i[r + 0], h = i[r + 1], l = i[r + 2], f = i[r + 3];
    const d = s[a + 0], m = s[a + 1], v = s[a + 2], E = s[a + 3];
    if (o === 0) {
      t[e + 0] = c, t[e + 1] = h, t[e + 2] = l, t[e + 3] = f;
      return;
    }
    if (o === 1) {
      t[e + 0] = d, t[e + 1] = m, t[e + 2] = v, t[e + 3] = E;
      return;
    }
    if (f !== E || c !== d || h !== m || l !== v) {
      let _ = 1 - o;
      const p = c * d + h * m + l * v + f * E, R = p >= 0 ? 1 : -1, M = 1 - p * p;
      if (M > Number.EPSILON) {
        const W = Math.sqrt(M), C = Math.atan2(W, p * R);
        _ = Math.sin(_ * C) / W, o = Math.sin(o * C) / W;
      }
      const P = o * R;
      if (c = c * _ + d * P, h = h * _ + m * P, l = l * _ + v * P, f = f * _ + E * P, _ === 1 - o) {
        const W = 1 / Math.sqrt(c * c + h * h + l * l + f * f);
        c *= W, h *= W, l *= W, f *= W;
      }
    }
    t[e] = c, t[e + 1] = h, t[e + 2] = l, t[e + 3] = f;
  }
  static multiplyQuaternionsFlat(t, e, i, r, s, a) {
    const o = i[r], c = i[r + 1], h = i[r + 2], l = i[r + 3], f = s[a], d = s[a + 1], m = s[a + 2], v = s[a + 3];
    return t[e] = o * v + l * f + c * m - h * d, t[e + 1] = c * v + l * d + h * f - o * m, t[e + 2] = h * v + l * m + o * d - c * f, t[e + 3] = l * v - o * f - c * d - h * m, t;
  }
  get x() {
    return this._x;
  }
  set x(t) {
    this._x = t, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t) {
    this._y = t, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t) {
    this._z = t, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(t) {
    this._w = t, this._onChangeCallback();
  }
  set(t, e, i, r) {
    return this._x = t, this._y = e, this._z = i, this._w = r, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(t) {
    return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this;
  }
  setFromEuler(t, e = !0) {
    const i = t._x, r = t._y, s = t._z, a = t._order, o = Math.cos, c = Math.sin, h = o(i / 2), l = o(r / 2), f = o(s / 2), d = c(i / 2), m = c(r / 2), v = c(s / 2);
    switch (a) {
      case "XYZ":
        this._x = d * l * f + h * m * v, this._y = h * m * f - d * l * v, this._z = h * l * v + d * m * f, this._w = h * l * f - d * m * v;
        break;
      case "YXZ":
        this._x = d * l * f + h * m * v, this._y = h * m * f - d * l * v, this._z = h * l * v - d * m * f, this._w = h * l * f + d * m * v;
        break;
      case "ZXY":
        this._x = d * l * f - h * m * v, this._y = h * m * f + d * l * v, this._z = h * l * v + d * m * f, this._w = h * l * f - d * m * v;
        break;
      case "ZYX":
        this._x = d * l * f - h * m * v, this._y = h * m * f + d * l * v, this._z = h * l * v - d * m * f, this._w = h * l * f + d * m * v;
        break;
      case "YZX":
        this._x = d * l * f + h * m * v, this._y = h * m * f + d * l * v, this._z = h * l * v - d * m * f, this._w = h * l * f - d * m * v;
        break;
      case "XZY":
        this._x = d * l * f - h * m * v, this._y = h * m * f - d * l * v, this._z = h * l * v + d * m * f, this._w = h * l * f + d * m * v;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);
    }
    return e === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(t, e) {
    const i = e / 2, r = Math.sin(i);
    return this._x = t.x * r, this._y = t.y * r, this._z = t.z * r, this._w = Math.cos(i), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(t) {
    const e = t.elements, i = e[0], r = e[4], s = e[8], a = e[1], o = e[5], c = e[9], h = e[2], l = e[6], f = e[10], d = i + o + f;
    if (d > 0) {
      const m = 0.5 / Math.sqrt(d + 1);
      this._w = 0.25 / m, this._x = (l - c) * m, this._y = (s - h) * m, this._z = (a - r) * m;
    } else if (i > o && i > f) {
      const m = 2 * Math.sqrt(1 + i - o - f);
      this._w = (l - c) / m, this._x = 0.25 * m, this._y = (r + a) / m, this._z = (s + h) / m;
    } else if (o > f) {
      const m = 2 * Math.sqrt(1 + o - i - f);
      this._w = (s - h) / m, this._x = (r + a) / m, this._y = 0.25 * m, this._z = (c + l) / m;
    } else {
      const m = 2 * Math.sqrt(1 + f - i - o);
      this._w = (a - r) / m, this._x = (s + h) / m, this._y = (c + l) / m, this._z = 0.25 * m;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(t, e) {
    let i = t.dot(e) + 1;
    return i < Number.EPSILON ? (i = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = i)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = i), this.normalize();
  }
  angleTo(t) {
    return 2 * Math.acos(Math.abs(An(this.dot(t), -1, 1)));
  }
  rotateTowards(t, e) {
    const i = this.angleTo(t);
    if (i === 0)
      return this;
    const r = Math.min(1, e / i);
    return this.slerp(t, r), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(t) {
    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let t = this.length();
    return t === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this;
  }
  multiply(t) {
    return this.multiplyQuaternions(this, t);
  }
  premultiply(t) {
    return this.multiplyQuaternions(t, this);
  }
  multiplyQuaternions(t, e) {
    const i = t._x, r = t._y, s = t._z, a = t._w, o = e._x, c = e._y, h = e._z, l = e._w;
    return this._x = i * l + a * o + r * h - s * c, this._y = r * l + a * c + s * o - i * h, this._z = s * l + a * h + i * c - r * o, this._w = a * l - i * o - r * c - s * h, this._onChangeCallback(), this;
  }
  slerp(t, e) {
    if (e === 0)
      return this;
    if (e === 1)
      return this.copy(t);
    const i = this._x, r = this._y, s = this._z, a = this._w;
    let o = a * t._w + i * t._x + r * t._y + s * t._z;
    if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1)
      return this._w = a, this._x = i, this._y = r, this._z = s, this;
    const c = 1 - o * o;
    if (c <= Number.EPSILON) {
      const m = 1 - e;
      return this._w = m * a + e * this._w, this._x = m * i + e * this._x, this._y = m * r + e * this._y, this._z = m * s + e * this._z, this.normalize(), this;
    }
    const h = Math.sqrt(c), l = Math.atan2(h, o), f = Math.sin((1 - e) * l) / h, d = Math.sin(e * l) / h;
    return this._w = a * f + this._w * d, this._x = i * f + this._x * d, this._y = r * f + this._y * d, this._z = s * f + this._z * d, this._onChangeCallback(), this;
  }
  slerpQuaternions(t, e, i) {
    return this.copy(t).slerp(e, i);
  }
  random() {
    const t = Math.random(), e = Math.sqrt(1 - t), i = Math.sqrt(t), r = 2 * Math.PI * Math.random(), s = 2 * Math.PI * Math.random();
    return this.set(
      e * Math.cos(r),
      i * Math.sin(s),
      i * Math.cos(s),
      e * Math.sin(r)
    );
  }
  equals(t) {
    return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
  }
  fromArray(t, e = 0) {
    return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t;
  }
  fromBufferAttribute(t, e) {
    return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(t) {
    return this._onChangeCallback = t, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
};
class Gt {
  constructor(t = 0, e = 0, i = 0) {
    Gt.prototype.isVector3 = !0, this.x = t, this.y = e, this.z = i;
  }
  set(t, e, i) {
    return i === void 0 && (i = this.z), this.x = t, this.y = e, this.z = i, this;
  }
  setScalar(t) {
    return this.x = t, this.y = t, this.z = t, this;
  }
  setX(t) {
    return this.x = t, this;
  }
  setY(t) {
    return this.y = t, this;
  }
  setZ(t) {
    return this.z = t, this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(t) {
    return this.x = t.x, this.y = t.y, this.z = t.z, this;
  }
  add(t) {
    return this.x += t.x, this.y += t.y, this.z += t.z, this;
  }
  addScalar(t) {
    return this.x += t, this.y += t, this.z += t, this;
  }
  addVectors(t, e) {
    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this;
  }
  addScaledVector(t, e) {
    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this;
  }
  sub(t) {
    return this.x -= t.x, this.y -= t.y, this.z -= t.z, this;
  }
  subScalar(t) {
    return this.x -= t, this.y -= t, this.z -= t, this;
  }
  subVectors(t, e) {
    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this;
  }
  multiply(t) {
    return this.x *= t.x, this.y *= t.y, this.z *= t.z, this;
  }
  multiplyScalar(t) {
    return this.x *= t, this.y *= t, this.z *= t, this;
  }
  multiplyVectors(t, e) {
    return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this;
  }
  applyEuler(t) {
    return this.applyQuaternion(bh.setFromEuler(t));
  }
  applyAxisAngle(t, e) {
    return this.applyQuaternion(bh.setFromAxisAngle(t, e));
  }
  applyMatrix3(t) {
    const e = this.x, i = this.y, r = this.z, s = t.elements;
    return this.x = s[0] * e + s[3] * i + s[6] * r, this.y = s[1] * e + s[4] * i + s[7] * r, this.z = s[2] * e + s[5] * i + s[8] * r, this;
  }
  applyNormalMatrix(t) {
    return this.applyMatrix3(t).normalize();
  }
  applyMatrix4(t) {
    const e = this.x, i = this.y, r = this.z, s = t.elements, a = 1 / (s[3] * e + s[7] * i + s[11] * r + s[15]);
    return this.x = (s[0] * e + s[4] * i + s[8] * r + s[12]) * a, this.y = (s[1] * e + s[5] * i + s[9] * r + s[13]) * a, this.z = (s[2] * e + s[6] * i + s[10] * r + s[14]) * a, this;
  }
  applyQuaternion(t) {
    const e = this.x, i = this.y, r = this.z, s = t.x, a = t.y, o = t.z, c = t.w, h = 2 * (a * r - o * i), l = 2 * (o * e - s * r), f = 2 * (s * i - a * e);
    return this.x = e + c * h + a * f - o * l, this.y = i + c * l + o * h - s * f, this.z = r + c * f + s * l - a * h, this;
  }
  project(t) {
    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix);
  }
  unproject(t) {
    return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld);
  }
  transformDirection(t) {
    const e = this.x, i = this.y, r = this.z, s = t.elements;
    return this.x = s[0] * e + s[4] * i + s[8] * r, this.y = s[1] * e + s[5] * i + s[9] * r, this.z = s[2] * e + s[6] * i + s[10] * r, this.normalize();
  }
  divide(t) {
    return this.x /= t.x, this.y /= t.y, this.z /= t.z, this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  min(t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this;
  }
  max(t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this;
  }
  clamp(t, e) {
    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this;
  }
  clampScalar(t, e) {
    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this;
  }
  clampLength(t, e) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this;
  }
  lerpVectors(t, e, i) {
    return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this.z = t.z + (e.z - t.z) * i, this;
  }
  cross(t) {
    return this.crossVectors(this, t);
  }
  crossVectors(t, e) {
    const i = t.x, r = t.y, s = t.z, a = e.x, o = e.y, c = e.z;
    return this.x = r * c - s * o, this.y = s * a - i * c, this.z = i * o - r * a, this;
  }
  projectOnVector(t) {
    const e = t.lengthSq();
    if (e === 0)
      return this.set(0, 0, 0);
    const i = t.dot(this) / e;
    return this.copy(t).multiplyScalar(i);
  }
  projectOnPlane(t) {
    return Lu.copy(this).projectOnVector(t), this.sub(Lu);
  }
  reflect(t) {
    return this.sub(Lu.copy(t).multiplyScalar(2 * this.dot(t)));
  }
  angleTo(t) {
    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
    if (e === 0)
      return Math.PI / 2;
    const i = this.dot(t) / e;
    return Math.acos(An(i, -1, 1));
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t));
  }
  distanceToSquared(t) {
    const e = this.x - t.x, i = this.y - t.y, r = this.z - t.z;
    return e * e + i * i + r * r;
  }
  manhattanDistanceTo(t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
  }
  setFromSpherical(t) {
    return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
  }
  setFromSphericalCoords(t, e, i) {
    const r = Math.sin(e) * t;
    return this.x = r * Math.sin(i), this.y = Math.cos(e) * t, this.z = r * Math.cos(i), this;
  }
  setFromCylindrical(t) {
    return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
  }
  setFromCylindricalCoords(t, e, i) {
    return this.x = t * Math.sin(e), this.y = i, this.z = t * Math.cos(e), this;
  }
  setFromMatrixPosition(t) {
    const e = t.elements;
    return this.x = e[12], this.y = e[13], this.z = e[14], this;
  }
  setFromMatrixScale(t) {
    const e = this.setFromMatrixColumn(t, 0).length(), i = this.setFromMatrixColumn(t, 1).length(), r = this.setFromMatrixColumn(t, 2).length();
    return this.x = e, this.y = i, this.z = r, this;
  }
  setFromMatrixColumn(t, e) {
    return this.fromArray(t.elements, e * 4);
  }
  setFromMatrix3Column(t, e) {
    return this.fromArray(t.elements, e * 3);
  }
  setFromEuler(t) {
    return this.x = t._x, this.y = t._y, this.z = t._z, this;
  }
  setFromColor(t) {
    return this.x = t.r, this.y = t.g, this.z = t.b, this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z;
  }
  fromArray(t, e = 0) {
    return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t;
  }
  fromBufferAttribute(t, e) {
    return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const t = (Math.random() - 0.5) * 2, e = Math.random() * Math.PI * 2, i = Math.sqrt(1 - t ** 2);
    return this.x = i * Math.cos(e), this.y = i * Math.sin(e), this.z = t, this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const Lu = /* @__PURE__ */ new Gt(), bh = /* @__PURE__ */ new Ea();
class oo {
  constructor(t = new Gt(1 / 0, 1 / 0, 1 / 0), e = new Gt(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = t, this.max = e;
  }
  set(t, e) {
    return this.min.copy(t), this.max.copy(e), this;
  }
  setFromArray(t) {
    this.makeEmpty();
    for (let e = 0, i = t.length; e < i; e += 3)
      this.expandByPoint(vi.fromArray(t, e));
    return this;
  }
  setFromBufferAttribute(t) {
    this.makeEmpty();
    for (let e = 0, i = t.count; e < i; e++)
      this.expandByPoint(vi.fromBufferAttribute(t, e));
    return this;
  }
  setFromPoints(t) {
    this.makeEmpty();
    for (let e = 0, i = t.length; e < i; e++)
      this.expandByPoint(t[e]);
    return this;
  }
  setFromCenterAndSize(t, e) {
    const i = vi.copy(e).multiplyScalar(0.5);
    return this.min.copy(t).sub(i), this.max.copy(t).add(i), this;
  }
  setFromObject(t, e = !1) {
    return this.makeEmpty(), this.expandByObject(t, e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.min.copy(t.min), this.max.copy(t.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(t) {
    return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(t) {
    return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
  }
  expandByPoint(t) {
    return this.min.min(t), this.max.max(t), this;
  }
  expandByVector(t) {
    return this.min.sub(t), this.max.add(t), this;
  }
  expandByScalar(t) {
    return this.min.addScalar(-t), this.max.addScalar(t), this;
  }
  expandByObject(t, e = !1) {
    t.updateWorldMatrix(!1, !1);
    const i = t.geometry;
    if (i !== void 0) {
      const s = i.getAttribute("position");
      if (e === !0 && s !== void 0 && t.isInstancedMesh !== !0)
        for (let a = 0, o = s.count; a < o; a++)
          t.isMesh === !0 ? t.getVertexPosition(a, vi) : vi.fromBufferAttribute(s, a), vi.applyMatrix4(t.matrixWorld), this.expandByPoint(vi);
      else
        t.boundingBox !== void 0 ? (t.boundingBox === null && t.computeBoundingBox(), hc.copy(t.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(), hc.copy(i.boundingBox)), hc.applyMatrix4(t.matrixWorld), this.union(hc);
    }
    const r = t.children;
    for (let s = 0, a = r.length; s < a; s++)
      this.expandByObject(r[s], e);
    return this;
  }
  containsPoint(t) {
    return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z);
  }
  containsBox(t) {
    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z;
  }
  getParameter(t, e) {
    return e.set(
      (t.x - this.min.x) / (this.max.x - this.min.x),
      (t.y - this.min.y) / (this.max.y - this.min.y),
      (t.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(t) {
    return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z);
  }
  intersectsSphere(t) {
    return this.clampPoint(t.center, vi), vi.distanceToSquared(t.center) <= t.radius * t.radius;
  }
  intersectsPlane(t) {
    let e, i;
    return t.normal.x > 0 ? (e = t.normal.x * this.min.x, i = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, i = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= -t.constant && i >= -t.constant;
  }
  intersectsTriangle(t) {
    if (this.isEmpty())
      return !1;
    this.getCenter(Ia), pc.subVectors(this.max, Ia), Vs.subVectors(t.a, Ia), Hs.subVectors(t.b, Ia), js.subVectors(t.c, Ia), Sr.subVectors(Hs, Vs), Ar.subVectors(js, Hs), ds.subVectors(Vs, js);
    let e = [
      0,
      -Sr.z,
      Sr.y,
      0,
      -Ar.z,
      Ar.y,
      0,
      -ds.z,
      ds.y,
      Sr.z,
      0,
      -Sr.x,
      Ar.z,
      0,
      -Ar.x,
      ds.z,
      0,
      -ds.x,
      -Sr.y,
      Sr.x,
      0,
      -Ar.y,
      Ar.x,
      0,
      -ds.y,
      ds.x,
      0
    ];
    return !Ou(e, Vs, Hs, js, pc) || (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !Ou(e, Vs, Hs, js, pc)) ? !1 : (dc.crossVectors(Sr, Ar), e = [dc.x, dc.y, dc.z], Ou(e, Vs, Hs, js, pc));
  }
  clampPoint(t, e) {
    return e.copy(t).clamp(this.min, this.max);
  }
  distanceToPoint(t) {
    return this.clampPoint(t, vi).distanceTo(t);
  }
  getBoundingSphere(t) {
    return this.isEmpty() ? t.makeEmpty() : (this.getCenter(t.center), t.radius = this.getSize(vi).length() * 0.5), t;
  }
  intersect(t) {
    return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(t) {
    return this.min.min(t.min), this.max.max(t.max), this;
  }
  applyMatrix4(t) {
    return this.isEmpty() ? this : (Qi[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), Qi[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), Qi[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), Qi[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), Qi[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), Qi[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), Qi[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), Qi[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(Qi), this);
  }
  translate(t) {
    return this.min.add(t), this.max.add(t), this;
  }
  equals(t) {
    return t.min.equals(this.min) && t.max.equals(this.max);
  }
}
const Qi = [
  /* @__PURE__ */ new Gt(),
  /* @__PURE__ */ new Gt(),
  /* @__PURE__ */ new Gt(),
  /* @__PURE__ */ new Gt(),
  /* @__PURE__ */ new Gt(),
  /* @__PURE__ */ new Gt(),
  /* @__PURE__ */ new Gt(),
  /* @__PURE__ */ new Gt()
], vi = /* @__PURE__ */ new Gt(), hc = /* @__PURE__ */ new oo(), Vs = /* @__PURE__ */ new Gt(), Hs = /* @__PURE__ */ new Gt(), js = /* @__PURE__ */ new Gt(), Sr = /* @__PURE__ */ new Gt(), Ar = /* @__PURE__ */ new Gt(), ds = /* @__PURE__ */ new Gt(), Ia = /* @__PURE__ */ new Gt(), pc = /* @__PURE__ */ new Gt(), dc = /* @__PURE__ */ new Gt(), ms = /* @__PURE__ */ new Gt();
function Ou(n, t, e, i, r) {
  for (let s = 0, a = n.length - 3; s <= a; s += 3) {
    ms.fromArray(n, s);
    const o = r.x * Math.abs(ms.x) + r.y * Math.abs(ms.y) + r.z * Math.abs(ms.z), c = t.dot(ms), h = e.dot(ms), l = i.dot(ms);
    if (Math.max(-Math.max(c, h, l), Math.min(c, h, l)) > o)
      return !1;
  }
  return !0;
}
const sv = /* @__PURE__ */ new oo(), Pa = /* @__PURE__ */ new Gt(), Du = /* @__PURE__ */ new Gt();
class Zl {
  constructor(t = new Gt(), e = -1) {
    this.isSphere = !0, this.center = t, this.radius = e;
  }
  set(t, e) {
    return this.center.copy(t), this.radius = e, this;
  }
  setFromPoints(t, e) {
    const i = this.center;
    e !== void 0 ? i.copy(e) : sv.setFromPoints(t).getCenter(i);
    let r = 0;
    for (let s = 0, a = t.length; s < a; s++)
      r = Math.max(r, i.distanceToSquared(t[s]));
    return this.radius = Math.sqrt(r), this;
  }
  copy(t) {
    return this.center.copy(t.center), this.radius = t.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(t) {
    return t.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(t) {
    return t.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(t) {
    const e = this.radius + t.radius;
    return t.center.distanceToSquared(this.center) <= e * e;
  }
  intersectsBox(t) {
    return t.intersectsSphere(this);
  }
  intersectsPlane(t) {
    return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(t, e) {
    const i = this.center.distanceToSquared(t);
    return e.copy(t), i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e;
  }
  getBoundingBox(t) {
    return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
  }
  applyMatrix4(t) {
    return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this;
  }
  translate(t) {
    return this.center.add(t), this;
  }
  expandByPoint(t) {
    if (this.isEmpty())
      return this.center.copy(t), this.radius = 0, this;
    Pa.subVectors(t, this.center);
    const e = Pa.lengthSq();
    if (e > this.radius * this.radius) {
      const i = Math.sqrt(e), r = (i - this.radius) * 0.5;
      this.center.addScaledVector(Pa, r / i), this.radius += r;
    }
    return this;
  }
  union(t) {
    return t.isEmpty() ? this : this.isEmpty() ? (this.copy(t), this) : (this.center.equals(t.center) === !0 ? this.radius = Math.max(this.radius, t.radius) : (Du.subVectors(t.center, this.center).setLength(t.radius), this.expandByPoint(Pa.copy(t.center).add(Du)), this.expandByPoint(Pa.copy(t.center).sub(Du))), this);
  }
  equals(t) {
    return t.center.equals(this.center) && t.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const tr = /* @__PURE__ */ new Gt(), Nu = /* @__PURE__ */ new Gt(), mc = /* @__PURE__ */ new Gt(), Tr = /* @__PURE__ */ new Gt(), Fu = /* @__PURE__ */ new Gt(), _c = /* @__PURE__ */ new Gt(), Uu = /* @__PURE__ */ new Gt();
class av {
  constructor(t = new Gt(), e = new Gt(0, 0, -1)) {
    this.origin = t, this.direction = e;
  }
  set(t, e) {
    return this.origin.copy(t), this.direction.copy(e), this;
  }
  copy(t) {
    return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
  }
  at(t, e) {
    return e.copy(this.origin).addScaledVector(this.direction, t);
  }
  lookAt(t) {
    return this.direction.copy(t).sub(this.origin).normalize(), this;
  }
  recast(t) {
    return this.origin.copy(this.at(t, tr)), this;
  }
  closestPointToPoint(t, e) {
    e.subVectors(t, this.origin);
    const i = e.dot(this.direction);
    return i < 0 ? e.copy(this.origin) : e.copy(this.origin).addScaledVector(this.direction, i);
  }
  distanceToPoint(t) {
    return Math.sqrt(this.distanceSqToPoint(t));
  }
  distanceSqToPoint(t) {
    const e = tr.subVectors(t, this.origin).dot(this.direction);
    return e < 0 ? this.origin.distanceToSquared(t) : (tr.copy(this.origin).addScaledVector(this.direction, e), tr.distanceToSquared(t));
  }
  distanceSqToSegment(t, e, i, r) {
    Nu.copy(t).add(e).multiplyScalar(0.5), mc.copy(e).sub(t).normalize(), Tr.copy(this.origin).sub(Nu);
    const s = t.distanceTo(e) * 0.5, a = -this.direction.dot(mc), o = Tr.dot(this.direction), c = -Tr.dot(mc), h = Tr.lengthSq(), l = Math.abs(1 - a * a);
    let f, d, m, v;
    if (l > 0)
      if (f = a * c - o, d = a * o - c, v = s * l, f >= 0)
        if (d >= -v)
          if (d <= v) {
            const E = 1 / l;
            f *= E, d *= E, m = f * (f + a * d + 2 * o) + d * (a * f + d + 2 * c) + h;
          } else
            d = s, f = Math.max(0, -(a * d + o)), m = -f * f + d * (d + 2 * c) + h;
        else
          d = -s, f = Math.max(0, -(a * d + o)), m = -f * f + d * (d + 2 * c) + h;
      else
        d <= -v ? (f = Math.max(0, -(-a * s + o)), d = f > 0 ? -s : Math.min(Math.max(-s, -c), s), m = -f * f + d * (d + 2 * c) + h) : d <= v ? (f = 0, d = Math.min(Math.max(-s, -c), s), m = d * (d + 2 * c) + h) : (f = Math.max(0, -(a * s + o)), d = f > 0 ? s : Math.min(Math.max(-s, -c), s), m = -f * f + d * (d + 2 * c) + h);
    else
      d = a > 0 ? -s : s, f = Math.max(0, -(a * d + o)), m = -f * f + d * (d + 2 * c) + h;
    return i && i.copy(this.origin).addScaledVector(this.direction, f), r && r.copy(Nu).addScaledVector(mc, d), m;
  }
  intersectSphere(t, e) {
    tr.subVectors(t.center, this.origin);
    const i = tr.dot(this.direction), r = tr.dot(tr) - i * i, s = t.radius * t.radius;
    if (r > s)
      return null;
    const a = Math.sqrt(s - r), o = i - a, c = i + a;
    return c < 0 ? null : o < 0 ? this.at(c, e) : this.at(o, e);
  }
  intersectsSphere(t) {
    return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
  }
  distanceToPlane(t) {
    const e = t.normal.dot(this.direction);
    if (e === 0)
      return t.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(t.normal) + t.constant) / e;
    return i >= 0 ? i : null;
  }
  intersectPlane(t, e) {
    const i = this.distanceToPlane(t);
    return i === null ? null : this.at(i, e);
  }
  intersectsPlane(t) {
    const e = t.distanceToPoint(this.origin);
    return e === 0 || t.normal.dot(this.direction) * e < 0;
  }
  intersectBox(t, e) {
    let i, r, s, a, o, c;
    const h = 1 / this.direction.x, l = 1 / this.direction.y, f = 1 / this.direction.z, d = this.origin;
    return h >= 0 ? (i = (t.min.x - d.x) * h, r = (t.max.x - d.x) * h) : (i = (t.max.x - d.x) * h, r = (t.min.x - d.x) * h), l >= 0 ? (s = (t.min.y - d.y) * l, a = (t.max.y - d.y) * l) : (s = (t.max.y - d.y) * l, a = (t.min.y - d.y) * l), i > a || s > r || ((s > i || isNaN(i)) && (i = s), (a < r || isNaN(r)) && (r = a), f >= 0 ? (o = (t.min.z - d.z) * f, c = (t.max.z - d.z) * f) : (o = (t.max.z - d.z) * f, c = (t.min.z - d.z) * f), i > c || o > r) || ((o > i || i !== i) && (i = o), (c < r || r !== r) && (r = c), r < 0) ? null : this.at(i >= 0 ? i : r, e);
  }
  intersectsBox(t) {
    return this.intersectBox(t, tr) !== null;
  }
  intersectTriangle(t, e, i, r, s) {
    Fu.subVectors(e, t), _c.subVectors(i, t), Uu.crossVectors(Fu, _c);
    let a = this.direction.dot(Uu), o;
    if (a > 0) {
      if (r)
        return null;
      o = 1;
    } else if (a < 0)
      o = -1, a = -a;
    else
      return null;
    Tr.subVectors(this.origin, t);
    const c = o * this.direction.dot(_c.crossVectors(Tr, _c));
    if (c < 0)
      return null;
    const h = o * this.direction.dot(Fu.cross(Tr));
    if (h < 0 || c + h > a)
      return null;
    const l = -o * Tr.dot(Uu);
    return l < 0 ? null : this.at(l / a, s);
  }
  applyMatrix4(t) {
    return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this;
  }
  equals(t) {
    return t.origin.equals(this.origin) && t.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
let vn = class Sl {
  constructor(t, e, i, r, s, a, o, c, h, l, f, d, m, v, E, _) {
    Sl.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], t !== void 0 && this.set(t, e, i, r, s, a, o, c, h, l, f, d, m, v, E, _);
  }
  set(t, e, i, r, s, a, o, c, h, l, f, d, m, v, E, _) {
    const p = this.elements;
    return p[0] = t, p[4] = e, p[8] = i, p[12] = r, p[1] = s, p[5] = a, p[9] = o, p[13] = c, p[2] = h, p[6] = l, p[10] = f, p[14] = d, p[3] = m, p[7] = v, p[11] = E, p[15] = _, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new Sl().fromArray(this.elements);
  }
  copy(t) {
    const e = this.elements, i = t.elements;
    return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], this;
  }
  copyPosition(t) {
    const e = this.elements, i = t.elements;
    return e[12] = i[12], e[13] = i[13], e[14] = i[14], this;
  }
  setFromMatrix3(t) {
    const e = t.elements;
    return this.set(
      e[0],
      e[3],
      e[6],
      0,
      e[1],
      e[4],
      e[7],
      0,
      e[2],
      e[5],
      e[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(t, e, i) {
    return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(t, e, i) {
    return this.set(
      t.x,
      e.x,
      i.x,
      0,
      t.y,
      e.y,
      i.y,
      0,
      t.z,
      e.z,
      i.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(t) {
    const e = this.elements, i = t.elements, r = 1 / Ws.setFromMatrixColumn(t, 0).length(), s = 1 / Ws.setFromMatrixColumn(t, 1).length(), a = 1 / Ws.setFromMatrixColumn(t, 2).length();
    return e[0] = i[0] * r, e[1] = i[1] * r, e[2] = i[2] * r, e[3] = 0, e[4] = i[4] * s, e[5] = i[5] * s, e[6] = i[6] * s, e[7] = 0, e[8] = i[8] * a, e[9] = i[9] * a, e[10] = i[10] * a, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
  }
  makeRotationFromEuler(t) {
    const e = this.elements, i = t.x, r = t.y, s = t.z, a = Math.cos(i), o = Math.sin(i), c = Math.cos(r), h = Math.sin(r), l = Math.cos(s), f = Math.sin(s);
    if (t.order === "XYZ") {
      const d = a * l, m = a * f, v = o * l, E = o * f;
      e[0] = c * l, e[4] = -c * f, e[8] = h, e[1] = m + v * h, e[5] = d - E * h, e[9] = -o * c, e[2] = E - d * h, e[6] = v + m * h, e[10] = a * c;
    } else if (t.order === "YXZ") {
      const d = c * l, m = c * f, v = h * l, E = h * f;
      e[0] = d + E * o, e[4] = v * o - m, e[8] = a * h, e[1] = a * f, e[5] = a * l, e[9] = -o, e[2] = m * o - v, e[6] = E + d * o, e[10] = a * c;
    } else if (t.order === "ZXY") {
      const d = c * l, m = c * f, v = h * l, E = h * f;
      e[0] = d - E * o, e[4] = -a * f, e[8] = v + m * o, e[1] = m + v * o, e[5] = a * l, e[9] = E - d * o, e[2] = -a * h, e[6] = o, e[10] = a * c;
    } else if (t.order === "ZYX") {
      const d = a * l, m = a * f, v = o * l, E = o * f;
      e[0] = c * l, e[4] = v * h - m, e[8] = d * h + E, e[1] = c * f, e[5] = E * h + d, e[9] = m * h - v, e[2] = -h, e[6] = o * c, e[10] = a * c;
    } else if (t.order === "YZX") {
      const d = a * c, m = a * h, v = o * c, E = o * h;
      e[0] = c * l, e[4] = E - d * f, e[8] = v * f + m, e[1] = f, e[5] = a * l, e[9] = -o * l, e[2] = -h * l, e[6] = m * f + v, e[10] = d - E * f;
    } else if (t.order === "XZY") {
      const d = a * c, m = a * h, v = o * c, E = o * h;
      e[0] = c * l, e[4] = -f, e[8] = h * l, e[1] = d * f + E, e[5] = a * l, e[9] = m * f - v, e[2] = v * f - m, e[6] = o * l, e[10] = E * f + d;
    }
    return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
  }
  makeRotationFromQuaternion(t) {
    return this.compose(ov, t, cv);
  }
  lookAt(t, e, i) {
    const r = this.elements;
    return ni.subVectors(t, e), ni.lengthSq() === 0 && (ni.z = 1), ni.normalize(), Cr.crossVectors(i, ni), Cr.lengthSq() === 0 && (Math.abs(i.z) === 1 ? ni.x += 1e-4 : ni.z += 1e-4, ni.normalize(), Cr.crossVectors(i, ni)), Cr.normalize(), yc.crossVectors(ni, Cr), r[0] = Cr.x, r[4] = yc.x, r[8] = ni.x, r[1] = Cr.y, r[5] = yc.y, r[9] = ni.y, r[2] = Cr.z, r[6] = yc.z, r[10] = ni.z, this;
  }
  multiply(t) {
    return this.multiplyMatrices(this, t);
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this);
  }
  multiplyMatrices(t, e) {
    const i = t.elements, r = e.elements, s = this.elements, a = i[0], o = i[4], c = i[8], h = i[12], l = i[1], f = i[5], d = i[9], m = i[13], v = i[2], E = i[6], _ = i[10], p = i[14], R = i[3], M = i[7], P = i[11], W = i[15], C = r[0], D = r[4], N = r[8], A = r[12], I = r[1], it = r[5], V = r[9], mt = r[13], k = r[2], B = r[6], G = r[10], H = r[14], w = r[3], ut = r[7], pt = r[11], _t = r[15];
    return s[0] = a * C + o * I + c * k + h * w, s[4] = a * D + o * it + c * B + h * ut, s[8] = a * N + o * V + c * G + h * pt, s[12] = a * A + o * mt + c * H + h * _t, s[1] = l * C + f * I + d * k + m * w, s[5] = l * D + f * it + d * B + m * ut, s[9] = l * N + f * V + d * G + m * pt, s[13] = l * A + f * mt + d * H + m * _t, s[2] = v * C + E * I + _ * k + p * w, s[6] = v * D + E * it + _ * B + p * ut, s[10] = v * N + E * V + _ * G + p * pt, s[14] = v * A + E * mt + _ * H + p * _t, s[3] = R * C + M * I + P * k + W * w, s[7] = R * D + M * it + P * B + W * ut, s[11] = R * N + M * V + P * G + W * pt, s[15] = R * A + M * mt + P * H + W * _t, this;
  }
  multiplyScalar(t) {
    const e = this.elements;
    return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this;
  }
  determinant() {
    const t = this.elements, e = t[0], i = t[4], r = t[8], s = t[12], a = t[1], o = t[5], c = t[9], h = t[13], l = t[2], f = t[6], d = t[10], m = t[14], v = t[3], E = t[7], _ = t[11], p = t[15];
    return v * (+s * c * f - r * h * f - s * o * d + i * h * d + r * o * m - i * c * m) + E * (+e * c * m - e * h * d + s * a * d - r * a * m + r * h * l - s * c * l) + _ * (+e * h * f - e * o * m - s * a * f + i * a * m + s * o * l - i * h * l) + p * (-r * o * l - e * c * f + e * o * d + r * a * f - i * a * d + i * c * l);
  }
  transpose() {
    const t = this.elements;
    let e;
    return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this;
  }
  setPosition(t, e, i) {
    const r = this.elements;
    return t.isVector3 ? (r[12] = t.x, r[13] = t.y, r[14] = t.z) : (r[12] = t, r[13] = e, r[14] = i), this;
  }
  invert() {
    const t = this.elements, e = t[0], i = t[1], r = t[2], s = t[3], a = t[4], o = t[5], c = t[6], h = t[7], l = t[8], f = t[9], d = t[10], m = t[11], v = t[12], E = t[13], _ = t[14], p = t[15], R = f * _ * h - E * d * h + E * c * m - o * _ * m - f * c * p + o * d * p, M = v * d * h - l * _ * h - v * c * m + a * _ * m + l * c * p - a * d * p, P = l * E * h - v * f * h + v * o * m - a * E * m - l * o * p + a * f * p, W = v * f * c - l * E * c - v * o * d + a * E * d + l * o * _ - a * f * _, C = e * R + i * M + r * P + s * W;
    if (C === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const D = 1 / C;
    return t[0] = R * D, t[1] = (E * d * s - f * _ * s - E * r * m + i * _ * m + f * r * p - i * d * p) * D, t[2] = (o * _ * s - E * c * s + E * r * h - i * _ * h - o * r * p + i * c * p) * D, t[3] = (f * c * s - o * d * s - f * r * h + i * d * h + o * r * m - i * c * m) * D, t[4] = M * D, t[5] = (l * _ * s - v * d * s + v * r * m - e * _ * m - l * r * p + e * d * p) * D, t[6] = (v * c * s - a * _ * s - v * r * h + e * _ * h + a * r * p - e * c * p) * D, t[7] = (a * d * s - l * c * s + l * r * h - e * d * h - a * r * m + e * c * m) * D, t[8] = P * D, t[9] = (v * f * s - l * E * s - v * i * m + e * E * m + l * i * p - e * f * p) * D, t[10] = (a * E * s - v * o * s + v * i * h - e * E * h - a * i * p + e * o * p) * D, t[11] = (l * o * s - a * f * s - l * i * h + e * f * h + a * i * m - e * o * m) * D, t[12] = W * D, t[13] = (l * E * r - v * f * r + v * i * d - e * E * d - l * i * _ + e * f * _) * D, t[14] = (v * o * r - a * E * r - v * i * c + e * E * c + a * i * _ - e * o * _) * D, t[15] = (a * f * r - l * o * r + l * i * c - e * f * c - a * i * d + e * o * d) * D, this;
  }
  scale(t) {
    const e = this.elements, i = t.x, r = t.y, s = t.z;
    return e[0] *= i, e[4] *= r, e[8] *= s, e[1] *= i, e[5] *= r, e[9] *= s, e[2] *= i, e[6] *= r, e[10] *= s, e[3] *= i, e[7] *= r, e[11] *= s, this;
  }
  getMaxScaleOnAxis() {
    const t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
    return Math.sqrt(Math.max(e, i, r));
  }
  makeTranslation(t, e, i) {
    return t.isVector3 ? this.set(
      1,
      0,
      0,
      t.x,
      0,
      1,
      0,
      t.y,
      0,
      0,
      1,
      t.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      t,
      0,
      1,
      0,
      e,
      0,
      0,
      1,
      i,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(t) {
    const e = Math.cos(t), i = Math.sin(t);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      e,
      -i,
      0,
      0,
      i,
      e,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(t) {
    const e = Math.cos(t), i = Math.sin(t);
    return this.set(
      e,
      0,
      i,
      0,
      0,
      1,
      0,
      0,
      -i,
      0,
      e,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(t) {
    const e = Math.cos(t), i = Math.sin(t);
    return this.set(
      e,
      -i,
      0,
      0,
      i,
      e,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(t, e) {
    const i = Math.cos(e), r = Math.sin(e), s = 1 - i, a = t.x, o = t.y, c = t.z, h = s * a, l = s * o;
    return this.set(
      h * a + i,
      h * o - r * c,
      h * c + r * o,
      0,
      h * o + r * c,
      l * o + i,
      l * c - r * a,
      0,
      h * c - r * o,
      l * c + r * a,
      s * c * c + i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(t, e, i) {
    return this.set(
      t,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(t, e, i, r, s, a) {
    return this.set(
      1,
      i,
      s,
      0,
      t,
      1,
      a,
      0,
      e,
      r,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(t, e, i) {
    const r = this.elements, s = e._x, a = e._y, o = e._z, c = e._w, h = s + s, l = a + a, f = o + o, d = s * h, m = s * l, v = s * f, E = a * l, _ = a * f, p = o * f, R = c * h, M = c * l, P = c * f, W = i.x, C = i.y, D = i.z;
    return r[0] = (1 - (E + p)) * W, r[1] = (m + P) * W, r[2] = (v - M) * W, r[3] = 0, r[4] = (m - P) * C, r[5] = (1 - (d + p)) * C, r[6] = (_ + R) * C, r[7] = 0, r[8] = (v + M) * D, r[9] = (_ - R) * D, r[10] = (1 - (d + E)) * D, r[11] = 0, r[12] = t.x, r[13] = t.y, r[14] = t.z, r[15] = 1, this;
  }
  decompose(t, e, i) {
    const r = this.elements;
    let s = Ws.set(r[0], r[1], r[2]).length();
    const a = Ws.set(r[4], r[5], r[6]).length(), o = Ws.set(r[8], r[9], r[10]).length();
    this.determinant() < 0 && (s = -s), t.x = r[12], t.y = r[13], t.z = r[14], xi.copy(this);
    const h = 1 / s, l = 1 / a, f = 1 / o;
    return xi.elements[0] *= h, xi.elements[1] *= h, xi.elements[2] *= h, xi.elements[4] *= l, xi.elements[5] *= l, xi.elements[6] *= l, xi.elements[8] *= f, xi.elements[9] *= f, xi.elements[10] *= f, e.setFromRotationMatrix(xi), i.x = s, i.y = a, i.z = o, this;
  }
  makePerspective(t, e, i, r, s, a, o = cr) {
    const c = this.elements, h = 2 * s / (e - t), l = 2 * s / (i - r), f = (e + t) / (e - t), d = (i + r) / (i - r);
    let m, v;
    if (o === cr)
      m = -(a + s) / (a - s), v = -2 * a * s / (a - s);
    else if (o === au)
      m = -a / (a - s), v = -a * s / (a - s);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o);
    return c[0] = h, c[4] = 0, c[8] = f, c[12] = 0, c[1] = 0, c[5] = l, c[9] = d, c[13] = 0, c[2] = 0, c[6] = 0, c[10] = m, c[14] = v, c[3] = 0, c[7] = 0, c[11] = -1, c[15] = 0, this;
  }
  makeOrthographic(t, e, i, r, s, a, o = cr) {
    const c = this.elements, h = 1 / (e - t), l = 1 / (i - r), f = 1 / (a - s), d = (e + t) * h, m = (i + r) * l;
    let v, E;
    if (o === cr)
      v = (a + s) * f, E = -2 * f;
    else if (o === au)
      v = s * f, E = -1 * f;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o);
    return c[0] = 2 * h, c[4] = 0, c[8] = 0, c[12] = -d, c[1] = 0, c[5] = 2 * l, c[9] = 0, c[13] = -m, c[2] = 0, c[6] = 0, c[10] = E, c[14] = -v, c[3] = 0, c[7] = 0, c[11] = 0, c[15] = 1, this;
  }
  equals(t) {
    const e = this.elements, i = t.elements;
    for (let r = 0; r < 16; r++)
      if (e[r] !== i[r])
        return !1;
    return !0;
  }
  fromArray(t, e = 0) {
    for (let i = 0; i < 16; i++)
      this.elements[i] = t[i + e];
    return this;
  }
  toArray(t = [], e = 0) {
    const i = this.elements;
    return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t;
  }
};
const Ws = /* @__PURE__ */ new Gt(), xi = /* @__PURE__ */ new vn(), ov = /* @__PURE__ */ new Gt(0, 0, 0), cv = /* @__PURE__ */ new Gt(1, 1, 1), Cr = /* @__PURE__ */ new Gt(), yc = /* @__PURE__ */ new Gt(), ni = /* @__PURE__ */ new Gt(), Eh = /* @__PURE__ */ new vn(), wh = /* @__PURE__ */ new Ea();
class hu {
  constructor(t = 0, e = 0, i = 0, r = hu.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = t, this._y = e, this._z = i, this._order = r;
  }
  get x() {
    return this._x;
  }
  set x(t) {
    this._x = t, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t) {
    this._y = t, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t) {
    this._z = t, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(t) {
    this._order = t, this._onChangeCallback();
  }
  set(t, e, i, r = this._order) {
    return this._x = t, this._y = e, this._z = i, this._order = r, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(t) {
    return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(t, e = this._order, i = !0) {
    const r = t.elements, s = r[0], a = r[4], o = r[8], c = r[1], h = r[5], l = r[9], f = r[2], d = r[6], m = r[10];
    switch (e) {
      case "XYZ":
        this._y = Math.asin(An(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(-l, m), this._z = Math.atan2(-a, s)) : (this._x = Math.atan2(d, h), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-An(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._y = Math.atan2(o, m), this._z = Math.atan2(c, h)) : (this._y = Math.atan2(-f, s), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(An(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._y = Math.atan2(-f, m), this._z = Math.atan2(-a, h)) : (this._y = 0, this._z = Math.atan2(c, s));
        break;
      case "ZYX":
        this._y = Math.asin(-An(f, -1, 1)), Math.abs(f) < 0.9999999 ? (this._x = Math.atan2(d, m), this._z = Math.atan2(c, s)) : (this._x = 0, this._z = Math.atan2(-a, h));
        break;
      case "YZX":
        this._z = Math.asin(An(c, -1, 1)), Math.abs(c) < 0.9999999 ? (this._x = Math.atan2(-l, h), this._y = Math.atan2(-f, s)) : (this._x = 0, this._y = Math.atan2(o, m));
        break;
      case "XZY":
        this._z = Math.asin(-An(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(d, h), this._y = Math.atan2(o, s)) : (this._x = Math.atan2(-l, m), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e);
    }
    return this._order = e, i === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(t, e, i) {
    return Eh.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Eh, e, i);
  }
  setFromVector3(t, e = this._order) {
    return this.set(t.x, t.y, t.z, e);
  }
  reorder(t) {
    return wh.setFromEuler(this), this.setFromQuaternion(wh, t);
  }
  equals(t) {
    return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
  }
  fromArray(t) {
    return this._x = t[0], this._y = t[1], this._z = t[2], t[3] !== void 0 && (this._order = t[3]), this._onChangeCallback(), this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t;
  }
  _onChange(t) {
    return this._onChangeCallback = t, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
hu.DEFAULT_ORDER = "XYZ";
class Td {
  constructor() {
    this.mask = 1;
  }
  set(t) {
    this.mask = (1 << t | 0) >>> 0;
  }
  enable(t) {
    this.mask |= 1 << t | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(t) {
    this.mask ^= 1 << t | 0;
  }
  disable(t) {
    this.mask &= ~(1 << t | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(t) {
    return (this.mask & t.mask) !== 0;
  }
  isEnabled(t) {
    return (this.mask & (1 << t | 0)) !== 0;
  }
}
let uv = 0;
const Mh = /* @__PURE__ */ new Gt(), qs = /* @__PURE__ */ new Ea(), er = /* @__PURE__ */ new vn(), gc = /* @__PURE__ */ new Gt(), La = /* @__PURE__ */ new Gt(), lv = /* @__PURE__ */ new Gt(), fv = /* @__PURE__ */ new Ea(), Sh = /* @__PURE__ */ new Gt(1, 0, 0), Ah = /* @__PURE__ */ new Gt(0, 1, 0), Th = /* @__PURE__ */ new Gt(0, 0, 1), hv = { type: "added" }, pv = { type: "removed" };
class oi extends Is {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: uv++ }), this.uuid = Ps(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = oi.DEFAULT_UP.clone();
    const t = new Gt(), e = new hu(), i = new Ea(), r = new Gt(1, 1, 1);
    function s() {
      i.setFromEuler(e, !1);
    }
    function a() {
      e.setFromQuaternion(i, void 0, !1);
    }
    e._onChange(s), i._onChange(a), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: r
      },
      modelViewMatrix: {
        value: new vn()
      },
      normalMatrix: {
        value: new Oe()
      }
    }), this.matrix = new vn(), this.matrixWorld = new vn(), this.matrixAutoUpdate = oi.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = oi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new Td(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(t) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(t) {
    return this.quaternion.premultiply(t), this;
  }
  setRotationFromAxisAngle(t, e) {
    this.quaternion.setFromAxisAngle(t, e);
  }
  setRotationFromEuler(t) {
    this.quaternion.setFromEuler(t, !0);
  }
  setRotationFromMatrix(t) {
    this.quaternion.setFromRotationMatrix(t);
  }
  setRotationFromQuaternion(t) {
    this.quaternion.copy(t);
  }
  rotateOnAxis(t, e) {
    return qs.setFromAxisAngle(t, e), this.quaternion.multiply(qs), this;
  }
  rotateOnWorldAxis(t, e) {
    return qs.setFromAxisAngle(t, e), this.quaternion.premultiply(qs), this;
  }
  rotateX(t) {
    return this.rotateOnAxis(Sh, t);
  }
  rotateY(t) {
    return this.rotateOnAxis(Ah, t);
  }
  rotateZ(t) {
    return this.rotateOnAxis(Th, t);
  }
  translateOnAxis(t, e) {
    return Mh.copy(t).applyQuaternion(this.quaternion), this.position.add(Mh.multiplyScalar(e)), this;
  }
  translateX(t) {
    return this.translateOnAxis(Sh, t);
  }
  translateY(t) {
    return this.translateOnAxis(Ah, t);
  }
  translateZ(t) {
    return this.translateOnAxis(Th, t);
  }
  localToWorld(t) {
    return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(t) {
    return this.updateWorldMatrix(!0, !1), t.applyMatrix4(er.copy(this.matrixWorld).invert());
  }
  lookAt(t, e, i) {
    t.isVector3 ? gc.copy(t) : gc.set(t, e, i);
    const r = this.parent;
    this.updateWorldMatrix(!0, !1), La.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? er.lookAt(La, gc, this.up) : er.lookAt(gc, La, this.up), this.quaternion.setFromRotationMatrix(er), r && (er.extractRotation(r.matrixWorld), qs.setFromRotationMatrix(er), this.quaternion.premultiply(qs.invert()));
  }
  add(t) {
    if (arguments.length > 1) {
      for (let e = 0; e < arguments.length; e++)
        this.add(arguments[e]);
      return this;
    }
    return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (t.parent !== null && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(hv)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this);
  }
  remove(t) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++)
        this.remove(arguments[i]);
      return this;
    }
    const e = this.children.indexOf(t);
    return e !== -1 && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(pv)), this;
  }
  removeFromParent() {
    const t = this.parent;
    return t !== null && t.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(t) {
    return this.updateWorldMatrix(!0, !1), er.copy(this.matrixWorld).invert(), t.parent !== null && (t.parent.updateWorldMatrix(!0, !1), er.multiply(t.parent.matrixWorld)), t.applyMatrix4(er), this.add(t), t.updateWorldMatrix(!1, !0), this;
  }
  getObjectById(t) {
    return this.getObjectByProperty("id", t);
  }
  getObjectByName(t) {
    return this.getObjectByProperty("name", t);
  }
  getObjectByProperty(t, e) {
    if (this[t] === e)
      return this;
    for (let i = 0, r = this.children.length; i < r; i++) {
      const a = this.children[i].getObjectByProperty(t, e);
      if (a !== void 0)
        return a;
    }
  }
  getObjectsByProperty(t, e, i = []) {
    this[t] === e && i.push(this);
    const r = this.children;
    for (let s = 0, a = r.length; s < a; s++)
      r[s].getObjectsByProperty(t, e, i);
    return i;
  }
  getWorldPosition(t) {
    return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(t) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(La, t, lv), t;
  }
  getWorldScale(t) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(La, fv, t), t;
  }
  getWorldDirection(t) {
    this.updateWorldMatrix(!0, !1);
    const e = this.matrixWorld.elements;
    return t.set(e[8], e[9], e[10]).normalize();
  }
  raycast() {
  }
  traverse(t) {
    t(this);
    const e = this.children;
    for (let i = 0, r = e.length; i < r; i++)
      e[i].traverse(t);
  }
  traverseVisible(t) {
    if (this.visible === !1)
      return;
    t(this);
    const e = this.children;
    for (let i = 0, r = e.length; i < r; i++)
      e[i].traverseVisible(t);
  }
  traverseAncestors(t) {
    const e = this.parent;
    e !== null && (t(e), e.traverseAncestors(t));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(t) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
    const e = this.children;
    for (let i = 0, r = e.length; i < r; i++) {
      const s = e[i];
      (s.matrixWorldAutoUpdate === !0 || t === !0) && s.updateMatrixWorld(t);
    }
  }
  updateWorldMatrix(t, e) {
    const i = this.parent;
    if (t === !0 && i !== null && i.matrixWorldAutoUpdate === !0 && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), e === !0) {
      const r = this.children;
      for (let s = 0, a = r.length; s < a; s++) {
        const o = r[s];
        o.matrixWorldAutoUpdate === !0 && o.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == "string", i = {};
    e && (t = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, i.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const r = {};
    r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (r.type = "BatchedMesh", r.perObjectFrustumCulled = this.perObjectFrustumCulled, r.sortObjects = this.sortObjects, r.drawRanges = this._drawRanges, r.reservedRanges = this._reservedRanges, r.visibility = this._visibility, r.active = this._active, r.bounds = this._bounds.map((o) => ({
      boxInitialized: o.boxInitialized,
      boxMin: o.box.min.toArray(),
      boxMax: o.box.max.toArray(),
      sphereInitialized: o.sphereInitialized,
      sphereRadius: o.sphere.radius,
      sphereCenter: o.sphere.center.toArray()
    })), r.maxGeometryCount = this._maxGeometryCount, r.maxVertexCount = this._maxVertexCount, r.maxIndexCount = this._maxIndexCount, r.geometryInitialized = this._geometryInitialized, r.geometryCount = this._geometryCount, r.matricesTexture = this._matricesTexture.toJSON(t), this.boundingSphere !== null && (r.boundingSphere = {
      center: r.boundingSphere.center.toArray(),
      radius: r.boundingSphere.radius
    }), this.boundingBox !== null && (r.boundingBox = {
      min: r.boundingBox.min.toArray(),
      max: r.boundingBox.max.toArray()
    }));
    function s(o, c) {
      return o[c.uuid] === void 0 && (o[c.uuid] = c.toJSON(t)), c.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(t).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = s(t.geometries, this.geometry);
      const o = this.geometry.parameters;
      if (o !== void 0 && o.shapes !== void 0) {
        const c = o.shapes;
        if (Array.isArray(c))
          for (let h = 0, l = c.length; h < l; h++) {
            const f = c[h];
            s(t.shapes, f);
          }
        else
          s(t.shapes, c);
      }
    }
    if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(t.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const o = [];
        for (let c = 0, h = this.material.length; c < h; c++)
          o.push(s(t.materials, this.material[c]));
        r.material = o;
      } else
        r.material = s(t.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let o = 0; o < this.children.length; o++)
        r.children.push(this.children[o].toJSON(t).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let o = 0; o < this.animations.length; o++) {
        const c = this.animations[o];
        r.animations.push(s(t.animations, c));
      }
    }
    if (e) {
      const o = a(t.geometries), c = a(t.materials), h = a(t.textures), l = a(t.images), f = a(t.shapes), d = a(t.skeletons), m = a(t.animations), v = a(t.nodes);
      o.length > 0 && (i.geometries = o), c.length > 0 && (i.materials = c), h.length > 0 && (i.textures = h), l.length > 0 && (i.images = l), f.length > 0 && (i.shapes = f), d.length > 0 && (i.skeletons = d), m.length > 0 && (i.animations = m), v.length > 0 && (i.nodes = v);
    }
    return i.object = r, i;
    function a(o) {
      const c = [];
      for (const h in o) {
        const l = o[h];
        delete l.metadata, c.push(l);
      }
      return c;
    }
  }
  clone(t) {
    return new this.constructor().copy(this, t);
  }
  copy(t, e = !0) {
    if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.animations = t.animations.slice(), this.userData = JSON.parse(JSON.stringify(t.userData)), e === !0)
      for (let i = 0; i < t.children.length; i++) {
        const r = t.children[i];
        this.add(r.clone());
      }
    return this;
  }
}
oi.DEFAULT_UP = /* @__PURE__ */ new Gt(0, 1, 0);
oi.DEFAULT_MATRIX_AUTO_UPDATE = !0;
oi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const bi = /* @__PURE__ */ new Gt(), nr = /* @__PURE__ */ new Gt(), Bu = /* @__PURE__ */ new Gt(), ir = /* @__PURE__ */ new Gt(), $s = /* @__PURE__ */ new Gt(), Xs = /* @__PURE__ */ new Gt(), Ch = /* @__PURE__ */ new Gt(), ku = /* @__PURE__ */ new Gt(), zu = /* @__PURE__ */ new Gt(), Gu = /* @__PURE__ */ new Gt();
let vc = !1;
class wi {
  constructor(t = new Gt(), e = new Gt(), i = new Gt()) {
    this.a = t, this.b = e, this.c = i;
  }
  static getNormal(t, e, i, r) {
    r.subVectors(i, e), bi.subVectors(t, e), r.cross(bi);
    const s = r.lengthSq();
    return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(t, e, i, r, s) {
    bi.subVectors(r, e), nr.subVectors(i, e), Bu.subVectors(t, e);
    const a = bi.dot(bi), o = bi.dot(nr), c = bi.dot(Bu), h = nr.dot(nr), l = nr.dot(Bu), f = a * h - o * o;
    if (f === 0)
      return s.set(0, 0, 0), null;
    const d = 1 / f, m = (h * c - o * l) * d, v = (a * l - o * c) * d;
    return s.set(1 - m - v, v, m);
  }
  static containsPoint(t, e, i, r) {
    return this.getBarycoord(t, e, i, r, ir) === null ? !1 : ir.x >= 0 && ir.y >= 0 && ir.x + ir.y <= 1;
  }
  static getUV(t, e, i, r, s, a, o, c) {
    return vc === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), vc = !0), this.getInterpolation(t, e, i, r, s, a, o, c);
  }
  static getInterpolation(t, e, i, r, s, a, o, c) {
    return this.getBarycoord(t, e, i, r, ir) === null ? (c.x = 0, c.y = 0, "z" in c && (c.z = 0), "w" in c && (c.w = 0), null) : (c.setScalar(0), c.addScaledVector(s, ir.x), c.addScaledVector(a, ir.y), c.addScaledVector(o, ir.z), c);
  }
  static isFrontFacing(t, e, i, r) {
    return bi.subVectors(i, e), nr.subVectors(t, e), bi.cross(nr).dot(r) < 0;
  }
  set(t, e, i) {
    return this.a.copy(t), this.b.copy(e), this.c.copy(i), this;
  }
  setFromPointsAndIndices(t, e, i, r) {
    return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[r]), this;
  }
  setFromAttributeAndIndices(t, e, i, r) {
    return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, i), this.c.fromBufferAttribute(t, r), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
  }
  getArea() {
    return bi.subVectors(this.c, this.b), nr.subVectors(this.a, this.b), bi.cross(nr).length() * 0.5;
  }
  getMidpoint(t) {
    return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(t) {
    return wi.getNormal(this.a, this.b, this.c, t);
  }
  getPlane(t) {
    return t.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(t, e) {
    return wi.getBarycoord(t, this.a, this.b, this.c, e);
  }
  getUV(t, e, i, r, s) {
    return vc === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), vc = !0), wi.getInterpolation(t, this.a, this.b, this.c, e, i, r, s);
  }
  getInterpolation(t, e, i, r, s) {
    return wi.getInterpolation(t, this.a, this.b, this.c, e, i, r, s);
  }
  containsPoint(t) {
    return wi.containsPoint(t, this.a, this.b, this.c);
  }
  isFrontFacing(t) {
    return wi.isFrontFacing(this.a, this.b, this.c, t);
  }
  intersectsBox(t) {
    return t.intersectsTriangle(this);
  }
  closestPointToPoint(t, e) {
    const i = this.a, r = this.b, s = this.c;
    let a, o;
    $s.subVectors(r, i), Xs.subVectors(s, i), ku.subVectors(t, i);
    const c = $s.dot(ku), h = Xs.dot(ku);
    if (c <= 0 && h <= 0)
      return e.copy(i);
    zu.subVectors(t, r);
    const l = $s.dot(zu), f = Xs.dot(zu);
    if (l >= 0 && f <= l)
      return e.copy(r);
    const d = c * f - l * h;
    if (d <= 0 && c >= 0 && l <= 0)
      return a = c / (c - l), e.copy(i).addScaledVector($s, a);
    Gu.subVectors(t, s);
    const m = $s.dot(Gu), v = Xs.dot(Gu);
    if (v >= 0 && m <= v)
      return e.copy(s);
    const E = m * h - c * v;
    if (E <= 0 && h >= 0 && v <= 0)
      return o = h / (h - v), e.copy(i).addScaledVector(Xs, o);
    const _ = l * v - m * f;
    if (_ <= 0 && f - l >= 0 && m - v >= 0)
      return Ch.subVectors(s, r), o = (f - l) / (f - l + (m - v)), e.copy(r).addScaledVector(Ch, o);
    const p = 1 / (_ + E + d);
    return a = E * p, o = d * p, e.copy(i).addScaledVector($s, a).addScaledVector(Xs, o);
  }
  equals(t) {
    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
  }
}
const Cd = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, Rr = { h: 0, s: 0, l: 0 }, xc = { h: 0, s: 0, l: 0 };
function Vu(n, t, e) {
  return e < 0 && (e += 1), e > 1 && (e -= 1), e < 1 / 6 ? n + (t - n) * 6 * e : e < 1 / 2 ? t : e < 2 / 3 ? n + (t - n) * 6 * (2 / 3 - e) : n;
}
class Ue {
  constructor(t, e, i) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(t, e, i);
  }
  set(t, e, i) {
    if (e === void 0 && i === void 0) {
      const r = t;
      r && r.isColor ? this.copy(r) : typeof r == "number" ? this.setHex(r) : typeof r == "string" && this.setStyle(r);
    } else
      this.setRGB(t, e, i);
    return this;
  }
  setScalar(t) {
    return this.r = t, this.g = t, this.b = t, this;
  }
  setHex(t, e = yn) {
    return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (t & 255) / 255, Ke.toWorkingColorSpace(this, e), this;
  }
  setRGB(t, e, i, r = Ke.workingColorSpace) {
    return this.r = t, this.g = e, this.b = i, Ke.toWorkingColorSpace(this, r), this;
  }
  setHSL(t, e, i, r = Ke.workingColorSpace) {
    if (t = Yl(t, 1), e = An(e, 0, 1), i = An(i, 0, 1), e === 0)
      this.r = this.g = this.b = i;
    else {
      const s = i <= 0.5 ? i * (1 + e) : i + e - i * e, a = 2 * i - s;
      this.r = Vu(a, s, t + 1 / 3), this.g = Vu(a, s, t), this.b = Vu(a, s, t - 1 / 3);
    }
    return Ke.toWorkingColorSpace(this, r), this;
  }
  setStyle(t, e = yn) {
    function i(s) {
      s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.");
    }
    let r;
    if (r = /^(\w+)\(([^\)]*)\)/.exec(t)) {
      let s;
      const a = r[1], o = r[2];
      switch (a) {
        case "rgb":
        case "rgba":
          if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
            return i(s[4]), this.setRGB(
              Math.min(255, parseInt(s[1], 10)) / 255,
              Math.min(255, parseInt(s[2], 10)) / 255,
              Math.min(255, parseInt(s[3], 10)) / 255,
              e
            );
          if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
            return i(s[4]), this.setRGB(
              Math.min(100, parseInt(s[1], 10)) / 100,
              Math.min(100, parseInt(s[2], 10)) / 100,
              Math.min(100, parseInt(s[3], 10)) / 100,
              e
            );
          break;
        case "hsl":
        case "hsla":
          if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
            return i(s[4]), this.setHSL(
              parseFloat(s[1]) / 360,
              parseFloat(s[2]) / 100,
              parseFloat(s[3]) / 100,
              e
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + t);
      }
    } else if (r = /^\#([A-Fa-f\d]+)$/.exec(t)) {
      const s = r[1], a = s.length;
      if (a === 3)
        return this.setRGB(
          parseInt(s.charAt(0), 16) / 15,
          parseInt(s.charAt(1), 16) / 15,
          parseInt(s.charAt(2), 16) / 15,
          e
        );
      if (a === 6)
        return this.setHex(parseInt(s, 16), e);
      console.warn("THREE.Color: Invalid hex color " + t);
    } else if (t && t.length > 0)
      return this.setColorName(t, e);
    return this;
  }
  setColorName(t, e = yn) {
    const i = Cd[t.toLowerCase()];
    return i !== void 0 ? this.setHex(i, e) : console.warn("THREE.Color: Unknown color " + t), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(t) {
    return this.r = t.r, this.g = t.g, this.b = t.b, this;
  }
  copySRGBToLinear(t) {
    return this.r = pa(t.r), this.g = pa(t.g), this.b = pa(t.b), this;
  }
  copyLinearToSRGB(t) {
    return this.r = Iu(t.r), this.g = Iu(t.g), this.b = Iu(t.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(t = yn) {
    return Ke.fromWorkingColorSpace(Un.copy(this), t), Math.round(An(Un.r * 255, 0, 255)) * 65536 + Math.round(An(Un.g * 255, 0, 255)) * 256 + Math.round(An(Un.b * 255, 0, 255));
  }
  getHexString(t = yn) {
    return ("000000" + this.getHex(t).toString(16)).slice(-6);
  }
  getHSL(t, e = Ke.workingColorSpace) {
    Ke.fromWorkingColorSpace(Un.copy(this), e);
    const i = Un.r, r = Un.g, s = Un.b, a = Math.max(i, r, s), o = Math.min(i, r, s);
    let c, h;
    const l = (o + a) / 2;
    if (o === a)
      c = 0, h = 0;
    else {
      const f = a - o;
      switch (h = l <= 0.5 ? f / (a + o) : f / (2 - a - o), a) {
        case i:
          c = (r - s) / f + (r < s ? 6 : 0);
          break;
        case r:
          c = (s - i) / f + 2;
          break;
        case s:
          c = (i - r) / f + 4;
          break;
      }
      c /= 6;
    }
    return t.h = c, t.s = h, t.l = l, t;
  }
  getRGB(t, e = Ke.workingColorSpace) {
    return Ke.fromWorkingColorSpace(Un.copy(this), e), t.r = Un.r, t.g = Un.g, t.b = Un.b, t;
  }
  getStyle(t = yn) {
    Ke.fromWorkingColorSpace(Un.copy(this), t);
    const e = Un.r, i = Un.g, r = Un.b;
    return t !== yn ? `color(${t} ${e.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})` : `rgb(${Math.round(e * 255)},${Math.round(i * 255)},${Math.round(r * 255)})`;
  }
  offsetHSL(t, e, i) {
    return this.getHSL(Rr), this.setHSL(Rr.h + t, Rr.s + e, Rr.l + i);
  }
  add(t) {
    return this.r += t.r, this.g += t.g, this.b += t.b, this;
  }
  addColors(t, e) {
    return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this;
  }
  addScalar(t) {
    return this.r += t, this.g += t, this.b += t, this;
  }
  sub(t) {
    return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this;
  }
  multiply(t) {
    return this.r *= t.r, this.g *= t.g, this.b *= t.b, this;
  }
  multiplyScalar(t) {
    return this.r *= t, this.g *= t, this.b *= t, this;
  }
  lerp(t, e) {
    return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this;
  }
  lerpColors(t, e, i) {
    return this.r = t.r + (e.r - t.r) * i, this.g = t.g + (e.g - t.g) * i, this.b = t.b + (e.b - t.b) * i, this;
  }
  lerpHSL(t, e) {
    this.getHSL(Rr), t.getHSL(xc);
    const i = Ha(Rr.h, xc.h, e), r = Ha(Rr.s, xc.s, e), s = Ha(Rr.l, xc.l, e);
    return this.setHSL(i, r, s), this;
  }
  setFromVector3(t) {
    return this.r = t.x, this.g = t.y, this.b = t.z, this;
  }
  applyMatrix3(t) {
    const e = this.r, i = this.g, r = this.b, s = t.elements;
    return this.r = s[0] * e + s[3] * i + s[6] * r, this.g = s[1] * e + s[4] * i + s[7] * r, this.b = s[2] * e + s[5] * i + s[8] * r, this;
  }
  equals(t) {
    return t.r === this.r && t.g === this.g && t.b === this.b;
  }
  fromArray(t, e = 0) {
    return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t;
  }
  fromBufferAttribute(t, e) {
    return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const Un = /* @__PURE__ */ new Ue();
Ue.NAMES = Cd;
let dv = 0;
class co extends Is {
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: dv++ }), this.uuid = Ps(), this.name = "", this.type = "Material", this.blending = ha, this.side = Hr, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = yl, this.blendDst = gl, this.blendEquation = Es, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Ue(0, 0, 0), this.blendAlpha = 0, this.depthFunc = tu, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = dh, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = zs, this.stencilZFail = zs, this.stencilZPass = zs, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(t) {
    this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(t) {
    if (t !== void 0)
      for (const e in t) {
        const i = t[e];
        if (i === void 0) {
          console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);
          continue;
        }
        const r = this[e];
        if (r === void 0) {
          console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`);
          continue;
        }
        r && r.isColor ? r.set(i) : r && r.isVector3 && i && i.isVector3 ? r.copy(i) : this[e] = i;
      }
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == "string";
    e && (t = {
      textures: {},
      images: {}
    });
    const i = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(t).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid), this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(t).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(t).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(t).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(t).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(t).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(t).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(t).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(t).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(t).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(t).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== ha && (i.blending = this.blending), this.side !== Hr && (i.side = this.side), this.vertexColors === !0 && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === !0 && (i.transparent = !0), this.blendSrc !== yl && (i.blendSrc = this.blendSrc), this.blendDst !== gl && (i.blendDst = this.blendDst), this.blendEquation !== Es && (i.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha), this.depthFunc !== tu && (i.depthFunc = this.depthFunc), this.depthTest === !1 && (i.depthTest = this.depthTest), this.depthWrite === !1 && (i.depthWrite = this.depthWrite), this.colorWrite === !1 && (i.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== dh && (i.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (i.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== zs && (i.stencilFail = this.stencilFail), this.stencilZFail !== zs && (i.stencilZFail = this.stencilZFail), this.stencilZPass !== zs && (i.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === !0 && (i.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === !0 && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaHash === !0 && (i.alphaHash = !0), this.alphaToCoverage === !0 && (i.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0), this.forceSinglePass === !0 && (i.forceSinglePass = !0), this.wireframe === !0 && (i.wireframe = !0), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (i.flatShading = !0), this.visible === !1 && (i.visible = !1), this.toneMapped === !1 && (i.toneMapped = !1), this.fog === !1 && (i.fog = !1), Object.keys(this.userData).length > 0 && (i.userData = this.userData);
    function r(s) {
      const a = [];
      for (const o in s) {
        const c = s[o];
        delete c.metadata, a.push(c);
      }
      return a;
    }
    if (e) {
      const s = r(t.textures), a = r(t.images);
      s.length > 0 && (i.textures = s), a.length > 0 && (i.images = a);
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    this.name = t.name, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.blendColor.copy(t.blendColor), this.blendAlpha = t.blendAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
    const e = t.clippingPlanes;
    let i = null;
    if (e !== null) {
      const r = e.length;
      i = new Array(r);
      for (let s = 0; s !== r; ++s)
        i[s] = e[s].clone();
    }
    return this.clippingPlanes = i, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaHash = t.alphaHash, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.forceSinglePass = t.forceSinglePass, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(t) {
    t === !0 && this.version++;
  }
}
class Rd extends co {
  constructor(t) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Ue(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = fd, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this;
  }
}
const _n = /* @__PURE__ */ new Gt(), bc = /* @__PURE__ */ new fe();
class gn {
  constructor(t, e, i = !1) {
    if (Array.isArray(t))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = t, this.itemSize = e, this.count = t !== void 0 ? t.length / e : 0, this.normalized = i, this.usage = mh, this._updateRange = { offset: 0, count: -1 }, this.updateRanges = [], this.gpuType = Fr, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(t) {
    t === !0 && this.version++;
  }
  get updateRange() {
    return console.warn("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
  }
  setUsage(t) {
    return this.usage = t, this;
  }
  addUpdateRange(t, e) {
    this.updateRanges.push({ start: t, count: e });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(t) {
    return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this.gpuType = t.gpuType, this;
  }
  copyAt(t, e, i) {
    t *= this.itemSize, i *= e.itemSize;
    for (let r = 0, s = this.itemSize; r < s; r++)
      this.array[t + r] = e.array[i + r];
    return this;
  }
  copyArray(t) {
    return this.array.set(t), this;
  }
  applyMatrix3(t) {
    if (this.itemSize === 2)
      for (let e = 0, i = this.count; e < i; e++)
        bc.fromBufferAttribute(this, e), bc.applyMatrix3(t), this.setXY(e, bc.x, bc.y);
    else if (this.itemSize === 3)
      for (let e = 0, i = this.count; e < i; e++)
        _n.fromBufferAttribute(this, e), _n.applyMatrix3(t), this.setXYZ(e, _n.x, _n.y, _n.z);
    return this;
  }
  applyMatrix4(t) {
    for (let e = 0, i = this.count; e < i; e++)
      _n.fromBufferAttribute(this, e), _n.applyMatrix4(t), this.setXYZ(e, _n.x, _n.y, _n.z);
    return this;
  }
  applyNormalMatrix(t) {
    for (let e = 0, i = this.count; e < i; e++)
      _n.fromBufferAttribute(this, e), _n.applyNormalMatrix(t), this.setXYZ(e, _n.x, _n.y, _n.z);
    return this;
  }
  transformDirection(t) {
    for (let e = 0, i = this.count; e < i; e++)
      _n.fromBufferAttribute(this, e), _n.transformDirection(t), this.setXYZ(e, _n.x, _n.y, _n.z);
    return this;
  }
  set(t, e = 0) {
    return this.array.set(t, e), this;
  }
  getComponent(t, e) {
    let i = this.array[t * this.itemSize + e];
    return this.normalized && (i = aa(i, this.array)), i;
  }
  setComponent(t, e, i) {
    return this.normalized && (i = Hn(i, this.array)), this.array[t * this.itemSize + e] = i, this;
  }
  getX(t) {
    let e = this.array[t * this.itemSize];
    return this.normalized && (e = aa(e, this.array)), e;
  }
  setX(t, e) {
    return this.normalized && (e = Hn(e, this.array)), this.array[t * this.itemSize] = e, this;
  }
  getY(t) {
    let e = this.array[t * this.itemSize + 1];
    return this.normalized && (e = aa(e, this.array)), e;
  }
  setY(t, e) {
    return this.normalized && (e = Hn(e, this.array)), this.array[t * this.itemSize + 1] = e, this;
  }
  getZ(t) {
    let e = this.array[t * this.itemSize + 2];
    return this.normalized && (e = aa(e, this.array)), e;
  }
  setZ(t, e) {
    return this.normalized && (e = Hn(e, this.array)), this.array[t * this.itemSize + 2] = e, this;
  }
  getW(t) {
    let e = this.array[t * this.itemSize + 3];
    return this.normalized && (e = aa(e, this.array)), e;
  }
  setW(t, e) {
    return this.normalized && (e = Hn(e, this.array)), this.array[t * this.itemSize + 3] = e, this;
  }
  setXY(t, e, i) {
    return t *= this.itemSize, this.normalized && (e = Hn(e, this.array), i = Hn(i, this.array)), this.array[t + 0] = e, this.array[t + 1] = i, this;
  }
  setXYZ(t, e, i, r) {
    return t *= this.itemSize, this.normalized && (e = Hn(e, this.array), i = Hn(i, this.array), r = Hn(r, this.array)), this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = r, this;
  }
  setXYZW(t, e, i, r, s) {
    return t *= this.itemSize, this.normalized && (e = Hn(e, this.array), i = Hn(i, this.array), r = Hn(r, this.array), s = Hn(s, this.array)), this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = r, this.array[t + 3] = s, this;
  }
  onUpload(t) {
    return this.onUploadCallback = t, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const t = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (t.name = this.name), this.usage !== mh && (t.usage = this.usage), t;
  }
}
class Id extends gn {
  constructor(t, e, i) {
    super(new Uint16Array(t), e, i);
  }
}
class Pd extends gn {
  constructor(t, e, i) {
    super(new Uint32Array(t), e, i);
  }
}
class ur extends gn {
  constructor(t, e, i) {
    super(new Float32Array(t), e, i);
  }
}
let mv = 0;
const pi = /* @__PURE__ */ new vn(), Hu = /* @__PURE__ */ new oi(), Ys = /* @__PURE__ */ new Gt(), ii = /* @__PURE__ */ new oo(), Oa = /* @__PURE__ */ new oo(), Mn = /* @__PURE__ */ new Gt();
class fr extends Is {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: mv++ }), this.uuid = Ps(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(t) {
    return Array.isArray(t) ? this.index = new (Md(t) ? Pd : Id)(t, 1) : this.index = t, this;
  }
  getAttribute(t) {
    return this.attributes[t];
  }
  setAttribute(t, e) {
    return this.attributes[t] = e, this;
  }
  deleteAttribute(t) {
    return delete this.attributes[t], this;
  }
  hasAttribute(t) {
    return this.attributes[t] !== void 0;
  }
  addGroup(t, e, i = 0) {
    this.groups.push({
      start: t,
      count: e,
      materialIndex: i
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(t, e) {
    this.drawRange.start = t, this.drawRange.count = e;
  }
  applyMatrix4(t) {
    const e = this.attributes.position;
    e !== void 0 && (e.applyMatrix4(t), e.needsUpdate = !0);
    const i = this.attributes.normal;
    if (i !== void 0) {
      const s = new Oe().getNormalMatrix(t);
      i.applyNormalMatrix(s), i.needsUpdate = !0;
    }
    const r = this.attributes.tangent;
    return r !== void 0 && (r.transformDirection(t), r.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(t) {
    return pi.makeRotationFromQuaternion(t), this.applyMatrix4(pi), this;
  }
  rotateX(t) {
    return pi.makeRotationX(t), this.applyMatrix4(pi), this;
  }
  rotateY(t) {
    return pi.makeRotationY(t), this.applyMatrix4(pi), this;
  }
  rotateZ(t) {
    return pi.makeRotationZ(t), this.applyMatrix4(pi), this;
  }
  translate(t, e, i) {
    return pi.makeTranslation(t, e, i), this.applyMatrix4(pi), this;
  }
  scale(t, e, i) {
    return pi.makeScale(t, e, i), this.applyMatrix4(pi), this;
  }
  lookAt(t) {
    return Hu.lookAt(t), Hu.updateMatrix(), this.applyMatrix4(Hu.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Ys).negate(), this.translate(Ys.x, Ys.y, Ys.z), this;
  }
  setFromPoints(t) {
    const e = [];
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      e.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute("position", new ur(e, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new oo());
    const t = this.attributes.position, e = this.morphAttributes.position;
    if (t && t.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(
        new Gt(-1 / 0, -1 / 0, -1 / 0),
        new Gt(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (t !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(t), e)
        for (let i = 0, r = e.length; i < r; i++) {
          const s = e[i];
          ii.setFromBufferAttribute(s), this.morphTargetsRelative ? (Mn.addVectors(this.boundingBox.min, ii.min), this.boundingBox.expandByPoint(Mn), Mn.addVectors(this.boundingBox.max, ii.max), this.boundingBox.expandByPoint(Mn)) : (this.boundingBox.expandByPoint(ii.min), this.boundingBox.expandByPoint(ii.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Zl());
    const t = this.attributes.position, e = this.morphAttributes.position;
    if (t && t.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new Gt(), 1 / 0);
      return;
    }
    if (t) {
      const i = this.boundingSphere.center;
      if (ii.setFromBufferAttribute(t), e)
        for (let s = 0, a = e.length; s < a; s++) {
          const o = e[s];
          Oa.setFromBufferAttribute(o), this.morphTargetsRelative ? (Mn.addVectors(ii.min, Oa.min), ii.expandByPoint(Mn), Mn.addVectors(ii.max, Oa.max), ii.expandByPoint(Mn)) : (ii.expandByPoint(Oa.min), ii.expandByPoint(Oa.max));
        }
      ii.getCenter(i);
      let r = 0;
      for (let s = 0, a = t.count; s < a; s++)
        Mn.fromBufferAttribute(t, s), r = Math.max(r, i.distanceToSquared(Mn));
      if (e)
        for (let s = 0, a = e.length; s < a; s++) {
          const o = e[s], c = this.morphTargetsRelative;
          for (let h = 0, l = o.count; h < l; h++)
            Mn.fromBufferAttribute(o, h), c && (Ys.fromBufferAttribute(t, h), Mn.add(Ys)), r = Math.max(r, i.distanceToSquared(Mn));
        }
      this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const t = this.index, e = this.attributes;
    if (t === null || e.position === void 0 || e.normal === void 0 || e.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const i = t.array, r = e.position.array, s = e.normal.array, a = e.uv.array, o = r.length / 3;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new gn(new Float32Array(4 * o), 4));
    const c = this.getAttribute("tangent").array, h = [], l = [];
    for (let I = 0; I < o; I++)
      h[I] = new Gt(), l[I] = new Gt();
    const f = new Gt(), d = new Gt(), m = new Gt(), v = new fe(), E = new fe(), _ = new fe(), p = new Gt(), R = new Gt();
    function M(I, it, V) {
      f.fromArray(r, I * 3), d.fromArray(r, it * 3), m.fromArray(r, V * 3), v.fromArray(a, I * 2), E.fromArray(a, it * 2), _.fromArray(a, V * 2), d.sub(f), m.sub(f), E.sub(v), _.sub(v);
      const mt = 1 / (E.x * _.y - _.x * E.y);
      isFinite(mt) && (p.copy(d).multiplyScalar(_.y).addScaledVector(m, -E.y).multiplyScalar(mt), R.copy(m).multiplyScalar(E.x).addScaledVector(d, -_.x).multiplyScalar(mt), h[I].add(p), h[it].add(p), h[V].add(p), l[I].add(R), l[it].add(R), l[V].add(R));
    }
    let P = this.groups;
    P.length === 0 && (P = [{
      start: 0,
      count: i.length
    }]);
    for (let I = 0, it = P.length; I < it; ++I) {
      const V = P[I], mt = V.start, k = V.count;
      for (let B = mt, G = mt + k; B < G; B += 3)
        M(
          i[B + 0],
          i[B + 1],
          i[B + 2]
        );
    }
    const W = new Gt(), C = new Gt(), D = new Gt(), N = new Gt();
    function A(I) {
      D.fromArray(s, I * 3), N.copy(D);
      const it = h[I];
      W.copy(it), W.sub(D.multiplyScalar(D.dot(it))).normalize(), C.crossVectors(N, it);
      const mt = C.dot(l[I]) < 0 ? -1 : 1;
      c[I * 4] = W.x, c[I * 4 + 1] = W.y, c[I * 4 + 2] = W.z, c[I * 4 + 3] = mt;
    }
    for (let I = 0, it = P.length; I < it; ++I) {
      const V = P[I], mt = V.start, k = V.count;
      for (let B = mt, G = mt + k; B < G; B += 3)
        A(i[B + 0]), A(i[B + 1]), A(i[B + 2]);
    }
  }
  computeVertexNormals() {
    const t = this.index, e = this.getAttribute("position");
    if (e !== void 0) {
      let i = this.getAttribute("normal");
      if (i === void 0)
        i = new gn(new Float32Array(e.count * 3), 3), this.setAttribute("normal", i);
      else
        for (let d = 0, m = i.count; d < m; d++)
          i.setXYZ(d, 0, 0, 0);
      const r = new Gt(), s = new Gt(), a = new Gt(), o = new Gt(), c = new Gt(), h = new Gt(), l = new Gt(), f = new Gt();
      if (t)
        for (let d = 0, m = t.count; d < m; d += 3) {
          const v = t.getX(d + 0), E = t.getX(d + 1), _ = t.getX(d + 2);
          r.fromBufferAttribute(e, v), s.fromBufferAttribute(e, E), a.fromBufferAttribute(e, _), l.subVectors(a, s), f.subVectors(r, s), l.cross(f), o.fromBufferAttribute(i, v), c.fromBufferAttribute(i, E), h.fromBufferAttribute(i, _), o.add(l), c.add(l), h.add(l), i.setXYZ(v, o.x, o.y, o.z), i.setXYZ(E, c.x, c.y, c.z), i.setXYZ(_, h.x, h.y, h.z);
        }
      else
        for (let d = 0, m = e.count; d < m; d += 3)
          r.fromBufferAttribute(e, d + 0), s.fromBufferAttribute(e, d + 1), a.fromBufferAttribute(e, d + 2), l.subVectors(a, s), f.subVectors(r, s), l.cross(f), i.setXYZ(d + 0, l.x, l.y, l.z), i.setXYZ(d + 1, l.x, l.y, l.z), i.setXYZ(d + 2, l.x, l.y, l.z);
      this.normalizeNormals(), i.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const t = this.attributes.normal;
    for (let e = 0, i = t.count; e < i; e++)
      Mn.fromBufferAttribute(t, e), Mn.normalize(), t.setXYZ(e, Mn.x, Mn.y, Mn.z);
  }
  toNonIndexed() {
    function t(o, c) {
      const h = o.array, l = o.itemSize, f = o.normalized, d = new h.constructor(c.length * l);
      let m = 0, v = 0;
      for (let E = 0, _ = c.length; E < _; E++) {
        o.isInterleavedBufferAttribute ? m = c[E] * o.data.stride + o.offset : m = c[E] * l;
        for (let p = 0; p < l; p++)
          d[v++] = h[m++];
      }
      return new gn(d, l, f);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const e = new fr(), i = this.index.array, r = this.attributes;
    for (const o in r) {
      const c = r[o], h = t(c, i);
      e.setAttribute(o, h);
    }
    const s = this.morphAttributes;
    for (const o in s) {
      const c = [], h = s[o];
      for (let l = 0, f = h.length; l < f; l++) {
        const d = h[l], m = t(d, i);
        c.push(m);
      }
      e.morphAttributes[o] = c;
    }
    e.morphTargetsRelative = this.morphTargetsRelative;
    const a = this.groups;
    for (let o = 0, c = a.length; o < c; o++) {
      const h = a[o];
      e.addGroup(h.start, h.count, h.materialIndex);
    }
    return e;
  }
  toJSON() {
    const t = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (t.uuid = this.uuid, t.type = this.type, this.name !== "" && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), this.parameters !== void 0) {
      const c = this.parameters;
      for (const h in c)
        c[h] !== void 0 && (t[h] = c[h]);
      return t;
    }
    t.data = { attributes: {} };
    const e = this.index;
    e !== null && (t.data.index = {
      type: e.array.constructor.name,
      array: Array.prototype.slice.call(e.array)
    });
    const i = this.attributes;
    for (const c in i) {
      const h = i[c];
      t.data.attributes[c] = h.toJSON(t.data);
    }
    const r = {};
    let s = !1;
    for (const c in this.morphAttributes) {
      const h = this.morphAttributes[c], l = [];
      for (let f = 0, d = h.length; f < d; f++) {
        const m = h[f];
        l.push(m.toJSON(t.data));
      }
      l.length > 0 && (r[c] = l, s = !0);
    }
    s && (t.data.morphAttributes = r, t.data.morphTargetsRelative = this.morphTargetsRelative);
    const a = this.groups;
    a.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(a)));
    const o = this.boundingSphere;
    return o !== null && (t.data.boundingSphere = {
      center: o.center.toArray(),
      radius: o.radius
    }), t;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const e = {};
    this.name = t.name;
    const i = t.index;
    i !== null && this.setIndex(i.clone(e));
    const r = t.attributes;
    for (const h in r) {
      const l = r[h];
      this.setAttribute(h, l.clone(e));
    }
    const s = t.morphAttributes;
    for (const h in s) {
      const l = [], f = s[h];
      for (let d = 0, m = f.length; d < m; d++)
        l.push(f[d].clone(e));
      this.morphAttributes[h] = l;
    }
    this.morphTargetsRelative = t.morphTargetsRelative;
    const a = t.groups;
    for (let h = 0, l = a.length; h < l; h++) {
      const f = a[h];
      this.addGroup(f.start, f.count, f.materialIndex);
    }
    const o = t.boundingBox;
    o !== null && (this.boundingBox = o.clone());
    const c = t.boundingSphere;
    return c !== null && (this.boundingSphere = c.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const Rh = /* @__PURE__ */ new vn(), _s = /* @__PURE__ */ new av(), Ec = /* @__PURE__ */ new Zl(), Ih = /* @__PURE__ */ new Gt(), Ks = /* @__PURE__ */ new Gt(), Zs = /* @__PURE__ */ new Gt(), Js = /* @__PURE__ */ new Gt(), ju = /* @__PURE__ */ new Gt(), wc = /* @__PURE__ */ new Gt(), Mc = /* @__PURE__ */ new fe(), Sc = /* @__PURE__ */ new fe(), Ac = /* @__PURE__ */ new fe(), Ph = /* @__PURE__ */ new Gt(), Lh = /* @__PURE__ */ new Gt(), Oh = /* @__PURE__ */ new Gt(), Tc = /* @__PURE__ */ new Gt(), Cc = /* @__PURE__ */ new Gt();
class Bi extends oi {
  constructor(t = new fr(), e = new Rd()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets();
  }
  copy(t, e) {
    return super.copy(t, e), t.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), t.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this;
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes, i = Object.keys(e);
    if (i.length > 0) {
      const r = e[i[0]];
      if (r !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, a = r.length; s < a; s++) {
          const o = r[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = s;
        }
      }
    }
  }
  getVertexPosition(t, e) {
    const i = this.geometry, r = i.attributes.position, s = i.morphAttributes.position, a = i.morphTargetsRelative;
    e.fromBufferAttribute(r, t);
    const o = this.morphTargetInfluences;
    if (s && o) {
      wc.set(0, 0, 0);
      for (let c = 0, h = s.length; c < h; c++) {
        const l = o[c], f = s[c];
        l !== 0 && (ju.fromBufferAttribute(f, t), a ? wc.addScaledVector(ju, l) : wc.addScaledVector(ju.sub(e), l));
      }
      e.add(wc);
    }
    return e;
  }
  raycast(t, e) {
    const i = this.geometry, r = this.material, s = this.matrixWorld;
    r !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(), Ec.copy(i.boundingSphere), Ec.applyMatrix4(s), _s.copy(t.ray).recast(t.near), !(Ec.containsPoint(_s.origin) === !1 && (_s.intersectSphere(Ec, Ih) === null || _s.origin.distanceToSquared(Ih) > (t.far - t.near) ** 2)) && (Rh.copy(s).invert(), _s.copy(t.ray).applyMatrix4(Rh), !(i.boundingBox !== null && _s.intersectsBox(i.boundingBox) === !1) && this._computeIntersections(t, e, _s)));
  }
  _computeIntersections(t, e, i) {
    let r;
    const s = this.geometry, a = this.material, o = s.index, c = s.attributes.position, h = s.attributes.uv, l = s.attributes.uv1, f = s.attributes.normal, d = s.groups, m = s.drawRange;
    if (o !== null)
      if (Array.isArray(a))
        for (let v = 0, E = d.length; v < E; v++) {
          const _ = d[v], p = a[_.materialIndex], R = Math.max(_.start, m.start), M = Math.min(o.count, Math.min(_.start + _.count, m.start + m.count));
          for (let P = R, W = M; P < W; P += 3) {
            const C = o.getX(P), D = o.getX(P + 1), N = o.getX(P + 2);
            r = Rc(this, p, t, i, h, l, f, C, D, N), r && (r.faceIndex = Math.floor(P / 3), r.face.materialIndex = _.materialIndex, e.push(r));
          }
        }
      else {
        const v = Math.max(0, m.start), E = Math.min(o.count, m.start + m.count);
        for (let _ = v, p = E; _ < p; _ += 3) {
          const R = o.getX(_), M = o.getX(_ + 1), P = o.getX(_ + 2);
          r = Rc(this, a, t, i, h, l, f, R, M, P), r && (r.faceIndex = Math.floor(_ / 3), e.push(r));
        }
      }
    else if (c !== void 0)
      if (Array.isArray(a))
        for (let v = 0, E = d.length; v < E; v++) {
          const _ = d[v], p = a[_.materialIndex], R = Math.max(_.start, m.start), M = Math.min(c.count, Math.min(_.start + _.count, m.start + m.count));
          for (let P = R, W = M; P < W; P += 3) {
            const C = P, D = P + 1, N = P + 2;
            r = Rc(this, p, t, i, h, l, f, C, D, N), r && (r.faceIndex = Math.floor(P / 3), r.face.materialIndex = _.materialIndex, e.push(r));
          }
        }
      else {
        const v = Math.max(0, m.start), E = Math.min(c.count, m.start + m.count);
        for (let _ = v, p = E; _ < p; _ += 3) {
          const R = _, M = _ + 1, P = _ + 2;
          r = Rc(this, a, t, i, h, l, f, R, M, P), r && (r.faceIndex = Math.floor(_ / 3), e.push(r));
        }
      }
  }
}
function _v(n, t, e, i, r, s, a, o) {
  let c;
  if (t.side === Zn ? c = i.intersectTriangle(a, s, r, !0, o) : c = i.intersectTriangle(r, s, a, t.side === Hr, o), c === null)
    return null;
  Cc.copy(o), Cc.applyMatrix4(n.matrixWorld);
  const h = e.ray.origin.distanceTo(Cc);
  return h < e.near || h > e.far ? null : {
    distance: h,
    point: Cc.clone(),
    object: n
  };
}
function Rc(n, t, e, i, r, s, a, o, c, h) {
  n.getVertexPosition(o, Ks), n.getVertexPosition(c, Zs), n.getVertexPosition(h, Js);
  const l = _v(n, t, e, i, Ks, Zs, Js, Tc);
  if (l) {
    r && (Mc.fromBufferAttribute(r, o), Sc.fromBufferAttribute(r, c), Ac.fromBufferAttribute(r, h), l.uv = wi.getInterpolation(Tc, Ks, Zs, Js, Mc, Sc, Ac, new fe())), s && (Mc.fromBufferAttribute(s, o), Sc.fromBufferAttribute(s, c), Ac.fromBufferAttribute(s, h), l.uv1 = wi.getInterpolation(Tc, Ks, Zs, Js, Mc, Sc, Ac, new fe()), l.uv2 = l.uv1), a && (Ph.fromBufferAttribute(a, o), Lh.fromBufferAttribute(a, c), Oh.fromBufferAttribute(a, h), l.normal = wi.getInterpolation(Tc, Ks, Zs, Js, Ph, Lh, Oh, new Gt()), l.normal.dot(i.direction) > 0 && l.normal.multiplyScalar(-1));
    const f = {
      a: o,
      b: c,
      c: h,
      normal: new Gt(),
      materialIndex: 0
    };
    wi.getNormal(Ks, Zs, Js, f.normal), l.face = f;
  }
  return l;
}
class uo extends fr {
  constructor(t = 1, e = 1, i = 1, r = 1, s = 1, a = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: t,
      height: e,
      depth: i,
      widthSegments: r,
      heightSegments: s,
      depthSegments: a
    };
    const o = this;
    r = Math.floor(r), s = Math.floor(s), a = Math.floor(a);
    const c = [], h = [], l = [], f = [];
    let d = 0, m = 0;
    v("z", "y", "x", -1, -1, i, e, t, a, s, 0), v("z", "y", "x", 1, -1, i, e, -t, a, s, 1), v("x", "z", "y", 1, 1, t, i, e, r, a, 2), v("x", "z", "y", 1, -1, t, i, -e, r, a, 3), v("x", "y", "z", 1, -1, t, e, i, r, s, 4), v("x", "y", "z", -1, -1, t, e, -i, r, s, 5), this.setIndex(c), this.setAttribute("position", new ur(h, 3)), this.setAttribute("normal", new ur(l, 3)), this.setAttribute("uv", new ur(f, 2));
    function v(E, _, p, R, M, P, W, C, D, N, A) {
      const I = P / D, it = W / N, V = P / 2, mt = W / 2, k = C / 2, B = D + 1, G = N + 1;
      let H = 0, w = 0;
      const ut = new Gt();
      for (let pt = 0; pt < G; pt++) {
        const _t = pt * it - mt;
        for (let vt = 0; vt < B; vt++) {
          const F = vt * I - V;
          ut[E] = F * R, ut[_] = _t * M, ut[p] = k, h.push(ut.x, ut.y, ut.z), ut[E] = 0, ut[_] = 0, ut[p] = C > 0 ? 1 : -1, l.push(ut.x, ut.y, ut.z), f.push(vt / D), f.push(1 - pt / N), H += 1;
        }
      }
      for (let pt = 0; pt < N; pt++)
        for (let _t = 0; _t < D; _t++) {
          const vt = d + _t + B * pt, F = d + _t + B * (pt + 1), rt = d + (_t + 1) + B * (pt + 1), b = d + (_t + 1) + B * pt;
          c.push(vt, F, b), c.push(F, rt, b), w += 6;
        }
      o.addGroup(m, w, A), m += w, d += H;
    }
  }
  copy(t) {
    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
  }
  static fromJSON(t) {
    return new uo(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments);
  }
}
function va(n) {
  const t = {};
  for (const e in n) {
    t[e] = {};
    for (const i in n[e]) {
      const r = n[e][i];
      r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), t[e][i] = null) : t[e][i] = r.clone() : Array.isArray(r) ? t[e][i] = r.slice() : t[e][i] = r;
    }
  }
  return t;
}
function jn(n) {
  const t = {};
  for (let e = 0; e < n.length; e++) {
    const i = va(n[e]);
    for (const r in i)
      t[r] = i[r];
  }
  return t;
}
function yv(n) {
  const t = [];
  for (let e = 0; e < n.length; e++)
    t.push(n[e].clone());
  return t;
}
function Ld(n) {
  return n.getRenderTarget() === null ? n.outputColorSpace : Ke.workingColorSpace;
}
const gv = { clone: va, merge: jn };
var vv = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, xv = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class jr extends co {
  constructor(t) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = vv, this.fragmentShader = xv, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      derivatives: !1,
      // set to use derivatives
      fragDepth: !1,
      // set to use fragment depth values
      drawBuffers: !1,
      // set to use draw buffers
      shaderTextureLOD: !1,
      // set to use shader texture LOD
      clipCullDistance: !1
      // set to use vertex shader clipping
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, t !== void 0 && this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = va(t.uniforms), this.uniformsGroups = yv(t.uniformsGroups), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.fog = t.fog, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this;
  }
  toJSON(t) {
    const e = super.toJSON(t);
    e.glslVersion = this.glslVersion, e.uniforms = {};
    for (const r in this.uniforms) {
      const a = this.uniforms[r].value;
      a && a.isTexture ? e.uniforms[r] = {
        type: "t",
        value: a.toJSON(t).uuid
      } : a && a.isColor ? e.uniforms[r] = {
        type: "c",
        value: a.getHex()
      } : a && a.isVector2 ? e.uniforms[r] = {
        type: "v2",
        value: a.toArray()
      } : a && a.isVector3 ? e.uniforms[r] = {
        type: "v3",
        value: a.toArray()
      } : a && a.isVector4 ? e.uniforms[r] = {
        type: "v4",
        value: a.toArray()
      } : a && a.isMatrix3 ? e.uniforms[r] = {
        type: "m3",
        value: a.toArray()
      } : a && a.isMatrix4 ? e.uniforms[r] = {
        type: "m4",
        value: a.toArray()
      } : e.uniforms[r] = {
        value: a
      };
    }
    Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e.lights = this.lights, e.clipping = this.clipping;
    const i = {};
    for (const r in this.extensions)
      this.extensions[r] === !0 && (i[r] = !0);
    return Object.keys(i).length > 0 && (e.extensions = i), e;
  }
}
class Od extends oi {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new vn(), this.projectionMatrix = new vn(), this.projectionMatrixInverse = new vn(), this.coordinateSystem = cr;
  }
  copy(t, e) {
    return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this.coordinateSystem = t.coordinateSystem, this;
  }
  getWorldDirection(t) {
    return super.getWorldDirection(t).negate();
  }
  updateMatrixWorld(t) {
    super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(t, e) {
    super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class di extends Od {
  constructor(t = 50, e = 1, i = 0.1, r = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = i, this.far = r, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(t, e) {
    return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = t.view === null ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(t) {
    const e = 0.5 * this.getFilmHeight() / t;
    this.fov = Ja * 2 * Math.atan(e), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const t = Math.tan(Va * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / t;
  }
  getEffectiveFOV() {
    return Ja * 2 * Math.atan(
      Math.tan(Va * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(t, e, i, r, s, a) {
    this.aspect = t / e, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = r, this.view.width = s, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const t = this.near;
    let e = t * Math.tan(Va * 0.5 * this.fov) / this.zoom, i = 2 * e, r = this.aspect * i, s = -0.5 * r;
    const a = this.view;
    if (this.view !== null && this.view.enabled) {
      const c = a.fullWidth, h = a.fullHeight;
      s += a.offsetX * r / c, e -= a.offsetY * i / h, r *= a.width / c, i *= a.height / h;
    }
    const o = this.filmOffset;
    o !== 0 && (s += t * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + r, e, e - i, t, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, this.view !== null && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e;
  }
}
const Qs = -90, ta = 1;
class bv extends oi {
  constructor(t, e, i) {
    super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const r = new di(Qs, ta, t, e);
    r.layers = this.layers, this.add(r);
    const s = new di(Qs, ta, t, e);
    s.layers = this.layers, this.add(s);
    const a = new di(Qs, ta, t, e);
    a.layers = this.layers, this.add(a);
    const o = new di(Qs, ta, t, e);
    o.layers = this.layers, this.add(o);
    const c = new di(Qs, ta, t, e);
    c.layers = this.layers, this.add(c);
    const h = new di(Qs, ta, t, e);
    h.layers = this.layers, this.add(h);
  }
  updateCoordinateSystem() {
    const t = this.coordinateSystem, e = this.children.concat(), [i, r, s, a, o, c] = e;
    for (const h of e)
      this.remove(h);
    if (t === cr)
      i.up.set(0, 1, 0), i.lookAt(1, 0, 0), r.up.set(0, 1, 0), r.lookAt(-1, 0, 0), s.up.set(0, 0, -1), s.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), o.up.set(0, 1, 0), o.lookAt(0, 0, 1), c.up.set(0, 1, 0), c.lookAt(0, 0, -1);
    else if (t === au)
      i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), r.up.set(0, -1, 0), r.lookAt(1, 0, 0), s.up.set(0, 0, 1), s.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), o.up.set(0, -1, 0), o.lookAt(0, 0, 1), c.up.set(0, -1, 0), c.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + t);
    for (const h of e)
      this.add(h), h.updateMatrixWorld();
  }
  update(t, e) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: i, activeMipmapLevel: r } = this;
    this.coordinateSystem !== t.coordinateSystem && (this.coordinateSystem = t.coordinateSystem, this.updateCoordinateSystem());
    const [s, a, o, c, h, l] = this.children, f = t.getRenderTarget(), d = t.getActiveCubeFace(), m = t.getActiveMipmapLevel(), v = t.xr.enabled;
    t.xr.enabled = !1;
    const E = i.texture.generateMipmaps;
    i.texture.generateMipmaps = !1, t.setRenderTarget(i, 0, r), t.render(e, s), t.setRenderTarget(i, 1, r), t.render(e, a), t.setRenderTarget(i, 2, r), t.render(e, o), t.setRenderTarget(i, 3, r), t.render(e, c), t.setRenderTarget(i, 4, r), t.render(e, h), i.texture.generateMipmaps = E, t.setRenderTarget(i, 5, r), t.render(e, l), t.setRenderTarget(f, d, m), t.xr.enabled = v, i.texture.needsPMREMUpdate = !0;
  }
}
class Dd extends qn {
  constructor(t, e, i, r, s, a, o, c, h, l) {
    t = t !== void 0 ? t : [], e = e !== void 0 ? e : ma, super(t, e, i, r, s, a, o, c, h, l), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(t) {
    this.image = t;
  }
}
class Ev extends Cs {
  constructor(t = 1, e = {}) {
    super(t, t, e), this.isWebGLCubeRenderTarget = !0;
    const i = { width: t, height: t, depth: 1 }, r = [i, i, i, i, i, i];
    e.encoding !== void 0 && (ja("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."), e.colorSpace = e.encoding === As ? yn : si), this.texture = new Dd(r, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = e.generateMipmaps !== void 0 ? e.generateMipmaps : !1, this.texture.minFilter = e.minFilter !== void 0 ? e.minFilter : ri;
  }
  fromEquirectangularTexture(t, e) {
    this.texture.type = e.type, this.texture.colorSpace = e.colorSpace, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
    const i = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, r = new uo(5, 5, 5), s = new jr({
      name: "CubemapFromEquirect",
      uniforms: va(i.uniforms),
      vertexShader: i.vertexShader,
      fragmentShader: i.fragmentShader,
      side: Zn,
      blending: kr
    });
    s.uniforms.tEquirect.value = e;
    const a = new Bi(r, s), o = e.minFilter;
    return e.minFilter === ya && (e.minFilter = ri), new bv(1, 10, this).update(t, a), e.minFilter = o, a.geometry.dispose(), a.material.dispose(), this;
  }
  clear(t, e, i, r) {
    const s = t.getRenderTarget();
    for (let a = 0; a < 6; a++)
      t.setRenderTarget(this, a), t.clear(e, i, r);
    t.setRenderTarget(s);
  }
}
const Wu = /* @__PURE__ */ new Gt(), wv = /* @__PURE__ */ new Gt(), Mv = /* @__PURE__ */ new Oe();
class xs {
  constructor(t = new Gt(1, 0, 0), e = 0) {
    this.isPlane = !0, this.normal = t, this.constant = e;
  }
  set(t, e) {
    return this.normal.copy(t), this.constant = e, this;
  }
  setComponents(t, e, i, r) {
    return this.normal.set(t, e, i), this.constant = r, this;
  }
  setFromNormalAndCoplanarPoint(t, e) {
    return this.normal.copy(t), this.constant = -e.dot(this.normal), this;
  }
  setFromCoplanarPoints(t, e, i) {
    const r = Wu.subVectors(i, e).cross(wv.subVectors(t, e)).normalize();
    return this.setFromNormalAndCoplanarPoint(r, t), this;
  }
  copy(t) {
    return this.normal.copy(t.normal), this.constant = t.constant, this;
  }
  normalize() {
    const t = 1 / this.normal.length();
    return this.normal.multiplyScalar(t), this.constant *= t, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(t) {
    return this.normal.dot(t) + this.constant;
  }
  distanceToSphere(t) {
    return this.distanceToPoint(t.center) - t.radius;
  }
  projectPoint(t, e) {
    return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t));
  }
  intersectLine(t, e) {
    const i = t.delta(Wu), r = this.normal.dot(i);
    if (r === 0)
      return this.distanceToPoint(t.start) === 0 ? e.copy(t.start) : null;
    const s = -(t.start.dot(this.normal) + this.constant) / r;
    return s < 0 || s > 1 ? null : e.copy(t.start).addScaledVector(i, s);
  }
  intersectsLine(t) {
    const e = this.distanceToPoint(t.start), i = this.distanceToPoint(t.end);
    return e < 0 && i > 0 || i < 0 && e > 0;
  }
  intersectsBox(t) {
    return t.intersectsPlane(this);
  }
  intersectsSphere(t) {
    return t.intersectsPlane(this);
  }
  coplanarPoint(t) {
    return t.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(t, e) {
    const i = e || Mv.getNormalMatrix(t), r = this.coplanarPoint(Wu).applyMatrix4(t), s = this.normal.applyMatrix3(i).normalize();
    return this.constant = -r.dot(s), this;
  }
  translate(t) {
    return this.constant -= t.dot(this.normal), this;
  }
  equals(t) {
    return t.normal.equals(this.normal) && t.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const ys = /* @__PURE__ */ new Zl(), Ic = /* @__PURE__ */ new Gt();
class Nd {
  constructor(t = new xs(), e = new xs(), i = new xs(), r = new xs(), s = new xs(), a = new xs()) {
    this.planes = [t, e, i, r, s, a];
  }
  set(t, e, i, r, s, a) {
    const o = this.planes;
    return o[0].copy(t), o[1].copy(e), o[2].copy(i), o[3].copy(r), o[4].copy(s), o[5].copy(a), this;
  }
  copy(t) {
    const e = this.planes;
    for (let i = 0; i < 6; i++)
      e[i].copy(t.planes[i]);
    return this;
  }
  setFromProjectionMatrix(t, e = cr) {
    const i = this.planes, r = t.elements, s = r[0], a = r[1], o = r[2], c = r[3], h = r[4], l = r[5], f = r[6], d = r[7], m = r[8], v = r[9], E = r[10], _ = r[11], p = r[12], R = r[13], M = r[14], P = r[15];
    if (i[0].setComponents(c - s, d - h, _ - m, P - p).normalize(), i[1].setComponents(c + s, d + h, _ + m, P + p).normalize(), i[2].setComponents(c + a, d + l, _ + v, P + R).normalize(), i[3].setComponents(c - a, d - l, _ - v, P - R).normalize(), i[4].setComponents(c - o, d - f, _ - E, P - M).normalize(), e === cr)
      i[5].setComponents(c + o, d + f, _ + E, P + M).normalize();
    else if (e === au)
      i[5].setComponents(o, f, E, M).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + e);
    return this;
  }
  intersectsObject(t) {
    if (t.boundingSphere !== void 0)
      t.boundingSphere === null && t.computeBoundingSphere(), ys.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
    else {
      const e = t.geometry;
      e.boundingSphere === null && e.computeBoundingSphere(), ys.copy(e.boundingSphere).applyMatrix4(t.matrixWorld);
    }
    return this.intersectsSphere(ys);
  }
  intersectsSprite(t) {
    return ys.center.set(0, 0, 0), ys.radius = 0.7071067811865476, ys.applyMatrix4(t.matrixWorld), this.intersectsSphere(ys);
  }
  intersectsSphere(t) {
    const e = this.planes, i = t.center, r = -t.radius;
    for (let s = 0; s < 6; s++)
      if (e[s].distanceToPoint(i) < r)
        return !1;
    return !0;
  }
  intersectsBox(t) {
    const e = this.planes;
    for (let i = 0; i < 6; i++) {
      const r = e[i];
      if (Ic.x = r.normal.x > 0 ? t.max.x : t.min.x, Ic.y = r.normal.y > 0 ? t.max.y : t.min.y, Ic.z = r.normal.z > 0 ? t.max.z : t.min.z, r.distanceToPoint(Ic) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(t) {
    const e = this.planes;
    for (let i = 0; i < 6; i++)
      if (e[i].distanceToPoint(t) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function Fd() {
  let n = null, t = !1, e = null, i = null;
  function r(s, a) {
    e(s, a), i = n.requestAnimationFrame(r);
  }
  return {
    start: function() {
      t !== !0 && e !== null && (i = n.requestAnimationFrame(r), t = !0);
    },
    stop: function() {
      n.cancelAnimationFrame(i), t = !1;
    },
    setAnimationLoop: function(s) {
      e = s;
    },
    setContext: function(s) {
      n = s;
    }
  };
}
function Sv(n, t) {
  const e = t.isWebGL2, i = /* @__PURE__ */ new WeakMap();
  function r(h, l) {
    const f = h.array, d = h.usage, m = f.byteLength, v = n.createBuffer();
    n.bindBuffer(l, v), n.bufferData(l, f, d), h.onUploadCallback();
    let E;
    if (f instanceof Float32Array)
      E = n.FLOAT;
    else if (f instanceof Uint16Array)
      if (h.isFloat16BufferAttribute)
        if (e)
          E = n.HALF_FLOAT;
        else
          throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
      else
        E = n.UNSIGNED_SHORT;
    else if (f instanceof Int16Array)
      E = n.SHORT;
    else if (f instanceof Uint32Array)
      E = n.UNSIGNED_INT;
    else if (f instanceof Int32Array)
      E = n.INT;
    else if (f instanceof Int8Array)
      E = n.BYTE;
    else if (f instanceof Uint8Array)
      E = n.UNSIGNED_BYTE;
    else if (f instanceof Uint8ClampedArray)
      E = n.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + f);
    return {
      buffer: v,
      type: E,
      bytesPerElement: f.BYTES_PER_ELEMENT,
      version: h.version,
      size: m
    };
  }
  function s(h, l, f) {
    const d = l.array, m = l._updateRange, v = l.updateRanges;
    if (n.bindBuffer(f, h), m.count === -1 && v.length === 0 && n.bufferSubData(f, 0, d), v.length !== 0) {
      for (let E = 0, _ = v.length; E < _; E++) {
        const p = v[E];
        e ? n.bufferSubData(
          f,
          p.start * d.BYTES_PER_ELEMENT,
          d,
          p.start,
          p.count
        ) : n.bufferSubData(
          f,
          p.start * d.BYTES_PER_ELEMENT,
          d.subarray(p.start, p.start + p.count)
        );
      }
      l.clearUpdateRanges();
    }
    m.count !== -1 && (e ? n.bufferSubData(
      f,
      m.offset * d.BYTES_PER_ELEMENT,
      d,
      m.offset,
      m.count
    ) : n.bufferSubData(
      f,
      m.offset * d.BYTES_PER_ELEMENT,
      d.subarray(m.offset, m.offset + m.count)
    ), m.count = -1), l.onUploadCallback();
  }
  function a(h) {
    return h.isInterleavedBufferAttribute && (h = h.data), i.get(h);
  }
  function o(h) {
    h.isInterleavedBufferAttribute && (h = h.data);
    const l = i.get(h);
    l && (n.deleteBuffer(l.buffer), i.delete(h));
  }
  function c(h, l) {
    if (h.isGLBufferAttribute) {
      const d = i.get(h);
      (!d || d.version < h.version) && i.set(h, {
        buffer: h.buffer,
        type: h.type,
        bytesPerElement: h.elementSize,
        version: h.version
      });
      return;
    }
    h.isInterleavedBufferAttribute && (h = h.data);
    const f = i.get(h);
    if (f === void 0)
      i.set(h, r(h, l));
    else if (f.version < h.version) {
      if (f.size !== h.array.byteLength)
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      s(f.buffer, h, l), f.version = h.version;
    }
  }
  return {
    get: a,
    remove: o,
    update: c
  };
}
class pu extends fr {
  constructor(t = 1, e = 1, i = 1, r = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: t,
      height: e,
      widthSegments: i,
      heightSegments: r
    };
    const s = t / 2, a = e / 2, o = Math.floor(i), c = Math.floor(r), h = o + 1, l = c + 1, f = t / o, d = e / c, m = [], v = [], E = [], _ = [];
    for (let p = 0; p < l; p++) {
      const R = p * d - a;
      for (let M = 0; M < h; M++) {
        const P = M * f - s;
        v.push(P, -R, 0), E.push(0, 0, 1), _.push(M / o), _.push(1 - p / c);
      }
    }
    for (let p = 0; p < c; p++)
      for (let R = 0; R < o; R++) {
        const M = R + h * p, P = R + h * (p + 1), W = R + 1 + h * (p + 1), C = R + 1 + h * p;
        m.push(M, P, C), m.push(P, W, C);
      }
    this.setIndex(m), this.setAttribute("position", new ur(v, 3)), this.setAttribute("normal", new ur(E, 3)), this.setAttribute("uv", new ur(_, 2));
  }
  copy(t) {
    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
  }
  static fromJSON(t) {
    return new pu(t.width, t.height, t.widthSegments, t.heightSegments);
  }
}
var Av = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, Tv = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, Cv = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, Rv = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, Iv = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`, Pv = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, Lv = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, Ov = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, Dv = `#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, Nv = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`, Fv = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, Uv = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, Bv = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, kv = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, zv = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, Gv = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, Vv = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, Hv = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, jv = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, Wv = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, qv = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, $v = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, Xv = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, Yv = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, Kv = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, Zv = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, Jv = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, Qv = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, tx = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, ex = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, nx = "gl_FragColor = linearToOutputTexel( gl_FragColor );", ix = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`, rx = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, sx = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, ax = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, ox = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, cx = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, ux = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, lx = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, fx = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, hx = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, px = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, dx = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, mx = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, _x = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, yx = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, gx = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, vx = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, xx = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, bx = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, Ex = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, wx = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, Mx = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, Sx = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, Ax = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, Tx = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, Cx = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, Rx = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, Ix = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, Px = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, Lx = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, Ox = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, Dx = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, Nx = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, Fx = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, Ux = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, Bx = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, kx = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, zx = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, Gx = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, Vx = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, Hx = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, jx = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, Wx = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, qx = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, $x = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, Xx = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, Yx = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, Kx = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, Zx = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, Jx = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, Qx = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, tb = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, eb = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, nb = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, ib = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, rb = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, sb = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, ab = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, ob = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, cb = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, ub = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, lb = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, fb = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, hb = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, pb = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, db = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, mb = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, _b = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, yb = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, gb = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color *= toneMappingExposure;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	return color;
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, vb = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, xb = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, bb = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, Eb = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, wb = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, Mb = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const Sb = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, Ab = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Tb = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, Cb = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Rb = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, Ib = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Pb = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, Lb = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, Ob = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, Db = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, Nb = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, Fb = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Ub = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, Bb = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, kb = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, zb = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Gb = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Vb = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Hb = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, jb = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Wb = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, qb = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, $b = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Xb = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Yb = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, Kb = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Zb = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Jb = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Qb = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, t1 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, e1 = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, n1 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, i1 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, r1 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Re = {
  alphahash_fragment: Av,
  alphahash_pars_fragment: Tv,
  alphamap_fragment: Cv,
  alphamap_pars_fragment: Rv,
  alphatest_fragment: Iv,
  alphatest_pars_fragment: Pv,
  aomap_fragment: Lv,
  aomap_pars_fragment: Ov,
  batching_pars_vertex: Dv,
  batching_vertex: Nv,
  begin_vertex: Fv,
  beginnormal_vertex: Uv,
  bsdfs: Bv,
  iridescence_fragment: kv,
  bumpmap_pars_fragment: zv,
  clipping_planes_fragment: Gv,
  clipping_planes_pars_fragment: Vv,
  clipping_planes_pars_vertex: Hv,
  clipping_planes_vertex: jv,
  color_fragment: Wv,
  color_pars_fragment: qv,
  color_pars_vertex: $v,
  color_vertex: Xv,
  common: Yv,
  cube_uv_reflection_fragment: Kv,
  defaultnormal_vertex: Zv,
  displacementmap_pars_vertex: Jv,
  displacementmap_vertex: Qv,
  emissivemap_fragment: tx,
  emissivemap_pars_fragment: ex,
  colorspace_fragment: nx,
  colorspace_pars_fragment: ix,
  envmap_fragment: rx,
  envmap_common_pars_fragment: sx,
  envmap_pars_fragment: ax,
  envmap_pars_vertex: ox,
  envmap_physical_pars_fragment: vx,
  envmap_vertex: cx,
  fog_vertex: ux,
  fog_pars_vertex: lx,
  fog_fragment: fx,
  fog_pars_fragment: hx,
  gradientmap_pars_fragment: px,
  lightmap_fragment: dx,
  lightmap_pars_fragment: mx,
  lights_lambert_fragment: _x,
  lights_lambert_pars_fragment: yx,
  lights_pars_begin: gx,
  lights_toon_fragment: xx,
  lights_toon_pars_fragment: bx,
  lights_phong_fragment: Ex,
  lights_phong_pars_fragment: wx,
  lights_physical_fragment: Mx,
  lights_physical_pars_fragment: Sx,
  lights_fragment_begin: Ax,
  lights_fragment_maps: Tx,
  lights_fragment_end: Cx,
  logdepthbuf_fragment: Rx,
  logdepthbuf_pars_fragment: Ix,
  logdepthbuf_pars_vertex: Px,
  logdepthbuf_vertex: Lx,
  map_fragment: Ox,
  map_pars_fragment: Dx,
  map_particle_fragment: Nx,
  map_particle_pars_fragment: Fx,
  metalnessmap_fragment: Ux,
  metalnessmap_pars_fragment: Bx,
  morphcolor_vertex: kx,
  morphnormal_vertex: zx,
  morphtarget_pars_vertex: Gx,
  morphtarget_vertex: Vx,
  normal_fragment_begin: Hx,
  normal_fragment_maps: jx,
  normal_pars_fragment: Wx,
  normal_pars_vertex: qx,
  normal_vertex: $x,
  normalmap_pars_fragment: Xx,
  clearcoat_normal_fragment_begin: Yx,
  clearcoat_normal_fragment_maps: Kx,
  clearcoat_pars_fragment: Zx,
  iridescence_pars_fragment: Jx,
  opaque_fragment: Qx,
  packing: tb,
  premultiplied_alpha_fragment: eb,
  project_vertex: nb,
  dithering_fragment: ib,
  dithering_pars_fragment: rb,
  roughnessmap_fragment: sb,
  roughnessmap_pars_fragment: ab,
  shadowmap_pars_fragment: ob,
  shadowmap_pars_vertex: cb,
  shadowmap_vertex: ub,
  shadowmask_pars_fragment: lb,
  skinbase_vertex: fb,
  skinning_pars_vertex: hb,
  skinning_vertex: pb,
  skinnormal_vertex: db,
  specularmap_fragment: mb,
  specularmap_pars_fragment: _b,
  tonemapping_fragment: yb,
  tonemapping_pars_fragment: gb,
  transmission_fragment: vb,
  transmission_pars_fragment: xb,
  uv_pars_fragment: bb,
  uv_pars_vertex: Eb,
  uv_vertex: wb,
  worldpos_vertex: Mb,
  background_vert: Sb,
  background_frag: Ab,
  backgroundCube_vert: Tb,
  backgroundCube_frag: Cb,
  cube_vert: Rb,
  cube_frag: Ib,
  depth_vert: Pb,
  depth_frag: Lb,
  distanceRGBA_vert: Ob,
  distanceRGBA_frag: Db,
  equirect_vert: Nb,
  equirect_frag: Fb,
  linedashed_vert: Ub,
  linedashed_frag: Bb,
  meshbasic_vert: kb,
  meshbasic_frag: zb,
  meshlambert_vert: Gb,
  meshlambert_frag: Vb,
  meshmatcap_vert: Hb,
  meshmatcap_frag: jb,
  meshnormal_vert: Wb,
  meshnormal_frag: qb,
  meshphong_vert: $b,
  meshphong_frag: Xb,
  meshphysical_vert: Yb,
  meshphysical_frag: Kb,
  meshtoon_vert: Zb,
  meshtoon_frag: Jb,
  points_vert: Qb,
  points_frag: t1,
  shadow_vert: e1,
  shadow_frag: n1,
  sprite_vert: i1,
  sprite_frag: r1
}, ue = {
  common: {
    diffuse: { value: /* @__PURE__ */ new Ue(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Oe() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Oe() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new Oe() }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new Oe() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new Oe() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new Oe() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new Oe() },
    normalScale: { value: /* @__PURE__ */ new fe(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new Oe() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new Oe() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new Oe() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new Oe() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new Ue(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new Ue(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Oe() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Oe() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new Ue(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new fe(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Oe() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Oe() },
    alphaTest: { value: 0 }
  }
}, Di = {
  basic: {
    uniforms: /* @__PURE__ */ jn([
      ue.common,
      ue.specularmap,
      ue.envmap,
      ue.aomap,
      ue.lightmap,
      ue.fog
    ]),
    vertexShader: Re.meshbasic_vert,
    fragmentShader: Re.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ jn([
      ue.common,
      ue.specularmap,
      ue.envmap,
      ue.aomap,
      ue.lightmap,
      ue.emissivemap,
      ue.bumpmap,
      ue.normalmap,
      ue.displacementmap,
      ue.fog,
      ue.lights,
      {
        emissive: { value: /* @__PURE__ */ new Ue(0) }
      }
    ]),
    vertexShader: Re.meshlambert_vert,
    fragmentShader: Re.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ jn([
      ue.common,
      ue.specularmap,
      ue.envmap,
      ue.aomap,
      ue.lightmap,
      ue.emissivemap,
      ue.bumpmap,
      ue.normalmap,
      ue.displacementmap,
      ue.fog,
      ue.lights,
      {
        emissive: { value: /* @__PURE__ */ new Ue(0) },
        specular: { value: /* @__PURE__ */ new Ue(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: Re.meshphong_vert,
    fragmentShader: Re.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ jn([
      ue.common,
      ue.envmap,
      ue.aomap,
      ue.lightmap,
      ue.emissivemap,
      ue.bumpmap,
      ue.normalmap,
      ue.displacementmap,
      ue.roughnessmap,
      ue.metalnessmap,
      ue.fog,
      ue.lights,
      {
        emissive: { value: /* @__PURE__ */ new Ue(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
        // temporary
      }
    ]),
    vertexShader: Re.meshphysical_vert,
    fragmentShader: Re.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ jn([
      ue.common,
      ue.aomap,
      ue.lightmap,
      ue.emissivemap,
      ue.bumpmap,
      ue.normalmap,
      ue.displacementmap,
      ue.gradientmap,
      ue.fog,
      ue.lights,
      {
        emissive: { value: /* @__PURE__ */ new Ue(0) }
      }
    ]),
    vertexShader: Re.meshtoon_vert,
    fragmentShader: Re.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ jn([
      ue.common,
      ue.bumpmap,
      ue.normalmap,
      ue.displacementmap,
      ue.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: Re.meshmatcap_vert,
    fragmentShader: Re.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ jn([
      ue.points,
      ue.fog
    ]),
    vertexShader: Re.points_vert,
    fragmentShader: Re.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ jn([
      ue.common,
      ue.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: Re.linedashed_vert,
    fragmentShader: Re.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ jn([
      ue.common,
      ue.displacementmap
    ]),
    vertexShader: Re.depth_vert,
    fragmentShader: Re.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ jn([
      ue.common,
      ue.bumpmap,
      ue.normalmap,
      ue.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Re.meshnormal_vert,
    fragmentShader: Re.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ jn([
      ue.sprite,
      ue.fog
    ]),
    vertexShader: Re.sprite_vert,
    fragmentShader: Re.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new Oe() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: Re.background_vert,
    fragmentShader: Re.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: Re.backgroundCube_vert,
    fragmentShader: Re.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: Re.cube_vert,
    fragmentShader: Re.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: Re.equirect_vert,
    fragmentShader: Re.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ jn([
      ue.common,
      ue.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new Gt() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: Re.distanceRGBA_vert,
    fragmentShader: Re.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ jn([
      ue.lights,
      ue.fog,
      {
        color: { value: /* @__PURE__ */ new Ue(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Re.shadow_vert,
    fragmentShader: Re.shadow_frag
  }
};
Di.physical = {
  uniforms: /* @__PURE__ */ jn([
    Di.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new Oe() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new Oe() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new fe(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new Oe() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new Oe() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new Oe() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new Ue(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new Oe() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new Oe() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new Oe() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new fe() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new Oe() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new Ue(0) },
      specularColor: { value: /* @__PURE__ */ new Ue(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new Oe() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new Oe() },
      anisotropyVector: { value: /* @__PURE__ */ new fe() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new Oe() }
    }
  ]),
  vertexShader: Re.meshphysical_vert,
  fragmentShader: Re.meshphysical_frag
};
const Pc = { r: 0, b: 0, g: 0 };
function s1(n, t, e, i, r, s, a) {
  const o = new Ue(0);
  let c = s === !0 ? 0 : 1, h, l, f = null, d = 0, m = null;
  function v(_, p) {
    let R = !1, M = p.isScene === !0 ? p.background : null;
    M && M.isTexture && (M = (p.backgroundBlurriness > 0 ? e : t).get(M)), M === null ? E(o, c) : M && M.isColor && (E(M, 1), R = !0);
    const P = n.xr.getEnvironmentBlendMode();
    P === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, a) : P === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, a), (n.autoClear || R) && n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil), M && (M.isCubeTexture || M.mapping === lu) ? (l === void 0 && (l = new Bi(
      new uo(1, 1, 1),
      new jr({
        name: "BackgroundCubeMaterial",
        uniforms: va(Di.backgroundCube.uniforms),
        vertexShader: Di.backgroundCube.vertexShader,
        fragmentShader: Di.backgroundCube.fragmentShader,
        side: Zn,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), l.geometry.deleteAttribute("normal"), l.geometry.deleteAttribute("uv"), l.onBeforeRender = function(W, C, D) {
      this.matrixWorld.copyPosition(D.matrixWorld);
    }, Object.defineProperty(l.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), r.update(l)), l.material.uniforms.envMap.value = M, l.material.uniforms.flipEnvMap.value = M.isCubeTexture && M.isRenderTargetTexture === !1 ? -1 : 1, l.material.uniforms.backgroundBlurriness.value = p.backgroundBlurriness, l.material.uniforms.backgroundIntensity.value = p.backgroundIntensity, l.material.toneMapped = Ke.getTransfer(M.colorSpace) !== nn, (f !== M || d !== M.version || m !== n.toneMapping) && (l.material.needsUpdate = !0, f = M, d = M.version, m = n.toneMapping), l.layers.enableAll(), _.unshift(l, l.geometry, l.material, 0, 0, null)) : M && M.isTexture && (h === void 0 && (h = new Bi(
      new pu(2, 2),
      new jr({
        name: "BackgroundMaterial",
        uniforms: va(Di.background.uniforms),
        vertexShader: Di.background.vertexShader,
        fragmentShader: Di.background.fragmentShader,
        side: Hr,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), h.geometry.deleteAttribute("normal"), Object.defineProperty(h.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), r.update(h)), h.material.uniforms.t2D.value = M, h.material.uniforms.backgroundIntensity.value = p.backgroundIntensity, h.material.toneMapped = Ke.getTransfer(M.colorSpace) !== nn, M.matrixAutoUpdate === !0 && M.updateMatrix(), h.material.uniforms.uvTransform.value.copy(M.matrix), (f !== M || d !== M.version || m !== n.toneMapping) && (h.material.needsUpdate = !0, f = M, d = M.version, m = n.toneMapping), h.layers.enableAll(), _.unshift(h, h.geometry, h.material, 0, 0, null));
  }
  function E(_, p) {
    _.getRGB(Pc, Ld(n)), i.buffers.color.setClear(Pc.r, Pc.g, Pc.b, p, a);
  }
  return {
    getClearColor: function() {
      return o;
    },
    setClearColor: function(_, p = 1) {
      o.set(_), c = p, E(o, c);
    },
    getClearAlpha: function() {
      return c;
    },
    setClearAlpha: function(_) {
      c = _, E(o, c);
    },
    render: v
  };
}
function a1(n, t, e, i) {
  const r = n.getParameter(n.MAX_VERTEX_ATTRIBS), s = i.isWebGL2 ? null : t.get("OES_vertex_array_object"), a = i.isWebGL2 || s !== null, o = {}, c = _(null);
  let h = c, l = !1;
  function f(k, B, G, H, w) {
    let ut = !1;
    if (a) {
      const pt = E(H, G, B);
      h !== pt && (h = pt, m(h.object)), ut = p(k, H, G, w), ut && R(k, H, G, w);
    } else {
      const pt = B.wireframe === !0;
      (h.geometry !== H.id || h.program !== G.id || h.wireframe !== pt) && (h.geometry = H.id, h.program = G.id, h.wireframe = pt, ut = !0);
    }
    w !== null && e.update(w, n.ELEMENT_ARRAY_BUFFER), (ut || l) && (l = !1, N(k, B, G, H), w !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.get(w).buffer));
  }
  function d() {
    return i.isWebGL2 ? n.createVertexArray() : s.createVertexArrayOES();
  }
  function m(k) {
    return i.isWebGL2 ? n.bindVertexArray(k) : s.bindVertexArrayOES(k);
  }
  function v(k) {
    return i.isWebGL2 ? n.deleteVertexArray(k) : s.deleteVertexArrayOES(k);
  }
  function E(k, B, G) {
    const H = G.wireframe === !0;
    let w = o[k.id];
    w === void 0 && (w = {}, o[k.id] = w);
    let ut = w[B.id];
    ut === void 0 && (ut = {}, w[B.id] = ut);
    let pt = ut[H];
    return pt === void 0 && (pt = _(d()), ut[H] = pt), pt;
  }
  function _(k) {
    const B = [], G = [], H = [];
    for (let w = 0; w < r; w++)
      B[w] = 0, G[w] = 0, H[w] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: B,
      enabledAttributes: G,
      attributeDivisors: H,
      object: k,
      attributes: {},
      index: null
    };
  }
  function p(k, B, G, H) {
    const w = h.attributes, ut = B.attributes;
    let pt = 0;
    const _t = G.getAttributes();
    for (const vt in _t)
      if (_t[vt].location >= 0) {
        const rt = w[vt];
        let b = ut[vt];
        if (b === void 0 && (vt === "instanceMatrix" && k.instanceMatrix && (b = k.instanceMatrix), vt === "instanceColor" && k.instanceColor && (b = k.instanceColor)), rt === void 0 || rt.attribute !== b || b && rt.data !== b.data)
          return !0;
        pt++;
      }
    return h.attributesNum !== pt || h.index !== H;
  }
  function R(k, B, G, H) {
    const w = {}, ut = B.attributes;
    let pt = 0;
    const _t = G.getAttributes();
    for (const vt in _t)
      if (_t[vt].location >= 0) {
        let rt = ut[vt];
        rt === void 0 && (vt === "instanceMatrix" && k.instanceMatrix && (rt = k.instanceMatrix), vt === "instanceColor" && k.instanceColor && (rt = k.instanceColor));
        const b = {};
        b.attribute = rt, rt && rt.data && (b.data = rt.data), w[vt] = b, pt++;
      }
    h.attributes = w, h.attributesNum = pt, h.index = H;
  }
  function M() {
    const k = h.newAttributes;
    for (let B = 0, G = k.length; B < G; B++)
      k[B] = 0;
  }
  function P(k) {
    W(k, 0);
  }
  function W(k, B) {
    const G = h.newAttributes, H = h.enabledAttributes, w = h.attributeDivisors;
    G[k] = 1, H[k] === 0 && (n.enableVertexAttribArray(k), H[k] = 1), w[k] !== B && ((i.isWebGL2 ? n : t.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](k, B), w[k] = B);
  }
  function C() {
    const k = h.newAttributes, B = h.enabledAttributes;
    for (let G = 0, H = B.length; G < H; G++)
      B[G] !== k[G] && (n.disableVertexAttribArray(G), B[G] = 0);
  }
  function D(k, B, G, H, w, ut, pt) {
    pt === !0 ? n.vertexAttribIPointer(k, B, G, w, ut) : n.vertexAttribPointer(k, B, G, H, w, ut);
  }
  function N(k, B, G, H) {
    if (i.isWebGL2 === !1 && (k.isInstancedMesh || H.isInstancedBufferGeometry) && t.get("ANGLE_instanced_arrays") === null)
      return;
    M();
    const w = H.attributes, ut = G.getAttributes(), pt = B.defaultAttributeValues;
    for (const _t in ut) {
      const vt = ut[_t];
      if (vt.location >= 0) {
        let F = w[_t];
        if (F === void 0 && (_t === "instanceMatrix" && k.instanceMatrix && (F = k.instanceMatrix), _t === "instanceColor" && k.instanceColor && (F = k.instanceColor)), F !== void 0) {
          const rt = F.normalized, b = F.itemSize, lt = e.get(F);
          if (lt === void 0)
            continue;
          const q = lt.buffer, U = lt.type, L = lt.bytesPerElement, j = i.isWebGL2 === !0 && (U === n.INT || U === n.UNSIGNED_INT || F.gpuType === dd);
          if (F.isInterleavedBufferAttribute) {
            const Y = F.data, K = Y.stride, yt = F.offset;
            if (Y.isInstancedInterleavedBuffer) {
              for (let Et = 0; Et < vt.locationSize; Et++)
                W(vt.location + Et, Y.meshPerAttribute);
              k.isInstancedMesh !== !0 && H._maxInstanceCount === void 0 && (H._maxInstanceCount = Y.meshPerAttribute * Y.count);
            } else
              for (let Et = 0; Et < vt.locationSize; Et++)
                P(vt.location + Et);
            n.bindBuffer(n.ARRAY_BUFFER, q);
            for (let Et = 0; Et < vt.locationSize; Et++)
              D(
                vt.location + Et,
                b / vt.locationSize,
                U,
                rt,
                K * L,
                (yt + b / vt.locationSize * Et) * L,
                j
              );
          } else {
            if (F.isInstancedBufferAttribute) {
              for (let Y = 0; Y < vt.locationSize; Y++)
                W(vt.location + Y, F.meshPerAttribute);
              k.isInstancedMesh !== !0 && H._maxInstanceCount === void 0 && (H._maxInstanceCount = F.meshPerAttribute * F.count);
            } else
              for (let Y = 0; Y < vt.locationSize; Y++)
                P(vt.location + Y);
            n.bindBuffer(n.ARRAY_BUFFER, q);
            for (let Y = 0; Y < vt.locationSize; Y++)
              D(
                vt.location + Y,
                b / vt.locationSize,
                U,
                rt,
                b * L,
                b / vt.locationSize * Y * L,
                j
              );
          }
        } else if (pt !== void 0) {
          const rt = pt[_t];
          if (rt !== void 0)
            switch (rt.length) {
              case 2:
                n.vertexAttrib2fv(vt.location, rt);
                break;
              case 3:
                n.vertexAttrib3fv(vt.location, rt);
                break;
              case 4:
                n.vertexAttrib4fv(vt.location, rt);
                break;
              default:
                n.vertexAttrib1fv(vt.location, rt);
            }
        }
      }
    }
    C();
  }
  function A() {
    V();
    for (const k in o) {
      const B = o[k];
      for (const G in B) {
        const H = B[G];
        for (const w in H)
          v(H[w].object), delete H[w];
        delete B[G];
      }
      delete o[k];
    }
  }
  function I(k) {
    if (o[k.id] === void 0)
      return;
    const B = o[k.id];
    for (const G in B) {
      const H = B[G];
      for (const w in H)
        v(H[w].object), delete H[w];
      delete B[G];
    }
    delete o[k.id];
  }
  function it(k) {
    for (const B in o) {
      const G = o[B];
      if (G[k.id] === void 0)
        continue;
      const H = G[k.id];
      for (const w in H)
        v(H[w].object), delete H[w];
      delete G[k.id];
    }
  }
  function V() {
    mt(), l = !0, h !== c && (h = c, m(h.object));
  }
  function mt() {
    c.geometry = null, c.program = null, c.wireframe = !1;
  }
  return {
    setup: f,
    reset: V,
    resetDefaultState: mt,
    dispose: A,
    releaseStatesOfGeometry: I,
    releaseStatesOfProgram: it,
    initAttributes: M,
    enableAttribute: P,
    disableUnusedAttributes: C
  };
}
function o1(n, t, e, i) {
  const r = i.isWebGL2;
  let s;
  function a(l) {
    s = l;
  }
  function o(l, f) {
    n.drawArrays(s, l, f), e.update(f, s, 1);
  }
  function c(l, f, d) {
    if (d === 0)
      return;
    let m, v;
    if (r)
      m = n, v = "drawArraysInstanced";
    else if (m = t.get("ANGLE_instanced_arrays"), v = "drawArraysInstancedANGLE", m === null) {
      console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    m[v](s, l, f, d), e.update(f, s, d);
  }
  function h(l, f, d) {
    if (d === 0)
      return;
    const m = t.get("WEBGL_multi_draw");
    if (m === null)
      for (let v = 0; v < d; v++)
        this.render(l[v], f[v]);
    else {
      m.multiDrawArraysWEBGL(s, l, 0, f, 0, d);
      let v = 0;
      for (let E = 0; E < d; E++)
        v += f[E];
      e.update(v, s, 1);
    }
  }
  this.setMode = a, this.render = o, this.renderInstances = c, this.renderMultiDraw = h;
}
function c1(n, t, e) {
  let i;
  function r() {
    if (i !== void 0)
      return i;
    if (t.has("EXT_texture_filter_anisotropic") === !0) {
      const D = t.get("EXT_texture_filter_anisotropic");
      i = n.getParameter(D.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      i = 0;
    return i;
  }
  function s(D) {
    if (D === "highp") {
      if (n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision > 0)
        return "highp";
      D = "mediump";
    }
    return D === "mediump" && n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  const a = typeof WebGL2RenderingContext < "u" && n.constructor.name === "WebGL2RenderingContext";
  let o = e.precision !== void 0 ? e.precision : "highp";
  const c = s(o);
  c !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", c, "instead."), o = c);
  const h = a || t.has("WEBGL_draw_buffers"), l = e.logarithmicDepthBuffer === !0, f = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS), d = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS), m = n.getParameter(n.MAX_TEXTURE_SIZE), v = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE), E = n.getParameter(n.MAX_VERTEX_ATTRIBS), _ = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS), p = n.getParameter(n.MAX_VARYING_VECTORS), R = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS), M = d > 0, P = a || t.has("OES_texture_float"), W = M && P, C = a ? n.getParameter(n.MAX_SAMPLES) : 0;
  return {
    isWebGL2: a,
    drawBuffers: h,
    getMaxAnisotropy: r,
    getMaxPrecision: s,
    precision: o,
    logarithmicDepthBuffer: l,
    maxTextures: f,
    maxVertexTextures: d,
    maxTextureSize: m,
    maxCubemapSize: v,
    maxAttributes: E,
    maxVertexUniforms: _,
    maxVaryings: p,
    maxFragmentUniforms: R,
    vertexTextures: M,
    floatFragmentTextures: P,
    floatVertexTextures: W,
    maxSamples: C
  };
}
function u1(n) {
  const t = this;
  let e = null, i = 0, r = !1, s = !1;
  const a = new xs(), o = new Oe(), c = { value: null, needsUpdate: !1 };
  this.uniform = c, this.numPlanes = 0, this.numIntersection = 0, this.init = function(f, d) {
    const m = f.length !== 0 || d || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    i !== 0 || r;
    return r = d, i = f.length, m;
  }, this.beginShadows = function() {
    s = !0, l(null);
  }, this.endShadows = function() {
    s = !1;
  }, this.setGlobalState = function(f, d) {
    e = l(f, d, 0);
  }, this.setState = function(f, d, m) {
    const v = f.clippingPlanes, E = f.clipIntersection, _ = f.clipShadows, p = n.get(f);
    if (!r || v === null || v.length === 0 || s && !_)
      s ? l(null) : h();
    else {
      const R = s ? 0 : i, M = R * 4;
      let P = p.clippingState || null;
      c.value = P, P = l(v, d, M, m);
      for (let W = 0; W !== M; ++W)
        P[W] = e[W];
      p.clippingState = P, this.numIntersection = E ? this.numPlanes : 0, this.numPlanes += R;
    }
  };
  function h() {
    c.value !== e && (c.value = e, c.needsUpdate = i > 0), t.numPlanes = i, t.numIntersection = 0;
  }
  function l(f, d, m, v) {
    const E = f !== null ? f.length : 0;
    let _ = null;
    if (E !== 0) {
      if (_ = c.value, v !== !0 || _ === null) {
        const p = m + E * 4, R = d.matrixWorldInverse;
        o.getNormalMatrix(R), (_ === null || _.length < p) && (_ = new Float32Array(p));
        for (let M = 0, P = m; M !== E; ++M, P += 4)
          a.copy(f[M]).applyMatrix4(R, o), a.normal.toArray(_, P), _[P + 3] = a.constant;
      }
      c.value = _, c.needsUpdate = !0;
    }
    return t.numPlanes = E, t.numIntersection = 0, _;
  }
}
function l1(n) {
  let t = /* @__PURE__ */ new WeakMap();
  function e(a, o) {
    return o === vl ? a.mapping = ma : o === xl && (a.mapping = _a), a;
  }
  function i(a) {
    if (a && a.isTexture) {
      const o = a.mapping;
      if (o === vl || o === xl)
        if (t.has(a)) {
          const c = t.get(a).texture;
          return e(c, a.mapping);
        } else {
          const c = a.image;
          if (c && c.height > 0) {
            const h = new Ev(c.height / 2);
            return h.fromEquirectangularTexture(n, a), t.set(a, h), a.addEventListener("dispose", r), e(h.texture, a.mapping);
          } else
            return null;
        }
    }
    return a;
  }
  function r(a) {
    const o = a.target;
    o.removeEventListener("dispose", r);
    const c = t.get(o);
    c !== void 0 && (t.delete(o), c.dispose());
  }
  function s() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: i,
    dispose: s
  };
}
class f1 extends Od {
  constructor(t = -1, e = 1, i = 1, r = -1, s = 0.1, a = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = i, this.bottom = r, this.near = s, this.far = a, this.updateProjectionMatrix();
  }
  copy(t, e) {
    return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = t.view === null ? null : Object.assign({}, t.view), this;
  }
  setViewOffset(t, e, i, r, s, a) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = r, this.view.width = s, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2;
    let s = i - t, a = i + t, o = r + e, c = r - e;
    if (this.view !== null && this.view.enabled) {
      const h = (this.right - this.left) / this.view.fullWidth / this.zoom, l = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      s += h * this.view.offsetX, a = s + h * this.view.width, o -= l * this.view.offsetY, c = o - l * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(s, a, o, c, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, this.view !== null && (e.object.view = Object.assign({}, this.view)), e;
  }
}
const oa = 4, Dh = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], ws = 20, qu = /* @__PURE__ */ new f1(), Nh = /* @__PURE__ */ new Ue();
let $u = null, Xu = 0, Yu = 0;
const bs = (1 + Math.sqrt(5)) / 2, ea = 1 / bs, Fh = [
  /* @__PURE__ */ new Gt(1, 1, 1),
  /* @__PURE__ */ new Gt(-1, 1, 1),
  /* @__PURE__ */ new Gt(1, 1, -1),
  /* @__PURE__ */ new Gt(-1, 1, -1),
  /* @__PURE__ */ new Gt(0, bs, ea),
  /* @__PURE__ */ new Gt(0, bs, -ea),
  /* @__PURE__ */ new Gt(ea, 0, bs),
  /* @__PURE__ */ new Gt(-ea, 0, bs),
  /* @__PURE__ */ new Gt(bs, ea, 0),
  /* @__PURE__ */ new Gt(-bs, ea, 0)
];
class Uh {
  constructor(t) {
    this._renderer = t, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(t, e = 0, i = 0.1, r = 100) {
    $u = this._renderer.getRenderTarget(), Xu = this._renderer.getActiveCubeFace(), Yu = this._renderer.getActiveMipmapLevel(), this._setSize(256);
    const s = this._allocateTargets();
    return s.depthBuffer = !0, this._sceneToCubeUV(t, i, r, s), e > 0 && this._blur(s, 0, 0, e), this._applyPMREM(s), this._cleanup(s), s;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromEquirectangular(t, e = null) {
    return this._fromTexture(t, e);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromCubemap(t, e = null) {
    return this._fromTexture(t, e);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = zh(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = kh(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(t) {
    this._lodMax = Math.floor(Math.log2(t)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let t = 0; t < this._lodPlanes.length; t++)
      this._lodPlanes[t].dispose();
  }
  _cleanup(t) {
    this._renderer.setRenderTarget($u, Xu, Yu), t.scissorTest = !1, Lc(t, 0, 0, t.width, t.height);
  }
  _fromTexture(t, e) {
    t.mapping === ma || t.mapping === _a ? this._setSize(t.image.length === 0 ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4), $u = this._renderer.getRenderTarget(), Xu = this._renderer.getActiveCubeFace(), Yu = this._renderer.getActiveMipmapLevel();
    const i = e || this._allocateTargets();
    return this._textureToCubeUV(t, i), this._applyPMREM(i), this._cleanup(i), i;
  }
  _allocateTargets() {
    const t = 3 * Math.max(this._cubeSize, 112), e = 4 * this._cubeSize, i = {
      magFilter: ri,
      minFilter: ri,
      generateMipmaps: !1,
      type: Za,
      format: yi,
      colorSpace: lr,
      depthBuffer: !1
    }, r = Bh(t, e, i);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== t || this._pingPongRenderTarget.height !== e) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = Bh(t, e, i);
      const { _lodMax: s } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = h1(s)), this._blurMaterial = p1(s, t, e);
    }
    return r;
  }
  _compileMaterial(t) {
    const e = new Bi(this._lodPlanes[0], t);
    this._renderer.compile(e, qu);
  }
  _sceneToCubeUV(t, e, i, r) {
    const o = new di(90, 1, e, i), c = [1, -1, 1, 1, 1, 1], h = [1, 1, 1, -1, -1, -1], l = this._renderer, f = l.autoClear, d = l.toneMapping;
    l.getClearColor(Nh), l.toneMapping = zr, l.autoClear = !1;
    const m = new Rd({
      name: "PMREM.Background",
      side: Zn,
      depthWrite: !1,
      depthTest: !1
    }), v = new Bi(new uo(), m);
    let E = !1;
    const _ = t.background;
    _ ? _.isColor && (m.color.copy(_), t.background = null, E = !0) : (m.color.copy(Nh), E = !0);
    for (let p = 0; p < 6; p++) {
      const R = p % 3;
      R === 0 ? (o.up.set(0, c[p], 0), o.lookAt(h[p], 0, 0)) : R === 1 ? (o.up.set(0, 0, c[p]), o.lookAt(0, h[p], 0)) : (o.up.set(0, c[p], 0), o.lookAt(0, 0, h[p]));
      const M = this._cubeSize;
      Lc(r, R * M, p > 2 ? M : 0, M, M), l.setRenderTarget(r), E && l.render(v, o), l.render(t, o);
    }
    v.geometry.dispose(), v.material.dispose(), l.toneMapping = d, l.autoClear = f, t.background = _;
  }
  _textureToCubeUV(t, e) {
    const i = this._renderer, r = t.mapping === ma || t.mapping === _a;
    r ? (this._cubemapMaterial === null && (this._cubemapMaterial = zh()), this._cubemapMaterial.uniforms.flipEnvMap.value = t.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = kh());
    const s = r ? this._cubemapMaterial : this._equirectMaterial, a = new Bi(this._lodPlanes[0], s), o = s.uniforms;
    o.envMap.value = t;
    const c = this._cubeSize;
    Lc(e, 0, 0, 3 * c, 2 * c), i.setRenderTarget(e), i.render(a, qu);
  }
  _applyPMREM(t) {
    const e = this._renderer, i = e.autoClear;
    e.autoClear = !1;
    for (let r = 1; r < this._lodPlanes.length; r++) {
      const s = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]), a = Fh[(r - 1) % Fh.length];
      this._blur(t, r - 1, r, s, a);
    }
    e.autoClear = i;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(t, e, i, r, s) {
    const a = this._pingPongRenderTarget;
    this._halfBlur(
      t,
      a,
      e,
      i,
      r,
      "latitudinal",
      s
    ), this._halfBlur(
      a,
      t,
      i,
      i,
      r,
      "longitudinal",
      s
    );
  }
  _halfBlur(t, e, i, r, s, a, o) {
    const c = this._renderer, h = this._blurMaterial;
    a !== "latitudinal" && a !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const l = 3, f = new Bi(this._lodPlanes[r], h), d = h.uniforms, m = this._sizeLods[i] - 1, v = isFinite(s) ? Math.PI / (2 * m) : 2 * Math.PI / (2 * ws - 1), E = s / v, _ = isFinite(s) ? 1 + Math.floor(l * E) : ws;
    _ > ws && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${_} samples when the maximum is set to ${ws}`);
    const p = [];
    let R = 0;
    for (let D = 0; D < ws; ++D) {
      const N = D / E, A = Math.exp(-N * N / 2);
      p.push(A), D === 0 ? R += A : D < _ && (R += 2 * A);
    }
    for (let D = 0; D < p.length; D++)
      p[D] = p[D] / R;
    d.envMap.value = t.texture, d.samples.value = _, d.weights.value = p, d.latitudinal.value = a === "latitudinal", o && (d.poleAxis.value = o);
    const { _lodMax: M } = this;
    d.dTheta.value = v, d.mipInt.value = M - i;
    const P = this._sizeLods[r], W = 3 * P * (r > M - oa ? r - M + oa : 0), C = 4 * (this._cubeSize - P);
    Lc(e, W, C, 3 * P, 2 * P), c.setRenderTarget(e), c.render(f, qu);
  }
}
function h1(n) {
  const t = [], e = [], i = [];
  let r = n;
  const s = n - oa + 1 + Dh.length;
  for (let a = 0; a < s; a++) {
    const o = Math.pow(2, r);
    e.push(o);
    let c = 1 / o;
    a > n - oa ? c = Dh[a - n + oa - 1] : a === 0 && (c = 0), i.push(c);
    const h = 1 / (o - 2), l = -h, f = 1 + h, d = [l, l, f, l, f, f, l, l, f, f, l, f], m = 6, v = 6, E = 3, _ = 2, p = 1, R = new Float32Array(E * v * m), M = new Float32Array(_ * v * m), P = new Float32Array(p * v * m);
    for (let C = 0; C < m; C++) {
      const D = C % 3 * 2 / 3 - 1, N = C > 2 ? 0 : -1, A = [
        D,
        N,
        0,
        D + 2 / 3,
        N,
        0,
        D + 2 / 3,
        N + 1,
        0,
        D,
        N,
        0,
        D + 2 / 3,
        N + 1,
        0,
        D,
        N + 1,
        0
      ];
      R.set(A, E * v * C), M.set(d, _ * v * C);
      const I = [C, C, C, C, C, C];
      P.set(I, p * v * C);
    }
    const W = new fr();
    W.setAttribute("position", new gn(R, E)), W.setAttribute("uv", new gn(M, _)), W.setAttribute("faceIndex", new gn(P, p)), t.push(W), r > oa && r--;
  }
  return { lodPlanes: t, sizeLods: e, sigmas: i };
}
function Bh(n, t, e) {
  const i = new Cs(n, t, e);
  return i.texture.mapping = lu, i.texture.name = "PMREM.cubeUv", i.scissorTest = !0, i;
}
function Lc(n, t, e, i, r) {
  n.viewport.set(t, e, i, r), n.scissor.set(t, e, i, r);
}
function p1(n, t, e) {
  const i = new Float32Array(ws), r = new Gt(0, 1, 0);
  return new jr({
    name: "SphericalGaussianBlur",
    defines: {
      n: ws,
      CUBEUV_TEXEL_WIDTH: 1 / t,
      CUBEUV_TEXEL_HEIGHT: 1 / e,
      CUBEUV_MAX_MIP: `${n}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: i },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: r }
    },
    vertexShader: Jl(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: kr,
    depthTest: !1,
    depthWrite: !1
  });
}
function kh() {
  return new jr({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: Jl(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: kr,
    depthTest: !1,
    depthWrite: !1
  });
}
function zh() {
  return new jr({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: Jl(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: kr,
    depthTest: !1,
    depthWrite: !1
  });
}
function Jl() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function d1(n) {
  let t = /* @__PURE__ */ new WeakMap(), e = null;
  function i(o) {
    if (o && o.isTexture) {
      const c = o.mapping, h = c === vl || c === xl, l = c === ma || c === _a;
      if (h || l)
        if (o.isRenderTargetTexture && o.needsPMREMUpdate === !0) {
          o.needsPMREMUpdate = !1;
          let f = t.get(o);
          return e === null && (e = new Uh(n)), f = h ? e.fromEquirectangular(o, f) : e.fromCubemap(o, f), t.set(o, f), f.texture;
        } else {
          if (t.has(o))
            return t.get(o).texture;
          {
            const f = o.image;
            if (h && f && f.height > 0 || l && f && r(f)) {
              e === null && (e = new Uh(n));
              const d = h ? e.fromEquirectangular(o) : e.fromCubemap(o);
              return t.set(o, d), o.addEventListener("dispose", s), d.texture;
            } else
              return null;
          }
        }
    }
    return o;
  }
  function r(o) {
    let c = 0;
    const h = 6;
    for (let l = 0; l < h; l++)
      o[l] !== void 0 && c++;
    return c === h;
  }
  function s(o) {
    const c = o.target;
    c.removeEventListener("dispose", s);
    const h = t.get(c);
    h !== void 0 && (t.delete(c), h.dispose());
  }
  function a() {
    t = /* @__PURE__ */ new WeakMap(), e !== null && (e.dispose(), e = null);
  }
  return {
    get: i,
    dispose: a
  };
}
function m1(n) {
  const t = {};
  function e(i) {
    if (t[i] !== void 0)
      return t[i];
    let r;
    switch (i) {
      case "WEBGL_depth_texture":
        r = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        r = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        r = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        r = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        r = n.getExtension(i);
    }
    return t[i] = r, r;
  }
  return {
    has: function(i) {
      return e(i) !== null;
    },
    init: function(i) {
      i.isWebGL2 ? (e("EXT_color_buffer_float"), e("WEBGL_clip_cull_distance")) : (e("WEBGL_depth_texture"), e("OES_texture_float"), e("OES_texture_half_float"), e("OES_texture_half_float_linear"), e("OES_standard_derivatives"), e("OES_element_index_uint"), e("OES_vertex_array_object"), e("ANGLE_instanced_arrays")), e("OES_texture_float_linear"), e("EXT_color_buffer_half_float"), e("WEBGL_multisampled_render_to_texture");
    },
    get: function(i) {
      const r = e(i);
      return r === null && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), r;
    }
  };
}
function _1(n, t, e, i) {
  const r = {}, s = /* @__PURE__ */ new WeakMap();
  function a(f) {
    const d = f.target;
    d.index !== null && t.remove(d.index);
    for (const v in d.attributes)
      t.remove(d.attributes[v]);
    for (const v in d.morphAttributes) {
      const E = d.morphAttributes[v];
      for (let _ = 0, p = E.length; _ < p; _++)
        t.remove(E[_]);
    }
    d.removeEventListener("dispose", a), delete r[d.id];
    const m = s.get(d);
    m && (t.remove(m), s.delete(d)), i.releaseStatesOfGeometry(d), d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount, e.memory.geometries--;
  }
  function o(f, d) {
    return r[d.id] === !0 || (d.addEventListener("dispose", a), r[d.id] = !0, e.memory.geometries++), d;
  }
  function c(f) {
    const d = f.attributes;
    for (const v in d)
      t.update(d[v], n.ARRAY_BUFFER);
    const m = f.morphAttributes;
    for (const v in m) {
      const E = m[v];
      for (let _ = 0, p = E.length; _ < p; _++)
        t.update(E[_], n.ARRAY_BUFFER);
    }
  }
  function h(f) {
    const d = [], m = f.index, v = f.attributes.position;
    let E = 0;
    if (m !== null) {
      const R = m.array;
      E = m.version;
      for (let M = 0, P = R.length; M < P; M += 3) {
        const W = R[M + 0], C = R[M + 1], D = R[M + 2];
        d.push(W, C, C, D, D, W);
      }
    } else if (v !== void 0) {
      const R = v.array;
      E = v.version;
      for (let M = 0, P = R.length / 3 - 1; M < P; M += 3) {
        const W = M + 0, C = M + 1, D = M + 2;
        d.push(W, C, C, D, D, W);
      }
    } else
      return;
    const _ = new (Md(d) ? Pd : Id)(d, 1);
    _.version = E;
    const p = s.get(f);
    p && t.remove(p), s.set(f, _);
  }
  function l(f) {
    const d = s.get(f);
    if (d) {
      const m = f.index;
      m !== null && d.version < m.version && h(f);
    } else
      h(f);
    return s.get(f);
  }
  return {
    get: o,
    update: c,
    getWireframeAttribute: l
  };
}
function y1(n, t, e, i) {
  const r = i.isWebGL2;
  let s;
  function a(m) {
    s = m;
  }
  let o, c;
  function h(m) {
    o = m.type, c = m.bytesPerElement;
  }
  function l(m, v) {
    n.drawElements(s, v, o, m * c), e.update(v, s, 1);
  }
  function f(m, v, E) {
    if (E === 0)
      return;
    let _, p;
    if (r)
      _ = n, p = "drawElementsInstanced";
    else if (_ = t.get("ANGLE_instanced_arrays"), p = "drawElementsInstancedANGLE", _ === null) {
      console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    _[p](s, v, o, m * c, E), e.update(v, s, E);
  }
  function d(m, v, E) {
    if (E === 0)
      return;
    const _ = t.get("WEBGL_multi_draw");
    if (_ === null)
      for (let p = 0; p < E; p++)
        this.render(m[p] / c, v[p]);
    else {
      _.multiDrawElementsWEBGL(s, v, 0, o, m, 0, E);
      let p = 0;
      for (let R = 0; R < E; R++)
        p += v[R];
      e.update(p, s, 1);
    }
  }
  this.setMode = a, this.setIndex = h, this.render = l, this.renderInstances = f, this.renderMultiDraw = d;
}
function g1(n) {
  const t = {
    geometries: 0,
    textures: 0
  }, e = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function i(s, a, o) {
    switch (e.calls++, a) {
      case n.TRIANGLES:
        e.triangles += o * (s / 3);
        break;
      case n.LINES:
        e.lines += o * (s / 2);
        break;
      case n.LINE_STRIP:
        e.lines += o * (s - 1);
        break;
      case n.LINE_LOOP:
        e.lines += o * s;
        break;
      case n.POINTS:
        e.points += o * s;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", a);
        break;
    }
  }
  function r() {
    e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0;
  }
  return {
    memory: t,
    render: e,
    programs: null,
    autoReset: !0,
    reset: r,
    update: i
  };
}
function v1(n, t) {
  return n[0] - t[0];
}
function x1(n, t) {
  return Math.abs(t[1]) - Math.abs(n[1]);
}
function b1(n, t, e) {
  const i = {}, r = new Float32Array(8), s = /* @__PURE__ */ new WeakMap(), a = new In(), o = [];
  for (let h = 0; h < 8; h++)
    o[h] = [h, 0];
  function c(h, l, f) {
    const d = h.morphTargetInfluences;
    if (t.isWebGL2 === !0) {
      const v = l.morphAttributes.position || l.morphAttributes.normal || l.morphAttributes.color, E = v !== void 0 ? v.length : 0;
      let _ = s.get(l);
      if (_ === void 0 || _.count !== E) {
        let B = function() {
          mt.dispose(), s.delete(l), l.removeEventListener("dispose", B);
        };
        var m = B;
        _ !== void 0 && _.texture.dispose();
        const M = l.morphAttributes.position !== void 0, P = l.morphAttributes.normal !== void 0, W = l.morphAttributes.color !== void 0, C = l.morphAttributes.position || [], D = l.morphAttributes.normal || [], N = l.morphAttributes.color || [];
        let A = 0;
        M === !0 && (A = 1), P === !0 && (A = 2), W === !0 && (A = 3);
        let I = l.attributes.position.count * A, it = 1;
        I > t.maxTextureSize && (it = Math.ceil(I / t.maxTextureSize), I = t.maxTextureSize);
        const V = new Float32Array(I * it * 4 * E), mt = new Ad(V, I, it, E);
        mt.type = Fr, mt.needsUpdate = !0;
        const k = A * 4;
        for (let G = 0; G < E; G++) {
          const H = C[G], w = D[G], ut = N[G], pt = I * it * 4 * G;
          for (let _t = 0; _t < H.count; _t++) {
            const vt = _t * k;
            M === !0 && (a.fromBufferAttribute(H, _t), V[pt + vt + 0] = a.x, V[pt + vt + 1] = a.y, V[pt + vt + 2] = a.z, V[pt + vt + 3] = 0), P === !0 && (a.fromBufferAttribute(w, _t), V[pt + vt + 4] = a.x, V[pt + vt + 5] = a.y, V[pt + vt + 6] = a.z, V[pt + vt + 7] = 0), W === !0 && (a.fromBufferAttribute(ut, _t), V[pt + vt + 8] = a.x, V[pt + vt + 9] = a.y, V[pt + vt + 10] = a.z, V[pt + vt + 11] = ut.itemSize === 4 ? a.w : 1);
          }
        }
        _ = {
          count: E,
          texture: mt,
          size: new fe(I, it)
        }, s.set(l, _), l.addEventListener("dispose", B);
      }
      let p = 0;
      for (let M = 0; M < d.length; M++)
        p += d[M];
      const R = l.morphTargetsRelative ? 1 : 1 - p;
      f.getUniforms().setValue(n, "morphTargetBaseInfluence", R), f.getUniforms().setValue(n, "morphTargetInfluences", d), f.getUniforms().setValue(n, "morphTargetsTexture", _.texture, e), f.getUniforms().setValue(n, "morphTargetsTextureSize", _.size);
    } else {
      const v = d === void 0 ? 0 : d.length;
      let E = i[l.id];
      if (E === void 0 || E.length !== v) {
        E = [];
        for (let P = 0; P < v; P++)
          E[P] = [P, 0];
        i[l.id] = E;
      }
      for (let P = 0; P < v; P++) {
        const W = E[P];
        W[0] = P, W[1] = d[P];
      }
      E.sort(x1);
      for (let P = 0; P < 8; P++)
        P < v && E[P][1] ? (o[P][0] = E[P][0], o[P][1] = E[P][1]) : (o[P][0] = Number.MAX_SAFE_INTEGER, o[P][1] = 0);
      o.sort(v1);
      const _ = l.morphAttributes.position, p = l.morphAttributes.normal;
      let R = 0;
      for (let P = 0; P < 8; P++) {
        const W = o[P], C = W[0], D = W[1];
        C !== Number.MAX_SAFE_INTEGER && D ? (_ && l.getAttribute("morphTarget" + P) !== _[C] && l.setAttribute("morphTarget" + P, _[C]), p && l.getAttribute("morphNormal" + P) !== p[C] && l.setAttribute("morphNormal" + P, p[C]), r[P] = D, R += D) : (_ && l.hasAttribute("morphTarget" + P) === !0 && l.deleteAttribute("morphTarget" + P), p && l.hasAttribute("morphNormal" + P) === !0 && l.deleteAttribute("morphNormal" + P), r[P] = 0);
      }
      const M = l.morphTargetsRelative ? 1 : 1 - R;
      f.getUniforms().setValue(n, "morphTargetBaseInfluence", M), f.getUniforms().setValue(n, "morphTargetInfluences", r);
    }
  }
  return {
    update: c
  };
}
function E1(n, t, e, i) {
  let r = /* @__PURE__ */ new WeakMap();
  function s(c) {
    const h = i.render.frame, l = c.geometry, f = t.get(c, l);
    if (r.get(f) !== h && (t.update(f), r.set(f, h)), c.isInstancedMesh && (c.hasEventListener("dispose", o) === !1 && c.addEventListener("dispose", o), r.get(c) !== h && (e.update(c.instanceMatrix, n.ARRAY_BUFFER), c.instanceColor !== null && e.update(c.instanceColor, n.ARRAY_BUFFER), r.set(c, h))), c.isSkinnedMesh) {
      const d = c.skeleton;
      r.get(d) !== h && (d.update(), r.set(d, h));
    }
    return f;
  }
  function a() {
    r = /* @__PURE__ */ new WeakMap();
  }
  function o(c) {
    const h = c.target;
    h.removeEventListener("dispose", o), e.remove(h.instanceMatrix), h.instanceColor !== null && e.remove(h.instanceColor);
  }
  return {
    update: s,
    dispose: a
  };
}
class Ud extends qn {
  constructor(t, e, i, r, s, a, o, c, h, l) {
    if (l = l !== void 0 ? l : Ss, l !== Ss && l !== ga)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    i === void 0 && l === Ss && (i = Nr), i === void 0 && l === ga && (i = Ms), super(null, r, s, a, o, c, l, i, h), this.isDepthTexture = !0, this.image = { width: t, height: e }, this.magFilter = o !== void 0 ? o : Bn, this.minFilter = c !== void 0 ? c : Bn, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(t) {
    return super.copy(t), this.compareFunction = t.compareFunction, this;
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return this.compareFunction !== null && (e.compareFunction = this.compareFunction), e;
  }
}
const Bd = /* @__PURE__ */ new qn(), kd = /* @__PURE__ */ new Ud(1, 1);
kd.compareFunction = wd;
const zd = /* @__PURE__ */ new Ad(), Gd = /* @__PURE__ */ new rv(), Vd = /* @__PURE__ */ new Dd(), Gh = [], Vh = [], Hh = new Float32Array(16), jh = new Float32Array(9), Wh = new Float32Array(4);
function wa(n, t, e) {
  const i = n[0];
  if (i <= 0 || i > 0)
    return n;
  const r = t * e;
  let s = Gh[r];
  if (s === void 0 && (s = new Float32Array(r), Gh[r] = s), t !== 0) {
    i.toArray(s, 0);
    for (let a = 1, o = 0; a !== t; ++a)
      o += e, n[a].toArray(s, o);
  }
  return s;
}
function xn(n, t) {
  if (n.length !== t.length)
    return !1;
  for (let e = 0, i = n.length; e < i; e++)
    if (n[e] !== t[e])
      return !1;
  return !0;
}
function bn(n, t) {
  for (let e = 0, i = t.length; e < i; e++)
    n[e] = t[e];
}
function du(n, t) {
  let e = Vh[t];
  e === void 0 && (e = new Int32Array(t), Vh[t] = e);
  for (let i = 0; i !== t; ++i)
    e[i] = n.allocateTextureUnit();
  return e;
}
function w1(n, t) {
  const e = this.cache;
  e[0] !== t && (n.uniform1f(this.addr, t), e[0] = t);
}
function M1(n, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y) && (n.uniform2f(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
  else {
    if (xn(e, t))
      return;
    n.uniform2fv(this.addr, t), bn(e, t);
  }
}
function S1(n, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (n.uniform3f(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
  else if (t.r !== void 0)
    (e[0] !== t.r || e[1] !== t.g || e[2] !== t.b) && (n.uniform3f(this.addr, t.r, t.g, t.b), e[0] = t.r, e[1] = t.g, e[2] = t.b);
  else {
    if (xn(e, t))
      return;
    n.uniform3fv(this.addr, t), bn(e, t);
  }
}
function A1(n, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (n.uniform4f(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
  else {
    if (xn(e, t))
      return;
    n.uniform4fv(this.addr, t), bn(e, t);
  }
}
function T1(n, t) {
  const e = this.cache, i = t.elements;
  if (i === void 0) {
    if (xn(e, t))
      return;
    n.uniformMatrix2fv(this.addr, !1, t), bn(e, t);
  } else {
    if (xn(e, i))
      return;
    Wh.set(i), n.uniformMatrix2fv(this.addr, !1, Wh), bn(e, i);
  }
}
function C1(n, t) {
  const e = this.cache, i = t.elements;
  if (i === void 0) {
    if (xn(e, t))
      return;
    n.uniformMatrix3fv(this.addr, !1, t), bn(e, t);
  } else {
    if (xn(e, i))
      return;
    jh.set(i), n.uniformMatrix3fv(this.addr, !1, jh), bn(e, i);
  }
}
function R1(n, t) {
  const e = this.cache, i = t.elements;
  if (i === void 0) {
    if (xn(e, t))
      return;
    n.uniformMatrix4fv(this.addr, !1, t), bn(e, t);
  } else {
    if (xn(e, i))
      return;
    Hh.set(i), n.uniformMatrix4fv(this.addr, !1, Hh), bn(e, i);
  }
}
function I1(n, t) {
  const e = this.cache;
  e[0] !== t && (n.uniform1i(this.addr, t), e[0] = t);
}
function P1(n, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y) && (n.uniform2i(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
  else {
    if (xn(e, t))
      return;
    n.uniform2iv(this.addr, t), bn(e, t);
  }
}
function L1(n, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (n.uniform3i(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
  else {
    if (xn(e, t))
      return;
    n.uniform3iv(this.addr, t), bn(e, t);
  }
}
function O1(n, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (n.uniform4i(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
  else {
    if (xn(e, t))
      return;
    n.uniform4iv(this.addr, t), bn(e, t);
  }
}
function D1(n, t) {
  const e = this.cache;
  e[0] !== t && (n.uniform1ui(this.addr, t), e[0] = t);
}
function N1(n, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y) && (n.uniform2ui(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
  else {
    if (xn(e, t))
      return;
    n.uniform2uiv(this.addr, t), bn(e, t);
  }
}
function F1(n, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (n.uniform3ui(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
  else {
    if (xn(e, t))
      return;
    n.uniform3uiv(this.addr, t), bn(e, t);
  }
}
function U1(n, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (n.uniform4ui(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
  else {
    if (xn(e, t))
      return;
    n.uniform4uiv(this.addr, t), bn(e, t);
  }
}
function B1(n, t, e) {
  const i = this.cache, r = e.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r);
  const s = this.type === n.SAMPLER_2D_SHADOW ? kd : Bd;
  e.setTexture2D(t || s, r);
}
function k1(n, t, e) {
  const i = this.cache, r = e.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), e.setTexture3D(t || Gd, r);
}
function z1(n, t, e) {
  const i = this.cache, r = e.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), e.setTextureCube(t || Vd, r);
}
function G1(n, t, e) {
  const i = this.cache, r = e.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), e.setTexture2DArray(t || zd, r);
}
function V1(n) {
  switch (n) {
    case 5126:
      return w1;
    case 35664:
      return M1;
    case 35665:
      return S1;
    case 35666:
      return A1;
    case 35674:
      return T1;
    case 35675:
      return C1;
    case 35676:
      return R1;
    case 5124:
    case 35670:
      return I1;
    case 35667:
    case 35671:
      return P1;
    case 35668:
    case 35672:
      return L1;
    case 35669:
    case 35673:
      return O1;
    case 5125:
      return D1;
    case 36294:
      return N1;
    case 36295:
      return F1;
    case 36296:
      return U1;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return B1;
    case 35679:
    case 36299:
    case 36307:
      return k1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return z1;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return G1;
  }
}
function H1(n, t) {
  n.uniform1fv(this.addr, t);
}
function j1(n, t) {
  const e = wa(t, this.size, 2);
  n.uniform2fv(this.addr, e);
}
function W1(n, t) {
  const e = wa(t, this.size, 3);
  n.uniform3fv(this.addr, e);
}
function q1(n, t) {
  const e = wa(t, this.size, 4);
  n.uniform4fv(this.addr, e);
}
function $1(n, t) {
  const e = wa(t, this.size, 4);
  n.uniformMatrix2fv(this.addr, !1, e);
}
function X1(n, t) {
  const e = wa(t, this.size, 9);
  n.uniformMatrix3fv(this.addr, !1, e);
}
function Y1(n, t) {
  const e = wa(t, this.size, 16);
  n.uniformMatrix4fv(this.addr, !1, e);
}
function K1(n, t) {
  n.uniform1iv(this.addr, t);
}
function Z1(n, t) {
  n.uniform2iv(this.addr, t);
}
function J1(n, t) {
  n.uniform3iv(this.addr, t);
}
function Q1(n, t) {
  n.uniform4iv(this.addr, t);
}
function tE(n, t) {
  n.uniform1uiv(this.addr, t);
}
function eE(n, t) {
  n.uniform2uiv(this.addr, t);
}
function nE(n, t) {
  n.uniform3uiv(this.addr, t);
}
function iE(n, t) {
  n.uniform4uiv(this.addr, t);
}
function rE(n, t, e) {
  const i = this.cache, r = t.length, s = du(e, r);
  xn(i, s) || (n.uniform1iv(this.addr, s), bn(i, s));
  for (let a = 0; a !== r; ++a)
    e.setTexture2D(t[a] || Bd, s[a]);
}
function sE(n, t, e) {
  const i = this.cache, r = t.length, s = du(e, r);
  xn(i, s) || (n.uniform1iv(this.addr, s), bn(i, s));
  for (let a = 0; a !== r; ++a)
    e.setTexture3D(t[a] || Gd, s[a]);
}
function aE(n, t, e) {
  const i = this.cache, r = t.length, s = du(e, r);
  xn(i, s) || (n.uniform1iv(this.addr, s), bn(i, s));
  for (let a = 0; a !== r; ++a)
    e.setTextureCube(t[a] || Vd, s[a]);
}
function oE(n, t, e) {
  const i = this.cache, r = t.length, s = du(e, r);
  xn(i, s) || (n.uniform1iv(this.addr, s), bn(i, s));
  for (let a = 0; a !== r; ++a)
    e.setTexture2DArray(t[a] || zd, s[a]);
}
function cE(n) {
  switch (n) {
    case 5126:
      return H1;
    case 35664:
      return j1;
    case 35665:
      return W1;
    case 35666:
      return q1;
    case 35674:
      return $1;
    case 35675:
      return X1;
    case 35676:
      return Y1;
    case 5124:
    case 35670:
      return K1;
    case 35667:
    case 35671:
      return Z1;
    case 35668:
    case 35672:
      return J1;
    case 35669:
    case 35673:
      return Q1;
    case 5125:
      return tE;
    case 36294:
      return eE;
    case 36295:
      return nE;
    case 36296:
      return iE;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return rE;
    case 35679:
    case 36299:
    case 36307:
      return sE;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return aE;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return oE;
  }
}
class uE {
  constructor(t, e, i) {
    this.id = t, this.addr = i, this.cache = [], this.type = e.type, this.setValue = V1(e.type);
  }
}
class lE {
  constructor(t, e, i) {
    this.id = t, this.addr = i, this.cache = [], this.type = e.type, this.size = e.size, this.setValue = cE(e.type);
  }
}
class fE {
  constructor(t) {
    this.id = t, this.seq = [], this.map = {};
  }
  setValue(t, e, i) {
    const r = this.seq;
    for (let s = 0, a = r.length; s !== a; ++s) {
      const o = r[s];
      o.setValue(t, e[o.id], i);
    }
  }
}
const Ku = /(\w+)(\])?(\[|\.)?/g;
function qh(n, t) {
  n.seq.push(t), n.map[t.id] = t;
}
function hE(n, t, e) {
  const i = n.name, r = i.length;
  for (Ku.lastIndex = 0; ; ) {
    const s = Ku.exec(i), a = Ku.lastIndex;
    let o = s[1];
    const c = s[2] === "]", h = s[3];
    if (c && (o = o | 0), h === void 0 || h === "[" && a + 2 === r) {
      qh(e, h === void 0 ? new uE(o, n, t) : new lE(o, n, t));
      break;
    } else {
      let f = e.map[o];
      f === void 0 && (f = new fE(o), qh(e, f)), e = f;
    }
  }
}
class Yc {
  constructor(t, e) {
    this.seq = [], this.map = {};
    const i = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
    for (let r = 0; r < i; ++r) {
      const s = t.getActiveUniform(e, r), a = t.getUniformLocation(e, s.name);
      hE(s, a, this);
    }
  }
  setValue(t, e, i, r) {
    const s = this.map[e];
    s !== void 0 && s.setValue(t, i, r);
  }
  setOptional(t, e, i) {
    const r = e[i];
    r !== void 0 && this.setValue(t, i, r);
  }
  static upload(t, e, i, r) {
    for (let s = 0, a = e.length; s !== a; ++s) {
      const o = e[s], c = i[o.id];
      c.needsUpdate !== !1 && o.setValue(t, c.value, r);
    }
  }
  static seqWithValue(t, e) {
    const i = [];
    for (let r = 0, s = t.length; r !== s; ++r) {
      const a = t[r];
      a.id in e && i.push(a);
    }
    return i;
  }
}
function $h(n, t, e) {
  const i = n.createShader(t);
  return n.shaderSource(i, e), n.compileShader(i), i;
}
const pE = 37297;
let dE = 0;
function mE(n, t) {
  const e = n.split(`
`), i = [], r = Math.max(t - 6, 0), s = Math.min(t + 6, e.length);
  for (let a = r; a < s; a++) {
    const o = a + 1;
    i.push(`${o === t ? ">" : " "} ${o}: ${e[a]}`);
  }
  return i.join(`
`);
}
function _E(n) {
  const t = Ke.getPrimaries(Ke.workingColorSpace), e = Ke.getPrimaries(n);
  let i;
  switch (t === e ? i = "" : t === su && e === ru ? i = "LinearDisplayP3ToLinearSRGB" : t === ru && e === su && (i = "LinearSRGBToLinearDisplayP3"), n) {
    case lr:
    case fu:
      return [i, "LinearTransferOETF"];
    case yn:
    case Xl:
      return [i, "sRGBTransferOETF"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space:", n), [i, "LinearTransferOETF"];
  }
}
function Xh(n, t, e) {
  const i = n.getShaderParameter(t, n.COMPILE_STATUS), r = n.getShaderInfoLog(t).trim();
  if (i && r === "")
    return "";
  const s = /ERROR: 0:(\d+)/.exec(r);
  if (s) {
    const a = parseInt(s[1]);
    return e.toUpperCase() + `

` + r + `

` + mE(n.getShaderSource(t), a);
  } else
    return r;
}
function yE(n, t) {
  const e = _E(t);
  return `vec4 ${n}( vec4 value ) { return ${e[0]}( ${e[1]}( value ) ); }`;
}
function gE(n, t) {
  let e;
  switch (t) {
    case pg:
      e = "Linear";
      break;
    case dg:
      e = "Reinhard";
      break;
    case mg:
      e = "OptimizedCineon";
      break;
    case _g:
      e = "ACESFilmic";
      break;
    case gg:
      e = "AgX";
      break;
    case yg:
      e = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), e = "Linear";
  }
  return "vec3 " + n + "( vec3 color ) { return " + e + "ToneMapping( color ); }";
}
function vE(n) {
  return [
    n.extensionDerivatives || n.envMapCubeUVHeight || n.bumpMap || n.normalMapTangentSpace || n.clearcoatNormalMap || n.flatShading || n.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (n.extensionFragDepth || n.logarithmicDepthBuffer) && n.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    n.extensionDrawBuffers && n.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (n.extensionShaderTextureLOD || n.envMap || n.transmission) && n.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ].filter(ca).join(`
`);
}
function xE(n) {
  return [
    n.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : ""
  ].filter(ca).join(`
`);
}
function bE(n) {
  const t = [];
  for (const e in n) {
    const i = n[e];
    i !== !1 && t.push("#define " + e + " " + i);
  }
  return t.join(`
`);
}
function EE(n, t) {
  const e = {}, i = n.getProgramParameter(t, n.ACTIVE_ATTRIBUTES);
  for (let r = 0; r < i; r++) {
    const s = n.getActiveAttrib(t, r), a = s.name;
    let o = 1;
    s.type === n.FLOAT_MAT2 && (o = 2), s.type === n.FLOAT_MAT3 && (o = 3), s.type === n.FLOAT_MAT4 && (o = 4), e[a] = {
      type: s.type,
      location: n.getAttribLocation(t, a),
      locationSize: o
    };
  }
  return e;
}
function ca(n) {
  return n !== "";
}
function Yh(n, t) {
  const e = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
  return n.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, e).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
}
function Kh(n, t) {
  return n.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection);
}
const wE = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Al(n) {
  return n.replace(wE, SE);
}
const ME = /* @__PURE__ */ new Map([
  ["encodings_fragment", "colorspace_fragment"],
  // @deprecated, r154
  ["encodings_pars_fragment", "colorspace_pars_fragment"],
  // @deprecated, r154
  ["output_fragment", "opaque_fragment"]
  // @deprecated, r154
]);
function SE(n, t) {
  let e = Re[t];
  if (e === void 0) {
    const i = ME.get(t);
    if (i !== void 0)
      e = Re[i], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', t, i);
    else
      throw new Error("Can not resolve #include <" + t + ">");
  }
  return Al(e);
}
const AE = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Zh(n) {
  return n.replace(AE, TE);
}
function TE(n, t, e, i) {
  let r = "";
  for (let s = parseInt(t); s < parseInt(e); s++)
    r += i.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
  return r;
}
function Jh(n) {
  let t = "precision " + n.precision + ` float;
precision ` + n.precision + " int;";
  return n.precision === "highp" ? t += `
#define HIGH_PRECISION` : n.precision === "mediump" ? t += `
#define MEDIUM_PRECISION` : n.precision === "lowp" && (t += `
#define LOW_PRECISION`), t;
}
function CE(n) {
  let t = "SHADOWMAP_TYPE_BASIC";
  return n.shadowMapType === ld ? t = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === Gy ? t = "SHADOWMAP_TYPE_PCF_SOFT" : n.shadowMapType === rr && (t = "SHADOWMAP_TYPE_VSM"), t;
}
function RE(n) {
  let t = "ENVMAP_TYPE_CUBE";
  if (n.envMap)
    switch (n.envMapMode) {
      case ma:
      case _a:
        t = "ENVMAP_TYPE_CUBE";
        break;
      case lu:
        t = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return t;
}
function IE(n) {
  let t = "ENVMAP_MODE_REFLECTION";
  if (n.envMap)
    switch (n.envMapMode) {
      case _a:
        t = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return t;
}
function PE(n) {
  let t = "ENVMAP_BLENDING_NONE";
  if (n.envMap)
    switch (n.combine) {
      case fd:
        t = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case fg:
        t = "ENVMAP_BLENDING_MIX";
        break;
      case hg:
        t = "ENVMAP_BLENDING_ADD";
        break;
    }
  return t;
}
function LE(n) {
  const t = n.envMapCubeUVHeight;
  if (t === null)
    return null;
  const e = Math.log2(t) - 2, i = 1 / t;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, e), 7 * 16)), texelHeight: i, maxMip: e };
}
function OE(n, t, e, i) {
  const r = n.getContext(), s = e.defines;
  let a = e.vertexShader, o = e.fragmentShader;
  const c = CE(e), h = RE(e), l = IE(e), f = PE(e), d = LE(e), m = e.isWebGL2 ? "" : vE(e), v = xE(e), E = bE(s), _ = r.createProgram();
  let p, R, M = e.glslVersion ? "#version " + e.glslVersion + `
` : "";
  e.isRawShaderMaterial ? (p = [
    "#define SHADER_TYPE " + e.shaderType,
    "#define SHADER_NAME " + e.shaderName,
    E
  ].filter(ca).join(`
`), p.length > 0 && (p += `
`), R = [
    m,
    "#define SHADER_TYPE " + e.shaderType,
    "#define SHADER_NAME " + e.shaderName,
    E
  ].filter(ca).join(`
`), R.length > 0 && (R += `
`)) : (p = [
    Jh(e),
    "#define SHADER_TYPE " + e.shaderType,
    "#define SHADER_NAME " + e.shaderName,
    E,
    e.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
    e.batching ? "#define USE_BATCHING" : "",
    e.instancing ? "#define USE_INSTANCING" : "",
    e.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    e.useFog && e.fog ? "#define USE_FOG" : "",
    e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "",
    e.map ? "#define USE_MAP" : "",
    e.envMap ? "#define USE_ENVMAP" : "",
    e.envMap ? "#define " + l : "",
    e.lightMap ? "#define USE_LIGHTMAP" : "",
    e.aoMap ? "#define USE_AOMAP" : "",
    e.bumpMap ? "#define USE_BUMPMAP" : "",
    e.normalMap ? "#define USE_NORMALMAP" : "",
    e.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    e.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    e.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
    e.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    e.anisotropy ? "#define USE_ANISOTROPY" : "",
    e.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    e.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    e.specularMap ? "#define USE_SPECULARMAP" : "",
    e.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    e.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    e.metalnessMap ? "#define USE_METALNESSMAP" : "",
    e.alphaMap ? "#define USE_ALPHAMAP" : "",
    e.alphaHash ? "#define USE_ALPHAHASH" : "",
    e.transmission ? "#define USE_TRANSMISSION" : "",
    e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    e.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    e.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    e.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    //
    e.mapUv ? "#define MAP_UV " + e.mapUv : "",
    e.alphaMapUv ? "#define ALPHAMAP_UV " + e.alphaMapUv : "",
    e.lightMapUv ? "#define LIGHTMAP_UV " + e.lightMapUv : "",
    e.aoMapUv ? "#define AOMAP_UV " + e.aoMapUv : "",
    e.emissiveMapUv ? "#define EMISSIVEMAP_UV " + e.emissiveMapUv : "",
    e.bumpMapUv ? "#define BUMPMAP_UV " + e.bumpMapUv : "",
    e.normalMapUv ? "#define NORMALMAP_UV " + e.normalMapUv : "",
    e.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + e.displacementMapUv : "",
    e.metalnessMapUv ? "#define METALNESSMAP_UV " + e.metalnessMapUv : "",
    e.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + e.roughnessMapUv : "",
    e.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + e.anisotropyMapUv : "",
    e.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + e.clearcoatMapUv : "",
    e.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + e.clearcoatNormalMapUv : "",
    e.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + e.clearcoatRoughnessMapUv : "",
    e.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + e.iridescenceMapUv : "",
    e.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + e.iridescenceThicknessMapUv : "",
    e.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + e.sheenColorMapUv : "",
    e.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + e.sheenRoughnessMapUv : "",
    e.specularMapUv ? "#define SPECULARMAP_UV " + e.specularMapUv : "",
    e.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + e.specularColorMapUv : "",
    e.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + e.specularIntensityMapUv : "",
    e.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + e.transmissionMapUv : "",
    e.thicknessMapUv ? "#define THICKNESSMAP_UV " + e.thicknessMapUv : "",
    //
    e.vertexTangents && e.flatShading === !1 ? "#define USE_TANGENT" : "",
    e.vertexColors ? "#define USE_COLOR" : "",
    e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    e.vertexUv1s ? "#define USE_UV1" : "",
    e.vertexUv2s ? "#define USE_UV2" : "",
    e.vertexUv3s ? "#define USE_UV3" : "",
    e.pointsUvs ? "#define USE_POINTS_UV" : "",
    e.flatShading ? "#define FLAT_SHADED" : "",
    e.skinning ? "#define USE_SKINNING" : "",
    e.morphTargets ? "#define USE_MORPHTARGETS" : "",
    e.morphNormals && e.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    e.morphColors && e.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
    e.morphTargetsCount > 0 && e.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
    e.morphTargetsCount > 0 && e.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + e.morphTextureStride : "",
    e.morphTargetsCount > 0 && e.isWebGL2 ? "#define MORPHTARGETS_COUNT " + e.morphTargetsCount : "",
    e.doubleSided ? "#define DOUBLE_SIDED" : "",
    e.flipSided ? "#define FLIP_SIDED" : "",
    e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    e.shadowMapEnabled ? "#define " + c : "",
    e.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    e.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    e.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
    e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    e.logarithmicDepthBuffer && e.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_UV1",
    "	attribute vec2 uv1;",
    "#endif",
    "#ifdef USE_UV2",
    "	attribute vec2 uv2;",
    "#endif",
    "#ifdef USE_UV3",
    "	attribute vec2 uv3;",
    "#endif",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
    "	attribute vec3 morphTarget0;",
    "	attribute vec3 morphTarget1;",
    "	attribute vec3 morphTarget2;",
    "	attribute vec3 morphTarget3;",
    "	#ifdef USE_MORPHNORMALS",
    "		attribute vec3 morphNormal0;",
    "		attribute vec3 morphNormal1;",
    "		attribute vec3 morphNormal2;",
    "		attribute vec3 morphNormal3;",
    "	#else",
    "		attribute vec3 morphTarget4;",
    "		attribute vec3 morphTarget5;",
    "		attribute vec3 morphTarget6;",
    "		attribute vec3 morphTarget7;",
    "	#endif",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(ca).join(`
`), R = [
    m,
    Jh(e),
    "#define SHADER_TYPE " + e.shaderType,
    "#define SHADER_NAME " + e.shaderName,
    E,
    e.useFog && e.fog ? "#define USE_FOG" : "",
    e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "",
    e.map ? "#define USE_MAP" : "",
    e.matcap ? "#define USE_MATCAP" : "",
    e.envMap ? "#define USE_ENVMAP" : "",
    e.envMap ? "#define " + h : "",
    e.envMap ? "#define " + l : "",
    e.envMap ? "#define " + f : "",
    d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
    d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
    d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
    e.lightMap ? "#define USE_LIGHTMAP" : "",
    e.aoMap ? "#define USE_AOMAP" : "",
    e.bumpMap ? "#define USE_BUMPMAP" : "",
    e.normalMap ? "#define USE_NORMALMAP" : "",
    e.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    e.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    e.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    e.anisotropy ? "#define USE_ANISOTROPY" : "",
    e.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    e.clearcoat ? "#define USE_CLEARCOAT" : "",
    e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    e.iridescence ? "#define USE_IRIDESCENCE" : "",
    e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    e.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    e.specularMap ? "#define USE_SPECULARMAP" : "",
    e.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    e.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    e.metalnessMap ? "#define USE_METALNESSMAP" : "",
    e.alphaMap ? "#define USE_ALPHAMAP" : "",
    e.alphaTest ? "#define USE_ALPHATEST" : "",
    e.alphaHash ? "#define USE_ALPHAHASH" : "",
    e.sheen ? "#define USE_SHEEN" : "",
    e.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    e.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    e.transmission ? "#define USE_TRANSMISSION" : "",
    e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    e.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    e.vertexTangents && e.flatShading === !1 ? "#define USE_TANGENT" : "",
    e.vertexColors || e.instancingColor ? "#define USE_COLOR" : "",
    e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    e.vertexUv1s ? "#define USE_UV1" : "",
    e.vertexUv2s ? "#define USE_UV2" : "",
    e.vertexUv3s ? "#define USE_UV3" : "",
    e.pointsUvs ? "#define USE_POINTS_UV" : "",
    e.gradientMap ? "#define USE_GRADIENTMAP" : "",
    e.flatShading ? "#define FLAT_SHADED" : "",
    e.doubleSided ? "#define DOUBLE_SIDED" : "",
    e.flipSided ? "#define FLIP_SIDED" : "",
    e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    e.shadowMapEnabled ? "#define " + c : "",
    e.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    e.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    e.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
    e.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    e.logarithmicDepthBuffer && e.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    e.toneMapping !== zr ? "#define TONE_MAPPING" : "",
    e.toneMapping !== zr ? Re.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    e.toneMapping !== zr ? gE("toneMapping", e.toneMapping) : "",
    e.dithering ? "#define DITHERING" : "",
    e.opaque ? "#define OPAQUE" : "",
    Re.colorspace_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    yE("linearToOutputTexel", e.outputColorSpace),
    e.useDepthPacking ? "#define DEPTH_PACKING " + e.depthPacking : "",
    `
`
  ].filter(ca).join(`
`)), a = Al(a), a = Yh(a, e), a = Kh(a, e), o = Al(o), o = Yh(o, e), o = Kh(o, e), a = Zh(a), o = Zh(o), e.isWebGL2 && e.isRawShaderMaterial !== !0 && (M = `#version 300 es
`, p = [
    v,
    "precision mediump sampler2DArray;",
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + p, R = [
    "precision mediump sampler2DArray;",
    "#define varying in",
    e.glslVersion === _h ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    e.glslVersion === _h ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + R);
  const P = M + p + a, W = M + R + o, C = $h(r, r.VERTEX_SHADER, P), D = $h(r, r.FRAGMENT_SHADER, W);
  r.attachShader(_, C), r.attachShader(_, D), e.index0AttributeName !== void 0 ? r.bindAttribLocation(_, 0, e.index0AttributeName) : e.morphTargets === !0 && r.bindAttribLocation(_, 0, "position"), r.linkProgram(_);
  function N(V) {
    if (n.debug.checkShaderErrors) {
      const mt = r.getProgramInfoLog(_).trim(), k = r.getShaderInfoLog(C).trim(), B = r.getShaderInfoLog(D).trim();
      let G = !0, H = !0;
      if (r.getProgramParameter(_, r.LINK_STATUS) === !1)
        if (G = !1, typeof n.debug.onShaderError == "function")
          n.debug.onShaderError(r, _, C, D);
        else {
          const w = Xh(r, C, "vertex"), ut = Xh(r, D, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(_, r.VALIDATE_STATUS) + `

Program Info Log: ` + mt + `
` + w + `
` + ut
          );
        }
      else
        mt !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", mt) : (k === "" || B === "") && (H = !1);
      H && (V.diagnostics = {
        runnable: G,
        programLog: mt,
        vertexShader: {
          log: k,
          prefix: p
        },
        fragmentShader: {
          log: B,
          prefix: R
        }
      });
    }
    r.deleteShader(C), r.deleteShader(D), A = new Yc(r, _), I = EE(r, _);
  }
  let A;
  this.getUniforms = function() {
    return A === void 0 && N(this), A;
  };
  let I;
  this.getAttributes = function() {
    return I === void 0 && N(this), I;
  };
  let it = e.rendererExtensionParallelShaderCompile === !1;
  return this.isReady = function() {
    return it === !1 && (it = r.getProgramParameter(_, pE)), it;
  }, this.destroy = function() {
    i.releaseStatesOfProgram(this), r.deleteProgram(_), this.program = void 0;
  }, this.type = e.shaderType, this.name = e.shaderName, this.id = dE++, this.cacheKey = t, this.usedTimes = 1, this.program = _, this.vertexShader = C, this.fragmentShader = D, this;
}
let DE = 0;
class NE {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(t) {
    const e = t.vertexShader, i = t.fragmentShader, r = this._getShaderStage(e), s = this._getShaderStage(i), a = this._getShaderCacheForMaterial(t);
    return a.has(r) === !1 && (a.add(r), r.usedTimes++), a.has(s) === !1 && (a.add(s), s.usedTimes++), this;
  }
  remove(t) {
    const e = this.materialCache.get(t);
    for (const i of e)
      i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
    return this.materialCache.delete(t), this;
  }
  getVertexShaderID(t) {
    return this._getShaderStage(t.vertexShader).id;
  }
  getFragmentShaderID(t) {
    return this._getShaderStage(t.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(t) {
    const e = this.materialCache;
    let i = e.get(t);
    return i === void 0 && (i = /* @__PURE__ */ new Set(), e.set(t, i)), i;
  }
  _getShaderStage(t) {
    const e = this.shaderCache;
    let i = e.get(t);
    return i === void 0 && (i = new FE(t), e.set(t, i)), i;
  }
}
class FE {
  constructor(t) {
    this.id = DE++, this.code = t, this.usedTimes = 0;
  }
}
function UE(n, t, e, i, r, s, a) {
  const o = new Td(), c = new NE(), h = [], l = r.isWebGL2, f = r.logarithmicDepthBuffer, d = r.vertexTextures;
  let m = r.precision;
  const v = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function E(A) {
    return A === 0 ? "uv" : `uv${A}`;
  }
  function _(A, I, it, V, mt) {
    const k = V.fog, B = mt.geometry, G = A.isMeshStandardMaterial ? V.environment : null, H = (A.isMeshStandardMaterial ? e : t).get(A.envMap || G), w = H && H.mapping === lu ? H.image.height : null, ut = v[A.type];
    A.precision !== null && (m = r.getMaxPrecision(A.precision), m !== A.precision && console.warn("THREE.WebGLProgram.getParameters:", A.precision, "not supported, using", m, "instead."));
    const pt = B.morphAttributes.position || B.morphAttributes.normal || B.morphAttributes.color, _t = pt !== void 0 ? pt.length : 0;
    let vt = 0;
    B.morphAttributes.position !== void 0 && (vt = 1), B.morphAttributes.normal !== void 0 && (vt = 2), B.morphAttributes.color !== void 0 && (vt = 3);
    let F, rt, b, lt;
    if (ut) {
      const Je = Di[ut];
      F = Je.vertexShader, rt = Je.fragmentShader;
    } else
      F = A.vertexShader, rt = A.fragmentShader, c.update(A), b = c.getVertexShaderID(A), lt = c.getFragmentShaderID(A);
    const q = n.getRenderTarget(), U = mt.isInstancedMesh === !0, L = mt.isBatchedMesh === !0, j = !!A.map, Y = !!A.matcap, K = !!H, yt = !!A.aoMap, Et = !!A.lightMap, Ct = !!A.bumpMap, Lt = !!A.normalMap, Wt = !!A.displacementMap, wt = !!A.emissiveMap, Q = !!A.metalnessMap, y = !!A.roughnessMap, g = A.anisotropy > 0, S = A.clearcoat > 0, O = A.iridescence > 0, Z = A.sheen > 0, tt = A.transmission > 0, gt = g && !!A.anisotropyMap, st = S && !!A.clearcoatMap, Tt = S && !!A.clearcoatNormalMap, Ft = S && !!A.clearcoatRoughnessMap, ht = O && !!A.iridescenceMap, It = O && !!A.iridescenceThicknessMap, z = Z && !!A.sheenColorMap, ft = Z && !!A.sheenRoughnessMap, nt = !!A.specularMap, J = !!A.specularColorMap, Rt = !!A.specularIntensityMap, Nt = tt && !!A.transmissionMap, Yt = tt && !!A.thicknessMap, Ht = !!A.gradientMap, Pt = !!A.alphaMap, Mt = A.alphaTest > 0, $t = !!A.alphaHash, Kt = !!A.extensions, te = !!B.attributes.uv1, Qt = !!B.attributes.uv2, ee = !!B.attributes.uv3;
    let Pe = zr;
    return A.toneMapped && (q === null || q.isXRRenderTarget === !0) && (Pe = n.toneMapping), {
      isWebGL2: l,
      shaderID: ut,
      shaderType: A.type,
      shaderName: A.name,
      vertexShader: F,
      fragmentShader: rt,
      defines: A.defines,
      customVertexShaderID: b,
      customFragmentShaderID: lt,
      isRawShaderMaterial: A.isRawShaderMaterial === !0,
      glslVersion: A.glslVersion,
      precision: m,
      batching: L,
      instancing: U,
      instancingColor: U && mt.instanceColor !== null,
      supportsVertexTextures: d,
      outputColorSpace: q === null ? n.outputColorSpace : q.isXRRenderTarget === !0 ? q.texture.colorSpace : lr,
      map: j,
      matcap: Y,
      envMap: K,
      envMapMode: K && H.mapping,
      envMapCubeUVHeight: w,
      aoMap: yt,
      lightMap: Et,
      bumpMap: Ct,
      normalMap: Lt,
      displacementMap: d && Wt,
      emissiveMap: wt,
      normalMapObjectSpace: Lt && A.normalMapType === Pg,
      normalMapTangentSpace: Lt && A.normalMapType === Ed,
      metalnessMap: Q,
      roughnessMap: y,
      anisotropy: g,
      anisotropyMap: gt,
      clearcoat: S,
      clearcoatMap: st,
      clearcoatNormalMap: Tt,
      clearcoatRoughnessMap: Ft,
      iridescence: O,
      iridescenceMap: ht,
      iridescenceThicknessMap: It,
      sheen: Z,
      sheenColorMap: z,
      sheenRoughnessMap: ft,
      specularMap: nt,
      specularColorMap: J,
      specularIntensityMap: Rt,
      transmission: tt,
      transmissionMap: Nt,
      thicknessMap: Yt,
      gradientMap: Ht,
      opaque: A.transparent === !1 && A.blending === ha,
      alphaMap: Pt,
      alphaTest: Mt,
      alphaHash: $t,
      combine: A.combine,
      //
      mapUv: j && E(A.map.channel),
      aoMapUv: yt && E(A.aoMap.channel),
      lightMapUv: Et && E(A.lightMap.channel),
      bumpMapUv: Ct && E(A.bumpMap.channel),
      normalMapUv: Lt && E(A.normalMap.channel),
      displacementMapUv: Wt && E(A.displacementMap.channel),
      emissiveMapUv: wt && E(A.emissiveMap.channel),
      metalnessMapUv: Q && E(A.metalnessMap.channel),
      roughnessMapUv: y && E(A.roughnessMap.channel),
      anisotropyMapUv: gt && E(A.anisotropyMap.channel),
      clearcoatMapUv: st && E(A.clearcoatMap.channel),
      clearcoatNormalMapUv: Tt && E(A.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Ft && E(A.clearcoatRoughnessMap.channel),
      iridescenceMapUv: ht && E(A.iridescenceMap.channel),
      iridescenceThicknessMapUv: It && E(A.iridescenceThicknessMap.channel),
      sheenColorMapUv: z && E(A.sheenColorMap.channel),
      sheenRoughnessMapUv: ft && E(A.sheenRoughnessMap.channel),
      specularMapUv: nt && E(A.specularMap.channel),
      specularColorMapUv: J && E(A.specularColorMap.channel),
      specularIntensityMapUv: Rt && E(A.specularIntensityMap.channel),
      transmissionMapUv: Nt && E(A.transmissionMap.channel),
      thicknessMapUv: Yt && E(A.thicknessMap.channel),
      alphaMapUv: Pt && E(A.alphaMap.channel),
      //
      vertexTangents: !!B.attributes.tangent && (Lt || g),
      vertexColors: A.vertexColors,
      vertexAlphas: A.vertexColors === !0 && !!B.attributes.color && B.attributes.color.itemSize === 4,
      vertexUv1s: te,
      vertexUv2s: Qt,
      vertexUv3s: ee,
      pointsUvs: mt.isPoints === !0 && !!B.attributes.uv && (j || Pt),
      fog: !!k,
      useFog: A.fog === !0,
      fogExp2: k && k.isFogExp2,
      flatShading: A.flatShading === !0,
      sizeAttenuation: A.sizeAttenuation === !0,
      logarithmicDepthBuffer: f,
      skinning: mt.isSkinnedMesh === !0,
      morphTargets: B.morphAttributes.position !== void 0,
      morphNormals: B.morphAttributes.normal !== void 0,
      morphColors: B.morphAttributes.color !== void 0,
      morphTargetsCount: _t,
      morphTextureStride: vt,
      numDirLights: I.directional.length,
      numPointLights: I.point.length,
      numSpotLights: I.spot.length,
      numSpotLightMaps: I.spotLightMap.length,
      numRectAreaLights: I.rectArea.length,
      numHemiLights: I.hemi.length,
      numDirLightShadows: I.directionalShadowMap.length,
      numPointLightShadows: I.pointShadowMap.length,
      numSpotLightShadows: I.spotShadowMap.length,
      numSpotLightShadowsWithMaps: I.numSpotLightShadowsWithMaps,
      numLightProbes: I.numLightProbes,
      numClippingPlanes: a.numPlanes,
      numClipIntersection: a.numIntersection,
      dithering: A.dithering,
      shadowMapEnabled: n.shadowMap.enabled && it.length > 0,
      shadowMapType: n.shadowMap.type,
      toneMapping: Pe,
      useLegacyLights: n._useLegacyLights,
      decodeVideoTexture: j && A.map.isVideoTexture === !0 && Ke.getTransfer(A.map.colorSpace) === nn,
      premultipliedAlpha: A.premultipliedAlpha,
      doubleSided: A.side === Mi,
      flipSided: A.side === Zn,
      useDepthPacking: A.depthPacking >= 0,
      depthPacking: A.depthPacking || 0,
      index0AttributeName: A.index0AttributeName,
      extensionDerivatives: Kt && A.extensions.derivatives === !0,
      extensionFragDepth: Kt && A.extensions.fragDepth === !0,
      extensionDrawBuffers: Kt && A.extensions.drawBuffers === !0,
      extensionShaderTextureLOD: Kt && A.extensions.shaderTextureLOD === !0,
      extensionClipCullDistance: Kt && A.extensions.clipCullDistance && i.has("WEBGL_clip_cull_distance"),
      rendererExtensionFragDepth: l || i.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: l || i.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: l || i.has("EXT_shader_texture_lod"),
      rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: A.customProgramCacheKey()
    };
  }
  function p(A) {
    const I = [];
    if (A.shaderID ? I.push(A.shaderID) : (I.push(A.customVertexShaderID), I.push(A.customFragmentShaderID)), A.defines !== void 0)
      for (const it in A.defines)
        I.push(it), I.push(A.defines[it]);
    return A.isRawShaderMaterial === !1 && (R(I, A), M(I, A), I.push(n.outputColorSpace)), I.push(A.customProgramCacheKey), I.join();
  }
  function R(A, I) {
    A.push(I.precision), A.push(I.outputColorSpace), A.push(I.envMapMode), A.push(I.envMapCubeUVHeight), A.push(I.mapUv), A.push(I.alphaMapUv), A.push(I.lightMapUv), A.push(I.aoMapUv), A.push(I.bumpMapUv), A.push(I.normalMapUv), A.push(I.displacementMapUv), A.push(I.emissiveMapUv), A.push(I.metalnessMapUv), A.push(I.roughnessMapUv), A.push(I.anisotropyMapUv), A.push(I.clearcoatMapUv), A.push(I.clearcoatNormalMapUv), A.push(I.clearcoatRoughnessMapUv), A.push(I.iridescenceMapUv), A.push(I.iridescenceThicknessMapUv), A.push(I.sheenColorMapUv), A.push(I.sheenRoughnessMapUv), A.push(I.specularMapUv), A.push(I.specularColorMapUv), A.push(I.specularIntensityMapUv), A.push(I.transmissionMapUv), A.push(I.thicknessMapUv), A.push(I.combine), A.push(I.fogExp2), A.push(I.sizeAttenuation), A.push(I.morphTargetsCount), A.push(I.morphAttributeCount), A.push(I.numDirLights), A.push(I.numPointLights), A.push(I.numSpotLights), A.push(I.numSpotLightMaps), A.push(I.numHemiLights), A.push(I.numRectAreaLights), A.push(I.numDirLightShadows), A.push(I.numPointLightShadows), A.push(I.numSpotLightShadows), A.push(I.numSpotLightShadowsWithMaps), A.push(I.numLightProbes), A.push(I.shadowMapType), A.push(I.toneMapping), A.push(I.numClippingPlanes), A.push(I.numClipIntersection), A.push(I.depthPacking);
  }
  function M(A, I) {
    o.disableAll(), I.isWebGL2 && o.enable(0), I.supportsVertexTextures && o.enable(1), I.instancing && o.enable(2), I.instancingColor && o.enable(3), I.matcap && o.enable(4), I.envMap && o.enable(5), I.normalMapObjectSpace && o.enable(6), I.normalMapTangentSpace && o.enable(7), I.clearcoat && o.enable(8), I.iridescence && o.enable(9), I.alphaTest && o.enable(10), I.vertexColors && o.enable(11), I.vertexAlphas && o.enable(12), I.vertexUv1s && o.enable(13), I.vertexUv2s && o.enable(14), I.vertexUv3s && o.enable(15), I.vertexTangents && o.enable(16), I.anisotropy && o.enable(17), I.alphaHash && o.enable(18), I.batching && o.enable(19), A.push(o.mask), o.disableAll(), I.fog && o.enable(0), I.useFog && o.enable(1), I.flatShading && o.enable(2), I.logarithmicDepthBuffer && o.enable(3), I.skinning && o.enable(4), I.morphTargets && o.enable(5), I.morphNormals && o.enable(6), I.morphColors && o.enable(7), I.premultipliedAlpha && o.enable(8), I.shadowMapEnabled && o.enable(9), I.useLegacyLights && o.enable(10), I.doubleSided && o.enable(11), I.flipSided && o.enable(12), I.useDepthPacking && o.enable(13), I.dithering && o.enable(14), I.transmission && o.enable(15), I.sheen && o.enable(16), I.opaque && o.enable(17), I.pointsUvs && o.enable(18), I.decodeVideoTexture && o.enable(19), A.push(o.mask);
  }
  function P(A) {
    const I = v[A.type];
    let it;
    if (I) {
      const V = Di[I];
      it = gv.clone(V.uniforms);
    } else
      it = A.uniforms;
    return it;
  }
  function W(A, I) {
    let it;
    for (let V = 0, mt = h.length; V < mt; V++) {
      const k = h[V];
      if (k.cacheKey === I) {
        it = k, ++it.usedTimes;
        break;
      }
    }
    return it === void 0 && (it = new OE(n, I, A, s), h.push(it)), it;
  }
  function C(A) {
    if (--A.usedTimes === 0) {
      const I = h.indexOf(A);
      h[I] = h[h.length - 1], h.pop(), A.destroy();
    }
  }
  function D(A) {
    c.remove(A);
  }
  function N() {
    c.dispose();
  }
  return {
    getParameters: _,
    getProgramCacheKey: p,
    getUniforms: P,
    acquireProgram: W,
    releaseProgram: C,
    releaseShaderCache: D,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: h,
    dispose: N
  };
}
function BE() {
  let n = /* @__PURE__ */ new WeakMap();
  function t(s) {
    let a = n.get(s);
    return a === void 0 && (a = {}, n.set(s, a)), a;
  }
  function e(s) {
    n.delete(s);
  }
  function i(s, a, o) {
    n.get(s)[a] = o;
  }
  function r() {
    n = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: t,
    remove: e,
    update: i,
    dispose: r
  };
}
function kE(n, t) {
  return n.groupOrder !== t.groupOrder ? n.groupOrder - t.groupOrder : n.renderOrder !== t.renderOrder ? n.renderOrder - t.renderOrder : n.material.id !== t.material.id ? n.material.id - t.material.id : n.z !== t.z ? n.z - t.z : n.id - t.id;
}
function Qh(n, t) {
  return n.groupOrder !== t.groupOrder ? n.groupOrder - t.groupOrder : n.renderOrder !== t.renderOrder ? n.renderOrder - t.renderOrder : n.z !== t.z ? t.z - n.z : n.id - t.id;
}
function tp() {
  const n = [];
  let t = 0;
  const e = [], i = [], r = [];
  function s() {
    t = 0, e.length = 0, i.length = 0, r.length = 0;
  }
  function a(f, d, m, v, E, _) {
    let p = n[t];
    return p === void 0 ? (p = {
      id: f.id,
      object: f,
      geometry: d,
      material: m,
      groupOrder: v,
      renderOrder: f.renderOrder,
      z: E,
      group: _
    }, n[t] = p) : (p.id = f.id, p.object = f, p.geometry = d, p.material = m, p.groupOrder = v, p.renderOrder = f.renderOrder, p.z = E, p.group = _), t++, p;
  }
  function o(f, d, m, v, E, _) {
    const p = a(f, d, m, v, E, _);
    m.transmission > 0 ? i.push(p) : m.transparent === !0 ? r.push(p) : e.push(p);
  }
  function c(f, d, m, v, E, _) {
    const p = a(f, d, m, v, E, _);
    m.transmission > 0 ? i.unshift(p) : m.transparent === !0 ? r.unshift(p) : e.unshift(p);
  }
  function h(f, d) {
    e.length > 1 && e.sort(f || kE), i.length > 1 && i.sort(d || Qh), r.length > 1 && r.sort(d || Qh);
  }
  function l() {
    for (let f = t, d = n.length; f < d; f++) {
      const m = n[f];
      if (m.id === null)
        break;
      m.id = null, m.object = null, m.geometry = null, m.material = null, m.group = null;
    }
  }
  return {
    opaque: e,
    transmissive: i,
    transparent: r,
    init: s,
    push: o,
    unshift: c,
    finish: l,
    sort: h
  };
}
function zE() {
  let n = /* @__PURE__ */ new WeakMap();
  function t(i, r) {
    const s = n.get(i);
    let a;
    return s === void 0 ? (a = new tp(), n.set(i, [a])) : r >= s.length ? (a = new tp(), s.push(a)) : a = s[r], a;
  }
  function e() {
    n = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: t,
    dispose: e
  };
}
function GE() {
  const n = {};
  return {
    get: function(t) {
      if (n[t.id] !== void 0)
        return n[t.id];
      let e;
      switch (t.type) {
        case "DirectionalLight":
          e = {
            direction: new Gt(),
            color: new Ue()
          };
          break;
        case "SpotLight":
          e = {
            position: new Gt(),
            direction: new Gt(),
            color: new Ue(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          e = {
            position: new Gt(),
            color: new Ue(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          e = {
            direction: new Gt(),
            skyColor: new Ue(),
            groundColor: new Ue()
          };
          break;
        case "RectAreaLight":
          e = {
            color: new Ue(),
            position: new Gt(),
            halfWidth: new Gt(),
            halfHeight: new Gt()
          };
          break;
      }
      return n[t.id] = e, e;
    }
  };
}
function VE() {
  const n = {};
  return {
    get: function(t) {
      if (n[t.id] !== void 0)
        return n[t.id];
      let e;
      switch (t.type) {
        case "DirectionalLight":
          e = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new fe()
          };
          break;
        case "SpotLight":
          e = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new fe()
          };
          break;
        case "PointLight":
          e = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new fe(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return n[t.id] = e, e;
    }
  };
}
let HE = 0;
function jE(n, t) {
  return (t.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (n.map ? 1 : 0);
}
function WE(n, t) {
  const e = new GE(), i = VE(), r = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let l = 0; l < 9; l++)
    r.probe.push(new Gt());
  const s = new Gt(), a = new vn(), o = new vn();
  function c(l, f) {
    let d = 0, m = 0, v = 0;
    for (let V = 0; V < 9; V++)
      r.probe[V].set(0, 0, 0);
    let E = 0, _ = 0, p = 0, R = 0, M = 0, P = 0, W = 0, C = 0, D = 0, N = 0, A = 0;
    l.sort(jE);
    const I = f === !0 ? Math.PI : 1;
    for (let V = 0, mt = l.length; V < mt; V++) {
      const k = l[V], B = k.color, G = k.intensity, H = k.distance, w = k.shadow && k.shadow.map ? k.shadow.map.texture : null;
      if (k.isAmbientLight)
        d += B.r * G * I, m += B.g * G * I, v += B.b * G * I;
      else if (k.isLightProbe) {
        for (let ut = 0; ut < 9; ut++)
          r.probe[ut].addScaledVector(k.sh.coefficients[ut], G);
        A++;
      } else if (k.isDirectionalLight) {
        const ut = e.get(k);
        if (ut.color.copy(k.color).multiplyScalar(k.intensity * I), k.castShadow) {
          const pt = k.shadow, _t = i.get(k);
          _t.shadowBias = pt.bias, _t.shadowNormalBias = pt.normalBias, _t.shadowRadius = pt.radius, _t.shadowMapSize = pt.mapSize, r.directionalShadow[E] = _t, r.directionalShadowMap[E] = w, r.directionalShadowMatrix[E] = k.shadow.matrix, P++;
        }
        r.directional[E] = ut, E++;
      } else if (k.isSpotLight) {
        const ut = e.get(k);
        ut.position.setFromMatrixPosition(k.matrixWorld), ut.color.copy(B).multiplyScalar(G * I), ut.distance = H, ut.coneCos = Math.cos(k.angle), ut.penumbraCos = Math.cos(k.angle * (1 - k.penumbra)), ut.decay = k.decay, r.spot[p] = ut;
        const pt = k.shadow;
        if (k.map && (r.spotLightMap[D] = k.map, D++, pt.updateMatrices(k), k.castShadow && N++), r.spotLightMatrix[p] = pt.matrix, k.castShadow) {
          const _t = i.get(k);
          _t.shadowBias = pt.bias, _t.shadowNormalBias = pt.normalBias, _t.shadowRadius = pt.radius, _t.shadowMapSize = pt.mapSize, r.spotShadow[p] = _t, r.spotShadowMap[p] = w, C++;
        }
        p++;
      } else if (k.isRectAreaLight) {
        const ut = e.get(k);
        ut.color.copy(B).multiplyScalar(G), ut.halfWidth.set(k.width * 0.5, 0, 0), ut.halfHeight.set(0, k.height * 0.5, 0), r.rectArea[R] = ut, R++;
      } else if (k.isPointLight) {
        const ut = e.get(k);
        if (ut.color.copy(k.color).multiplyScalar(k.intensity * I), ut.distance = k.distance, ut.decay = k.decay, k.castShadow) {
          const pt = k.shadow, _t = i.get(k);
          _t.shadowBias = pt.bias, _t.shadowNormalBias = pt.normalBias, _t.shadowRadius = pt.radius, _t.shadowMapSize = pt.mapSize, _t.shadowCameraNear = pt.camera.near, _t.shadowCameraFar = pt.camera.far, r.pointShadow[_] = _t, r.pointShadowMap[_] = w, r.pointShadowMatrix[_] = k.shadow.matrix, W++;
        }
        r.point[_] = ut, _++;
      } else if (k.isHemisphereLight) {
        const ut = e.get(k);
        ut.skyColor.copy(k.color).multiplyScalar(G * I), ut.groundColor.copy(k.groundColor).multiplyScalar(G * I), r.hemi[M] = ut, M++;
      }
    }
    R > 0 && (t.isWebGL2 ? n.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = ue.LTC_FLOAT_1, r.rectAreaLTC2 = ue.LTC_FLOAT_2) : (r.rectAreaLTC1 = ue.LTC_HALF_1, r.rectAreaLTC2 = ue.LTC_HALF_2) : n.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = ue.LTC_FLOAT_1, r.rectAreaLTC2 = ue.LTC_FLOAT_2) : n.has("OES_texture_half_float_linear") === !0 ? (r.rectAreaLTC1 = ue.LTC_HALF_1, r.rectAreaLTC2 = ue.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = d, r.ambient[1] = m, r.ambient[2] = v;
    const it = r.hash;
    (it.directionalLength !== E || it.pointLength !== _ || it.spotLength !== p || it.rectAreaLength !== R || it.hemiLength !== M || it.numDirectionalShadows !== P || it.numPointShadows !== W || it.numSpotShadows !== C || it.numSpotMaps !== D || it.numLightProbes !== A) && (r.directional.length = E, r.spot.length = p, r.rectArea.length = R, r.point.length = _, r.hemi.length = M, r.directionalShadow.length = P, r.directionalShadowMap.length = P, r.pointShadow.length = W, r.pointShadowMap.length = W, r.spotShadow.length = C, r.spotShadowMap.length = C, r.directionalShadowMatrix.length = P, r.pointShadowMatrix.length = W, r.spotLightMatrix.length = C + D - N, r.spotLightMap.length = D, r.numSpotLightShadowsWithMaps = N, r.numLightProbes = A, it.directionalLength = E, it.pointLength = _, it.spotLength = p, it.rectAreaLength = R, it.hemiLength = M, it.numDirectionalShadows = P, it.numPointShadows = W, it.numSpotShadows = C, it.numSpotMaps = D, it.numLightProbes = A, r.version = HE++);
  }
  function h(l, f) {
    let d = 0, m = 0, v = 0, E = 0, _ = 0;
    const p = f.matrixWorldInverse;
    for (let R = 0, M = l.length; R < M; R++) {
      const P = l[R];
      if (P.isDirectionalLight) {
        const W = r.directional[d];
        W.direction.setFromMatrixPosition(P.matrixWorld), s.setFromMatrixPosition(P.target.matrixWorld), W.direction.sub(s), W.direction.transformDirection(p), d++;
      } else if (P.isSpotLight) {
        const W = r.spot[v];
        W.position.setFromMatrixPosition(P.matrixWorld), W.position.applyMatrix4(p), W.direction.setFromMatrixPosition(P.matrixWorld), s.setFromMatrixPosition(P.target.matrixWorld), W.direction.sub(s), W.direction.transformDirection(p), v++;
      } else if (P.isRectAreaLight) {
        const W = r.rectArea[E];
        W.position.setFromMatrixPosition(P.matrixWorld), W.position.applyMatrix4(p), o.identity(), a.copy(P.matrixWorld), a.premultiply(p), o.extractRotation(a), W.halfWidth.set(P.width * 0.5, 0, 0), W.halfHeight.set(0, P.height * 0.5, 0), W.halfWidth.applyMatrix4(o), W.halfHeight.applyMatrix4(o), E++;
      } else if (P.isPointLight) {
        const W = r.point[m];
        W.position.setFromMatrixPosition(P.matrixWorld), W.position.applyMatrix4(p), m++;
      } else if (P.isHemisphereLight) {
        const W = r.hemi[_];
        W.direction.setFromMatrixPosition(P.matrixWorld), W.direction.transformDirection(p), _++;
      }
    }
  }
  return {
    setup: c,
    setupView: h,
    state: r
  };
}
function ep(n, t) {
  const e = new WE(n, t), i = [], r = [];
  function s() {
    i.length = 0, r.length = 0;
  }
  function a(f) {
    i.push(f);
  }
  function o(f) {
    r.push(f);
  }
  function c(f) {
    e.setup(i, f);
  }
  function h(f) {
    e.setupView(i, f);
  }
  return {
    init: s,
    state: {
      lightsArray: i,
      shadowsArray: r,
      lights: e
    },
    setupLights: c,
    setupLightsView: h,
    pushLight: a,
    pushShadow: o
  };
}
function qE(n, t) {
  let e = /* @__PURE__ */ new WeakMap();
  function i(s, a = 0) {
    const o = e.get(s);
    let c;
    return o === void 0 ? (c = new ep(n, t), e.set(s, [c])) : a >= o.length ? (c = new ep(n, t), o.push(c)) : c = o[a], c;
  }
  function r() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: i,
    dispose: r
  };
}
class $E extends co {
  constructor(t) {
    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = Rg, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this;
  }
}
class XE extends co {
  constructor(t) {
    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this;
  }
}
const YE = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, KE = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function ZE(n, t, e) {
  let i = new Nd();
  const r = new fe(), s = new fe(), a = new In(), o = new $E({ depthPacking: Ig }), c = new XE(), h = {}, l = e.maxTextureSize, f = { [Hr]: Zn, [Zn]: Hr, [Mi]: Mi }, d = new jr({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new fe() },
      radius: { value: 4 }
    },
    vertexShader: YE,
    fragmentShader: KE
  }), m = d.clone();
  m.defines.HORIZONTAL_PASS = 1;
  const v = new fr();
  v.setAttribute(
    "position",
    new gn(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const E = new Bi(v, d), _ = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = ld;
  let p = this.type;
  this.render = function(C, D, N) {
    if (_.enabled === !1 || _.autoUpdate === !1 && _.needsUpdate === !1 || C.length === 0)
      return;
    const A = n.getRenderTarget(), I = n.getActiveCubeFace(), it = n.getActiveMipmapLevel(), V = n.state;
    V.setBlending(kr), V.buffers.color.setClear(1, 1, 1, 1), V.buffers.depth.setTest(!0), V.setScissorTest(!1);
    const mt = p !== rr && this.type === rr, k = p === rr && this.type !== rr;
    for (let B = 0, G = C.length; B < G; B++) {
      const H = C[B], w = H.shadow;
      if (w === void 0) {
        console.warn("THREE.WebGLShadowMap:", H, "has no shadow.");
        continue;
      }
      if (w.autoUpdate === !1 && w.needsUpdate === !1)
        continue;
      r.copy(w.mapSize);
      const ut = w.getFrameExtents();
      if (r.multiply(ut), s.copy(w.mapSize), (r.x > l || r.y > l) && (r.x > l && (s.x = Math.floor(l / ut.x), r.x = s.x * ut.x, w.mapSize.x = s.x), r.y > l && (s.y = Math.floor(l / ut.y), r.y = s.y * ut.y, w.mapSize.y = s.y)), w.map === null || mt === !0 || k === !0) {
        const _t = this.type !== rr ? { minFilter: Bn, magFilter: Bn } : {};
        w.map !== null && w.map.dispose(), w.map = new Cs(r.x, r.y, _t), w.map.texture.name = H.name + ".shadowMap", w.camera.updateProjectionMatrix();
      }
      n.setRenderTarget(w.map), n.clear();
      const pt = w.getViewportCount();
      for (let _t = 0; _t < pt; _t++) {
        const vt = w.getViewport(_t);
        a.set(
          s.x * vt.x,
          s.y * vt.y,
          s.x * vt.z,
          s.y * vt.w
        ), V.viewport(a), w.updateMatrices(H, _t), i = w.getFrustum(), P(D, N, w.camera, H, this.type);
      }
      w.isPointLightShadow !== !0 && this.type === rr && R(w, N), w.needsUpdate = !1;
    }
    p = this.type, _.needsUpdate = !1, n.setRenderTarget(A, I, it);
  };
  function R(C, D) {
    const N = t.update(E);
    d.defines.VSM_SAMPLES !== C.blurSamples && (d.defines.VSM_SAMPLES = C.blurSamples, m.defines.VSM_SAMPLES = C.blurSamples, d.needsUpdate = !0, m.needsUpdate = !0), C.mapPass === null && (C.mapPass = new Cs(r.x, r.y)), d.uniforms.shadow_pass.value = C.map.texture, d.uniforms.resolution.value = C.mapSize, d.uniforms.radius.value = C.radius, n.setRenderTarget(C.mapPass), n.clear(), n.renderBufferDirect(D, null, N, d, E, null), m.uniforms.shadow_pass.value = C.mapPass.texture, m.uniforms.resolution.value = C.mapSize, m.uniforms.radius.value = C.radius, n.setRenderTarget(C.map), n.clear(), n.renderBufferDirect(D, null, N, m, E, null);
  }
  function M(C, D, N, A) {
    let I = null;
    const it = N.isPointLight === !0 ? C.customDistanceMaterial : C.customDepthMaterial;
    if (it !== void 0)
      I = it;
    else if (I = N.isPointLight === !0 ? c : o, n.localClippingEnabled && D.clipShadows === !0 && Array.isArray(D.clippingPlanes) && D.clippingPlanes.length !== 0 || D.displacementMap && D.displacementScale !== 0 || D.alphaMap && D.alphaTest > 0 || D.map && D.alphaTest > 0) {
      const V = I.uuid, mt = D.uuid;
      let k = h[V];
      k === void 0 && (k = {}, h[V] = k);
      let B = k[mt];
      B === void 0 && (B = I.clone(), k[mt] = B, D.addEventListener("dispose", W)), I = B;
    }
    if (I.visible = D.visible, I.wireframe = D.wireframe, A === rr ? I.side = D.shadowSide !== null ? D.shadowSide : D.side : I.side = D.shadowSide !== null ? D.shadowSide : f[D.side], I.alphaMap = D.alphaMap, I.alphaTest = D.alphaTest, I.map = D.map, I.clipShadows = D.clipShadows, I.clippingPlanes = D.clippingPlanes, I.clipIntersection = D.clipIntersection, I.displacementMap = D.displacementMap, I.displacementScale = D.displacementScale, I.displacementBias = D.displacementBias, I.wireframeLinewidth = D.wireframeLinewidth, I.linewidth = D.linewidth, N.isPointLight === !0 && I.isMeshDistanceMaterial === !0) {
      const V = n.properties.get(I);
      V.light = N;
    }
    return I;
  }
  function P(C, D, N, A, I) {
    if (C.visible === !1)
      return;
    if (C.layers.test(D.layers) && (C.isMesh || C.isLine || C.isPoints) && (C.castShadow || C.receiveShadow && I === rr) && (!C.frustumCulled || i.intersectsObject(C))) {
      C.modelViewMatrix.multiplyMatrices(N.matrixWorldInverse, C.matrixWorld);
      const mt = t.update(C), k = C.material;
      if (Array.isArray(k)) {
        const B = mt.groups;
        for (let G = 0, H = B.length; G < H; G++) {
          const w = B[G], ut = k[w.materialIndex];
          if (ut && ut.visible) {
            const pt = M(C, ut, A, I);
            C.onBeforeShadow(n, C, D, N, mt, pt, w), n.renderBufferDirect(N, null, mt, pt, C, w), C.onAfterShadow(n, C, D, N, mt, pt, w);
          }
        }
      } else if (k.visible) {
        const B = M(C, k, A, I);
        C.onBeforeShadow(n, C, D, N, mt, B, null), n.renderBufferDirect(N, null, mt, B, C, null), C.onAfterShadow(n, C, D, N, mt, B, null);
      }
    }
    const V = C.children;
    for (let mt = 0, k = V.length; mt < k; mt++)
      P(V[mt], D, N, A, I);
  }
  function W(C) {
    C.target.removeEventListener("dispose", W);
    for (const N in h) {
      const A = h[N], I = C.target.uuid;
      I in A && (A[I].dispose(), delete A[I]);
    }
  }
}
function JE(n, t, e) {
  const i = e.isWebGL2;
  function r() {
    let Mt = !1;
    const $t = new In();
    let Kt = null;
    const te = new In(0, 0, 0, 0);
    return {
      setMask: function(Qt) {
        Kt !== Qt && !Mt && (n.colorMask(Qt, Qt, Qt, Qt), Kt = Qt);
      },
      setLocked: function(Qt) {
        Mt = Qt;
      },
      setClear: function(Qt, ee, Pe, Ne, Je) {
        Je === !0 && (Qt *= Ne, ee *= Ne, Pe *= Ne), $t.set(Qt, ee, Pe, Ne), te.equals($t) === !1 && (n.clearColor(Qt, ee, Pe, Ne), te.copy($t));
      },
      reset: function() {
        Mt = !1, Kt = null, te.set(-1, 0, 0, 0);
      }
    };
  }
  function s() {
    let Mt = !1, $t = null, Kt = null, te = null;
    return {
      setTest: function(Qt) {
        Qt ? L(n.DEPTH_TEST) : j(n.DEPTH_TEST);
      },
      setMask: function(Qt) {
        $t !== Qt && !Mt && (n.depthMask(Qt), $t = Qt);
      },
      setFunc: function(Qt) {
        if (Kt !== Qt) {
          switch (Qt) {
            case rg:
              n.depthFunc(n.NEVER);
              break;
            case sg:
              n.depthFunc(n.ALWAYS);
              break;
            case ag:
              n.depthFunc(n.LESS);
              break;
            case tu:
              n.depthFunc(n.LEQUAL);
              break;
            case og:
              n.depthFunc(n.EQUAL);
              break;
            case cg:
              n.depthFunc(n.GEQUAL);
              break;
            case ug:
              n.depthFunc(n.GREATER);
              break;
            case lg:
              n.depthFunc(n.NOTEQUAL);
              break;
            default:
              n.depthFunc(n.LEQUAL);
          }
          Kt = Qt;
        }
      },
      setLocked: function(Qt) {
        Mt = Qt;
      },
      setClear: function(Qt) {
        te !== Qt && (n.clearDepth(Qt), te = Qt);
      },
      reset: function() {
        Mt = !1, $t = null, Kt = null, te = null;
      }
    };
  }
  function a() {
    let Mt = !1, $t = null, Kt = null, te = null, Qt = null, ee = null, Pe = null, Ne = null, Je = null;
    return {
      setTest: function(ve) {
        Mt || (ve ? L(n.STENCIL_TEST) : j(n.STENCIL_TEST));
      },
      setMask: function(ve) {
        $t !== ve && !Mt && (n.stencilMask(ve), $t = ve);
      },
      setFunc: function(ve, tn, dn) {
        (Kt !== ve || te !== tn || Qt !== dn) && (n.stencilFunc(ve, tn, dn), Kt = ve, te = tn, Qt = dn);
      },
      setOp: function(ve, tn, dn) {
        (ee !== ve || Pe !== tn || Ne !== dn) && (n.stencilOp(ve, tn, dn), ee = ve, Pe = tn, Ne = dn);
      },
      setLocked: function(ve) {
        Mt = ve;
      },
      setClear: function(ve) {
        Je !== ve && (n.clearStencil(ve), Je = ve);
      },
      reset: function() {
        Mt = !1, $t = null, Kt = null, te = null, Qt = null, ee = null, Pe = null, Ne = null, Je = null;
      }
    };
  }
  const o = new r(), c = new s(), h = new a(), l = /* @__PURE__ */ new WeakMap(), f = /* @__PURE__ */ new WeakMap();
  let d = {}, m = {}, v = /* @__PURE__ */ new WeakMap(), E = [], _ = null, p = !1, R = null, M = null, P = null, W = null, C = null, D = null, N = null, A = new Ue(0, 0, 0), I = 0, it = !1, V = null, mt = null, k = null, B = null, G = null;
  const H = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let w = !1, ut = 0;
  const pt = n.getParameter(n.VERSION);
  pt.indexOf("WebGL") !== -1 ? (ut = parseFloat(/^WebGL (\d)/.exec(pt)[1]), w = ut >= 1) : pt.indexOf("OpenGL ES") !== -1 && (ut = parseFloat(/^OpenGL ES (\d)/.exec(pt)[1]), w = ut >= 2);
  let _t = null, vt = {};
  const F = n.getParameter(n.SCISSOR_BOX), rt = n.getParameter(n.VIEWPORT), b = new In().fromArray(F), lt = new In().fromArray(rt);
  function q(Mt, $t, Kt, te) {
    const Qt = new Uint8Array(4), ee = n.createTexture();
    n.bindTexture(Mt, ee), n.texParameteri(Mt, n.TEXTURE_MIN_FILTER, n.NEAREST), n.texParameteri(Mt, n.TEXTURE_MAG_FILTER, n.NEAREST);
    for (let Pe = 0; Pe < Kt; Pe++)
      i && (Mt === n.TEXTURE_3D || Mt === n.TEXTURE_2D_ARRAY) ? n.texImage3D($t, 0, n.RGBA, 1, 1, te, 0, n.RGBA, n.UNSIGNED_BYTE, Qt) : n.texImage2D($t + Pe, 0, n.RGBA, 1, 1, 0, n.RGBA, n.UNSIGNED_BYTE, Qt);
    return ee;
  }
  const U = {};
  U[n.TEXTURE_2D] = q(n.TEXTURE_2D, n.TEXTURE_2D, 1), U[n.TEXTURE_CUBE_MAP] = q(n.TEXTURE_CUBE_MAP, n.TEXTURE_CUBE_MAP_POSITIVE_X, 6), i && (U[n.TEXTURE_2D_ARRAY] = q(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1), U[n.TEXTURE_3D] = q(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1)), o.setClear(0, 0, 0, 1), c.setClear(1), h.setClear(0), L(n.DEPTH_TEST), c.setFunc(tu), wt(!1), Q(Uf), L(n.CULL_FACE), Lt(kr);
  function L(Mt) {
    d[Mt] !== !0 && (n.enable(Mt), d[Mt] = !0);
  }
  function j(Mt) {
    d[Mt] !== !1 && (n.disable(Mt), d[Mt] = !1);
  }
  function Y(Mt, $t) {
    return m[Mt] !== $t ? (n.bindFramebuffer(Mt, $t), m[Mt] = $t, i && (Mt === n.DRAW_FRAMEBUFFER && (m[n.FRAMEBUFFER] = $t), Mt === n.FRAMEBUFFER && (m[n.DRAW_FRAMEBUFFER] = $t)), !0) : !1;
  }
  function K(Mt, $t) {
    let Kt = E, te = !1;
    if (Mt)
      if (Kt = v.get($t), Kt === void 0 && (Kt = [], v.set($t, Kt)), Mt.isWebGLMultipleRenderTargets) {
        const Qt = Mt.texture;
        if (Kt.length !== Qt.length || Kt[0] !== n.COLOR_ATTACHMENT0) {
          for (let ee = 0, Pe = Qt.length; ee < Pe; ee++)
            Kt[ee] = n.COLOR_ATTACHMENT0 + ee;
          Kt.length = Qt.length, te = !0;
        }
      } else
        Kt[0] !== n.COLOR_ATTACHMENT0 && (Kt[0] = n.COLOR_ATTACHMENT0, te = !0);
    else
      Kt[0] !== n.BACK && (Kt[0] = n.BACK, te = !0);
    te && (e.isWebGL2 ? n.drawBuffers(Kt) : t.get("WEBGL_draw_buffers").drawBuffersWEBGL(Kt));
  }
  function yt(Mt) {
    return _ !== Mt ? (n.useProgram(Mt), _ = Mt, !0) : !1;
  }
  const Et = {
    [Es]: n.FUNC_ADD,
    [Hy]: n.FUNC_SUBTRACT,
    [jy]: n.FUNC_REVERSE_SUBTRACT
  };
  if (i)
    Et[Gf] = n.MIN, Et[Vf] = n.MAX;
  else {
    const Mt = t.get("EXT_blend_minmax");
    Mt !== null && (Et[Gf] = Mt.MIN_EXT, Et[Vf] = Mt.MAX_EXT);
  }
  const Ct = {
    [Wy]: n.ZERO,
    [qy]: n.ONE,
    [$y]: n.SRC_COLOR,
    [yl]: n.SRC_ALPHA,
    [Qy]: n.SRC_ALPHA_SATURATE,
    [Zy]: n.DST_COLOR,
    [Yy]: n.DST_ALPHA,
    [Xy]: n.ONE_MINUS_SRC_COLOR,
    [gl]: n.ONE_MINUS_SRC_ALPHA,
    [Jy]: n.ONE_MINUS_DST_COLOR,
    [Ky]: n.ONE_MINUS_DST_ALPHA,
    [tg]: n.CONSTANT_COLOR,
    [eg]: n.ONE_MINUS_CONSTANT_COLOR,
    [ng]: n.CONSTANT_ALPHA,
    [ig]: n.ONE_MINUS_CONSTANT_ALPHA
  };
  function Lt(Mt, $t, Kt, te, Qt, ee, Pe, Ne, Je, ve) {
    if (Mt === kr) {
      p === !0 && (j(n.BLEND), p = !1);
      return;
    }
    if (p === !1 && (L(n.BLEND), p = !0), Mt !== Vy) {
      if (Mt !== R || ve !== it) {
        if ((M !== Es || C !== Es) && (n.blendEquation(n.FUNC_ADD), M = Es, C = Es), ve)
          switch (Mt) {
            case ha:
              n.blendFuncSeparate(n.ONE, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
              break;
            case Bf:
              n.blendFunc(n.ONE, n.ONE);
              break;
            case kf:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case zf:
              n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", Mt);
              break;
          }
        else
          switch (Mt) {
            case ha:
              n.blendFuncSeparate(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
              break;
            case Bf:
              n.blendFunc(n.SRC_ALPHA, n.ONE);
              break;
            case kf:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case zf:
              n.blendFunc(n.ZERO, n.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", Mt);
              break;
          }
        P = null, W = null, D = null, N = null, A.set(0, 0, 0), I = 0, R = Mt, it = ve;
      }
      return;
    }
    Qt = Qt || $t, ee = ee || Kt, Pe = Pe || te, ($t !== M || Qt !== C) && (n.blendEquationSeparate(Et[$t], Et[Qt]), M = $t, C = Qt), (Kt !== P || te !== W || ee !== D || Pe !== N) && (n.blendFuncSeparate(Ct[Kt], Ct[te], Ct[ee], Ct[Pe]), P = Kt, W = te, D = ee, N = Pe), (Ne.equals(A) === !1 || Je !== I) && (n.blendColor(Ne.r, Ne.g, Ne.b, Je), A.copy(Ne), I = Je), R = Mt, it = !1;
  }
  function Wt(Mt, $t) {
    Mt.side === Mi ? j(n.CULL_FACE) : L(n.CULL_FACE);
    let Kt = Mt.side === Zn;
    $t && (Kt = !Kt), wt(Kt), Mt.blending === ha && Mt.transparent === !1 ? Lt(kr) : Lt(Mt.blending, Mt.blendEquation, Mt.blendSrc, Mt.blendDst, Mt.blendEquationAlpha, Mt.blendSrcAlpha, Mt.blendDstAlpha, Mt.blendColor, Mt.blendAlpha, Mt.premultipliedAlpha), c.setFunc(Mt.depthFunc), c.setTest(Mt.depthTest), c.setMask(Mt.depthWrite), o.setMask(Mt.colorWrite);
    const te = Mt.stencilWrite;
    h.setTest(te), te && (h.setMask(Mt.stencilWriteMask), h.setFunc(Mt.stencilFunc, Mt.stencilRef, Mt.stencilFuncMask), h.setOp(Mt.stencilFail, Mt.stencilZFail, Mt.stencilZPass)), g(Mt.polygonOffset, Mt.polygonOffsetFactor, Mt.polygonOffsetUnits), Mt.alphaToCoverage === !0 ? L(n.SAMPLE_ALPHA_TO_COVERAGE) : j(n.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function wt(Mt) {
    V !== Mt && (Mt ? n.frontFace(n.CW) : n.frontFace(n.CCW), V = Mt);
  }
  function Q(Mt) {
    Mt !== ky ? (L(n.CULL_FACE), Mt !== mt && (Mt === Uf ? n.cullFace(n.BACK) : Mt === zy ? n.cullFace(n.FRONT) : n.cullFace(n.FRONT_AND_BACK))) : j(n.CULL_FACE), mt = Mt;
  }
  function y(Mt) {
    Mt !== k && (w && n.lineWidth(Mt), k = Mt);
  }
  function g(Mt, $t, Kt) {
    Mt ? (L(n.POLYGON_OFFSET_FILL), (B !== $t || G !== Kt) && (n.polygonOffset($t, Kt), B = $t, G = Kt)) : j(n.POLYGON_OFFSET_FILL);
  }
  function S(Mt) {
    Mt ? L(n.SCISSOR_TEST) : j(n.SCISSOR_TEST);
  }
  function O(Mt) {
    Mt === void 0 && (Mt = n.TEXTURE0 + H - 1), _t !== Mt && (n.activeTexture(Mt), _t = Mt);
  }
  function Z(Mt, $t, Kt) {
    Kt === void 0 && (_t === null ? Kt = n.TEXTURE0 + H - 1 : Kt = _t);
    let te = vt[Kt];
    te === void 0 && (te = { type: void 0, texture: void 0 }, vt[Kt] = te), (te.type !== Mt || te.texture !== $t) && (_t !== Kt && (n.activeTexture(Kt), _t = Kt), n.bindTexture(Mt, $t || U[Mt]), te.type = Mt, te.texture = $t);
  }
  function tt() {
    const Mt = vt[_t];
    Mt !== void 0 && Mt.type !== void 0 && (n.bindTexture(Mt.type, null), Mt.type = void 0, Mt.texture = void 0);
  }
  function gt() {
    try {
      n.compressedTexImage2D.apply(n, arguments);
    } catch (Mt) {
      console.error("THREE.WebGLState:", Mt);
    }
  }
  function st() {
    try {
      n.compressedTexImage3D.apply(n, arguments);
    } catch (Mt) {
      console.error("THREE.WebGLState:", Mt);
    }
  }
  function Tt() {
    try {
      n.texSubImage2D.apply(n, arguments);
    } catch (Mt) {
      console.error("THREE.WebGLState:", Mt);
    }
  }
  function Ft() {
    try {
      n.texSubImage3D.apply(n, arguments);
    } catch (Mt) {
      console.error("THREE.WebGLState:", Mt);
    }
  }
  function ht() {
    try {
      n.compressedTexSubImage2D.apply(n, arguments);
    } catch (Mt) {
      console.error("THREE.WebGLState:", Mt);
    }
  }
  function It() {
    try {
      n.compressedTexSubImage3D.apply(n, arguments);
    } catch (Mt) {
      console.error("THREE.WebGLState:", Mt);
    }
  }
  function z() {
    try {
      n.texStorage2D.apply(n, arguments);
    } catch (Mt) {
      console.error("THREE.WebGLState:", Mt);
    }
  }
  function ft() {
    try {
      n.texStorage3D.apply(n, arguments);
    } catch (Mt) {
      console.error("THREE.WebGLState:", Mt);
    }
  }
  function nt() {
    try {
      n.texImage2D.apply(n, arguments);
    } catch (Mt) {
      console.error("THREE.WebGLState:", Mt);
    }
  }
  function J() {
    try {
      n.texImage3D.apply(n, arguments);
    } catch (Mt) {
      console.error("THREE.WebGLState:", Mt);
    }
  }
  function Rt(Mt) {
    b.equals(Mt) === !1 && (n.scissor(Mt.x, Mt.y, Mt.z, Mt.w), b.copy(Mt));
  }
  function Nt(Mt) {
    lt.equals(Mt) === !1 && (n.viewport(Mt.x, Mt.y, Mt.z, Mt.w), lt.copy(Mt));
  }
  function Yt(Mt, $t) {
    let Kt = f.get($t);
    Kt === void 0 && (Kt = /* @__PURE__ */ new WeakMap(), f.set($t, Kt));
    let te = Kt.get(Mt);
    te === void 0 && (te = n.getUniformBlockIndex($t, Mt.name), Kt.set(Mt, te));
  }
  function Ht(Mt, $t) {
    const te = f.get($t).get(Mt);
    l.get($t) !== te && (n.uniformBlockBinding($t, te, Mt.__bindingPointIndex), l.set($t, te));
  }
  function Pt() {
    n.disable(n.BLEND), n.disable(n.CULL_FACE), n.disable(n.DEPTH_TEST), n.disable(n.POLYGON_OFFSET_FILL), n.disable(n.SCISSOR_TEST), n.disable(n.STENCIL_TEST), n.disable(n.SAMPLE_ALPHA_TO_COVERAGE), n.blendEquation(n.FUNC_ADD), n.blendFunc(n.ONE, n.ZERO), n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO), n.blendColor(0, 0, 0, 0), n.colorMask(!0, !0, !0, !0), n.clearColor(0, 0, 0, 0), n.depthMask(!0), n.depthFunc(n.LESS), n.clearDepth(1), n.stencilMask(4294967295), n.stencilFunc(n.ALWAYS, 0, 4294967295), n.stencilOp(n.KEEP, n.KEEP, n.KEEP), n.clearStencil(0), n.cullFace(n.BACK), n.frontFace(n.CCW), n.polygonOffset(0, 0), n.activeTexture(n.TEXTURE0), n.bindFramebuffer(n.FRAMEBUFFER, null), i === !0 && (n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null), n.bindFramebuffer(n.READ_FRAMEBUFFER, null)), n.useProgram(null), n.lineWidth(1), n.scissor(0, 0, n.canvas.width, n.canvas.height), n.viewport(0, 0, n.canvas.width, n.canvas.height), d = {}, _t = null, vt = {}, m = {}, v = /* @__PURE__ */ new WeakMap(), E = [], _ = null, p = !1, R = null, M = null, P = null, W = null, C = null, D = null, N = null, A = new Ue(0, 0, 0), I = 0, it = !1, V = null, mt = null, k = null, B = null, G = null, b.set(0, 0, n.canvas.width, n.canvas.height), lt.set(0, 0, n.canvas.width, n.canvas.height), o.reset(), c.reset(), h.reset();
  }
  return {
    buffers: {
      color: o,
      depth: c,
      stencil: h
    },
    enable: L,
    disable: j,
    bindFramebuffer: Y,
    drawBuffers: K,
    useProgram: yt,
    setBlending: Lt,
    setMaterial: Wt,
    setFlipSided: wt,
    setCullFace: Q,
    setLineWidth: y,
    setPolygonOffset: g,
    setScissorTest: S,
    activeTexture: O,
    bindTexture: Z,
    unbindTexture: tt,
    compressedTexImage2D: gt,
    compressedTexImage3D: st,
    texImage2D: nt,
    texImage3D: J,
    updateUBOMapping: Yt,
    uniformBlockBinding: Ht,
    texStorage2D: z,
    texStorage3D: ft,
    texSubImage2D: Tt,
    texSubImage3D: Ft,
    compressedTexSubImage2D: ht,
    compressedTexSubImage3D: It,
    scissor: Rt,
    viewport: Nt,
    reset: Pt
  };
}
function QE(n, t, e, i, r, s, a) {
  const o = r.isWebGL2, c = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null, h = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), l = /* @__PURE__ */ new WeakMap();
  let f;
  const d = /* @__PURE__ */ new WeakMap();
  let m = !1;
  try {
    m = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function v(Q, y) {
    return m ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(Q, y)
    ) : cu("canvas");
  }
  function E(Q, y, g, S) {
    let O = 1;
    if ((Q.width > S || Q.height > S) && (O = S / Math.max(Q.width, Q.height)), O < 1 || y === !0)
      if (typeof HTMLImageElement < "u" && Q instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && Q instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && Q instanceof ImageBitmap) {
        const Z = y ? ou : Math.floor, tt = Z(O * Q.width), gt = Z(O * Q.height);
        f === void 0 && (f = v(tt, gt));
        const st = g ? v(tt, gt) : f;
        return st.width = tt, st.height = gt, st.getContext("2d").drawImage(Q, 0, 0, tt, gt), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + Q.width + "x" + Q.height + ") to (" + tt + "x" + gt + ")."), st;
      } else
        return "data" in Q && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + Q.width + "x" + Q.height + ")."), Q;
    return Q;
  }
  function _(Q) {
    return wl(Q.width) && wl(Q.height);
  }
  function p(Q) {
    return o ? !1 : Q.wrapS !== _i || Q.wrapT !== _i || Q.minFilter !== Bn && Q.minFilter !== ri;
  }
  function R(Q, y) {
    return Q.generateMipmaps && y && Q.minFilter !== Bn && Q.minFilter !== ri;
  }
  function M(Q) {
    n.generateMipmap(Q);
  }
  function P(Q, y, g, S, O = !1) {
    if (o === !1)
      return y;
    if (Q !== null) {
      if (n[Q] !== void 0)
        return n[Q];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + Q + "'");
    }
    let Z = y;
    if (y === n.RED && (g === n.FLOAT && (Z = n.R32F), g === n.HALF_FLOAT && (Z = n.R16F), g === n.UNSIGNED_BYTE && (Z = n.R8)), y === n.RED_INTEGER && (g === n.UNSIGNED_BYTE && (Z = n.R8UI), g === n.UNSIGNED_SHORT && (Z = n.R16UI), g === n.UNSIGNED_INT && (Z = n.R32UI), g === n.BYTE && (Z = n.R8I), g === n.SHORT && (Z = n.R16I), g === n.INT && (Z = n.R32I)), y === n.RG && (g === n.FLOAT && (Z = n.RG32F), g === n.HALF_FLOAT && (Z = n.RG16F), g === n.UNSIGNED_BYTE && (Z = n.RG8)), y === n.RGBA) {
      const tt = O ? iu : Ke.getTransfer(S);
      g === n.FLOAT && (Z = n.RGBA32F), g === n.HALF_FLOAT && (Z = n.RGBA16F), g === n.UNSIGNED_BYTE && (Z = tt === nn ? n.SRGB8_ALPHA8 : n.RGBA8), g === n.UNSIGNED_SHORT_4_4_4_4 && (Z = n.RGBA4), g === n.UNSIGNED_SHORT_5_5_5_1 && (Z = n.RGB5_A1);
    }
    return (Z === n.R16F || Z === n.R32F || Z === n.RG16F || Z === n.RG32F || Z === n.RGBA16F || Z === n.RGBA32F) && t.get("EXT_color_buffer_float"), Z;
  }
  function W(Q, y, g) {
    return R(Q, g) === !0 || Q.isFramebufferTexture && Q.minFilter !== Bn && Q.minFilter !== ri ? Math.log2(Math.max(y.width, y.height)) + 1 : Q.mipmaps !== void 0 && Q.mipmaps.length > 0 ? Q.mipmaps.length : Q.isCompressedTexture && Array.isArray(Q.image) ? y.mipmaps.length : 1;
  }
  function C(Q) {
    return Q === Bn || Q === bl || Q === Xc ? n.NEAREST : n.LINEAR;
  }
  function D(Q) {
    const y = Q.target;
    y.removeEventListener("dispose", D), A(y), y.isVideoTexture && l.delete(y);
  }
  function N(Q) {
    const y = Q.target;
    y.removeEventListener("dispose", N), it(y);
  }
  function A(Q) {
    const y = i.get(Q);
    if (y.__webglInit === void 0)
      return;
    const g = Q.source, S = d.get(g);
    if (S) {
      const O = S[y.__cacheKey];
      O.usedTimes--, O.usedTimes === 0 && I(Q), Object.keys(S).length === 0 && d.delete(g);
    }
    i.remove(Q);
  }
  function I(Q) {
    const y = i.get(Q);
    n.deleteTexture(y.__webglTexture);
    const g = Q.source, S = d.get(g);
    delete S[y.__cacheKey], a.memory.textures--;
  }
  function it(Q) {
    const y = Q.texture, g = i.get(Q), S = i.get(y);
    if (S.__webglTexture !== void 0 && (n.deleteTexture(S.__webglTexture), a.memory.textures--), Q.depthTexture && Q.depthTexture.dispose(), Q.isWebGLCubeRenderTarget)
      for (let O = 0; O < 6; O++) {
        if (Array.isArray(g.__webglFramebuffer[O]))
          for (let Z = 0; Z < g.__webglFramebuffer[O].length; Z++)
            n.deleteFramebuffer(g.__webglFramebuffer[O][Z]);
        else
          n.deleteFramebuffer(g.__webglFramebuffer[O]);
        g.__webglDepthbuffer && n.deleteRenderbuffer(g.__webglDepthbuffer[O]);
      }
    else {
      if (Array.isArray(g.__webglFramebuffer))
        for (let O = 0; O < g.__webglFramebuffer.length; O++)
          n.deleteFramebuffer(g.__webglFramebuffer[O]);
      else
        n.deleteFramebuffer(g.__webglFramebuffer);
      if (g.__webglDepthbuffer && n.deleteRenderbuffer(g.__webglDepthbuffer), g.__webglMultisampledFramebuffer && n.deleteFramebuffer(g.__webglMultisampledFramebuffer), g.__webglColorRenderbuffer)
        for (let O = 0; O < g.__webglColorRenderbuffer.length; O++)
          g.__webglColorRenderbuffer[O] && n.deleteRenderbuffer(g.__webglColorRenderbuffer[O]);
      g.__webglDepthRenderbuffer && n.deleteRenderbuffer(g.__webglDepthRenderbuffer);
    }
    if (Q.isWebGLMultipleRenderTargets)
      for (let O = 0, Z = y.length; O < Z; O++) {
        const tt = i.get(y[O]);
        tt.__webglTexture && (n.deleteTexture(tt.__webglTexture), a.memory.textures--), i.remove(y[O]);
      }
    i.remove(y), i.remove(Q);
  }
  let V = 0;
  function mt() {
    V = 0;
  }
  function k() {
    const Q = V;
    return Q >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + Q + " texture units while this GPU supports only " + r.maxTextures), V += 1, Q;
  }
  function B(Q) {
    const y = [];
    return y.push(Q.wrapS), y.push(Q.wrapT), y.push(Q.wrapR || 0), y.push(Q.magFilter), y.push(Q.minFilter), y.push(Q.anisotropy), y.push(Q.internalFormat), y.push(Q.format), y.push(Q.type), y.push(Q.generateMipmaps), y.push(Q.premultiplyAlpha), y.push(Q.flipY), y.push(Q.unpackAlignment), y.push(Q.colorSpace), y.join();
  }
  function G(Q, y) {
    const g = i.get(Q);
    if (Q.isVideoTexture && Wt(Q), Q.isRenderTargetTexture === !1 && Q.version > 0 && g.__version !== Q.version) {
      const S = Q.image;
      if (S === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (S.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        b(g, Q, y);
        return;
      }
    }
    e.bindTexture(n.TEXTURE_2D, g.__webglTexture, n.TEXTURE0 + y);
  }
  function H(Q, y) {
    const g = i.get(Q);
    if (Q.version > 0 && g.__version !== Q.version) {
      b(g, Q, y);
      return;
    }
    e.bindTexture(n.TEXTURE_2D_ARRAY, g.__webglTexture, n.TEXTURE0 + y);
  }
  function w(Q, y) {
    const g = i.get(Q);
    if (Q.version > 0 && g.__version !== Q.version) {
      b(g, Q, y);
      return;
    }
    e.bindTexture(n.TEXTURE_3D, g.__webglTexture, n.TEXTURE0 + y);
  }
  function ut(Q, y) {
    const g = i.get(Q);
    if (Q.version > 0 && g.__version !== Q.version) {
      lt(g, Q, y);
      return;
    }
    e.bindTexture(n.TEXTURE_CUBE_MAP, g.__webglTexture, n.TEXTURE0 + y);
  }
  const pt = {
    [eu]: n.REPEAT,
    [_i]: n.CLAMP_TO_EDGE,
    [nu]: n.MIRRORED_REPEAT
  }, _t = {
    [Bn]: n.NEAREST,
    [bl]: n.NEAREST_MIPMAP_NEAREST,
    [Xc]: n.NEAREST_MIPMAP_LINEAR,
    [ri]: n.LINEAR,
    [pd]: n.LINEAR_MIPMAP_NEAREST,
    [ya]: n.LINEAR_MIPMAP_LINEAR
  }, vt = {
    [Lg]: n.NEVER,
    [Bg]: n.ALWAYS,
    [Og]: n.LESS,
    [wd]: n.LEQUAL,
    [Dg]: n.EQUAL,
    [Ug]: n.GEQUAL,
    [Ng]: n.GREATER,
    [Fg]: n.NOTEQUAL
  };
  function F(Q, y, g) {
    if (g ? (n.texParameteri(Q, n.TEXTURE_WRAP_S, pt[y.wrapS]), n.texParameteri(Q, n.TEXTURE_WRAP_T, pt[y.wrapT]), (Q === n.TEXTURE_3D || Q === n.TEXTURE_2D_ARRAY) && n.texParameteri(Q, n.TEXTURE_WRAP_R, pt[y.wrapR]), n.texParameteri(Q, n.TEXTURE_MAG_FILTER, _t[y.magFilter]), n.texParameteri(Q, n.TEXTURE_MIN_FILTER, _t[y.minFilter])) : (n.texParameteri(Q, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(Q, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), (Q === n.TEXTURE_3D || Q === n.TEXTURE_2D_ARRAY) && n.texParameteri(Q, n.TEXTURE_WRAP_R, n.CLAMP_TO_EDGE), (y.wrapS !== _i || y.wrapT !== _i) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), n.texParameteri(Q, n.TEXTURE_MAG_FILTER, C(y.magFilter)), n.texParameteri(Q, n.TEXTURE_MIN_FILTER, C(y.minFilter)), y.minFilter !== Bn && y.minFilter !== ri && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), y.compareFunction && (n.texParameteri(Q, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE), n.texParameteri(Q, n.TEXTURE_COMPARE_FUNC, vt[y.compareFunction])), t.has("EXT_texture_filter_anisotropic") === !0) {
      const S = t.get("EXT_texture_filter_anisotropic");
      if (y.magFilter === Bn || y.minFilter !== Xc && y.minFilter !== ya || y.type === Fr && t.has("OES_texture_float_linear") === !1 || o === !1 && y.type === Za && t.has("OES_texture_half_float_linear") === !1)
        return;
      (y.anisotropy > 1 || i.get(y).__currentAnisotropy) && (n.texParameterf(Q, S.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(y.anisotropy, r.getMaxAnisotropy())), i.get(y).__currentAnisotropy = y.anisotropy);
    }
  }
  function rt(Q, y) {
    let g = !1;
    Q.__webglInit === void 0 && (Q.__webglInit = !0, y.addEventListener("dispose", D));
    const S = y.source;
    let O = d.get(S);
    O === void 0 && (O = {}, d.set(S, O));
    const Z = B(y);
    if (Z !== Q.__cacheKey) {
      O[Z] === void 0 && (O[Z] = {
        texture: n.createTexture(),
        usedTimes: 0
      }, a.memory.textures++, g = !0), O[Z].usedTimes++;
      const tt = O[Q.__cacheKey];
      tt !== void 0 && (O[Q.__cacheKey].usedTimes--, tt.usedTimes === 0 && I(y)), Q.__cacheKey = Z, Q.__webglTexture = O[Z].texture;
    }
    return g;
  }
  function b(Q, y, g) {
    let S = n.TEXTURE_2D;
    (y.isDataArrayTexture || y.isCompressedArrayTexture) && (S = n.TEXTURE_2D_ARRAY), y.isData3DTexture && (S = n.TEXTURE_3D);
    const O = rt(Q, y), Z = y.source;
    e.bindTexture(S, Q.__webglTexture, n.TEXTURE0 + g);
    const tt = i.get(Z);
    if (Z.version !== tt.__version || O === !0) {
      e.activeTexture(n.TEXTURE0 + g);
      const gt = Ke.getPrimaries(Ke.workingColorSpace), st = y.colorSpace === si ? null : Ke.getPrimaries(y.colorSpace), Tt = y.colorSpace === si || gt === st ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
      n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, y.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, y.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, y.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, Tt);
      const Ft = p(y) && _(y.image) === !1;
      let ht = E(y.image, Ft, !1, r.maxTextureSize);
      ht = wt(y, ht);
      const It = _(ht) || o, z = s.convert(y.format, y.colorSpace);
      let ft = s.convert(y.type), nt = P(y.internalFormat, z, ft, y.colorSpace, y.isVideoTexture);
      F(S, y, It);
      let J;
      const Rt = y.mipmaps, Nt = o && y.isVideoTexture !== !0 && nt !== xd, Yt = tt.__version === void 0 || O === !0, Ht = W(y, ht, It);
      if (y.isDepthTexture)
        nt = n.DEPTH_COMPONENT, o ? y.type === Fr ? nt = n.DEPTH_COMPONENT32F : y.type === Nr ? nt = n.DEPTH_COMPONENT24 : y.type === Ms ? nt = n.DEPTH24_STENCIL8 : nt = n.DEPTH_COMPONENT16 : y.type === Fr && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), y.format === Ss && nt === n.DEPTH_COMPONENT && y.type !== $l && y.type !== Nr && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), y.type = Nr, ft = s.convert(y.type)), y.format === ga && nt === n.DEPTH_COMPONENT && (nt = n.DEPTH_STENCIL, y.type !== Ms && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), y.type = Ms, ft = s.convert(y.type))), Yt && (Nt ? e.texStorage2D(n.TEXTURE_2D, 1, nt, ht.width, ht.height) : e.texImage2D(n.TEXTURE_2D, 0, nt, ht.width, ht.height, 0, z, ft, null));
      else if (y.isDataTexture)
        if (Rt.length > 0 && It) {
          Nt && Yt && e.texStorage2D(n.TEXTURE_2D, Ht, nt, Rt[0].width, Rt[0].height);
          for (let Pt = 0, Mt = Rt.length; Pt < Mt; Pt++)
            J = Rt[Pt], Nt ? e.texSubImage2D(n.TEXTURE_2D, Pt, 0, 0, J.width, J.height, z, ft, J.data) : e.texImage2D(n.TEXTURE_2D, Pt, nt, J.width, J.height, 0, z, ft, J.data);
          y.generateMipmaps = !1;
        } else
          Nt ? (Yt && e.texStorage2D(n.TEXTURE_2D, Ht, nt, ht.width, ht.height), e.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, ht.width, ht.height, z, ft, ht.data)) : e.texImage2D(n.TEXTURE_2D, 0, nt, ht.width, ht.height, 0, z, ft, ht.data);
      else if (y.isCompressedTexture)
        if (y.isCompressedArrayTexture) {
          Nt && Yt && e.texStorage3D(n.TEXTURE_2D_ARRAY, Ht, nt, Rt[0].width, Rt[0].height, ht.depth);
          for (let Pt = 0, Mt = Rt.length; Pt < Mt; Pt++)
            J = Rt[Pt], y.format !== yi ? z !== null ? Nt ? e.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, Pt, 0, 0, 0, J.width, J.height, ht.depth, z, J.data, 0, 0) : e.compressedTexImage3D(n.TEXTURE_2D_ARRAY, Pt, nt, J.width, J.height, ht.depth, 0, J.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Nt ? e.texSubImage3D(n.TEXTURE_2D_ARRAY, Pt, 0, 0, 0, J.width, J.height, ht.depth, z, ft, J.data) : e.texImage3D(n.TEXTURE_2D_ARRAY, Pt, nt, J.width, J.height, ht.depth, 0, z, ft, J.data);
        } else {
          Nt && Yt && e.texStorage2D(n.TEXTURE_2D, Ht, nt, Rt[0].width, Rt[0].height);
          for (let Pt = 0, Mt = Rt.length; Pt < Mt; Pt++)
            J = Rt[Pt], y.format !== yi ? z !== null ? Nt ? e.compressedTexSubImage2D(n.TEXTURE_2D, Pt, 0, 0, J.width, J.height, z, J.data) : e.compressedTexImage2D(n.TEXTURE_2D, Pt, nt, J.width, J.height, 0, J.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Nt ? e.texSubImage2D(n.TEXTURE_2D, Pt, 0, 0, J.width, J.height, z, ft, J.data) : e.texImage2D(n.TEXTURE_2D, Pt, nt, J.width, J.height, 0, z, ft, J.data);
        }
      else if (y.isDataArrayTexture)
        Nt ? (Yt && e.texStorage3D(n.TEXTURE_2D_ARRAY, Ht, nt, ht.width, ht.height, ht.depth), e.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, 0, ht.width, ht.height, ht.depth, z, ft, ht.data)) : e.texImage3D(n.TEXTURE_2D_ARRAY, 0, nt, ht.width, ht.height, ht.depth, 0, z, ft, ht.data);
      else if (y.isData3DTexture)
        Nt ? (Yt && e.texStorage3D(n.TEXTURE_3D, Ht, nt, ht.width, ht.height, ht.depth), e.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, ht.width, ht.height, ht.depth, z, ft, ht.data)) : e.texImage3D(n.TEXTURE_3D, 0, nt, ht.width, ht.height, ht.depth, 0, z, ft, ht.data);
      else if (y.isFramebufferTexture) {
        if (Yt)
          if (Nt)
            e.texStorage2D(n.TEXTURE_2D, Ht, nt, ht.width, ht.height);
          else {
            let Pt = ht.width, Mt = ht.height;
            for (let $t = 0; $t < Ht; $t++)
              e.texImage2D(n.TEXTURE_2D, $t, nt, Pt, Mt, 0, z, ft, null), Pt >>= 1, Mt >>= 1;
          }
      } else if (Rt.length > 0 && It) {
        Nt && Yt && e.texStorage2D(n.TEXTURE_2D, Ht, nt, Rt[0].width, Rt[0].height);
        for (let Pt = 0, Mt = Rt.length; Pt < Mt; Pt++)
          J = Rt[Pt], Nt ? e.texSubImage2D(n.TEXTURE_2D, Pt, 0, 0, z, ft, J) : e.texImage2D(n.TEXTURE_2D, Pt, nt, z, ft, J);
        y.generateMipmaps = !1;
      } else
        Nt ? (Yt && e.texStorage2D(n.TEXTURE_2D, Ht, nt, ht.width, ht.height), e.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, z, ft, ht)) : e.texImage2D(n.TEXTURE_2D, 0, nt, z, ft, ht);
      R(y, It) && M(S), tt.__version = Z.version, y.onUpdate && y.onUpdate(y);
    }
    Q.__version = y.version;
  }
  function lt(Q, y, g) {
    if (y.image.length !== 6)
      return;
    const S = rt(Q, y), O = y.source;
    e.bindTexture(n.TEXTURE_CUBE_MAP, Q.__webglTexture, n.TEXTURE0 + g);
    const Z = i.get(O);
    if (O.version !== Z.__version || S === !0) {
      e.activeTexture(n.TEXTURE0 + g);
      const tt = Ke.getPrimaries(Ke.workingColorSpace), gt = y.colorSpace === si ? null : Ke.getPrimaries(y.colorSpace), st = y.colorSpace === si || tt === gt ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
      n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, y.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, y.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, y.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, st);
      const Tt = y.isCompressedTexture || y.image[0].isCompressedTexture, Ft = y.image[0] && y.image[0].isDataTexture, ht = [];
      for (let Pt = 0; Pt < 6; Pt++)
        !Tt && !Ft ? ht[Pt] = E(y.image[Pt], !1, !0, r.maxCubemapSize) : ht[Pt] = Ft ? y.image[Pt].image : y.image[Pt], ht[Pt] = wt(y, ht[Pt]);
      const It = ht[0], z = _(It) || o, ft = s.convert(y.format, y.colorSpace), nt = s.convert(y.type), J = P(y.internalFormat, ft, nt, y.colorSpace), Rt = o && y.isVideoTexture !== !0, Nt = Z.__version === void 0 || S === !0;
      let Yt = W(y, It, z);
      F(n.TEXTURE_CUBE_MAP, y, z);
      let Ht;
      if (Tt) {
        Rt && Nt && e.texStorage2D(n.TEXTURE_CUBE_MAP, Yt, J, It.width, It.height);
        for (let Pt = 0; Pt < 6; Pt++) {
          Ht = ht[Pt].mipmaps;
          for (let Mt = 0; Mt < Ht.length; Mt++) {
            const $t = Ht[Mt];
            y.format !== yi ? ft !== null ? Rt ? e.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Pt, Mt, 0, 0, $t.width, $t.height, ft, $t.data) : e.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Pt, Mt, J, $t.width, $t.height, 0, $t.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Rt ? e.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Pt, Mt, 0, 0, $t.width, $t.height, ft, nt, $t.data) : e.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Pt, Mt, J, $t.width, $t.height, 0, ft, nt, $t.data);
          }
        }
      } else {
        Ht = y.mipmaps, Rt && Nt && (Ht.length > 0 && Yt++, e.texStorage2D(n.TEXTURE_CUBE_MAP, Yt, J, ht[0].width, ht[0].height));
        for (let Pt = 0; Pt < 6; Pt++)
          if (Ft) {
            Rt ? e.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Pt, 0, 0, 0, ht[Pt].width, ht[Pt].height, ft, nt, ht[Pt].data) : e.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Pt, 0, J, ht[Pt].width, ht[Pt].height, 0, ft, nt, ht[Pt].data);
            for (let Mt = 0; Mt < Ht.length; Mt++) {
              const Kt = Ht[Mt].image[Pt].image;
              Rt ? e.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Pt, Mt + 1, 0, 0, Kt.width, Kt.height, ft, nt, Kt.data) : e.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Pt, Mt + 1, J, Kt.width, Kt.height, 0, ft, nt, Kt.data);
            }
          } else {
            Rt ? e.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Pt, 0, 0, 0, ft, nt, ht[Pt]) : e.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Pt, 0, J, ft, nt, ht[Pt]);
            for (let Mt = 0; Mt < Ht.length; Mt++) {
              const $t = Ht[Mt];
              Rt ? e.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Pt, Mt + 1, 0, 0, ft, nt, $t.image[Pt]) : e.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Pt, Mt + 1, J, ft, nt, $t.image[Pt]);
            }
          }
      }
      R(y, z) && M(n.TEXTURE_CUBE_MAP), Z.__version = O.version, y.onUpdate && y.onUpdate(y);
    }
    Q.__version = y.version;
  }
  function q(Q, y, g, S, O, Z) {
    const tt = s.convert(g.format, g.colorSpace), gt = s.convert(g.type), st = P(g.internalFormat, tt, gt, g.colorSpace);
    if (!i.get(y).__hasExternalTextures) {
      const Ft = Math.max(1, y.width >> Z), ht = Math.max(1, y.height >> Z);
      O === n.TEXTURE_3D || O === n.TEXTURE_2D_ARRAY ? e.texImage3D(O, Z, st, Ft, ht, y.depth, 0, tt, gt, null) : e.texImage2D(O, Z, st, Ft, ht, 0, tt, gt, null);
    }
    e.bindFramebuffer(n.FRAMEBUFFER, Q), Lt(y) ? c.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, S, O, i.get(g).__webglTexture, 0, Ct(y)) : (O === n.TEXTURE_2D || O >= n.TEXTURE_CUBE_MAP_POSITIVE_X && O <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z) && n.framebufferTexture2D(n.FRAMEBUFFER, S, O, i.get(g).__webglTexture, Z), e.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function U(Q, y, g) {
    if (n.bindRenderbuffer(n.RENDERBUFFER, Q), y.depthBuffer && !y.stencilBuffer) {
      let S = o === !0 ? n.DEPTH_COMPONENT24 : n.DEPTH_COMPONENT16;
      if (g || Lt(y)) {
        const O = y.depthTexture;
        O && O.isDepthTexture && (O.type === Fr ? S = n.DEPTH_COMPONENT32F : O.type === Nr && (S = n.DEPTH_COMPONENT24));
        const Z = Ct(y);
        Lt(y) ? c.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, Z, S, y.width, y.height) : n.renderbufferStorageMultisample(n.RENDERBUFFER, Z, S, y.width, y.height);
      } else
        n.renderbufferStorage(n.RENDERBUFFER, S, y.width, y.height);
      n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.RENDERBUFFER, Q);
    } else if (y.depthBuffer && y.stencilBuffer) {
      const S = Ct(y);
      g && Lt(y) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, S, n.DEPTH24_STENCIL8, y.width, y.height) : Lt(y) ? c.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, S, n.DEPTH24_STENCIL8, y.width, y.height) : n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, y.width, y.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, Q);
    } else {
      const S = y.isWebGLMultipleRenderTargets === !0 ? y.texture : [y.texture];
      for (let O = 0; O < S.length; O++) {
        const Z = S[O], tt = s.convert(Z.format, Z.colorSpace), gt = s.convert(Z.type), st = P(Z.internalFormat, tt, gt, Z.colorSpace), Tt = Ct(y);
        g && Lt(y) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, Tt, st, y.width, y.height) : Lt(y) ? c.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, Tt, st, y.width, y.height) : n.renderbufferStorage(n.RENDERBUFFER, st, y.width, y.height);
      }
    }
    n.bindRenderbuffer(n.RENDERBUFFER, null);
  }
  function L(Q, y) {
    if (y && y.isWebGLCubeRenderTarget)
      throw new Error("Depth Texture with cube render targets is not supported");
    if (e.bindFramebuffer(n.FRAMEBUFFER, Q), !(y.depthTexture && y.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!i.get(y.depthTexture).__webglTexture || y.depthTexture.image.width !== y.width || y.depthTexture.image.height !== y.height) && (y.depthTexture.image.width = y.width, y.depthTexture.image.height = y.height, y.depthTexture.needsUpdate = !0), G(y.depthTexture, 0);
    const S = i.get(y.depthTexture).__webglTexture, O = Ct(y);
    if (y.depthTexture.format === Ss)
      Lt(y) ? c.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, S, 0, O) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, S, 0);
    else if (y.depthTexture.format === ga)
      Lt(y) ? c.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, S, 0, O) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, S, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function j(Q) {
    const y = i.get(Q), g = Q.isWebGLCubeRenderTarget === !0;
    if (Q.depthTexture && !y.__autoAllocateDepthBuffer) {
      if (g)
        throw new Error("target.depthTexture not supported in Cube render targets");
      L(y.__webglFramebuffer, Q);
    } else if (g) {
      y.__webglDepthbuffer = [];
      for (let S = 0; S < 6; S++)
        e.bindFramebuffer(n.FRAMEBUFFER, y.__webglFramebuffer[S]), y.__webglDepthbuffer[S] = n.createRenderbuffer(), U(y.__webglDepthbuffer[S], Q, !1);
    } else
      e.bindFramebuffer(n.FRAMEBUFFER, y.__webglFramebuffer), y.__webglDepthbuffer = n.createRenderbuffer(), U(y.__webglDepthbuffer, Q, !1);
    e.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function Y(Q, y, g) {
    const S = i.get(Q);
    y !== void 0 && q(S.__webglFramebuffer, Q, Q.texture, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, 0), g !== void 0 && j(Q);
  }
  function K(Q) {
    const y = Q.texture, g = i.get(Q), S = i.get(y);
    Q.addEventListener("dispose", N), Q.isWebGLMultipleRenderTargets !== !0 && (S.__webglTexture === void 0 && (S.__webglTexture = n.createTexture()), S.__version = y.version, a.memory.textures++);
    const O = Q.isWebGLCubeRenderTarget === !0, Z = Q.isWebGLMultipleRenderTargets === !0, tt = _(Q) || o;
    if (O) {
      g.__webglFramebuffer = [];
      for (let gt = 0; gt < 6; gt++)
        if (o && y.mipmaps && y.mipmaps.length > 0) {
          g.__webglFramebuffer[gt] = [];
          for (let st = 0; st < y.mipmaps.length; st++)
            g.__webglFramebuffer[gt][st] = n.createFramebuffer();
        } else
          g.__webglFramebuffer[gt] = n.createFramebuffer();
    } else {
      if (o && y.mipmaps && y.mipmaps.length > 0) {
        g.__webglFramebuffer = [];
        for (let gt = 0; gt < y.mipmaps.length; gt++)
          g.__webglFramebuffer[gt] = n.createFramebuffer();
      } else
        g.__webglFramebuffer = n.createFramebuffer();
      if (Z)
        if (r.drawBuffers) {
          const gt = Q.texture;
          for (let st = 0, Tt = gt.length; st < Tt; st++) {
            const Ft = i.get(gt[st]);
            Ft.__webglTexture === void 0 && (Ft.__webglTexture = n.createTexture(), a.memory.textures++);
          }
        } else
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
      if (o && Q.samples > 0 && Lt(Q) === !1) {
        const gt = Z ? y : [y];
        g.__webglMultisampledFramebuffer = n.createFramebuffer(), g.__webglColorRenderbuffer = [], e.bindFramebuffer(n.FRAMEBUFFER, g.__webglMultisampledFramebuffer);
        for (let st = 0; st < gt.length; st++) {
          const Tt = gt[st];
          g.__webglColorRenderbuffer[st] = n.createRenderbuffer(), n.bindRenderbuffer(n.RENDERBUFFER, g.__webglColorRenderbuffer[st]);
          const Ft = s.convert(Tt.format, Tt.colorSpace), ht = s.convert(Tt.type), It = P(Tt.internalFormat, Ft, ht, Tt.colorSpace, Q.isXRRenderTarget === !0), z = Ct(Q);
          n.renderbufferStorageMultisample(n.RENDERBUFFER, z, It, Q.width, Q.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + st, n.RENDERBUFFER, g.__webglColorRenderbuffer[st]);
        }
        n.bindRenderbuffer(n.RENDERBUFFER, null), Q.depthBuffer && (g.__webglDepthRenderbuffer = n.createRenderbuffer(), U(g.__webglDepthRenderbuffer, Q, !0)), e.bindFramebuffer(n.FRAMEBUFFER, null);
      }
    }
    if (O) {
      e.bindTexture(n.TEXTURE_CUBE_MAP, S.__webglTexture), F(n.TEXTURE_CUBE_MAP, y, tt);
      for (let gt = 0; gt < 6; gt++)
        if (o && y.mipmaps && y.mipmaps.length > 0)
          for (let st = 0; st < y.mipmaps.length; st++)
            q(g.__webglFramebuffer[gt][st], Q, y, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + gt, st);
        else
          q(g.__webglFramebuffer[gt], Q, y, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + gt, 0);
      R(y, tt) && M(n.TEXTURE_CUBE_MAP), e.unbindTexture();
    } else if (Z) {
      const gt = Q.texture;
      for (let st = 0, Tt = gt.length; st < Tt; st++) {
        const Ft = gt[st], ht = i.get(Ft);
        e.bindTexture(n.TEXTURE_2D, ht.__webglTexture), F(n.TEXTURE_2D, Ft, tt), q(g.__webglFramebuffer, Q, Ft, n.COLOR_ATTACHMENT0 + st, n.TEXTURE_2D, 0), R(Ft, tt) && M(n.TEXTURE_2D);
      }
      e.unbindTexture();
    } else {
      let gt = n.TEXTURE_2D;
      if ((Q.isWebGL3DRenderTarget || Q.isWebGLArrayRenderTarget) && (o ? gt = Q.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), e.bindTexture(gt, S.__webglTexture), F(gt, y, tt), o && y.mipmaps && y.mipmaps.length > 0)
        for (let st = 0; st < y.mipmaps.length; st++)
          q(g.__webglFramebuffer[st], Q, y, n.COLOR_ATTACHMENT0, gt, st);
      else
        q(g.__webglFramebuffer, Q, y, n.COLOR_ATTACHMENT0, gt, 0);
      R(y, tt) && M(gt), e.unbindTexture();
    }
    Q.depthBuffer && j(Q);
  }
  function yt(Q) {
    const y = _(Q) || o, g = Q.isWebGLMultipleRenderTargets === !0 ? Q.texture : [Q.texture];
    for (let S = 0, O = g.length; S < O; S++) {
      const Z = g[S];
      if (R(Z, y)) {
        const tt = Q.isWebGLCubeRenderTarget ? n.TEXTURE_CUBE_MAP : n.TEXTURE_2D, gt = i.get(Z).__webglTexture;
        e.bindTexture(tt, gt), M(tt), e.unbindTexture();
      }
    }
  }
  function Et(Q) {
    if (o && Q.samples > 0 && Lt(Q) === !1) {
      const y = Q.isWebGLMultipleRenderTargets ? Q.texture : [Q.texture], g = Q.width, S = Q.height;
      let O = n.COLOR_BUFFER_BIT;
      const Z = [], tt = Q.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT, gt = i.get(Q), st = Q.isWebGLMultipleRenderTargets === !0;
      if (st)
        for (let Tt = 0; Tt < y.length; Tt++)
          e.bindFramebuffer(n.FRAMEBUFFER, gt.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Tt, n.RENDERBUFFER, null), e.bindFramebuffer(n.FRAMEBUFFER, gt.__webglFramebuffer), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Tt, n.TEXTURE_2D, null, 0);
      e.bindFramebuffer(n.READ_FRAMEBUFFER, gt.__webglMultisampledFramebuffer), e.bindFramebuffer(n.DRAW_FRAMEBUFFER, gt.__webglFramebuffer);
      for (let Tt = 0; Tt < y.length; Tt++) {
        Z.push(n.COLOR_ATTACHMENT0 + Tt), Q.depthBuffer && Z.push(tt);
        const Ft = gt.__ignoreDepthValues !== void 0 ? gt.__ignoreDepthValues : !1;
        if (Ft === !1 && (Q.depthBuffer && (O |= n.DEPTH_BUFFER_BIT), Q.stencilBuffer && (O |= n.STENCIL_BUFFER_BIT)), st && n.framebufferRenderbuffer(n.READ_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, gt.__webglColorRenderbuffer[Tt]), Ft === !0 && (n.invalidateFramebuffer(n.READ_FRAMEBUFFER, [tt]), n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [tt])), st) {
          const ht = i.get(y[Tt]).__webglTexture;
          n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, ht, 0);
        }
        n.blitFramebuffer(0, 0, g, S, 0, 0, g, S, O, n.NEAREST), h && n.invalidateFramebuffer(n.READ_FRAMEBUFFER, Z);
      }
      if (e.bindFramebuffer(n.READ_FRAMEBUFFER, null), e.bindFramebuffer(n.DRAW_FRAMEBUFFER, null), st)
        for (let Tt = 0; Tt < y.length; Tt++) {
          e.bindFramebuffer(n.FRAMEBUFFER, gt.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Tt, n.RENDERBUFFER, gt.__webglColorRenderbuffer[Tt]);
          const Ft = i.get(y[Tt]).__webglTexture;
          e.bindFramebuffer(n.FRAMEBUFFER, gt.__webglFramebuffer), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Tt, n.TEXTURE_2D, Ft, 0);
        }
      e.bindFramebuffer(n.DRAW_FRAMEBUFFER, gt.__webglMultisampledFramebuffer);
    }
  }
  function Ct(Q) {
    return Math.min(r.maxSamples, Q.samples);
  }
  function Lt(Q) {
    const y = i.get(Q);
    return o && Q.samples > 0 && t.has("WEBGL_multisampled_render_to_texture") === !0 && y.__useRenderToTexture !== !1;
  }
  function Wt(Q) {
    const y = a.render.frame;
    l.get(Q) !== y && (l.set(Q, y), Q.update());
  }
  function wt(Q, y) {
    const g = Q.colorSpace, S = Q.format, O = Q.type;
    return Q.isCompressedTexture === !0 || Q.isVideoTexture === !0 || Q.format === El || g !== lr && g !== si && (Ke.getTransfer(g) === nn ? o === !1 ? t.has("EXT_sRGB") === !0 && S === yi ? (Q.format = El, Q.minFilter = ri, Q.generateMipmaps = !1) : y = Sd.sRGBToLinear(y) : (S !== yi || O !== Gr) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", g)), y;
  }
  this.allocateTextureUnit = k, this.resetTextureUnits = mt, this.setTexture2D = G, this.setTexture2DArray = H, this.setTexture3D = w, this.setTextureCube = ut, this.rebindTextures = Y, this.setupRenderTarget = K, this.updateRenderTargetMipmap = yt, this.updateMultisampleRenderTarget = Et, this.setupDepthRenderbuffer = j, this.setupFrameBufferTexture = q, this.useMultisampledRTT = Lt;
}
function tw(n, t, e) {
  const i = e.isWebGL2;
  function r(s, a = si) {
    let o;
    const c = Ke.getTransfer(a);
    if (s === Gr)
      return n.UNSIGNED_BYTE;
    if (s === md)
      return n.UNSIGNED_SHORT_4_4_4_4;
    if (s === _d)
      return n.UNSIGNED_SHORT_5_5_5_1;
    if (s === vg)
      return n.BYTE;
    if (s === xg)
      return n.SHORT;
    if (s === $l)
      return n.UNSIGNED_SHORT;
    if (s === dd)
      return n.INT;
    if (s === Nr)
      return n.UNSIGNED_INT;
    if (s === Fr)
      return n.FLOAT;
    if (s === Za)
      return i ? n.HALF_FLOAT : (o = t.get("OES_texture_half_float"), o !== null ? o.HALF_FLOAT_OES : null);
    if (s === bg)
      return n.ALPHA;
    if (s === yi)
      return n.RGBA;
    if (s === Eg)
      return n.LUMINANCE;
    if (s === wg)
      return n.LUMINANCE_ALPHA;
    if (s === Ss)
      return n.DEPTH_COMPONENT;
    if (s === ga)
      return n.DEPTH_STENCIL;
    if (s === El)
      return o = t.get("EXT_sRGB"), o !== null ? o.SRGB_ALPHA_EXT : null;
    if (s === Mg)
      return n.RED;
    if (s === yd)
      return n.RED_INTEGER;
    if (s === Sg)
      return n.RG;
    if (s === gd)
      return n.RG_INTEGER;
    if (s === vd)
      return n.RGBA_INTEGER;
    if (s === Mu || s === Su || s === Au || s === Tu)
      if (c === nn)
        if (o = t.get("WEBGL_compressed_texture_s3tc_srgb"), o !== null) {
          if (s === Mu)
            return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (s === Su)
            return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (s === Au)
            return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (s === Tu)
            return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (o = t.get("WEBGL_compressed_texture_s3tc"), o !== null) {
        if (s === Mu)
          return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (s === Su)
          return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (s === Au)
          return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (s === Tu)
          return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (s === Hf || s === jf || s === Wf || s === qf)
      if (o = t.get("WEBGL_compressed_texture_pvrtc"), o !== null) {
        if (s === Hf)
          return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (s === jf)
          return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (s === Wf)
          return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (s === qf)
          return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (s === xd)
      return o = t.get("WEBGL_compressed_texture_etc1"), o !== null ? o.COMPRESSED_RGB_ETC1_WEBGL : null;
    if (s === $f || s === Xf)
      if (o = t.get("WEBGL_compressed_texture_etc"), o !== null) {
        if (s === $f)
          return c === nn ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
        if (s === Xf)
          return c === nn ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : o.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (s === Yf || s === Kf || s === Zf || s === Jf || s === Qf || s === th || s === eh || s === nh || s === ih || s === rh || s === sh || s === ah || s === oh || s === ch)
      if (o = t.get("WEBGL_compressed_texture_astc"), o !== null) {
        if (s === Yf)
          return c === nn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (s === Kf)
          return c === nn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (s === Zf)
          return c === nn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (s === Jf)
          return c === nn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (s === Qf)
          return c === nn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (s === th)
          return c === nn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (s === eh)
          return c === nn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (s === nh)
          return c === nn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (s === ih)
          return c === nn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (s === rh)
          return c === nn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (s === sh)
          return c === nn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (s === ah)
          return c === nn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (s === oh)
          return c === nn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (s === ch)
          return c === nn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : o.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (s === Cu || s === uh || s === lh)
      if (o = t.get("EXT_texture_compression_bptc"), o !== null) {
        if (s === Cu)
          return c === nn ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (s === uh)
          return o.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (s === lh)
          return o.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else
        return null;
    if (s === Ag || s === fh || s === hh || s === ph)
      if (o = t.get("EXT_texture_compression_rgtc"), o !== null) {
        if (s === Cu)
          return o.COMPRESSED_RED_RGTC1_EXT;
        if (s === fh)
          return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (s === hh)
          return o.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (s === ph)
          return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return s === Ms ? i ? n.UNSIGNED_INT_24_8 : (o = t.get("WEBGL_depth_texture"), o !== null ? o.UNSIGNED_INT_24_8_WEBGL : null) : n[s] !== void 0 ? n[s] : null;
  }
  return { convert: r };
}
class ew extends di {
  constructor(t = []) {
    super(), this.isArrayCamera = !0, this.cameras = t;
  }
}
class Oc extends oi {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const nw = { type: "move" };
class Zu {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new Oc(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new Oc(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Gt(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Gt()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new Oc(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Gt(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Gt()), this._grip;
  }
  dispatchEvent(t) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(t), this._grip !== null && this._grip.dispatchEvent(t), this._hand !== null && this._hand.dispatchEvent(t), this;
  }
  connect(t) {
    if (t && t.hand) {
      const e = this._hand;
      if (e)
        for (const i of t.hand.values())
          this._getHandJoint(e, i);
    }
    return this.dispatchEvent({ type: "connected", data: t }), this;
  }
  disconnect(t) {
    return this.dispatchEvent({ type: "disconnected", data: t }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(t, e, i) {
    let r = null, s = null, a = null;
    const o = this._targetRay, c = this._grip, h = this._hand;
    if (t && e.session.visibilityState !== "visible-blurred") {
      if (h && t.hand) {
        a = !0;
        for (const E of t.hand.values()) {
          const _ = e.getJointPose(E, i), p = this._getHandJoint(h, E);
          _ !== null && (p.matrix.fromArray(_.transform.matrix), p.matrix.decompose(p.position, p.rotation, p.scale), p.matrixWorldNeedsUpdate = !0, p.jointRadius = _.radius), p.visible = _ !== null;
        }
        const l = h.joints["index-finger-tip"], f = h.joints["thumb-tip"], d = l.position.distanceTo(f.position), m = 0.02, v = 5e-3;
        h.inputState.pinching && d > m + v ? (h.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: t.handedness,
          target: this
        })) : !h.inputState.pinching && d <= m - v && (h.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: t.handedness,
          target: this
        }));
      } else
        c !== null && t.gripSpace && (s = e.getPose(t.gripSpace, i), s !== null && (c.matrix.fromArray(s.transform.matrix), c.matrix.decompose(c.position, c.rotation, c.scale), c.matrixWorldNeedsUpdate = !0, s.linearVelocity ? (c.hasLinearVelocity = !0, c.linearVelocity.copy(s.linearVelocity)) : c.hasLinearVelocity = !1, s.angularVelocity ? (c.hasAngularVelocity = !0, c.angularVelocity.copy(s.angularVelocity)) : c.hasAngularVelocity = !1));
      o !== null && (r = e.getPose(t.targetRaySpace, i), r === null && s !== null && (r = s), r !== null && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(nw)));
    }
    return o !== null && (o.visible = r !== null), c !== null && (c.visible = s !== null), h !== null && (h.visible = a !== null), this;
  }
  // private method
  _getHandJoint(t, e) {
    if (t.joints[e.jointName] === void 0) {
      const i = new Oc();
      i.matrixAutoUpdate = !1, i.visible = !1, t.joints[e.jointName] = i, t.add(i);
    }
    return t.joints[e.jointName];
  }
}
class iw extends Is {
  constructor(t, e) {
    super();
    const i = this;
    let r = null, s = 1, a = null, o = "local-floor", c = 1, h = null, l = null, f = null, d = null, m = null, v = null;
    const E = e.getContextAttributes();
    let _ = null, p = null;
    const R = [], M = [], P = new fe();
    let W = null;
    const C = new di();
    C.layers.enable(1), C.viewport = new In();
    const D = new di();
    D.layers.enable(2), D.viewport = new In();
    const N = [C, D], A = new ew();
    A.layers.enable(1), A.layers.enable(2);
    let I = null, it = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(F) {
      let rt = R[F];
      return rt === void 0 && (rt = new Zu(), R[F] = rt), rt.getTargetRaySpace();
    }, this.getControllerGrip = function(F) {
      let rt = R[F];
      return rt === void 0 && (rt = new Zu(), R[F] = rt), rt.getGripSpace();
    }, this.getHand = function(F) {
      let rt = R[F];
      return rt === void 0 && (rt = new Zu(), R[F] = rt), rt.getHandSpace();
    };
    function V(F) {
      const rt = M.indexOf(F.inputSource);
      if (rt === -1)
        return;
      const b = R[rt];
      b !== void 0 && (b.update(F.inputSource, F.frame, h || a), b.dispatchEvent({ type: F.type, data: F.inputSource }));
    }
    function mt() {
      r.removeEventListener("select", V), r.removeEventListener("selectstart", V), r.removeEventListener("selectend", V), r.removeEventListener("squeeze", V), r.removeEventListener("squeezestart", V), r.removeEventListener("squeezeend", V), r.removeEventListener("end", mt), r.removeEventListener("inputsourceschange", k);
      for (let F = 0; F < R.length; F++) {
        const rt = M[F];
        rt !== null && (M[F] = null, R[F].disconnect(rt));
      }
      I = null, it = null, t.setRenderTarget(_), m = null, d = null, f = null, r = null, p = null, vt.stop(), i.isPresenting = !1, t.setPixelRatio(W), t.setSize(P.width, P.height, !1), i.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(F) {
      s = F, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(F) {
      o = F, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return h || a;
    }, this.setReferenceSpace = function(F) {
      h = F;
    }, this.getBaseLayer = function() {
      return d !== null ? d : m;
    }, this.getBinding = function() {
      return f;
    }, this.getFrame = function() {
      return v;
    }, this.getSession = function() {
      return r;
    }, this.setSession = async function(F) {
      if (r = F, r !== null) {
        if (_ = t.getRenderTarget(), r.addEventListener("select", V), r.addEventListener("selectstart", V), r.addEventListener("selectend", V), r.addEventListener("squeeze", V), r.addEventListener("squeezestart", V), r.addEventListener("squeezeend", V), r.addEventListener("end", mt), r.addEventListener("inputsourceschange", k), E.xrCompatible !== !0 && await e.makeXRCompatible(), W = t.getPixelRatio(), t.getSize(P), r.renderState.layers === void 0 || t.capabilities.isWebGL2 === !1) {
          const rt = {
            antialias: r.renderState.layers === void 0 ? E.antialias : !0,
            alpha: !0,
            depth: E.depth,
            stencil: E.stencil,
            framebufferScaleFactor: s
          };
          m = new XRWebGLLayer(r, e, rt), r.updateRenderState({ baseLayer: m }), t.setPixelRatio(1), t.setSize(m.framebufferWidth, m.framebufferHeight, !1), p = new Cs(
            m.framebufferWidth,
            m.framebufferHeight,
            {
              format: yi,
              type: Gr,
              colorSpace: t.outputColorSpace,
              stencilBuffer: E.stencil
            }
          );
        } else {
          let rt = null, b = null, lt = null;
          E.depth && (lt = E.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24, rt = E.stencil ? ga : Ss, b = E.stencil ? Ms : Nr);
          const q = {
            colorFormat: e.RGBA8,
            depthFormat: lt,
            scaleFactor: s
          };
          f = new XRWebGLBinding(r, e), d = f.createProjectionLayer(q), r.updateRenderState({ layers: [d] }), t.setPixelRatio(1), t.setSize(d.textureWidth, d.textureHeight, !1), p = new Cs(
            d.textureWidth,
            d.textureHeight,
            {
              format: yi,
              type: Gr,
              depthTexture: new Ud(d.textureWidth, d.textureHeight, b, void 0, void 0, void 0, void 0, void 0, void 0, rt),
              stencilBuffer: E.stencil,
              colorSpace: t.outputColorSpace,
              samples: E.antialias ? 4 : 0
            }
          );
          const U = t.properties.get(p);
          U.__ignoreDepthValues = d.ignoreDepthValues;
        }
        p.isXRRenderTarget = !0, this.setFoveation(c), h = null, a = await r.requestReferenceSpace(o), vt.setContext(r), vt.start(), i.isPresenting = !0, i.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (r !== null)
        return r.environmentBlendMode;
    };
    function k(F) {
      for (let rt = 0; rt < F.removed.length; rt++) {
        const b = F.removed[rt], lt = M.indexOf(b);
        lt >= 0 && (M[lt] = null, R[lt].disconnect(b));
      }
      for (let rt = 0; rt < F.added.length; rt++) {
        const b = F.added[rt];
        let lt = M.indexOf(b);
        if (lt === -1) {
          for (let U = 0; U < R.length; U++)
            if (U >= M.length) {
              M.push(b), lt = U;
              break;
            } else if (M[U] === null) {
              M[U] = b, lt = U;
              break;
            }
          if (lt === -1)
            break;
        }
        const q = R[lt];
        q && q.connect(b);
      }
    }
    const B = new Gt(), G = new Gt();
    function H(F, rt, b) {
      B.setFromMatrixPosition(rt.matrixWorld), G.setFromMatrixPosition(b.matrixWorld);
      const lt = B.distanceTo(G), q = rt.projectionMatrix.elements, U = b.projectionMatrix.elements, L = q[14] / (q[10] - 1), j = q[14] / (q[10] + 1), Y = (q[9] + 1) / q[5], K = (q[9] - 1) / q[5], yt = (q[8] - 1) / q[0], Et = (U[8] + 1) / U[0], Ct = L * yt, Lt = L * Et, Wt = lt / (-yt + Et), wt = Wt * -yt;
      rt.matrixWorld.decompose(F.position, F.quaternion, F.scale), F.translateX(wt), F.translateZ(Wt), F.matrixWorld.compose(F.position, F.quaternion, F.scale), F.matrixWorldInverse.copy(F.matrixWorld).invert();
      const Q = L + Wt, y = j + Wt, g = Ct - wt, S = Lt + (lt - wt), O = Y * j / y * Q, Z = K * j / y * Q;
      F.projectionMatrix.makePerspective(g, S, O, Z, Q, y), F.projectionMatrixInverse.copy(F.projectionMatrix).invert();
    }
    function w(F, rt) {
      rt === null ? F.matrixWorld.copy(F.matrix) : F.matrixWorld.multiplyMatrices(rt.matrixWorld, F.matrix), F.matrixWorldInverse.copy(F.matrixWorld).invert();
    }
    this.updateCamera = function(F) {
      if (r === null)
        return;
      A.near = D.near = C.near = F.near, A.far = D.far = C.far = F.far, (I !== A.near || it !== A.far) && (r.updateRenderState({
        depthNear: A.near,
        depthFar: A.far
      }), I = A.near, it = A.far);
      const rt = F.parent, b = A.cameras;
      w(A, rt);
      for (let lt = 0; lt < b.length; lt++)
        w(b[lt], rt);
      b.length === 2 ? H(A, C, D) : A.projectionMatrix.copy(C.projectionMatrix), ut(F, A, rt);
    };
    function ut(F, rt, b) {
      b === null ? F.matrix.copy(rt.matrixWorld) : (F.matrix.copy(b.matrixWorld), F.matrix.invert(), F.matrix.multiply(rt.matrixWorld)), F.matrix.decompose(F.position, F.quaternion, F.scale), F.updateMatrixWorld(!0), F.projectionMatrix.copy(rt.projectionMatrix), F.projectionMatrixInverse.copy(rt.projectionMatrixInverse), F.isPerspectiveCamera && (F.fov = Ja * 2 * Math.atan(1 / F.projectionMatrix.elements[5]), F.zoom = 1);
    }
    this.getCamera = function() {
      return A;
    }, this.getFoveation = function() {
      if (!(d === null && m === null))
        return c;
    }, this.setFoveation = function(F) {
      c = F, d !== null && (d.fixedFoveation = F), m !== null && m.fixedFoveation !== void 0 && (m.fixedFoveation = F);
    };
    let pt = null;
    function _t(F, rt) {
      if (l = rt.getViewerPose(h || a), v = rt, l !== null) {
        const b = l.views;
        m !== null && (t.setRenderTargetFramebuffer(p, m.framebuffer), t.setRenderTarget(p));
        let lt = !1;
        b.length !== A.cameras.length && (A.cameras.length = 0, lt = !0);
        for (let q = 0; q < b.length; q++) {
          const U = b[q];
          let L = null;
          if (m !== null)
            L = m.getViewport(U);
          else {
            const Y = f.getViewSubImage(d, U);
            L = Y.viewport, q === 0 && (t.setRenderTargetTextures(
              p,
              Y.colorTexture,
              d.ignoreDepthValues ? void 0 : Y.depthStencilTexture
            ), t.setRenderTarget(p));
          }
          let j = N[q];
          j === void 0 && (j = new di(), j.layers.enable(q), j.viewport = new In(), N[q] = j), j.matrix.fromArray(U.transform.matrix), j.matrix.decompose(j.position, j.quaternion, j.scale), j.projectionMatrix.fromArray(U.projectionMatrix), j.projectionMatrixInverse.copy(j.projectionMatrix).invert(), j.viewport.set(L.x, L.y, L.width, L.height), q === 0 && (A.matrix.copy(j.matrix), A.matrix.decompose(A.position, A.quaternion, A.scale)), lt === !0 && A.cameras.push(j);
        }
      }
      for (let b = 0; b < R.length; b++) {
        const lt = M[b], q = R[b];
        lt !== null && q !== void 0 && q.update(lt, rt, h || a);
      }
      pt && pt(F, rt), rt.detectedPlanes && i.dispatchEvent({ type: "planesdetected", data: rt }), v = null;
    }
    const vt = new Fd();
    vt.setAnimationLoop(_t), this.setAnimationLoop = function(F) {
      pt = F;
    }, this.dispose = function() {
    };
  }
}
function rw(n, t) {
  function e(_, p) {
    _.matrixAutoUpdate === !0 && _.updateMatrix(), p.value.copy(_.matrix);
  }
  function i(_, p) {
    p.color.getRGB(_.fogColor.value, Ld(n)), p.isFog ? (_.fogNear.value = p.near, _.fogFar.value = p.far) : p.isFogExp2 && (_.fogDensity.value = p.density);
  }
  function r(_, p, R, M, P) {
    p.isMeshBasicMaterial || p.isMeshLambertMaterial ? s(_, p) : p.isMeshToonMaterial ? (s(_, p), f(_, p)) : p.isMeshPhongMaterial ? (s(_, p), l(_, p)) : p.isMeshStandardMaterial ? (s(_, p), d(_, p), p.isMeshPhysicalMaterial && m(_, p, P)) : p.isMeshMatcapMaterial ? (s(_, p), v(_, p)) : p.isMeshDepthMaterial ? s(_, p) : p.isMeshDistanceMaterial ? (s(_, p), E(_, p)) : p.isMeshNormalMaterial ? s(_, p) : p.isLineBasicMaterial ? (a(_, p), p.isLineDashedMaterial && o(_, p)) : p.isPointsMaterial ? c(_, p, R, M) : p.isSpriteMaterial ? h(_, p) : p.isShadowMaterial ? (_.color.value.copy(p.color), _.opacity.value = p.opacity) : p.isShaderMaterial && (p.uniformsNeedUpdate = !1);
  }
  function s(_, p) {
    _.opacity.value = p.opacity, p.color && _.diffuse.value.copy(p.color), p.emissive && _.emissive.value.copy(p.emissive).multiplyScalar(p.emissiveIntensity), p.map && (_.map.value = p.map, e(p.map, _.mapTransform)), p.alphaMap && (_.alphaMap.value = p.alphaMap, e(p.alphaMap, _.alphaMapTransform)), p.bumpMap && (_.bumpMap.value = p.bumpMap, e(p.bumpMap, _.bumpMapTransform), _.bumpScale.value = p.bumpScale, p.side === Zn && (_.bumpScale.value *= -1)), p.normalMap && (_.normalMap.value = p.normalMap, e(p.normalMap, _.normalMapTransform), _.normalScale.value.copy(p.normalScale), p.side === Zn && _.normalScale.value.negate()), p.displacementMap && (_.displacementMap.value = p.displacementMap, e(p.displacementMap, _.displacementMapTransform), _.displacementScale.value = p.displacementScale, _.displacementBias.value = p.displacementBias), p.emissiveMap && (_.emissiveMap.value = p.emissiveMap, e(p.emissiveMap, _.emissiveMapTransform)), p.specularMap && (_.specularMap.value = p.specularMap, e(p.specularMap, _.specularMapTransform)), p.alphaTest > 0 && (_.alphaTest.value = p.alphaTest);
    const R = t.get(p).envMap;
    if (R && (_.envMap.value = R, _.flipEnvMap.value = R.isCubeTexture && R.isRenderTargetTexture === !1 ? -1 : 1, _.reflectivity.value = p.reflectivity, _.ior.value = p.ior, _.refractionRatio.value = p.refractionRatio), p.lightMap) {
      _.lightMap.value = p.lightMap;
      const M = n._useLegacyLights === !0 ? Math.PI : 1;
      _.lightMapIntensity.value = p.lightMapIntensity * M, e(p.lightMap, _.lightMapTransform);
    }
    p.aoMap && (_.aoMap.value = p.aoMap, _.aoMapIntensity.value = p.aoMapIntensity, e(p.aoMap, _.aoMapTransform));
  }
  function a(_, p) {
    _.diffuse.value.copy(p.color), _.opacity.value = p.opacity, p.map && (_.map.value = p.map, e(p.map, _.mapTransform));
  }
  function o(_, p) {
    _.dashSize.value = p.dashSize, _.totalSize.value = p.dashSize + p.gapSize, _.scale.value = p.scale;
  }
  function c(_, p, R, M) {
    _.diffuse.value.copy(p.color), _.opacity.value = p.opacity, _.size.value = p.size * R, _.scale.value = M * 0.5, p.map && (_.map.value = p.map, e(p.map, _.uvTransform)), p.alphaMap && (_.alphaMap.value = p.alphaMap, e(p.alphaMap, _.alphaMapTransform)), p.alphaTest > 0 && (_.alphaTest.value = p.alphaTest);
  }
  function h(_, p) {
    _.diffuse.value.copy(p.color), _.opacity.value = p.opacity, _.rotation.value = p.rotation, p.map && (_.map.value = p.map, e(p.map, _.mapTransform)), p.alphaMap && (_.alphaMap.value = p.alphaMap, e(p.alphaMap, _.alphaMapTransform)), p.alphaTest > 0 && (_.alphaTest.value = p.alphaTest);
  }
  function l(_, p) {
    _.specular.value.copy(p.specular), _.shininess.value = Math.max(p.shininess, 1e-4);
  }
  function f(_, p) {
    p.gradientMap && (_.gradientMap.value = p.gradientMap);
  }
  function d(_, p) {
    _.metalness.value = p.metalness, p.metalnessMap && (_.metalnessMap.value = p.metalnessMap, e(p.metalnessMap, _.metalnessMapTransform)), _.roughness.value = p.roughness, p.roughnessMap && (_.roughnessMap.value = p.roughnessMap, e(p.roughnessMap, _.roughnessMapTransform)), t.get(p).envMap && (_.envMapIntensity.value = p.envMapIntensity);
  }
  function m(_, p, R) {
    _.ior.value = p.ior, p.sheen > 0 && (_.sheenColor.value.copy(p.sheenColor).multiplyScalar(p.sheen), _.sheenRoughness.value = p.sheenRoughness, p.sheenColorMap && (_.sheenColorMap.value = p.sheenColorMap, e(p.sheenColorMap, _.sheenColorMapTransform)), p.sheenRoughnessMap && (_.sheenRoughnessMap.value = p.sheenRoughnessMap, e(p.sheenRoughnessMap, _.sheenRoughnessMapTransform))), p.clearcoat > 0 && (_.clearcoat.value = p.clearcoat, _.clearcoatRoughness.value = p.clearcoatRoughness, p.clearcoatMap && (_.clearcoatMap.value = p.clearcoatMap, e(p.clearcoatMap, _.clearcoatMapTransform)), p.clearcoatRoughnessMap && (_.clearcoatRoughnessMap.value = p.clearcoatRoughnessMap, e(p.clearcoatRoughnessMap, _.clearcoatRoughnessMapTransform)), p.clearcoatNormalMap && (_.clearcoatNormalMap.value = p.clearcoatNormalMap, e(p.clearcoatNormalMap, _.clearcoatNormalMapTransform), _.clearcoatNormalScale.value.copy(p.clearcoatNormalScale), p.side === Zn && _.clearcoatNormalScale.value.negate())), p.iridescence > 0 && (_.iridescence.value = p.iridescence, _.iridescenceIOR.value = p.iridescenceIOR, _.iridescenceThicknessMinimum.value = p.iridescenceThicknessRange[0], _.iridescenceThicknessMaximum.value = p.iridescenceThicknessRange[1], p.iridescenceMap && (_.iridescenceMap.value = p.iridescenceMap, e(p.iridescenceMap, _.iridescenceMapTransform)), p.iridescenceThicknessMap && (_.iridescenceThicknessMap.value = p.iridescenceThicknessMap, e(p.iridescenceThicknessMap, _.iridescenceThicknessMapTransform))), p.transmission > 0 && (_.transmission.value = p.transmission, _.transmissionSamplerMap.value = R.texture, _.transmissionSamplerSize.value.set(R.width, R.height), p.transmissionMap && (_.transmissionMap.value = p.transmissionMap, e(p.transmissionMap, _.transmissionMapTransform)), _.thickness.value = p.thickness, p.thicknessMap && (_.thicknessMap.value = p.thicknessMap, e(p.thicknessMap, _.thicknessMapTransform)), _.attenuationDistance.value = p.attenuationDistance, _.attenuationColor.value.copy(p.attenuationColor)), p.anisotropy > 0 && (_.anisotropyVector.value.set(p.anisotropy * Math.cos(p.anisotropyRotation), p.anisotropy * Math.sin(p.anisotropyRotation)), p.anisotropyMap && (_.anisotropyMap.value = p.anisotropyMap, e(p.anisotropyMap, _.anisotropyMapTransform))), _.specularIntensity.value = p.specularIntensity, _.specularColor.value.copy(p.specularColor), p.specularColorMap && (_.specularColorMap.value = p.specularColorMap, e(p.specularColorMap, _.specularColorMapTransform)), p.specularIntensityMap && (_.specularIntensityMap.value = p.specularIntensityMap, e(p.specularIntensityMap, _.specularIntensityMapTransform));
  }
  function v(_, p) {
    p.matcap && (_.matcap.value = p.matcap);
  }
  function E(_, p) {
    const R = t.get(p).light;
    _.referencePosition.value.setFromMatrixPosition(R.matrixWorld), _.nearDistance.value = R.shadow.camera.near, _.farDistance.value = R.shadow.camera.far;
  }
  return {
    refreshFogUniforms: i,
    refreshMaterialUniforms: r
  };
}
function sw(n, t, e, i) {
  let r = {}, s = {}, a = [];
  const o = e.isWebGL2 ? n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function c(R, M) {
    const P = M.program;
    i.uniformBlockBinding(R, P);
  }
  function h(R, M) {
    let P = r[R.id];
    P === void 0 && (v(R), P = l(R), r[R.id] = P, R.addEventListener("dispose", _));
    const W = M.program;
    i.updateUBOMapping(R, W);
    const C = t.render.frame;
    s[R.id] !== C && (d(R), s[R.id] = C);
  }
  function l(R) {
    const M = f();
    R.__bindingPointIndex = M;
    const P = n.createBuffer(), W = R.__size, C = R.usage;
    return n.bindBuffer(n.UNIFORM_BUFFER, P), n.bufferData(n.UNIFORM_BUFFER, W, C), n.bindBuffer(n.UNIFORM_BUFFER, null), n.bindBufferBase(n.UNIFORM_BUFFER, M, P), P;
  }
  function f() {
    for (let R = 0; R < o; R++)
      if (a.indexOf(R) === -1)
        return a.push(R), R;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function d(R) {
    const M = r[R.id], P = R.uniforms, W = R.__cache;
    n.bindBuffer(n.UNIFORM_BUFFER, M);
    for (let C = 0, D = P.length; C < D; C++) {
      const N = Array.isArray(P[C]) ? P[C] : [P[C]];
      for (let A = 0, I = N.length; A < I; A++) {
        const it = N[A];
        if (m(it, C, A, W) === !0) {
          const V = it.__offset, mt = Array.isArray(it.value) ? it.value : [it.value];
          let k = 0;
          for (let B = 0; B < mt.length; B++) {
            const G = mt[B], H = E(G);
            typeof G == "number" || typeof G == "boolean" ? (it.__data[0] = G, n.bufferSubData(n.UNIFORM_BUFFER, V + k, it.__data)) : G.isMatrix3 ? (it.__data[0] = G.elements[0], it.__data[1] = G.elements[1], it.__data[2] = G.elements[2], it.__data[3] = 0, it.__data[4] = G.elements[3], it.__data[5] = G.elements[4], it.__data[6] = G.elements[5], it.__data[7] = 0, it.__data[8] = G.elements[6], it.__data[9] = G.elements[7], it.__data[10] = G.elements[8], it.__data[11] = 0) : (G.toArray(it.__data, k), k += H.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          n.bufferSubData(n.UNIFORM_BUFFER, V, it.__data);
        }
      }
    }
    n.bindBuffer(n.UNIFORM_BUFFER, null);
  }
  function m(R, M, P, W) {
    const C = R.value, D = M + "_" + P;
    if (W[D] === void 0)
      return typeof C == "number" || typeof C == "boolean" ? W[D] = C : W[D] = C.clone(), !0;
    {
      const N = W[D];
      if (typeof C == "number" || typeof C == "boolean") {
        if (N !== C)
          return W[D] = C, !0;
      } else if (N.equals(C) === !1)
        return N.copy(C), !0;
    }
    return !1;
  }
  function v(R) {
    const M = R.uniforms;
    let P = 0;
    const W = 16;
    for (let D = 0, N = M.length; D < N; D++) {
      const A = Array.isArray(M[D]) ? M[D] : [M[D]];
      for (let I = 0, it = A.length; I < it; I++) {
        const V = A[I], mt = Array.isArray(V.value) ? V.value : [V.value];
        for (let k = 0, B = mt.length; k < B; k++) {
          const G = mt[k], H = E(G), w = P % W;
          w !== 0 && W - w < H.boundary && (P += W - w), V.__data = new Float32Array(H.storage / Float32Array.BYTES_PER_ELEMENT), V.__offset = P, P += H.storage;
        }
      }
    }
    const C = P % W;
    return C > 0 && (P += W - C), R.__size = P, R.__cache = {}, this;
  }
  function E(R) {
    const M = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof R == "number" || typeof R == "boolean" ? (M.boundary = 4, M.storage = 4) : R.isVector2 ? (M.boundary = 8, M.storage = 8) : R.isVector3 || R.isColor ? (M.boundary = 16, M.storage = 12) : R.isVector4 ? (M.boundary = 16, M.storage = 16) : R.isMatrix3 ? (M.boundary = 48, M.storage = 48) : R.isMatrix4 ? (M.boundary = 64, M.storage = 64) : R.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", R), M;
  }
  function _(R) {
    const M = R.target;
    M.removeEventListener("dispose", _);
    const P = a.indexOf(M.__bindingPointIndex);
    a.splice(P, 1), n.deleteBuffer(r[M.id]), delete r[M.id], delete s[M.id];
  }
  function p() {
    for (const R in r)
      n.deleteBuffer(r[R]);
    a = [], r = {}, s = {};
  }
  return {
    bind: c,
    update: h,
    dispose: p
  };
}
class Hd {
  constructor(t = {}) {
    const {
      canvas: e = Qg(),
      context: i = null,
      depth: r = !0,
      stencil: s = !0,
      alpha: a = !1,
      antialias: o = !1,
      premultipliedAlpha: c = !0,
      preserveDrawingBuffer: h = !1,
      powerPreference: l = "default",
      failIfMajorPerformanceCaveat: f = !1
    } = t;
    this.isWebGLRenderer = !0;
    let d;
    i !== null ? d = i.getContextAttributes().alpha : d = a;
    const m = new Uint32Array(4), v = new Int32Array(4);
    let E = null, _ = null;
    const p = [], R = [];
    this.domElement = e, this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: !0,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = yn, this._useLegacyLights = !1, this.toneMapping = zr, this.toneMappingExposure = 1;
    const M = this;
    let P = !1, W = 0, C = 0, D = null, N = -1, A = null;
    const I = new In(), it = new In();
    let V = null;
    const mt = new Ue(0);
    let k = 0, B = e.width, G = e.height, H = 1, w = null, ut = null;
    const pt = new In(0, 0, B, G), _t = new In(0, 0, B, G);
    let vt = !1;
    const F = new Nd();
    let rt = !1, b = !1, lt = null;
    const q = new vn(), U = new fe(), L = new Gt(), j = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    function Y() {
      return D === null ? H : 1;
    }
    let K = i;
    function yt(St, kt) {
      for (let qt = 0; qt < St.length; qt++) {
        const Xt = St[qt], jt = e.getContext(Xt, kt);
        if (jt !== null)
          return jt;
      }
      return null;
    }
    try {
      const St = {
        alpha: !0,
        depth: r,
        stencil: s,
        antialias: o,
        premultipliedAlpha: c,
        preserveDrawingBuffer: h,
        powerPreference: l,
        failIfMajorPerformanceCaveat: f
      };
      if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${ql}`), e.addEventListener("webglcontextlost", Pt, !1), e.addEventListener("webglcontextrestored", Mt, !1), e.addEventListener("webglcontextcreationerror", $t, !1), K === null) {
        const kt = ["webgl2", "webgl", "experimental-webgl"];
        if (M.isWebGL1Renderer === !0 && kt.shift(), K = yt(kt, St), K === null)
          throw yt(kt) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
      typeof WebGLRenderingContext < "u" && K instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), K.getShaderPrecisionFormat === void 0 && (K.getShaderPrecisionFormat = function() {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
    } catch (St) {
      throw console.error("THREE.WebGLRenderer: " + St.message), St;
    }
    let Et, Ct, Lt, Wt, wt, Q, y, g, S, O, Z, tt, gt, st, Tt, Ft, ht, It, z, ft, nt, J, Rt, Nt;
    function Yt() {
      Et = new m1(K), Ct = new c1(K, Et, t), Et.init(Ct), J = new tw(K, Et, Ct), Lt = new JE(K, Et, Ct), Wt = new g1(K), wt = new BE(), Q = new QE(K, Et, Lt, wt, Ct, J, Wt), y = new l1(M), g = new d1(M), S = new Sv(K, Ct), Rt = new a1(K, Et, S, Ct), O = new _1(K, S, Wt, Rt), Z = new E1(K, O, S, Wt), z = new b1(K, Ct, Q), Ft = new u1(wt), tt = new UE(M, y, g, Et, Ct, Rt, Ft), gt = new rw(M, wt), st = new zE(), Tt = new qE(Et, Ct), It = new s1(M, y, g, Lt, Z, d, c), ht = new ZE(M, Z, Ct), Nt = new sw(K, Wt, Ct, Lt), ft = new o1(K, Et, Wt, Ct), nt = new y1(K, Et, Wt, Ct), Wt.programs = tt.programs, M.capabilities = Ct, M.extensions = Et, M.properties = wt, M.renderLists = st, M.shadowMap = ht, M.state = Lt, M.info = Wt;
    }
    Yt();
    const Ht = new iw(M, K);
    this.xr = Ht, this.getContext = function() {
      return K;
    }, this.getContextAttributes = function() {
      return K.getContextAttributes();
    }, this.forceContextLoss = function() {
      const St = Et.get("WEBGL_lose_context");
      St && St.loseContext();
    }, this.forceContextRestore = function() {
      const St = Et.get("WEBGL_lose_context");
      St && St.restoreContext();
    }, this.getPixelRatio = function() {
      return H;
    }, this.setPixelRatio = function(St) {
      St !== void 0 && (H = St, this.setSize(B, G, !1));
    }, this.getSize = function(St) {
      return St.set(B, G);
    }, this.setSize = function(St, kt, qt = !0) {
      if (Ht.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      B = St, G = kt, e.width = Math.floor(St * H), e.height = Math.floor(kt * H), qt === !0 && (e.style.width = St + "px", e.style.height = kt + "px"), this.setViewport(0, 0, St, kt);
    }, this.getDrawingBufferSize = function(St) {
      return St.set(B * H, G * H).floor();
    }, this.setDrawingBufferSize = function(St, kt, qt) {
      B = St, G = kt, H = qt, e.width = Math.floor(St * qt), e.height = Math.floor(kt * qt), this.setViewport(0, 0, St, kt);
    }, this.getCurrentViewport = function(St) {
      return St.copy(I);
    }, this.getViewport = function(St) {
      return St.copy(pt);
    }, this.setViewport = function(St, kt, qt, Xt) {
      St.isVector4 ? pt.set(St.x, St.y, St.z, St.w) : pt.set(St, kt, qt, Xt), Lt.viewport(I.copy(pt).multiplyScalar(H).floor());
    }, this.getScissor = function(St) {
      return St.copy(_t);
    }, this.setScissor = function(St, kt, qt, Xt) {
      St.isVector4 ? _t.set(St.x, St.y, St.z, St.w) : _t.set(St, kt, qt, Xt), Lt.scissor(it.copy(_t).multiplyScalar(H).floor());
    }, this.getScissorTest = function() {
      return vt;
    }, this.setScissorTest = function(St) {
      Lt.setScissorTest(vt = St);
    }, this.setOpaqueSort = function(St) {
      w = St;
    }, this.setTransparentSort = function(St) {
      ut = St;
    }, this.getClearColor = function(St) {
      return St.copy(It.getClearColor());
    }, this.setClearColor = function() {
      It.setClearColor.apply(It, arguments);
    }, this.getClearAlpha = function() {
      return It.getClearAlpha();
    }, this.setClearAlpha = function() {
      It.setClearAlpha.apply(It, arguments);
    }, this.clear = function(St = !0, kt = !0, qt = !0) {
      let Xt = 0;
      if (St) {
        let jt = !1;
        if (D !== null) {
          const le = D.texture.format;
          jt = le === vd || le === gd || le === yd;
        }
        if (jt) {
          const le = D.texture.type, me = le === Gr || le === Nr || le === $l || le === Ms || le === md || le === _d, ye = It.getClearColor(), xe = It.getClearAlpha(), Te = ye.r, Ee = ye.g, we = ye.b;
          me ? (m[0] = Te, m[1] = Ee, m[2] = we, m[3] = xe, K.clearBufferuiv(K.COLOR, 0, m)) : (v[0] = Te, v[1] = Ee, v[2] = we, v[3] = xe, K.clearBufferiv(K.COLOR, 0, v));
        } else
          Xt |= K.COLOR_BUFFER_BIT;
      }
      kt && (Xt |= K.DEPTH_BUFFER_BIT), qt && (Xt |= K.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), K.clear(Xt);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      e.removeEventListener("webglcontextlost", Pt, !1), e.removeEventListener("webglcontextrestored", Mt, !1), e.removeEventListener("webglcontextcreationerror", $t, !1), st.dispose(), Tt.dispose(), wt.dispose(), y.dispose(), g.dispose(), Z.dispose(), Rt.dispose(), Nt.dispose(), tt.dispose(), Ht.dispose(), Ht.removeEventListener("sessionstart", Je), Ht.removeEventListener("sessionend", ve), lt && (lt.dispose(), lt = null), tn.stop();
    };
    function Pt(St) {
      St.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), P = !0;
    }
    function Mt() {
      console.log("THREE.WebGLRenderer: Context Restored."), P = !1;
      const St = Wt.autoReset, kt = ht.enabled, qt = ht.autoUpdate, Xt = ht.needsUpdate, jt = ht.type;
      Yt(), Wt.autoReset = St, ht.enabled = kt, ht.autoUpdate = qt, ht.needsUpdate = Xt, ht.type = jt;
    }
    function $t(St) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", St.statusMessage);
    }
    function Kt(St) {
      const kt = St.target;
      kt.removeEventListener("dispose", Kt), te(kt);
    }
    function te(St) {
      Qt(St), wt.remove(St);
    }
    function Qt(St) {
      const kt = wt.get(St).programs;
      kt !== void 0 && (kt.forEach(function(qt) {
        tt.releaseProgram(qt);
      }), St.isShaderMaterial && tt.releaseShaderCache(St));
    }
    this.renderBufferDirect = function(St, kt, qt, Xt, jt, le) {
      kt === null && (kt = j);
      const me = jt.isMesh && jt.matrixWorld.determinant() < 0, ye = ji(St, kt, qt, Xt, jt);
      Lt.setMaterial(Xt, me);
      let xe = qt.index, Te = 1;
      if (Xt.wireframe === !0) {
        if (xe = O.getWireframeAttribute(qt), xe === void 0)
          return;
        Te = 2;
      }
      const Ee = qt.drawRange, we = qt.attributes.position;
      let We = Ee.start * Te, fn = (Ee.start + Ee.count) * Te;
      le !== null && (We = Math.max(We, le.start * Te), fn = Math.min(fn, (le.start + le.count) * Te)), xe !== null ? (We = Math.max(We, 0), fn = Math.min(fn, xe.count)) : we != null && (We = Math.max(We, 0), fn = Math.min(fn, we.count));
      const Qe = fn - We;
      if (Qe < 0 || Qe === 1 / 0)
        return;
      Rt.setup(jt, Xt, ye, qt, xe);
      let wn, Ve = ft;
      if (xe !== null && (wn = S.get(xe), Ve = nt, Ve.setIndex(wn)), jt.isMesh)
        Xt.wireframe === !0 ? (Lt.setLineWidth(Xt.wireframeLinewidth * Y()), Ve.setMode(K.LINES)) : Ve.setMode(K.TRIANGLES);
      else if (jt.isLine) {
        let Ae = Xt.linewidth;
        Ae === void 0 && (Ae = 1), Lt.setLineWidth(Ae * Y()), jt.isLineSegments ? Ve.setMode(K.LINES) : jt.isLineLoop ? Ve.setMode(K.LINE_LOOP) : Ve.setMode(K.LINE_STRIP);
      } else
        jt.isPoints ? Ve.setMode(K.POINTS) : jt.isSprite && Ve.setMode(K.TRIANGLES);
      if (jt.isBatchedMesh)
        Ve.renderMultiDraw(jt._multiDrawStarts, jt._multiDrawCounts, jt._multiDrawCount);
      else if (jt.isInstancedMesh)
        Ve.renderInstances(We, Qe, jt.count);
      else if (qt.isInstancedBufferGeometry) {
        const Ae = qt._maxInstanceCount !== void 0 ? qt._maxInstanceCount : 1 / 0, li = Math.min(qt.instanceCount, Ae);
        Ve.renderInstances(We, Qe, li);
      } else
        Ve.render(We, Qe);
    };
    function ee(St, kt, qt) {
      St.transparent === !0 && St.side === Mi && St.forceSinglePass === !1 ? (St.side = Zn, St.needsUpdate = !0, ci(St, kt, qt), St.side = Hr, St.needsUpdate = !0, ci(St, kt, qt), St.side = Mi) : ci(St, kt, qt);
    }
    this.compile = function(St, kt, qt = null) {
      qt === null && (qt = St), _ = Tt.get(qt), _.init(), R.push(_), qt.traverseVisible(function(jt) {
        jt.isLight && jt.layers.test(kt.layers) && (_.pushLight(jt), jt.castShadow && _.pushShadow(jt));
      }), St !== qt && St.traverseVisible(function(jt) {
        jt.isLight && jt.layers.test(kt.layers) && (_.pushLight(jt), jt.castShadow && _.pushShadow(jt));
      }), _.setupLights(M._useLegacyLights);
      const Xt = /* @__PURE__ */ new Set();
      return St.traverse(function(jt) {
        const le = jt.material;
        if (le)
          if (Array.isArray(le))
            for (let me = 0; me < le.length; me++) {
              const ye = le[me];
              ee(ye, qt, jt), Xt.add(ye);
            }
          else
            ee(le, qt, jt), Xt.add(le);
      }), R.pop(), _ = null, Xt;
    }, this.compileAsync = function(St, kt, qt = null) {
      const Xt = this.compile(St, kt, qt);
      return new Promise((jt) => {
        function le() {
          if (Xt.forEach(function(me) {
            wt.get(me).currentProgram.isReady() && Xt.delete(me);
          }), Xt.size === 0) {
            jt(St);
            return;
          }
          setTimeout(le, 10);
        }
        Et.get("KHR_parallel_shader_compile") !== null ? le() : setTimeout(le, 10);
      });
    };
    let Pe = null;
    function Ne(St) {
      Pe && Pe(St);
    }
    function Je() {
      tn.stop();
    }
    function ve() {
      tn.start();
    }
    const tn = new Fd();
    tn.setAnimationLoop(Ne), typeof self < "u" && tn.setContext(self), this.setAnimationLoop = function(St) {
      Pe = St, Ht.setAnimationLoop(St), St === null ? tn.stop() : tn.start();
    }, Ht.addEventListener("sessionstart", Je), Ht.addEventListener("sessionend", ve), this.render = function(St, kt) {
      if (kt !== void 0 && kt.isCamera !== !0) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (P === !0)
        return;
      St.matrixWorldAutoUpdate === !0 && St.updateMatrixWorld(), kt.parent === null && kt.matrixWorldAutoUpdate === !0 && kt.updateMatrixWorld(), Ht.enabled === !0 && Ht.isPresenting === !0 && (Ht.cameraAutoUpdate === !0 && Ht.updateCamera(kt), kt = Ht.getCamera()), St.isScene === !0 && St.onBeforeRender(M, St, kt, D), _ = Tt.get(St, R.length), _.init(), R.push(_), q.multiplyMatrices(kt.projectionMatrix, kt.matrixWorldInverse), F.setFromProjectionMatrix(q), b = this.localClippingEnabled, rt = Ft.init(this.clippingPlanes, b), E = st.get(St, p.length), E.init(), p.push(E), dn(St, kt, 0, M.sortObjects), E.finish(), M.sortObjects === !0 && E.sort(w, ut), this.info.render.frame++, rt === !0 && Ft.beginShadows();
      const qt = _.state.shadowsArray;
      if (ht.render(qt, St, kt), rt === !0 && Ft.endShadows(), this.info.autoReset === !0 && this.info.reset(), It.render(E, St), _.setupLights(M._useLegacyLights), kt.isArrayCamera) {
        const Xt = kt.cameras;
        for (let jt = 0, le = Xt.length; jt < le; jt++) {
          const me = Xt[jt];
          Qn(E, St, me, me.viewport);
        }
      } else
        Qn(E, St, kt);
      D !== null && (Q.updateMultisampleRenderTarget(D), Q.updateRenderTargetMipmap(D)), St.isScene === !0 && St.onAfterRender(M, St, kt), Rt.resetDefaultState(), N = -1, A = null, R.pop(), R.length > 0 ? _ = R[R.length - 1] : _ = null, p.pop(), p.length > 0 ? E = p[p.length - 1] : E = null;
    };
    function dn(St, kt, qt, Xt) {
      if (St.visible === !1)
        return;
      if (St.layers.test(kt.layers)) {
        if (St.isGroup)
          qt = St.renderOrder;
        else if (St.isLOD)
          St.autoUpdate === !0 && St.update(kt);
        else if (St.isLight)
          _.pushLight(St), St.castShadow && _.pushShadow(St);
        else if (St.isSprite) {
          if (!St.frustumCulled || F.intersectsSprite(St)) {
            Xt && L.setFromMatrixPosition(St.matrixWorld).applyMatrix4(q);
            const me = Z.update(St), ye = St.material;
            ye.visible && E.push(St, me, ye, qt, L.z, null);
          }
        } else if ((St.isMesh || St.isLine || St.isPoints) && (!St.frustumCulled || F.intersectsObject(St))) {
          const me = Z.update(St), ye = St.material;
          if (Xt && (St.boundingSphere !== void 0 ? (St.boundingSphere === null && St.computeBoundingSphere(), L.copy(St.boundingSphere.center)) : (me.boundingSphere === null && me.computeBoundingSphere(), L.copy(me.boundingSphere.center)), L.applyMatrix4(St.matrixWorld).applyMatrix4(q)), Array.isArray(ye)) {
            const xe = me.groups;
            for (let Te = 0, Ee = xe.length; Te < Ee; Te++) {
              const we = xe[Te], We = ye[we.materialIndex];
              We && We.visible && E.push(St, me, We, qt, L.z, we);
            }
          } else
            ye.visible && E.push(St, me, ye, qt, L.z, null);
        }
      }
      const le = St.children;
      for (let me = 0, ye = le.length; me < ye; me++)
        dn(le[me], kt, qt, Xt);
    }
    function Qn(St, kt, qt, Xt) {
      const jt = St.opaque, le = St.transmissive, me = St.transparent;
      _.setupLightsView(qt), rt === !0 && Ft.setGlobalState(M.clippingPlanes, qt), le.length > 0 && zn(jt, le, kt, qt), Xt && Lt.viewport(I.copy(Xt)), jt.length > 0 && Rn(jt, kt, qt), le.length > 0 && Rn(le, kt, qt), me.length > 0 && Rn(me, kt, qt), Lt.buffers.depth.setTest(!0), Lt.buffers.depth.setMask(!0), Lt.buffers.color.setMask(!0), Lt.setPolygonOffset(!1);
    }
    function zn(St, kt, qt, Xt) {
      if ((qt.isScene === !0 ? qt.overrideMaterial : null) !== null)
        return;
      const le = Ct.isWebGL2;
      lt === null && (lt = new Cs(1, 1, {
        generateMipmaps: !0,
        type: Et.has("EXT_color_buffer_half_float") ? Za : Gr,
        minFilter: ya,
        samples: le ? 4 : 0
      })), M.getDrawingBufferSize(U), le ? lt.setSize(U.x, U.y) : lt.setSize(ou(U.x), ou(U.y));
      const me = M.getRenderTarget();
      M.setRenderTarget(lt), M.getClearColor(mt), k = M.getClearAlpha(), k < 1 && M.setClearColor(16777215, 0.5), M.clear();
      const ye = M.toneMapping;
      M.toneMapping = zr, Rn(St, qt, Xt), Q.updateMultisampleRenderTarget(lt), Q.updateRenderTargetMipmap(lt);
      let xe = !1;
      for (let Te = 0, Ee = kt.length; Te < Ee; Te++) {
        const we = kt[Te], We = we.object, fn = we.geometry, Qe = we.material, wn = we.group;
        if (Qe.side === Mi && We.layers.test(Xt.layers)) {
          const Ve = Qe.side;
          Qe.side = Zn, Qe.needsUpdate = !0, Gn(We, qt, Xt, fn, Qe, wn), Qe.side = Ve, Qe.needsUpdate = !0, xe = !0;
        }
      }
      xe === !0 && (Q.updateMultisampleRenderTarget(lt), Q.updateRenderTargetMipmap(lt)), M.setRenderTarget(me), M.setClearColor(mt, k), M.toneMapping = ye;
    }
    function Rn(St, kt, qt) {
      const Xt = kt.isScene === !0 ? kt.overrideMaterial : null;
      for (let jt = 0, le = St.length; jt < le; jt++) {
        const me = St[jt], ye = me.object, xe = me.geometry, Te = Xt === null ? me.material : Xt, Ee = me.group;
        ye.layers.test(qt.layers) && Gn(ye, kt, qt, xe, Te, Ee);
      }
    }
    function Gn(St, kt, qt, Xt, jt, le) {
      St.onBeforeRender(M, kt, qt, Xt, jt, le), St.modelViewMatrix.multiplyMatrices(qt.matrixWorldInverse, St.matrixWorld), St.normalMatrix.getNormalMatrix(St.modelViewMatrix), jt.onBeforeRender(M, kt, qt, Xt, St, le), jt.transparent === !0 && jt.side === Mi && jt.forceSinglePass === !1 ? (jt.side = Zn, jt.needsUpdate = !0, M.renderBufferDirect(qt, kt, Xt, jt, St, le), jt.side = Hr, jt.needsUpdate = !0, M.renderBufferDirect(qt, kt, Xt, jt, St, le), jt.side = Mi) : M.renderBufferDirect(qt, kt, Xt, jt, St, le), St.onAfterRender(M, kt, qt, Xt, jt, le);
    }
    function ci(St, kt, qt) {
      kt.isScene !== !0 && (kt = j);
      const Xt = wt.get(St), jt = _.state.lights, le = _.state.shadowsArray, me = jt.state.version, ye = tt.getParameters(St, jt.state, le, kt, qt), xe = tt.getProgramCacheKey(ye);
      let Te = Xt.programs;
      Xt.environment = St.isMeshStandardMaterial ? kt.environment : null, Xt.fog = kt.fog, Xt.envMap = (St.isMeshStandardMaterial ? g : y).get(St.envMap || Xt.environment), Te === void 0 && (St.addEventListener("dispose", Kt), Te = /* @__PURE__ */ new Map(), Xt.programs = Te);
      let Ee = Te.get(xe);
      if (Ee !== void 0) {
        if (Xt.currentProgram === Ee && Xt.lightsStateVersion === me)
          return ui(St, ye), Ee;
      } else
        ye.uniforms = tt.getUniforms(St), St.onBuild(qt, ye, M), St.onBeforeCompile(ye, M), Ee = tt.acquireProgram(ye, xe), Te.set(xe, Ee), Xt.uniforms = ye.uniforms;
      const we = Xt.uniforms;
      return (!St.isShaderMaterial && !St.isRawShaderMaterial || St.clipping === !0) && (we.clippingPlanes = Ft.uniform), ui(St, ye), Xt.needsLights = qi(St), Xt.lightsStateVersion = me, Xt.needsLights && (we.ambientLightColor.value = jt.state.ambient, we.lightProbe.value = jt.state.probe, we.directionalLights.value = jt.state.directional, we.directionalLightShadows.value = jt.state.directionalShadow, we.spotLights.value = jt.state.spot, we.spotLightShadows.value = jt.state.spotShadow, we.rectAreaLights.value = jt.state.rectArea, we.ltc_1.value = jt.state.rectAreaLTC1, we.ltc_2.value = jt.state.rectAreaLTC2, we.pointLights.value = jt.state.point, we.pointLightShadows.value = jt.state.pointShadow, we.hemisphereLights.value = jt.state.hemi, we.directionalShadowMap.value = jt.state.directionalShadowMap, we.directionalShadowMatrix.value = jt.state.directionalShadowMatrix, we.spotShadowMap.value = jt.state.spotShadowMap, we.spotLightMatrix.value = jt.state.spotLightMatrix, we.spotLightMap.value = jt.state.spotLightMap, we.pointShadowMap.value = jt.state.pointShadowMap, we.pointShadowMatrix.value = jt.state.pointShadowMatrix), Xt.currentProgram = Ee, Xt.uniformsList = null, Ee;
    }
    function Ai(St) {
      if (St.uniformsList === null) {
        const kt = St.currentProgram.getUniforms();
        St.uniformsList = Yc.seqWithValue(kt.seq, St.uniforms);
      }
      return St.uniformsList;
    }
    function ui(St, kt) {
      const qt = wt.get(St);
      qt.outputColorSpace = kt.outputColorSpace, qt.batching = kt.batching, qt.instancing = kt.instancing, qt.instancingColor = kt.instancingColor, qt.skinning = kt.skinning, qt.morphTargets = kt.morphTargets, qt.morphNormals = kt.morphNormals, qt.morphColors = kt.morphColors, qt.morphTargetsCount = kt.morphTargetsCount, qt.numClippingPlanes = kt.numClippingPlanes, qt.numIntersection = kt.numClipIntersection, qt.vertexAlphas = kt.vertexAlphas, qt.vertexTangents = kt.vertexTangents, qt.toneMapping = kt.toneMapping;
    }
    function ji(St, kt, qt, Xt, jt) {
      kt.isScene !== !0 && (kt = j), Q.resetTextureUnits();
      const le = kt.fog, me = Xt.isMeshStandardMaterial ? kt.environment : null, ye = D === null ? M.outputColorSpace : D.isXRRenderTarget === !0 ? D.texture.colorSpace : lr, xe = (Xt.isMeshStandardMaterial ? g : y).get(Xt.envMap || me), Te = Xt.vertexColors === !0 && !!qt.attributes.color && qt.attributes.color.itemSize === 4, Ee = !!qt.attributes.tangent && (!!Xt.normalMap || Xt.anisotropy > 0), we = !!qt.morphAttributes.position, We = !!qt.morphAttributes.normal, fn = !!qt.morphAttributes.color;
      let Qe = zr;
      Xt.toneMapped && (D === null || D.isXRRenderTarget === !0) && (Qe = M.toneMapping);
      const wn = qt.morphAttributes.position || qt.morphAttributes.normal || qt.morphAttributes.color, Ve = wn !== void 0 ? wn.length : 0, Ae = wt.get(Xt), li = _.state.lights;
      if (rt === !0 && (b === !0 || St !== A)) {
        const He = St === A && Xt.id === N;
        Ft.setState(Xt, St, He);
      }
      let ze = !1;
      Xt.version === Ae.__version ? (Ae.needsLights && Ae.lightsStateVersion !== li.state.version || Ae.outputColorSpace !== ye || jt.isBatchedMesh && Ae.batching === !1 || !jt.isBatchedMesh && Ae.batching === !0 || jt.isInstancedMesh && Ae.instancing === !1 || !jt.isInstancedMesh && Ae.instancing === !0 || jt.isSkinnedMesh && Ae.skinning === !1 || !jt.isSkinnedMesh && Ae.skinning === !0 || jt.isInstancedMesh && Ae.instancingColor === !0 && jt.instanceColor === null || jt.isInstancedMesh && Ae.instancingColor === !1 && jt.instanceColor !== null || Ae.envMap !== xe || Xt.fog === !0 && Ae.fog !== le || Ae.numClippingPlanes !== void 0 && (Ae.numClippingPlanes !== Ft.numPlanes || Ae.numIntersection !== Ft.numIntersection) || Ae.vertexAlphas !== Te || Ae.vertexTangents !== Ee || Ae.morphTargets !== we || Ae.morphNormals !== We || Ae.morphColors !== fn || Ae.toneMapping !== Qe || Ct.isWebGL2 === !0 && Ae.morphTargetsCount !== Ve) && (ze = !0) : (ze = !0, Ae.__version = Xt.version);
      let On = Ae.currentProgram;
      ze === !0 && (On = ci(Xt, kt, jt));
      let hn = !1, Yn = !1, fi = !1;
      const en = On.getUniforms(), mn = Ae.uniforms;
      if (Lt.useProgram(On.program) && (hn = !0, Yn = !0, fi = !0), Xt.id !== N && (N = Xt.id, Yn = !0), hn || A !== St) {
        en.setValue(K, "projectionMatrix", St.projectionMatrix), en.setValue(K, "viewMatrix", St.matrixWorldInverse);
        const He = en.map.cameraPosition;
        He !== void 0 && He.setValue(K, L.setFromMatrixPosition(St.matrixWorld)), Ct.logarithmicDepthBuffer && en.setValue(
          K,
          "logDepthBufFC",
          2 / (Math.log(St.far + 1) / Math.LN2)
        ), (Xt.isMeshPhongMaterial || Xt.isMeshToonMaterial || Xt.isMeshLambertMaterial || Xt.isMeshBasicMaterial || Xt.isMeshStandardMaterial || Xt.isShaderMaterial) && en.setValue(K, "isOrthographic", St.isOrthographicCamera === !0), A !== St && (A = St, Yn = !0, fi = !0);
      }
      if (jt.isSkinnedMesh) {
        en.setOptional(K, jt, "bindMatrix"), en.setOptional(K, jt, "bindMatrixInverse");
        const He = jt.skeleton;
        He && (Ct.floatVertexTextures ? (He.boneTexture === null && He.computeBoneTexture(), en.setValue(K, "boneTexture", He.boneTexture, Q)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
      }
      jt.isBatchedMesh && (en.setOptional(K, jt, "batchingTexture"), en.setValue(K, "batchingTexture", jt._matricesTexture, Q));
      const rn = qt.morphAttributes;
      if ((rn.position !== void 0 || rn.normal !== void 0 || rn.color !== void 0 && Ct.isWebGL2 === !0) && z.update(jt, qt, On), (Yn || Ae.receiveShadow !== jt.receiveShadow) && (Ae.receiveShadow = jt.receiveShadow, en.setValue(K, "receiveShadow", jt.receiveShadow)), Xt.isMeshGouraudMaterial && Xt.envMap !== null && (mn.envMap.value = xe, mn.flipEnvMap.value = xe.isCubeTexture && xe.isRenderTargetTexture === !1 ? -1 : 1), Yn && (en.setValue(K, "toneMappingExposure", M.toneMappingExposure), Ae.needsLights && Wi(mn, fi), le && Xt.fog === !0 && gt.refreshFogUniforms(mn, le), gt.refreshMaterialUniforms(mn, Xt, H, G, lt), Yc.upload(K, Ai(Ae), mn, Q)), Xt.isShaderMaterial && Xt.uniformsNeedUpdate === !0 && (Yc.upload(K, Ai(Ae), mn, Q), Xt.uniformsNeedUpdate = !1), Xt.isSpriteMaterial && en.setValue(K, "center", jt.center), en.setValue(K, "modelViewMatrix", jt.modelViewMatrix), en.setValue(K, "normalMatrix", jt.normalMatrix), en.setValue(K, "modelMatrix", jt.matrixWorld), Xt.isShaderMaterial || Xt.isRawShaderMaterial) {
        const He = Xt.uniformsGroups;
        for (let Vn = 0, ti = He.length; Vn < ti; Vn++)
          if (Ct.isWebGL2) {
            const Ti = He[Vn];
            Nt.update(Ti, On), Nt.bind(Ti, On);
          } else
            console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
      }
      return On;
    }
    function Wi(St, kt) {
      St.ambientLightColor.needsUpdate = kt, St.lightProbe.needsUpdate = kt, St.directionalLights.needsUpdate = kt, St.directionalLightShadows.needsUpdate = kt, St.pointLights.needsUpdate = kt, St.pointLightShadows.needsUpdate = kt, St.spotLights.needsUpdate = kt, St.spotLightShadows.needsUpdate = kt, St.rectAreaLights.needsUpdate = kt, St.hemisphereLights.needsUpdate = kt;
    }
    function qi(St) {
      return St.isMeshLambertMaterial || St.isMeshToonMaterial || St.isMeshPhongMaterial || St.isMeshStandardMaterial || St.isShadowMaterial || St.isShaderMaterial && St.lights === !0;
    }
    this.getActiveCubeFace = function() {
      return W;
    }, this.getActiveMipmapLevel = function() {
      return C;
    }, this.getRenderTarget = function() {
      return D;
    }, this.setRenderTargetTextures = function(St, kt, qt) {
      wt.get(St.texture).__webglTexture = kt, wt.get(St.depthTexture).__webglTexture = qt;
      const Xt = wt.get(St);
      Xt.__hasExternalTextures = !0, Xt.__hasExternalTextures && (Xt.__autoAllocateDepthBuffer = qt === void 0, Xt.__autoAllocateDepthBuffer || Et.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), Xt.__useRenderToTexture = !1));
    }, this.setRenderTargetFramebuffer = function(St, kt) {
      const qt = wt.get(St);
      qt.__webglFramebuffer = kt, qt.__useDefaultFramebuffer = kt === void 0;
    }, this.setRenderTarget = function(St, kt = 0, qt = 0) {
      D = St, W = kt, C = qt;
      let Xt = !0, jt = null, le = !1, me = !1;
      if (St) {
        const xe = wt.get(St);
        xe.__useDefaultFramebuffer !== void 0 ? (Lt.bindFramebuffer(K.FRAMEBUFFER, null), Xt = !1) : xe.__webglFramebuffer === void 0 ? Q.setupRenderTarget(St) : xe.__hasExternalTextures && Q.rebindTextures(St, wt.get(St.texture).__webglTexture, wt.get(St.depthTexture).__webglTexture);
        const Te = St.texture;
        (Te.isData3DTexture || Te.isDataArrayTexture || Te.isCompressedArrayTexture) && (me = !0);
        const Ee = wt.get(St).__webglFramebuffer;
        St.isWebGLCubeRenderTarget ? (Array.isArray(Ee[kt]) ? jt = Ee[kt][qt] : jt = Ee[kt], le = !0) : Ct.isWebGL2 && St.samples > 0 && Q.useMultisampledRTT(St) === !1 ? jt = wt.get(St).__webglMultisampledFramebuffer : Array.isArray(Ee) ? jt = Ee[qt] : jt = Ee, I.copy(St.viewport), it.copy(St.scissor), V = St.scissorTest;
      } else
        I.copy(pt).multiplyScalar(H).floor(), it.copy(_t).multiplyScalar(H).floor(), V = vt;
      if (Lt.bindFramebuffer(K.FRAMEBUFFER, jt) && Ct.drawBuffers && Xt && Lt.drawBuffers(St, jt), Lt.viewport(I), Lt.scissor(it), Lt.setScissorTest(V), le) {
        const xe = wt.get(St.texture);
        K.framebufferTexture2D(K.FRAMEBUFFER, K.COLOR_ATTACHMENT0, K.TEXTURE_CUBE_MAP_POSITIVE_X + kt, xe.__webglTexture, qt);
      } else if (me) {
        const xe = wt.get(St.texture), Te = kt || 0;
        K.framebufferTextureLayer(K.FRAMEBUFFER, K.COLOR_ATTACHMENT0, xe.__webglTexture, qt || 0, Te);
      }
      N = -1;
    }, this.readRenderTargetPixels = function(St, kt, qt, Xt, jt, le, me) {
      if (!(St && St.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let ye = wt.get(St).__webglFramebuffer;
      if (St.isWebGLCubeRenderTarget && me !== void 0 && (ye = ye[me]), ye) {
        Lt.bindFramebuffer(K.FRAMEBUFFER, ye);
        try {
          const xe = St.texture, Te = xe.format, Ee = xe.type;
          if (Te !== yi && J.convert(Te) !== K.getParameter(K.IMPLEMENTATION_COLOR_READ_FORMAT)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          const we = Ee === Za && (Et.has("EXT_color_buffer_half_float") || Ct.isWebGL2 && Et.has("EXT_color_buffer_float"));
          if (Ee !== Gr && J.convert(Ee) !== K.getParameter(K.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
          !(Ee === Fr && (Ct.isWebGL2 || Et.has("OES_texture_float") || Et.has("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
          !we) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          kt >= 0 && kt <= St.width - Xt && qt >= 0 && qt <= St.height - jt && K.readPixels(kt, qt, Xt, jt, J.convert(Te), J.convert(Ee), le);
        } finally {
          const xe = D !== null ? wt.get(D).__webglFramebuffer : null;
          Lt.bindFramebuffer(K.FRAMEBUFFER, xe);
        }
      }
    }, this.copyFramebufferToTexture = function(St, kt, qt = 0) {
      const Xt = Math.pow(2, -qt), jt = Math.floor(kt.image.width * Xt), le = Math.floor(kt.image.height * Xt);
      Q.setTexture2D(kt, 0), K.copyTexSubImage2D(K.TEXTURE_2D, qt, 0, 0, St.x, St.y, jt, le), Lt.unbindTexture();
    }, this.copyTextureToTexture = function(St, kt, qt, Xt = 0) {
      const jt = kt.image.width, le = kt.image.height, me = J.convert(qt.format), ye = J.convert(qt.type);
      Q.setTexture2D(qt, 0), K.pixelStorei(K.UNPACK_FLIP_Y_WEBGL, qt.flipY), K.pixelStorei(K.UNPACK_PREMULTIPLY_ALPHA_WEBGL, qt.premultiplyAlpha), K.pixelStorei(K.UNPACK_ALIGNMENT, qt.unpackAlignment), kt.isDataTexture ? K.texSubImage2D(K.TEXTURE_2D, Xt, St.x, St.y, jt, le, me, ye, kt.image.data) : kt.isCompressedTexture ? K.compressedTexSubImage2D(K.TEXTURE_2D, Xt, St.x, St.y, kt.mipmaps[0].width, kt.mipmaps[0].height, me, kt.mipmaps[0].data) : K.texSubImage2D(K.TEXTURE_2D, Xt, St.x, St.y, me, ye, kt.image), Xt === 0 && qt.generateMipmaps && K.generateMipmap(K.TEXTURE_2D), Lt.unbindTexture();
    }, this.copyTextureToTexture3D = function(St, kt, qt, Xt, jt = 0) {
      if (M.isWebGL1Renderer) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        return;
      }
      const le = St.max.x - St.min.x + 1, me = St.max.y - St.min.y + 1, ye = St.max.z - St.min.z + 1, xe = J.convert(Xt.format), Te = J.convert(Xt.type);
      let Ee;
      if (Xt.isData3DTexture)
        Q.setTexture3D(Xt, 0), Ee = K.TEXTURE_3D;
      else if (Xt.isDataArrayTexture || Xt.isCompressedArrayTexture)
        Q.setTexture2DArray(Xt, 0), Ee = K.TEXTURE_2D_ARRAY;
      else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      K.pixelStorei(K.UNPACK_FLIP_Y_WEBGL, Xt.flipY), K.pixelStorei(K.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Xt.premultiplyAlpha), K.pixelStorei(K.UNPACK_ALIGNMENT, Xt.unpackAlignment);
      const we = K.getParameter(K.UNPACK_ROW_LENGTH), We = K.getParameter(K.UNPACK_IMAGE_HEIGHT), fn = K.getParameter(K.UNPACK_SKIP_PIXELS), Qe = K.getParameter(K.UNPACK_SKIP_ROWS), wn = K.getParameter(K.UNPACK_SKIP_IMAGES), Ve = qt.isCompressedTexture ? qt.mipmaps[jt] : qt.image;
      K.pixelStorei(K.UNPACK_ROW_LENGTH, Ve.width), K.pixelStorei(K.UNPACK_IMAGE_HEIGHT, Ve.height), K.pixelStorei(K.UNPACK_SKIP_PIXELS, St.min.x), K.pixelStorei(K.UNPACK_SKIP_ROWS, St.min.y), K.pixelStorei(K.UNPACK_SKIP_IMAGES, St.min.z), qt.isDataTexture || qt.isData3DTexture ? K.texSubImage3D(Ee, jt, kt.x, kt.y, kt.z, le, me, ye, xe, Te, Ve.data) : qt.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), K.compressedTexSubImage3D(Ee, jt, kt.x, kt.y, kt.z, le, me, ye, xe, Ve.data)) : K.texSubImage3D(Ee, jt, kt.x, kt.y, kt.z, le, me, ye, xe, Te, Ve), K.pixelStorei(K.UNPACK_ROW_LENGTH, we), K.pixelStorei(K.UNPACK_IMAGE_HEIGHT, We), K.pixelStorei(K.UNPACK_SKIP_PIXELS, fn), K.pixelStorei(K.UNPACK_SKIP_ROWS, Qe), K.pixelStorei(K.UNPACK_SKIP_IMAGES, wn), jt === 0 && Xt.generateMipmaps && K.generateMipmap(Ee), Lt.unbindTexture();
    }, this.initTexture = function(St) {
      St.isCubeTexture ? Q.setTextureCube(St, 0) : St.isData3DTexture ? Q.setTexture3D(St, 0) : St.isDataArrayTexture || St.isCompressedArrayTexture ? Q.setTexture2DArray(St, 0) : Q.setTexture2D(St, 0), Lt.unbindTexture();
    }, this.resetState = function() {
      W = 0, C = 0, D = null, Lt.reset(), Rt.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return cr;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(t) {
    this._outputColorSpace = t;
    const e = this.getContext();
    e.drawingBufferColorSpace = t === Xl ? "display-p3" : "srgb", e.unpackColorSpace = Ke.workingColorSpace === fu ? "display-p3" : "srgb";
  }
  get outputEncoding() {
    return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace === yn ? As : bd;
  }
  set outputEncoding(t) {
    console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace = t === As ? yn : lr;
  }
  get useLegacyLights() {
    return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights;
  }
  set useLegacyLights(t) {
    console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = t;
  }
}
class aw extends Hd {
}
aw.prototype.isWebGL1Renderer = !0;
class Tl extends oi {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(t, e) {
    return super.copy(t, e), t.background !== null && (this.background = t.background.clone()), t.environment !== null && (this.environment = t.environment.clone()), t.fog !== null && (this.fog = t.fog.clone()), this.backgroundBlurriness = t.backgroundBlurriness, this.backgroundIntensity = t.backgroundIntensity, t.overrideMaterial !== null && (this.overrideMaterial = t.overrideMaterial.clone()), this.matrixAutoUpdate = t.matrixAutoUpdate, this;
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return this.fog !== null && (e.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (e.object.backgroundIntensity = this.backgroundIntensity), e;
  }
}
class Ju extends qn {
  constructor(t, e, i, r, s, a, o, c, h, l, f, d) {
    super(null, a, o, c, h, l, r, s, f, d), this.isCompressedTexture = !0, this.image = { width: e, height: i }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class ow extends qn {
  constructor(t, e, i, r, s, a, o, c, h) {
    super(t, e, i, r, s, a, o, c, h), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}
class zi {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(t, e) {
    const i = this.getUtoTmapping(t);
    return this.getPoint(i, e);
  }
  // Get sequence of points using getPoint( t )
  getPoints(t = 5) {
    const e = [];
    for (let i = 0; i <= t; i++)
      e.push(this.getPoint(i / t));
    return e;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(t = 5) {
    const e = [];
    for (let i = 0; i <= t; i++)
      e.push(this.getPointAt(i / t));
    return e;
  }
  // Get total curve arc length
  getLength() {
    const t = this.getLengths();
    return t[t.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(t = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const e = [];
    let i, r = this.getPoint(0), s = 0;
    e.push(0);
    for (let a = 1; a <= t; a++)
      i = this.getPoint(a / t), s += i.distanceTo(r), e.push(s), r = i;
    return this.cacheArcLengths = e, e;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(t, e) {
    const i = this.getLengths();
    let r = 0;
    const s = i.length;
    let a;
    e ? a = e : a = t * i[s - 1];
    let o = 0, c = s - 1, h;
    for (; o <= c; )
      if (r = Math.floor(o + (c - o) / 2), h = i[r] - a, h < 0)
        o = r + 1;
      else if (h > 0)
        c = r - 1;
      else {
        c = r;
        break;
      }
    if (r = c, i[r] === a)
      return r / (s - 1);
    const l = i[r], d = i[r + 1] - l, m = (a - l) / d;
    return (r + m) / (s - 1);
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(t, e) {
    let r = t - 1e-4, s = t + 1e-4;
    r < 0 && (r = 0), s > 1 && (s = 1);
    const a = this.getPoint(r), o = this.getPoint(s), c = e || (a.isVector2 ? new fe() : new Gt());
    return c.copy(o).sub(a).normalize(), c;
  }
  getTangentAt(t, e) {
    const i = this.getUtoTmapping(t);
    return this.getTangent(i, e);
  }
  computeFrenetFrames(t, e) {
    const i = new Gt(), r = [], s = [], a = [], o = new Gt(), c = new vn();
    for (let m = 0; m <= t; m++) {
      const v = m / t;
      r[m] = this.getTangentAt(v, new Gt());
    }
    s[0] = new Gt(), a[0] = new Gt();
    let h = Number.MAX_VALUE;
    const l = Math.abs(r[0].x), f = Math.abs(r[0].y), d = Math.abs(r[0].z);
    l <= h && (h = l, i.set(1, 0, 0)), f <= h && (h = f, i.set(0, 1, 0)), d <= h && i.set(0, 0, 1), o.crossVectors(r[0], i).normalize(), s[0].crossVectors(r[0], o), a[0].crossVectors(r[0], s[0]);
    for (let m = 1; m <= t; m++) {
      if (s[m] = s[m - 1].clone(), a[m] = a[m - 1].clone(), o.crossVectors(r[m - 1], r[m]), o.length() > Number.EPSILON) {
        o.normalize();
        const v = Math.acos(An(r[m - 1].dot(r[m]), -1, 1));
        s[m].applyMatrix4(c.makeRotationAxis(o, v));
      }
      a[m].crossVectors(r[m], s[m]);
    }
    if (e === !0) {
      let m = Math.acos(An(s[0].dot(s[t]), -1, 1));
      m /= t, r[0].dot(o.crossVectors(s[0], s[t])) > 0 && (m = -m);
      for (let v = 1; v <= t; v++)
        s[v].applyMatrix4(c.makeRotationAxis(r[v], m * v)), a[v].crossVectors(r[v], s[v]);
    }
    return {
      tangents: r,
      normals: s,
      binormals: a
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.arcLengthDivisions = t.arcLengthDivisions, this;
  }
  toJSON() {
    const t = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t;
  }
  fromJSON(t) {
    return this.arcLengthDivisions = t.arcLengthDivisions, this;
  }
}
class Ql extends zi {
  constructor(t = 0, e = 0, i = 1, r = 1, s = 0, a = Math.PI * 2, o = !1, c = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = i, this.yRadius = r, this.aStartAngle = s, this.aEndAngle = a, this.aClockwise = o, this.aRotation = c;
  }
  getPoint(t, e) {
    const i = e || new fe(), r = Math.PI * 2;
    let s = this.aEndAngle - this.aStartAngle;
    const a = Math.abs(s) < Number.EPSILON;
    for (; s < 0; )
      s += r;
    for (; s > r; )
      s -= r;
    s < Number.EPSILON && (a ? s = 0 : s = r), this.aClockwise === !0 && !a && (s === r ? s = -r : s = s - r);
    const o = this.aStartAngle + t * s;
    let c = this.aX + this.xRadius * Math.cos(o), h = this.aY + this.yRadius * Math.sin(o);
    if (this.aRotation !== 0) {
      const l = Math.cos(this.aRotation), f = Math.sin(this.aRotation), d = c - this.aX, m = h - this.aY;
      c = d * l - m * f + this.aX, h = d * f + m * l + this.aY;
    }
    return i.set(c, h);
  }
  copy(t) {
    return super.copy(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
  }
  toJSON() {
    const t = super.toJSON();
    return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t;
  }
  fromJSON(t) {
    return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
  }
}
class cw extends Ql {
  constructor(t, e, i, r, s, a) {
    super(t, e, i, i, r, s, a), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function tf() {
  let n = 0, t = 0, e = 0, i = 0;
  function r(s, a, o, c) {
    n = s, t = o, e = -3 * s + 3 * a - 2 * o - c, i = 2 * s - 2 * a + o + c;
  }
  return {
    initCatmullRom: function(s, a, o, c, h) {
      r(a, o, h * (o - s), h * (c - a));
    },
    initNonuniformCatmullRom: function(s, a, o, c, h, l, f) {
      let d = (a - s) / h - (o - s) / (h + l) + (o - a) / l, m = (o - a) / l - (c - a) / (l + f) + (c - o) / f;
      d *= l, m *= l, r(a, o, d, m);
    },
    calc: function(s) {
      const a = s * s, o = a * s;
      return n + t * s + e * a + i * o;
    }
  };
}
const Dc = /* @__PURE__ */ new Gt(), Qu = /* @__PURE__ */ new tf(), tl = /* @__PURE__ */ new tf(), el = /* @__PURE__ */ new tf();
class uw extends zi {
  constructor(t = [], e = !1, i = "centripetal", r = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = i, this.tension = r;
  }
  getPoint(t, e = new Gt()) {
    const i = e, r = this.points, s = r.length, a = (s - (this.closed ? 0 : 1)) * t;
    let o = Math.floor(a), c = a - o;
    this.closed ? o += o > 0 ? 0 : (Math.floor(Math.abs(o) / s) + 1) * s : c === 0 && o === s - 1 && (o = s - 2, c = 1);
    let h, l;
    this.closed || o > 0 ? h = r[(o - 1) % s] : (Dc.subVectors(r[0], r[1]).add(r[0]), h = Dc);
    const f = r[o % s], d = r[(o + 1) % s];
    if (this.closed || o + 2 < s ? l = r[(o + 2) % s] : (Dc.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), l = Dc), this.curveType === "centripetal" || this.curveType === "chordal") {
      const m = this.curveType === "chordal" ? 0.5 : 0.25;
      let v = Math.pow(h.distanceToSquared(f), m), E = Math.pow(f.distanceToSquared(d), m), _ = Math.pow(d.distanceToSquared(l), m);
      E < 1e-4 && (E = 1), v < 1e-4 && (v = E), _ < 1e-4 && (_ = E), Qu.initNonuniformCatmullRom(h.x, f.x, d.x, l.x, v, E, _), tl.initNonuniformCatmullRom(h.y, f.y, d.y, l.y, v, E, _), el.initNonuniformCatmullRom(h.z, f.z, d.z, l.z, v, E, _);
    } else
      this.curveType === "catmullrom" && (Qu.initCatmullRom(h.x, f.x, d.x, l.x, this.tension), tl.initCatmullRom(h.y, f.y, d.y, l.y, this.tension), el.initCatmullRom(h.z, f.z, d.z, l.z, this.tension));
    return i.set(
      Qu.calc(c),
      tl.calc(c),
      el.calc(c)
    ), i;
  }
  copy(t) {
    super.copy(t), this.points = [];
    for (let e = 0, i = t.points.length; e < i; e++) {
      const r = t.points[e];
      this.points.push(r.clone());
    }
    return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
  }
  toJSON() {
    const t = super.toJSON();
    t.points = [];
    for (let e = 0, i = this.points.length; e < i; e++) {
      const r = this.points[e];
      t.points.push(r.toArray());
    }
    return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t;
  }
  fromJSON(t) {
    super.fromJSON(t), this.points = [];
    for (let e = 0, i = t.points.length; e < i; e++) {
      const r = t.points[e];
      this.points.push(new Gt().fromArray(r));
    }
    return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
  }
}
function np(n, t, e, i, r) {
  const s = (i - t) * 0.5, a = (r - e) * 0.5, o = n * n, c = n * o;
  return (2 * e - 2 * i + s + a) * c + (-3 * e + 3 * i - 2 * s - a) * o + s * n + e;
}
function lw(n, t) {
  const e = 1 - n;
  return e * e * t;
}
function fw(n, t) {
  return 2 * (1 - n) * n * t;
}
function hw(n, t) {
  return n * n * t;
}
function Wa(n, t, e, i) {
  return lw(n, t) + fw(n, e) + hw(n, i);
}
function pw(n, t) {
  const e = 1 - n;
  return e * e * e * t;
}
function dw(n, t) {
  const e = 1 - n;
  return 3 * e * e * n * t;
}
function mw(n, t) {
  return 3 * (1 - n) * n * n * t;
}
function _w(n, t) {
  return n * n * n * t;
}
function qa(n, t, e, i, r) {
  return pw(n, t) + dw(n, e) + mw(n, i) + _w(n, r);
}
class jd extends zi {
  constructor(t = new fe(), e = new fe(), i = new fe(), r = new fe()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = i, this.v3 = r;
  }
  getPoint(t, e = new fe()) {
    const i = e, r = this.v0, s = this.v1, a = this.v2, o = this.v3;
    return i.set(
      qa(t, r.x, s.x, a.x, o.x),
      qa(t, r.y, s.y, a.y, o.y)
    ), i;
  }
  copy(t) {
    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
  }
  toJSON() {
    const t = super.toJSON();
    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
  }
  fromJSON(t) {
    return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
  }
}
class yw extends zi {
  constructor(t = new Gt(), e = new Gt(), i = new Gt(), r = new Gt()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = i, this.v3 = r;
  }
  getPoint(t, e = new Gt()) {
    const i = e, r = this.v0, s = this.v1, a = this.v2, o = this.v3;
    return i.set(
      qa(t, r.x, s.x, a.x, o.x),
      qa(t, r.y, s.y, a.y, o.y),
      qa(t, r.z, s.z, a.z, o.z)
    ), i;
  }
  copy(t) {
    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
  }
  toJSON() {
    const t = super.toJSON();
    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
  }
  fromJSON(t) {
    return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
  }
}
class Wd extends zi {
  constructor(t = new fe(), e = new fe()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = t, this.v2 = e;
  }
  getPoint(t, e = new fe()) {
    const i = e;
    return t === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(t, e) {
    return this.getPoint(t, e);
  }
  getTangent(t, e = new fe()) {
    return e.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(t, e) {
    return this.getTangent(t, e);
  }
  copy(t) {
    return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }
  toJSON() {
    const t = super.toJSON();
    return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
  }
  fromJSON(t) {
    return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }
}
class gw extends zi {
  constructor(t = new Gt(), e = new Gt()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = t, this.v2 = e;
  }
  getPoint(t, e = new Gt()) {
    const i = e;
    return t === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(t, e) {
    return this.getPoint(t, e);
  }
  getTangent(t, e = new Gt()) {
    return e.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(t, e) {
    return this.getTangent(t, e);
  }
  copy(t) {
    return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }
  toJSON() {
    const t = super.toJSON();
    return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
  }
  fromJSON(t) {
    return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }
}
class qd extends zi {
  constructor(t = new fe(), e = new fe(), i = new fe()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = i;
  }
  getPoint(t, e = new fe()) {
    const i = e, r = this.v0, s = this.v1, a = this.v2;
    return i.set(
      Wa(t, r.x, s.x, a.x),
      Wa(t, r.y, s.y, a.y)
    ), i;
  }
  copy(t) {
    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }
  toJSON() {
    const t = super.toJSON();
    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
  }
  fromJSON(t) {
    return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }
}
class vw extends zi {
  constructor(t = new Gt(), e = new Gt(), i = new Gt()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = i;
  }
  getPoint(t, e = new Gt()) {
    const i = e, r = this.v0, s = this.v1, a = this.v2;
    return i.set(
      Wa(t, r.x, s.x, a.x),
      Wa(t, r.y, s.y, a.y),
      Wa(t, r.z, s.z, a.z)
    ), i;
  }
  copy(t) {
    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }
  toJSON() {
    const t = super.toJSON();
    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
  }
  fromJSON(t) {
    return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
  }
}
class $d extends zi {
  constructor(t = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = t;
  }
  getPoint(t, e = new fe()) {
    const i = e, r = this.points, s = (r.length - 1) * t, a = Math.floor(s), o = s - a, c = r[a === 0 ? a : a - 1], h = r[a], l = r[a > r.length - 2 ? r.length - 1 : a + 1], f = r[a > r.length - 3 ? r.length - 1 : a + 2];
    return i.set(
      np(o, c.x, h.x, l.x, f.x),
      np(o, c.y, h.y, l.y, f.y)
    ), i;
  }
  copy(t) {
    super.copy(t), this.points = [];
    for (let e = 0, i = t.points.length; e < i; e++) {
      const r = t.points[e];
      this.points.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const t = super.toJSON();
    t.points = [];
    for (let e = 0, i = this.points.length; e < i; e++) {
      const r = this.points[e];
      t.points.push(r.toArray());
    }
    return t;
  }
  fromJSON(t) {
    super.fromJSON(t), this.points = [];
    for (let e = 0, i = t.points.length; e < i; e++) {
      const r = t.points[e];
      this.points.push(new fe().fromArray(r));
    }
    return this;
  }
}
var Cl = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: cw,
  CatmullRomCurve3: uw,
  CubicBezierCurve: jd,
  CubicBezierCurve3: yw,
  EllipseCurve: Ql,
  LineCurve: Wd,
  LineCurve3: gw,
  QuadraticBezierCurve: qd,
  QuadraticBezierCurve3: vw,
  SplineCurve: $d
});
class xw extends zi {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(t) {
    this.curves.push(t);
  }
  closePath() {
    const t = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1);
    if (!t.equals(e)) {
      const i = t.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new Cl[i](e, t));
    }
    return this;
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(t, e) {
    const i = t * this.getLength(), r = this.getCurveLengths();
    let s = 0;
    for (; s < r.length; ) {
      if (r[s] >= i) {
        const a = r[s] - i, o = this.curves[s], c = o.getLength(), h = c === 0 ? 0 : 1 - a / c;
        return o.getPointAt(h, e);
      }
      s++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const t = this.getCurveLengths();
    return t[t.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const t = [];
    let e = 0;
    for (let i = 0, r = this.curves.length; i < r; i++)
      e += this.curves[i].getLength(), t.push(e);
    return this.cacheLengths = t, t;
  }
  getSpacedPoints(t = 40) {
    const e = [];
    for (let i = 0; i <= t; i++)
      e.push(this.getPoint(i / t));
    return this.autoClose && e.push(e[0]), e;
  }
  getPoints(t = 12) {
    const e = [];
    let i;
    for (let r = 0, s = this.curves; r < s.length; r++) {
      const a = s[r], o = a.isEllipseCurve ? t * 2 : a.isLineCurve || a.isLineCurve3 ? 1 : a.isSplineCurve ? t * a.points.length : t, c = a.getPoints(o);
      for (let h = 0; h < c.length; h++) {
        const l = c[h];
        i && i.equals(l) || (e.push(l), i = l);
      }
    }
    return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e;
  }
  copy(t) {
    super.copy(t), this.curves = [];
    for (let e = 0, i = t.curves.length; e < i; e++) {
      const r = t.curves[e];
      this.curves.push(r.clone());
    }
    return this.autoClose = t.autoClose, this;
  }
  toJSON() {
    const t = super.toJSON();
    t.autoClose = this.autoClose, t.curves = [];
    for (let e = 0, i = this.curves.length; e < i; e++) {
      const r = this.curves[e];
      t.curves.push(r.toJSON());
    }
    return t;
  }
  fromJSON(t) {
    super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
    for (let e = 0, i = t.curves.length; e < i; e++) {
      const r = t.curves[e];
      this.curves.push(new Cl[r.type]().fromJSON(r));
    }
    return this;
  }
}
class Rl extends xw {
  constructor(t) {
    super(), this.type = "Path", this.currentPoint = new fe(), t && this.setFromPoints(t);
  }
  setFromPoints(t) {
    this.moveTo(t[0].x, t[0].y);
    for (let e = 1, i = t.length; e < i; e++)
      this.lineTo(t[e].x, t[e].y);
    return this;
  }
  moveTo(t, e) {
    return this.currentPoint.set(t, e), this;
  }
  lineTo(t, e) {
    const i = new Wd(this.currentPoint.clone(), new fe(t, e));
    return this.curves.push(i), this.currentPoint.set(t, e), this;
  }
  quadraticCurveTo(t, e, i, r) {
    const s = new qd(
      this.currentPoint.clone(),
      new fe(t, e),
      new fe(i, r)
    );
    return this.curves.push(s), this.currentPoint.set(i, r), this;
  }
  bezierCurveTo(t, e, i, r, s, a) {
    const o = new jd(
      this.currentPoint.clone(),
      new fe(t, e),
      new fe(i, r),
      new fe(s, a)
    );
    return this.curves.push(o), this.currentPoint.set(s, a), this;
  }
  splineThru(t) {
    const e = [this.currentPoint.clone()].concat(t), i = new $d(e);
    return this.curves.push(i), this.currentPoint.copy(t[t.length - 1]), this;
  }
  arc(t, e, i, r, s, a) {
    const o = this.currentPoint.x, c = this.currentPoint.y;
    return this.absarc(
      t + o,
      e + c,
      i,
      r,
      s,
      a
    ), this;
  }
  absarc(t, e, i, r, s, a) {
    return this.absellipse(t, e, i, i, r, s, a), this;
  }
  ellipse(t, e, i, r, s, a, o, c) {
    const h = this.currentPoint.x, l = this.currentPoint.y;
    return this.absellipse(t + h, e + l, i, r, s, a, o, c), this;
  }
  absellipse(t, e, i, r, s, a, o, c) {
    const h = new Ql(t, e, i, r, s, a, o, c);
    if (this.curves.length > 0) {
      const f = h.getPoint(0);
      f.equals(this.currentPoint) || this.lineTo(f.x, f.y);
    }
    this.curves.push(h);
    const l = h.getPoint(1);
    return this.currentPoint.copy(l), this;
  }
  copy(t) {
    return super.copy(t), this.currentPoint.copy(t.currentPoint), this;
  }
  toJSON() {
    const t = super.toJSON();
    return t.currentPoint = this.currentPoint.toArray(), t;
  }
  fromJSON(t) {
    return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this;
  }
}
class Xd extends Rl {
  constructor(t) {
    super(t), this.uuid = Ps(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(t) {
    const e = [];
    for (let i = 0, r = this.holes.length; i < r; i++)
      e[i] = this.holes[i].getPoints(t);
    return e;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(t) {
    return {
      shape: this.getPoints(t),
      holes: this.getPointsHoles(t)
    };
  }
  copy(t) {
    super.copy(t), this.holes = [];
    for (let e = 0, i = t.holes.length; e < i; e++) {
      const r = t.holes[e];
      this.holes.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const t = super.toJSON();
    t.uuid = this.uuid, t.holes = [];
    for (let e = 0, i = this.holes.length; e < i; e++) {
      const r = this.holes[e];
      t.holes.push(r.toJSON());
    }
    return t;
  }
  fromJSON(t) {
    super.fromJSON(t), this.uuid = t.uuid, this.holes = [];
    for (let e = 0, i = t.holes.length; e < i; e++) {
      const r = t.holes[e];
      this.holes.push(new Rl().fromJSON(r));
    }
    return this;
  }
}
const bw = {
  triangulate: function(n, t, e = 2) {
    const i = t && t.length, r = i ? t[0] * e : n.length;
    let s = Yd(n, 0, r, e, !0);
    const a = [];
    if (!s || s.next === s.prev)
      return a;
    let o, c, h, l, f, d, m;
    if (i && (s = Aw(n, t, s, e)), n.length > 80 * e) {
      o = h = n[0], c = l = n[1];
      for (let v = e; v < r; v += e)
        f = n[v], d = n[v + 1], f < o && (o = f), d < c && (c = d), f > h && (h = f), d > l && (l = d);
      m = Math.max(h - o, l - c), m = m !== 0 ? 32767 / m : 0;
    }
    return Qa(s, a, e, o, c, m, 0), a;
  }
};
function Yd(n, t, e, i, r) {
  let s, a;
  if (r === Uw(n, t, e, i) > 0)
    for (s = t; s < e; s += i)
      a = ip(s, n[s], n[s + 1], a);
  else
    for (s = e - i; s >= t; s -= i)
      a = ip(s, n[s], n[s + 1], a);
  return a && mu(a, a.next) && (eo(a), a = a.next), a;
}
function Rs(n, t) {
  if (!n)
    return n;
  t || (t = n);
  let e = n, i;
  do
    if (i = !1, !e.steiner && (mu(e, e.next) || ln(e.prev, e, e.next) === 0)) {
      if (eo(e), e = t = e.prev, e === e.next)
        break;
      i = !0;
    } else
      e = e.next;
  while (i || e !== t);
  return t;
}
function Qa(n, t, e, i, r, s, a) {
  if (!n)
    return;
  !a && s && Pw(n, i, r, s);
  let o = n, c, h;
  for (; n.prev !== n.next; ) {
    if (c = n.prev, h = n.next, s ? ww(n, i, r, s) : Ew(n)) {
      t.push(c.i / e | 0), t.push(n.i / e | 0), t.push(h.i / e | 0), eo(n), n = h.next, o = h.next;
      continue;
    }
    if (n = h, n === o) {
      a ? a === 1 ? (n = Mw(Rs(n), t, e), Qa(n, t, e, i, r, s, 2)) : a === 2 && Sw(n, t, e, i, r, s) : Qa(Rs(n), t, e, i, r, s, 1);
      break;
    }
  }
}
function Ew(n) {
  const t = n.prev, e = n, i = n.next;
  if (ln(t, e, i) >= 0)
    return !1;
  const r = t.x, s = e.x, a = i.x, o = t.y, c = e.y, h = i.y, l = r < s ? r < a ? r : a : s < a ? s : a, f = o < c ? o < h ? o : h : c < h ? c : h, d = r > s ? r > a ? r : a : s > a ? s : a, m = o > c ? o > h ? o : h : c > h ? c : h;
  let v = i.next;
  for (; v !== t; ) {
    if (v.x >= l && v.x <= d && v.y >= f && v.y <= m && ua(r, o, s, c, a, h, v.x, v.y) && ln(v.prev, v, v.next) >= 0)
      return !1;
    v = v.next;
  }
  return !0;
}
function ww(n, t, e, i) {
  const r = n.prev, s = n, a = n.next;
  if (ln(r, s, a) >= 0)
    return !1;
  const o = r.x, c = s.x, h = a.x, l = r.y, f = s.y, d = a.y, m = o < c ? o < h ? o : h : c < h ? c : h, v = l < f ? l < d ? l : d : f < d ? f : d, E = o > c ? o > h ? o : h : c > h ? c : h, _ = l > f ? l > d ? l : d : f > d ? f : d, p = Il(m, v, t, e, i), R = Il(E, _, t, e, i);
  let M = n.prevZ, P = n.nextZ;
  for (; M && M.z >= p && P && P.z <= R; ) {
    if (M.x >= m && M.x <= E && M.y >= v && M.y <= _ && M !== r && M !== a && ua(o, l, c, f, h, d, M.x, M.y) && ln(M.prev, M, M.next) >= 0 || (M = M.prevZ, P.x >= m && P.x <= E && P.y >= v && P.y <= _ && P !== r && P !== a && ua(o, l, c, f, h, d, P.x, P.y) && ln(P.prev, P, P.next) >= 0))
      return !1;
    P = P.nextZ;
  }
  for (; M && M.z >= p; ) {
    if (M.x >= m && M.x <= E && M.y >= v && M.y <= _ && M !== r && M !== a && ua(o, l, c, f, h, d, M.x, M.y) && ln(M.prev, M, M.next) >= 0)
      return !1;
    M = M.prevZ;
  }
  for (; P && P.z <= R; ) {
    if (P.x >= m && P.x <= E && P.y >= v && P.y <= _ && P !== r && P !== a && ua(o, l, c, f, h, d, P.x, P.y) && ln(P.prev, P, P.next) >= 0)
      return !1;
    P = P.nextZ;
  }
  return !0;
}
function Mw(n, t, e) {
  let i = n;
  do {
    const r = i.prev, s = i.next.next;
    !mu(r, s) && Kd(r, i, i.next, s) && to(r, s) && to(s, r) && (t.push(r.i / e | 0), t.push(i.i / e | 0), t.push(s.i / e | 0), eo(i), eo(i.next), i = n = s), i = i.next;
  } while (i !== n);
  return Rs(i);
}
function Sw(n, t, e, i, r, s) {
  let a = n;
  do {
    let o = a.next.next;
    for (; o !== a.prev; ) {
      if (a.i !== o.i && Dw(a, o)) {
        let c = Zd(a, o);
        a = Rs(a, a.next), c = Rs(c, c.next), Qa(a, t, e, i, r, s, 0), Qa(c, t, e, i, r, s, 0);
        return;
      }
      o = o.next;
    }
    a = a.next;
  } while (a !== n);
}
function Aw(n, t, e, i) {
  const r = [];
  let s, a, o, c, h;
  for (s = 0, a = t.length; s < a; s++)
    o = t[s] * i, c = s < a - 1 ? t[s + 1] * i : n.length, h = Yd(n, o, c, i, !1), h === h.next && (h.steiner = !0), r.push(Ow(h));
  for (r.sort(Tw), s = 0; s < r.length; s++)
    e = Cw(r[s], e);
  return e;
}
function Tw(n, t) {
  return n.x - t.x;
}
function Cw(n, t) {
  const e = Rw(n, t);
  if (!e)
    return t;
  const i = Zd(e, n);
  return Rs(i, i.next), Rs(e, e.next);
}
function Rw(n, t) {
  let e = t, i = -1 / 0, r;
  const s = n.x, a = n.y;
  do {
    if (a <= e.y && a >= e.next.y && e.next.y !== e.y) {
      const d = e.x + (a - e.y) * (e.next.x - e.x) / (e.next.y - e.y);
      if (d <= s && d > i && (i = d, r = e.x < e.next.x ? e : e.next, d === s))
        return r;
    }
    e = e.next;
  } while (e !== t);
  if (!r)
    return null;
  const o = r, c = r.x, h = r.y;
  let l = 1 / 0, f;
  e = r;
  do
    s >= e.x && e.x >= c && s !== e.x && ua(a < h ? s : i, a, c, h, a < h ? i : s, a, e.x, e.y) && (f = Math.abs(a - e.y) / (s - e.x), to(e, n) && (f < l || f === l && (e.x > r.x || e.x === r.x && Iw(r, e))) && (r = e, l = f)), e = e.next;
  while (e !== o);
  return r;
}
function Iw(n, t) {
  return ln(n.prev, n, t.prev) < 0 && ln(t.next, n, n.next) < 0;
}
function Pw(n, t, e, i) {
  let r = n;
  do
    r.z === 0 && (r.z = Il(r.x, r.y, t, e, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;
  while (r !== n);
  r.prevZ.nextZ = null, r.prevZ = null, Lw(r);
}
function Lw(n) {
  let t, e, i, r, s, a, o, c, h = 1;
  do {
    for (e = n, n = null, s = null, a = 0; e; ) {
      for (a++, i = e, o = 0, t = 0; t < h && (o++, i = i.nextZ, !!i); t++)
        ;
      for (c = h; o > 0 || c > 0 && i; )
        o !== 0 && (c === 0 || !i || e.z <= i.z) ? (r = e, e = e.nextZ, o--) : (r = i, i = i.nextZ, c--), s ? s.nextZ = r : n = r, r.prevZ = s, s = r;
      e = i;
    }
    s.nextZ = null, h *= 2;
  } while (a > 1);
  return n;
}
function Il(n, t, e, i, r) {
  return n = (n - e) * r | 0, t = (t - i) * r | 0, n = (n | n << 8) & 16711935, n = (n | n << 4) & 252645135, n = (n | n << 2) & 858993459, n = (n | n << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, n | t << 1;
}
function Ow(n) {
  let t = n, e = n;
  do
    (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next;
  while (t !== n);
  return e;
}
function ua(n, t, e, i, r, s, a, o) {
  return (r - a) * (t - o) >= (n - a) * (s - o) && (n - a) * (i - o) >= (e - a) * (t - o) && (e - a) * (s - o) >= (r - a) * (i - o);
}
function Dw(n, t) {
  return n.next.i !== t.i && n.prev.i !== t.i && !Nw(n, t) && // dones't intersect other edges
  (to(n, t) && to(t, n) && Fw(n, t) && // locally visible
  (ln(n.prev, n, t.prev) || ln(n, t.prev, t)) || // does not create opposite-facing sectors
  mu(n, t) && ln(n.prev, n, n.next) > 0 && ln(t.prev, t, t.next) > 0);
}
function ln(n, t, e) {
  return (t.y - n.y) * (e.x - t.x) - (t.x - n.x) * (e.y - t.y);
}
function mu(n, t) {
  return n.x === t.x && n.y === t.y;
}
function Kd(n, t, e, i) {
  const r = Fc(ln(n, t, e)), s = Fc(ln(n, t, i)), a = Fc(ln(e, i, n)), o = Fc(ln(e, i, t));
  return !!(r !== s && a !== o || r === 0 && Nc(n, e, t) || s === 0 && Nc(n, i, t) || a === 0 && Nc(e, n, i) || o === 0 && Nc(e, t, i));
}
function Nc(n, t, e) {
  return t.x <= Math.max(n.x, e.x) && t.x >= Math.min(n.x, e.x) && t.y <= Math.max(n.y, e.y) && t.y >= Math.min(n.y, e.y);
}
function Fc(n) {
  return n > 0 ? 1 : n < 0 ? -1 : 0;
}
function Nw(n, t) {
  let e = n;
  do {
    if (e.i !== n.i && e.next.i !== n.i && e.i !== t.i && e.next.i !== t.i && Kd(e, e.next, n, t))
      return !0;
    e = e.next;
  } while (e !== n);
  return !1;
}
function to(n, t) {
  return ln(n.prev, n, n.next) < 0 ? ln(n, t, n.next) >= 0 && ln(n, n.prev, t) >= 0 : ln(n, t, n.prev) < 0 || ln(n, n.next, t) < 0;
}
function Fw(n, t) {
  let e = n, i = !1;
  const r = (n.x + t.x) / 2, s = (n.y + t.y) / 2;
  do
    e.y > s != e.next.y > s && e.next.y !== e.y && r < (e.next.x - e.x) * (s - e.y) / (e.next.y - e.y) + e.x && (i = !i), e = e.next;
  while (e !== n);
  return i;
}
function Zd(n, t) {
  const e = new Pl(n.i, n.x, n.y), i = new Pl(t.i, t.x, t.y), r = n.next, s = t.prev;
  return n.next = t, t.prev = n, e.next = r, r.prev = e, i.next = e, e.prev = i, s.next = i, i.prev = s, i;
}
function ip(n, t, e, i) {
  const r = new Pl(n, t, e);
  return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r;
}
function eo(n) {
  n.next.prev = n.prev, n.prev.next = n.next, n.prevZ && (n.prevZ.nextZ = n.nextZ), n.nextZ && (n.nextZ.prevZ = n.prevZ);
}
function Pl(n, t, e) {
  this.i = n, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function Uw(n, t, e, i) {
  let r = 0;
  for (let s = t, a = e - i; s < e; s += i)
    r += (n[a] - n[s]) * (n[s + 1] + n[a + 1]), a = s;
  return r;
}
class $a {
  // calculate area of the contour polygon
  static area(t) {
    const e = t.length;
    let i = 0;
    for (let r = e - 1, s = 0; s < e; r = s++)
      i += t[r].x * t[s].y - t[s].x * t[r].y;
    return i * 0.5;
  }
  static isClockWise(t) {
    return $a.area(t) < 0;
  }
  static triangulateShape(t, e) {
    const i = [], r = [], s = [];
    rp(t), sp(i, t);
    let a = t.length;
    e.forEach(rp);
    for (let c = 0; c < e.length; c++)
      r.push(a), a += e[c].length, sp(i, e[c]);
    const o = bw.triangulate(i, r);
    for (let c = 0; c < o.length; c += 3)
      s.push(o.slice(c, c + 3));
    return s;
  }
}
function rp(n) {
  const t = n.length;
  t > 2 && n[t - 1].equals(n[0]) && n.pop();
}
function sp(n, t) {
  for (let e = 0; e < t.length; e++)
    n.push(t[e].x), n.push(t[e].y);
}
class ef extends fr {
  constructor(t = new Xd([new fe(0.5, 0.5), new fe(-0.5, 0.5), new fe(-0.5, -0.5), new fe(0.5, -0.5)]), e = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: t,
      options: e
    }, t = Array.isArray(t) ? t : [t];
    const i = this, r = [], s = [];
    for (let o = 0, c = t.length; o < c; o++) {
      const h = t[o];
      a(h);
    }
    this.setAttribute("position", new ur(r, 3)), this.setAttribute("uv", new ur(s, 2)), this.computeVertexNormals();
    function a(o) {
      const c = [], h = e.curveSegments !== void 0 ? e.curveSegments : 12, l = e.steps !== void 0 ? e.steps : 1, f = e.depth !== void 0 ? e.depth : 1;
      let d = e.bevelEnabled !== void 0 ? e.bevelEnabled : !0, m = e.bevelThickness !== void 0 ? e.bevelThickness : 0.2, v = e.bevelSize !== void 0 ? e.bevelSize : m - 0.1, E = e.bevelOffset !== void 0 ? e.bevelOffset : 0, _ = e.bevelSegments !== void 0 ? e.bevelSegments : 3;
      const p = e.extrudePath, R = e.UVGenerator !== void 0 ? e.UVGenerator : Bw;
      let M, P = !1, W, C, D, N;
      p && (M = p.getSpacedPoints(l), P = !0, d = !1, W = p.computeFrenetFrames(l, !1), C = new Gt(), D = new Gt(), N = new Gt()), d || (_ = 0, m = 0, v = 0, E = 0);
      const A = o.extractPoints(h);
      let I = A.shape;
      const it = A.holes;
      if (!$a.isClockWise(I)) {
        I = I.reverse();
        for (let K = 0, yt = it.length; K < yt; K++) {
          const Et = it[K];
          $a.isClockWise(Et) && (it[K] = Et.reverse());
        }
      }
      const mt = $a.triangulateShape(I, it), k = I;
      for (let K = 0, yt = it.length; K < yt; K++) {
        const Et = it[K];
        I = I.concat(Et);
      }
      function B(K, yt, Et) {
        return yt || console.error("THREE.ExtrudeGeometry: vec does not exist"), K.clone().addScaledVector(yt, Et);
      }
      const G = I.length, H = mt.length;
      function w(K, yt, Et) {
        let Ct, Lt, Wt;
        const wt = K.x - yt.x, Q = K.y - yt.y, y = Et.x - K.x, g = Et.y - K.y, S = wt * wt + Q * Q, O = wt * g - Q * y;
        if (Math.abs(O) > Number.EPSILON) {
          const Z = Math.sqrt(S), tt = Math.sqrt(y * y + g * g), gt = yt.x - Q / Z, st = yt.y + wt / Z, Tt = Et.x - g / tt, Ft = Et.y + y / tt, ht = ((Tt - gt) * g - (Ft - st) * y) / (wt * g - Q * y);
          Ct = gt + wt * ht - K.x, Lt = st + Q * ht - K.y;
          const It = Ct * Ct + Lt * Lt;
          if (It <= 2)
            return new fe(Ct, Lt);
          Wt = Math.sqrt(It / 2);
        } else {
          let Z = !1;
          wt > Number.EPSILON ? y > Number.EPSILON && (Z = !0) : wt < -Number.EPSILON ? y < -Number.EPSILON && (Z = !0) : Math.sign(Q) === Math.sign(g) && (Z = !0), Z ? (Ct = -Q, Lt = wt, Wt = Math.sqrt(S)) : (Ct = wt, Lt = Q, Wt = Math.sqrt(S / 2));
        }
        return new fe(Ct / Wt, Lt / Wt);
      }
      const ut = [];
      for (let K = 0, yt = k.length, Et = yt - 1, Ct = K + 1; K < yt; K++, Et++, Ct++)
        Et === yt && (Et = 0), Ct === yt && (Ct = 0), ut[K] = w(k[K], k[Et], k[Ct]);
      const pt = [];
      let _t, vt = ut.concat();
      for (let K = 0, yt = it.length; K < yt; K++) {
        const Et = it[K];
        _t = [];
        for (let Ct = 0, Lt = Et.length, Wt = Lt - 1, wt = Ct + 1; Ct < Lt; Ct++, Wt++, wt++)
          Wt === Lt && (Wt = 0), wt === Lt && (wt = 0), _t[Ct] = w(Et[Ct], Et[Wt], Et[wt]);
        pt.push(_t), vt = vt.concat(_t);
      }
      for (let K = 0; K < _; K++) {
        const yt = K / _, Et = m * Math.cos(yt * Math.PI / 2), Ct = v * Math.sin(yt * Math.PI / 2) + E;
        for (let Lt = 0, Wt = k.length; Lt < Wt; Lt++) {
          const wt = B(k[Lt], ut[Lt], Ct);
          q(wt.x, wt.y, -Et);
        }
        for (let Lt = 0, Wt = it.length; Lt < Wt; Lt++) {
          const wt = it[Lt];
          _t = pt[Lt];
          for (let Q = 0, y = wt.length; Q < y; Q++) {
            const g = B(wt[Q], _t[Q], Ct);
            q(g.x, g.y, -Et);
          }
        }
      }
      const F = v + E;
      for (let K = 0; K < G; K++) {
        const yt = d ? B(I[K], vt[K], F) : I[K];
        P ? (D.copy(W.normals[0]).multiplyScalar(yt.x), C.copy(W.binormals[0]).multiplyScalar(yt.y), N.copy(M[0]).add(D).add(C), q(N.x, N.y, N.z)) : q(yt.x, yt.y, 0);
      }
      for (let K = 1; K <= l; K++)
        for (let yt = 0; yt < G; yt++) {
          const Et = d ? B(I[yt], vt[yt], F) : I[yt];
          P ? (D.copy(W.normals[K]).multiplyScalar(Et.x), C.copy(W.binormals[K]).multiplyScalar(Et.y), N.copy(M[K]).add(D).add(C), q(N.x, N.y, N.z)) : q(Et.x, Et.y, f / l * K);
        }
      for (let K = _ - 1; K >= 0; K--) {
        const yt = K / _, Et = m * Math.cos(yt * Math.PI / 2), Ct = v * Math.sin(yt * Math.PI / 2) + E;
        for (let Lt = 0, Wt = k.length; Lt < Wt; Lt++) {
          const wt = B(k[Lt], ut[Lt], Ct);
          q(wt.x, wt.y, f + Et);
        }
        for (let Lt = 0, Wt = it.length; Lt < Wt; Lt++) {
          const wt = it[Lt];
          _t = pt[Lt];
          for (let Q = 0, y = wt.length; Q < y; Q++) {
            const g = B(wt[Q], _t[Q], Ct);
            P ? q(g.x, g.y + M[l - 1].y, M[l - 1].x + Et) : q(g.x, g.y, f + Et);
          }
        }
      }
      rt(), b();
      function rt() {
        const K = r.length / 3;
        if (d) {
          let yt = 0, Et = G * yt;
          for (let Ct = 0; Ct < H; Ct++) {
            const Lt = mt[Ct];
            U(Lt[2] + Et, Lt[1] + Et, Lt[0] + Et);
          }
          yt = l + _ * 2, Et = G * yt;
          for (let Ct = 0; Ct < H; Ct++) {
            const Lt = mt[Ct];
            U(Lt[0] + Et, Lt[1] + Et, Lt[2] + Et);
          }
        } else {
          for (let yt = 0; yt < H; yt++) {
            const Et = mt[yt];
            U(Et[2], Et[1], Et[0]);
          }
          for (let yt = 0; yt < H; yt++) {
            const Et = mt[yt];
            U(Et[0] + G * l, Et[1] + G * l, Et[2] + G * l);
          }
        }
        i.addGroup(K, r.length / 3 - K, 0);
      }
      function b() {
        const K = r.length / 3;
        let yt = 0;
        lt(k, yt), yt += k.length;
        for (let Et = 0, Ct = it.length; Et < Ct; Et++) {
          const Lt = it[Et];
          lt(Lt, yt), yt += Lt.length;
        }
        i.addGroup(K, r.length / 3 - K, 1);
      }
      function lt(K, yt) {
        let Et = K.length;
        for (; --Et >= 0; ) {
          const Ct = Et;
          let Lt = Et - 1;
          Lt < 0 && (Lt = K.length - 1);
          for (let Wt = 0, wt = l + _ * 2; Wt < wt; Wt++) {
            const Q = G * Wt, y = G * (Wt + 1), g = yt + Ct + Q, S = yt + Lt + Q, O = yt + Lt + y, Z = yt + Ct + y;
            L(g, S, O, Z);
          }
        }
      }
      function q(K, yt, Et) {
        c.push(K), c.push(yt), c.push(Et);
      }
      function U(K, yt, Et) {
        j(K), j(yt), j(Et);
        const Ct = r.length / 3, Lt = R.generateTopUV(i, r, Ct - 3, Ct - 2, Ct - 1);
        Y(Lt[0]), Y(Lt[1]), Y(Lt[2]);
      }
      function L(K, yt, Et, Ct) {
        j(K), j(yt), j(Ct), j(yt), j(Et), j(Ct);
        const Lt = r.length / 3, Wt = R.generateSideWallUV(i, r, Lt - 6, Lt - 3, Lt - 2, Lt - 1);
        Y(Wt[0]), Y(Wt[1]), Y(Wt[3]), Y(Wt[1]), Y(Wt[2]), Y(Wt[3]);
      }
      function j(K) {
        r.push(c[K * 3 + 0]), r.push(c[K * 3 + 1]), r.push(c[K * 3 + 2]);
      }
      function Y(K) {
        s.push(K.x), s.push(K.y);
      }
    }
  }
  copy(t) {
    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
  }
  toJSON() {
    const t = super.toJSON(), e = this.parameters.shapes, i = this.parameters.options;
    return kw(e, i, t);
  }
  static fromJSON(t, e) {
    const i = [];
    for (let s = 0, a = t.shapes.length; s < a; s++) {
      const o = e[t.shapes[s]];
      i.push(o);
    }
    const r = t.options.extrudePath;
    return r !== void 0 && (t.options.extrudePath = new Cl[r.type]().fromJSON(r)), new ef(i, t.options);
  }
}
const Bw = {
  generateTopUV: function(n, t, e, i, r) {
    const s = t[e * 3], a = t[e * 3 + 1], o = t[i * 3], c = t[i * 3 + 1], h = t[r * 3], l = t[r * 3 + 1];
    return [
      new fe(s, a),
      new fe(o, c),
      new fe(h, l)
    ];
  },
  generateSideWallUV: function(n, t, e, i, r, s) {
    const a = t[e * 3], o = t[e * 3 + 1], c = t[e * 3 + 2], h = t[i * 3], l = t[i * 3 + 1], f = t[i * 3 + 2], d = t[r * 3], m = t[r * 3 + 1], v = t[r * 3 + 2], E = t[s * 3], _ = t[s * 3 + 1], p = t[s * 3 + 2];
    return Math.abs(o - l) < Math.abs(a - h) ? [
      new fe(a, 1 - c),
      new fe(h, 1 - f),
      new fe(d, 1 - v),
      new fe(E, 1 - p)
    ] : [
      new fe(o, 1 - c),
      new fe(l, 1 - f),
      new fe(m, 1 - v),
      new fe(_, 1 - p)
    ];
  }
};
function kw(n, t, e) {
  if (e.shapes = [], Array.isArray(n))
    for (let i = 0, r = n.length; i < r; i++) {
      const s = n[i];
      e.shapes.push(s.uuid);
    }
  else
    e.shapes.push(n.uuid);
  return e.options = Object.assign({}, t), t.extrudePath !== void 0 && (e.options.extrudePath = t.extrudePath.toJSON()), e;
}
class zw extends co {
  constructor(t) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Ue(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ue(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ed, this.normalScale = new fe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.defines = { STANDARD: "" }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this;
  }
}
class Gw extends zw {
  constructor(t) {
    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new fe(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get: function() {
        return An(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(e) {
        this.ior = (1 + 0.4 * e) / (1 - 0.4 * e);
      }
    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Ue(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Ue(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Ue(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(t);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(t) {
    this._anisotropy > 0 != t > 0 && this.version++, this._anisotropy = t;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(t) {
    this._clearcoat > 0 != t > 0 && this.version++, this._clearcoat = t;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(t) {
    this._iridescence > 0 != t > 0 && this.version++, this._iridescence = t;
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(t) {
    this._sheen > 0 != t > 0 && this.version++, this._sheen = t;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(t) {
    this._transmission > 0 != t > 0 && this.version++, this._transmission = t;
  }
  copy(t) {
    return super.copy(t), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.anisotropy = t.anisotropy, this.anisotropyRotation = t.anisotropyRotation, this.anisotropyMap = t.anisotropyMap, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.ior = t.ior, this.iridescence = t.iridescence, this.iridescenceMap = t.iridescenceMap, this.iridescenceIOR = t.iridescenceIOR, this.iridescenceThicknessRange = [...t.iridescenceThicknessRange], this.iridescenceThicknessMap = t.iridescenceThicknessMap, this.sheen = t.sheen, this.sheenColor.copy(t.sheenColor), this.sheenColorMap = t.sheenColorMap, this.sheenRoughness = t.sheenRoughness, this.sheenRoughnessMap = t.sheenRoughnessMap, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this;
  }
}
const nf = "\\[\\]\\.:\\/", Vw = new RegExp("[" + nf + "]", "g"), rf = "[^" + nf + "]", Hw = "[^" + nf.replace("\\.", "") + "]", jw = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", rf), Ww = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", Hw), qw = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", rf), $w = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", rf), Xw = new RegExp(
  "^" + jw + Ww + qw + $w + "$"
), Yw = ["material", "materials", "bones", "map"];
class Kw {
  constructor(t, e, i) {
    const r = i || Ge.parseTrackName(e);
    this._targetGroup = t, this._bindings = t.subscribe_(e, r);
  }
  getValue(t, e) {
    this.bind();
    const i = this._targetGroup.nCachedObjects_, r = this._bindings[i];
    r !== void 0 && r.getValue(t, e);
  }
  setValue(t, e) {
    const i = this._bindings;
    for (let r = this._targetGroup.nCachedObjects_, s = i.length; r !== s; ++r)
      i[r].setValue(t, e);
  }
  bind() {
    const t = this._bindings;
    for (let e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e)
      t[e].bind();
  }
  unbind() {
    const t = this._bindings;
    for (let e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e)
      t[e].unbind();
  }
}
class Ge {
  constructor(t, e, i) {
    this.path = e, this.parsedPath = i || Ge.parseTrackName(e), this.node = Ge.findNode(t, this.parsedPath.nodeName), this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(t, e, i) {
    return t && t.isAnimationObjectGroup ? new Ge.Composite(t, e, i) : new Ge(t, e, i);
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  static sanitizeNodeName(t) {
    return t.replace(/\s/g, "_").replace(Vw, "");
  }
  static parseTrackName(t) {
    const e = Xw.exec(t);
    if (e === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + t);
    const i = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: e[2],
      objectName: e[3],
      objectIndex: e[4],
      propertyName: e[5],
      // required
      propertyIndex: e[6]
    }, r = i.nodeName && i.nodeName.lastIndexOf(".");
    if (r !== void 0 && r !== -1) {
      const s = i.nodeName.substring(r + 1);
      Yw.indexOf(s) !== -1 && (i.nodeName = i.nodeName.substring(0, r), i.objectName = s);
    }
    if (i.propertyName === null || i.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
    return i;
  }
  static findNode(t, e) {
    if (e === void 0 || e === "" || e === "." || e === -1 || e === t.name || e === t.uuid)
      return t;
    if (t.skeleton) {
      const i = t.skeleton.getBoneByName(e);
      if (i !== void 0)
        return i;
    }
    if (t.children) {
      const i = function(s) {
        for (let a = 0; a < s.length; a++) {
          const o = s[a];
          if (o.name === e || o.uuid === e)
            return o;
          const c = i(o.children);
          if (c)
            return c;
        }
        return null;
      }, r = i(t.children);
      if (r)
        return r;
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(t, e) {
    t[e] = this.targetObject[this.propertyName];
  }
  _getValue_array(t, e) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r)
      t[e++] = i[r];
  }
  _getValue_arrayElement(t, e) {
    t[e] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(t, e) {
    this.resolvedProperty.toArray(t, e);
  }
  // Direct
  _setValue_direct(t, e) {
    this.targetObject[this.propertyName] = t[e];
  }
  _setValue_direct_setNeedsUpdate(t, e) {
    this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
    this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // EntireArray
  _setValue_array(t, e) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r)
      i[r] = t[e++];
  }
  _setValue_array_setNeedsUpdate(t, e) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r)
      i[r] = t[e++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r)
      i[r] = t[e++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // ArrayElement
  _setValue_arrayElement(t, e) {
    this.resolvedProperty[this.propertyIndex] = t[e];
  }
  _setValue_arrayElement_setNeedsUpdate(t, e) {
    this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
    this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // HasToFromArray
  _setValue_fromArray(t, e) {
    this.resolvedProperty.fromArray(t, e);
  }
  _setValue_fromArray_setNeedsUpdate(t, e) {
    this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
    this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _getValue_unbound(t, e) {
    this.bind(), this.getValue(t, e);
  }
  _setValue_unbound(t, e) {
    this.bind(), this.setValue(t, e);
  }
  // create getter / setter pair for a property in the scene graph
  bind() {
    let t = this.node;
    const e = this.parsedPath, i = e.objectName, r = e.propertyName;
    let s = e.propertyIndex;
    if (t || (t = Ge.findNode(this.rootNode, e.nodeName), this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) {
      console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
      return;
    }
    if (i) {
      let h = e.objectIndex;
      switch (i) {
        case "materials":
          if (!t.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!t.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          t = t.material.materials;
          break;
        case "bones":
          if (!t.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          t = t.skeleton.bones;
          for (let l = 0; l < t.length; l++)
            if (t[l].name === h) {
              h = l;
              break;
            }
          break;
        case "map":
          if ("map" in t) {
            t = t.map;
            break;
          }
          if (!t.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!t.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          t = t.material.map;
          break;
        default:
          if (t[i] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          t = t[i];
      }
      if (h !== void 0) {
        if (t[h] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
          return;
        }
        t = t[h];
      }
    }
    const a = t[r];
    if (a === void 0) {
      const h = e.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + h + "." + r + " but it wasn't found.", t);
      return;
    }
    let o = this.Versioning.None;
    this.targetObject = t, t.needsUpdate !== void 0 ? o = this.Versioning.NeedsUpdate : t.matrixWorldNeedsUpdate !== void 0 && (o = this.Versioning.MatrixWorldNeedsUpdate);
    let c = this.BindingType.Direct;
    if (s !== void 0) {
      if (r === "morphTargetInfluences") {
        if (!t.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!t.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        t.morphTargetDictionary[s] !== void 0 && (s = t.morphTargetDictionary[s]);
      }
      c = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = s;
    } else
      a.fromArray !== void 0 && a.toArray !== void 0 ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (c = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = r;
    this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][o];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
Ge.Composite = Kw;
Ge.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
Ge.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
Ge.prototype.GetterByBindingType = [
  Ge.prototype._getValue_direct,
  Ge.prototype._getValue_array,
  Ge.prototype._getValue_arrayElement,
  Ge.prototype._getValue_toArray
];
Ge.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    Ge.prototype._setValue_direct,
    Ge.prototype._setValue_direct_setNeedsUpdate,
    Ge.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    Ge.prototype._setValue_array,
    Ge.prototype._setValue_array_setNeedsUpdate,
    Ge.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    Ge.prototype._setValue_arrayElement,
    Ge.prototype._setValue_arrayElement_setNeedsUpdate,
    Ge.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    Ge.prototype._setValue_fromArray,
    Ge.prototype._setValue_fromArray_setNeedsUpdate,
    Ge.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class sf {
  constructor(t) {
    this.value = t;
  }
  clone() {
    return new sf(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: ql
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = ql);
class ap {
  /**
   * 
   * @param {import("@turf/helpers").Polygon} geojson
   * @param {number} [depth=1]  
   */
  static polygonToGeometry(t, e = 1) {
    const i = new Xd();
    for (let r = 0; r < t.coordinates.length; r++) {
      if (r === 0) {
        i.setFromPoints(t.coordinates[r].map((s) => new fe().fromArray(s)));
        continue;
      }
      i.holes.push(
        this._toRingToBufferGeometry(t.coordinates[r])
      );
    }
    return new ef(i, {
      depth: e
    });
  }
  /**
   * 
   * @param {import("@turf/helpers").LineString} geojson 
   */
  static polylineToGeometry(t) {
    const e = [];
    for (let i = 0; i < t.coordinates.length; i++)
      e.push(
        t.coordinates[i][0],
        t.coordinates[i][1],
        0
      );
    return e;
  }
  /**
   * 
   * @param {Array<[number , number]>} points 
   */
  static _toRingToBufferGeometry(t) {
    return new Rl(t.map((e) => new fe().fromArray(e)));
  }
}
function Zw(n, t = !1) {
  const e = n[0].index !== null, i = new Set(Object.keys(n[0].attributes)), r = new Set(Object.keys(n[0].morphAttributes)), s = {}, a = {}, o = n[0].morphTargetsRelative, c = new fr();
  let h = 0;
  for (let l = 0; l < n.length; ++l) {
    const f = n[l];
    let d = 0;
    if (e !== (f.index !== null))
      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + l + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null;
    for (const m in f.attributes) {
      if (!i.has(m))
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + l + '. All geometries must have compatible attributes; make sure "' + m + '" attribute exists among all geometries, or in none of them.'), null;
      s[m] === void 0 && (s[m] = []), s[m].push(f.attributes[m]), d++;
    }
    if (d !== i.size)
      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + l + ". Make sure all geometries have the same number of attributes."), null;
    if (o !== f.morphTargetsRelative)
      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + l + ". .morphTargetsRelative must be consistent throughout all geometries."), null;
    for (const m in f.morphAttributes) {
      if (!r.has(m))
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + l + ".  .morphAttributes must be consistent throughout all geometries."), null;
      a[m] === void 0 && (a[m] = []), a[m].push(f.morphAttributes[m]);
    }
    if (t) {
      let m;
      if (e)
        m = f.index.count;
      else if (f.attributes.position !== void 0)
        m = f.attributes.position.count;
      else
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + l + ". The geometry must have either an index or a position attribute"), null;
      c.addGroup(h, m, l), h += m;
    }
  }
  if (e) {
    let l = 0;
    const f = [];
    for (let d = 0; d < n.length; ++d) {
      const m = n[d].index;
      for (let v = 0; v < m.count; ++v)
        f.push(m.getX(v) + l);
      l += n[d].attributes.position.count;
    }
    c.setIndex(f);
  }
  for (const l in s) {
    const f = op(s[l]);
    if (!f)
      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + l + " attribute."), null;
    c.setAttribute(l, f);
  }
  for (const l in a) {
    const f = a[l][0].length;
    if (f === 0)
      break;
    c.morphAttributes = c.morphAttributes || {}, c.morphAttributes[l] = [];
    for (let d = 0; d < f; ++d) {
      const m = [];
      for (let E = 0; E < a[l].length; ++E)
        m.push(a[l][E][d]);
      const v = op(m);
      if (!v)
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + l + " morphAttribute."), null;
      c.morphAttributes[l].push(v);
    }
  }
  return c;
}
function op(n) {
  let t, e, i, r = -1, s = 0;
  for (let h = 0; h < n.length; ++h) {
    const l = n[h];
    if (l.isInterleavedBufferAttribute)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported."), null;
    if (t === void 0 && (t = l.array.constructor), t !== l.array.constructor)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null;
    if (e === void 0 && (e = l.itemSize), e !== l.itemSize)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null;
    if (i === void 0 && (i = l.normalized), i !== l.normalized)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null;
    if (r === -1 && (r = l.gpuType), r !== l.gpuType)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."), null;
    s += l.array.length;
  }
  const a = new t(s);
  let o = 0;
  for (let h = 0; h < n.length; ++h)
    a.set(n[h].array, o), o += n[h].array.length;
  const c = new gn(a, e, i);
  return r !== void 0 && (c.gpuType = r), c;
}
let Da, nl, na, Uc;
function il(n, t = 1 / 0, e = null) {
  nl || (nl = new pu(2, 2, 1, 1)), na || (na = new jr({
    uniforms: { blitTexture: new sf(n) },
    vertexShader: `
			varying vec2 vUv;
			void main(){
				vUv = uv;
				gl_Position = vec4(position.xy * 1.0,0.,.999999);
			}`,
    fragmentShader: `
			uniform sampler2D blitTexture; 
			varying vec2 vUv;

			void main(){ 
				gl_FragColor = vec4(vUv.xy, 0, 1);
				
				#ifdef IS_SRGB
				gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );
				#else
				gl_FragColor = texture2D( blitTexture, vUv);
				#endif
			}`
  })), na.uniforms.blitTexture.value = n, na.defines.IS_SRGB = n.colorSpace == yn, na.needsUpdate = !0, Uc || (Uc = new Bi(nl, na), Uc.frustrumCulled = !1);
  const i = new di(), r = new Tl();
  r.add(Uc), e === null && (e = Da = new Hd({ antialias: !1 }));
  const s = Math.min(n.image.width, t), a = Math.min(n.image.height, t);
  e.setSize(s, a), e.clear(), e.render(r, i);
  const o = document.createElement("canvas"), c = o.getContext("2d");
  o.width = s, o.height = a, c.drawImage(e.domElement, 0, 0, s, a);
  const h = new ow(o);
  return h.minFilter = n.minFilter, h.magFilter = n.magFilter, h.wrapS = n.wrapS, h.wrapT = n.wrapT, h.name = n.name, Da && (Da.forceContextLoss(), Da.dispose(), Da = null), h;
}
let Na = class {
  constructor() {
  }
  /**
   * 
   * @param {Blob} blob 
   */
  readAsArrayBuffer(t) {
    t.arrayBuffer().then((e) => {
      this.result = e, this.onloadend(e);
    });
  }
  onloadend() {
  }
};
const cp = {
  POSITION: [
    "byte",
    "byte normalized",
    "unsigned byte",
    "unsigned byte normalized",
    "short",
    "short normalized",
    "unsigned short",
    "unsigned short normalized"
  ],
  NORMAL: [
    "byte normalized",
    "short normalized"
  ],
  TANGENT: [
    "byte normalized",
    "short normalized"
  ],
  TEXCOORD: [
    "byte",
    "byte normalized",
    "unsigned byte",
    "short",
    "short normalized",
    "unsigned short"
  ]
};
class af {
  constructor() {
    this.pluginCallbacks = [], this.register(function(t) {
      return new oM(t);
    }), this.register(function(t) {
      return new cM(t);
    }), this.register(function(t) {
      return new fM(t);
    }), this.register(function(t) {
      return new hM(t);
    }), this.register(function(t) {
      return new pM(t);
    }), this.register(function(t) {
      return new dM(t);
    }), this.register(function(t) {
      return new uM(t);
    }), this.register(function(t) {
      return new lM(t);
    }), this.register(function(t) {
      return new mM(t);
    }), this.register(function(t) {
      return new _M(t);
    }), this.register(function(t) {
      return new yM(t);
    }), this.register(function(t) {
      return new gM(t);
    }), this.register(function(t) {
      return new vM(t);
    });
  }
  register(t) {
    return this.pluginCallbacks.indexOf(t) === -1 && this.pluginCallbacks.push(t), this;
  }
  unregister(t) {
    return this.pluginCallbacks.indexOf(t) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1), this;
  }
  /**
   * Parse scenes and generate GLTF output
   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
   * @param  {Function} onDone  Callback on completed
   * @param  {Function} onError  Callback on errors
   * @param  {Object} options options
   */
  parse(t, e, i, r) {
    const s = new aM(), a = [];
    for (let o = 0, c = this.pluginCallbacks.length; o < c; o++)
      a.push(this.pluginCallbacks[o](s));
    s.setPlugins(a), s.write(t, e, r).catch(i);
  }
  parseAsync(t, e) {
    const i = this;
    return new Promise(function(r, s) {
      i.parse(t, r, s, e);
    });
  }
}
const Fe = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  BYTE: 5120,
  UNSIGNED_BYTE: 5121,
  SHORT: 5122,
  UNSIGNED_SHORT: 5123,
  INT: 5124,
  UNSIGNED_INT: 5125,
  FLOAT: 5126,
  ARRAY_BUFFER: 34962,
  ELEMENT_ARRAY_BUFFER: 34963,
  NEAREST: 9728,
  LINEAR: 9729,
  NEAREST_MIPMAP_NEAREST: 9984,
  LINEAR_MIPMAP_NEAREST: 9985,
  NEAREST_MIPMAP_LINEAR: 9986,
  LINEAR_MIPMAP_LINEAR: 9987,
  CLAMP_TO_EDGE: 33071,
  MIRRORED_REPEAT: 33648,
  REPEAT: 10497
}, rl = "KHR_mesh_quantization", ai = {};
ai[Bn] = Fe.NEAREST;
ai[bl] = Fe.NEAREST_MIPMAP_NEAREST;
ai[Xc] = Fe.NEAREST_MIPMAP_LINEAR;
ai[ri] = Fe.LINEAR;
ai[pd] = Fe.LINEAR_MIPMAP_NEAREST;
ai[ya] = Fe.LINEAR_MIPMAP_LINEAR;
ai[_i] = Fe.CLAMP_TO_EDGE;
ai[eu] = Fe.REPEAT;
ai[nu] = Fe.MIRRORED_REPEAT;
const up = {
  scale: "scale",
  position: "translation",
  quaternion: "rotation",
  morphTargetInfluences: "weights"
}, Jw = new Ue(), lp = 12, Qw = 1179937895, tM = 2, fp = 8, eM = 1313821514, nM = 5130562;
function ka(n, t) {
  return n.length === t.length && n.every(function(e, i) {
    return e === t[i];
  });
}
function iM(n) {
  return new TextEncoder().encode(n).buffer;
}
function rM(n) {
  return ka(n.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
}
function sM(n, t, e) {
  const i = {
    min: new Array(n.itemSize).fill(Number.POSITIVE_INFINITY),
    max: new Array(n.itemSize).fill(Number.NEGATIVE_INFINITY)
  };
  for (let r = t; r < t + e; r++)
    for (let s = 0; s < n.itemSize; s++) {
      let a;
      n.itemSize > 4 ? a = n.array[r * n.itemSize + s] : (s === 0 ? a = n.getX(r) : s === 1 ? a = n.getY(r) : s === 2 ? a = n.getZ(r) : s === 3 && (a = n.getW(r)), n.normalized === !0 && (a = Ml.normalize(a, n.array))), i.min[s] = Math.min(i.min[s], a), i.max[s] = Math.max(i.max[s], a);
    }
  return i;
}
function Jd(n) {
  return Math.ceil(n / 4) * 4;
}
function sl(n, t = 0) {
  const e = Jd(n.byteLength);
  if (e !== n.byteLength) {
    const i = new Uint8Array(e);
    if (i.set(new Uint8Array(n)), t !== 0)
      for (let r = n.byteLength; r < e; r++)
        i[r] = t;
    return i.buffer;
  }
  return n;
}
function hp() {
  return typeof document > "u" && typeof OffscreenCanvas < "u" ? new OffscreenCanvas(1, 1) : document.createElement("canvas");
}
function pp(n, t) {
  if (n.toBlob !== void 0)
    return new Promise((i) => n.toBlob(i, t));
  let e;
  return t === "image/jpeg" ? e = 0.92 : t === "image/webp" && (e = 0.8), n.convertToBlob({
    type: t,
    quality: e
  });
}
class aM {
  constructor() {
    this.plugins = [], this.options = {}, this.pending = [], this.buffers = [], this.byteOffset = 0, this.buffers = [], this.nodeMap = /* @__PURE__ */ new Map(), this.skins = [], this.extensionsUsed = {}, this.extensionsRequired = {}, this.uids = /* @__PURE__ */ new Map(), this.uid = 0, this.json = {
      asset: {
        version: "2.0",
        generator: "THREE.GLTFExporter"
      }
    }, this.cache = {
      meshes: /* @__PURE__ */ new Map(),
      attributes: /* @__PURE__ */ new Map(),
      attributesNormalized: /* @__PURE__ */ new Map(),
      materials: /* @__PURE__ */ new Map(),
      textures: /* @__PURE__ */ new Map(),
      images: /* @__PURE__ */ new Map()
    };
  }
  setPlugins(t) {
    this.plugins = t;
  }
  /**
   * Parse scenes and generate GLTF output
   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
   * @param  {Function} onDone  Callback on completed
   * @param  {Object} options options
   */
  async write(t, e, i = {}) {
    this.options = Object.assign({
      // default options
      binary: !1,
      trs: !1,
      onlyVisible: !0,
      maxTextureSize: 1 / 0,
      animations: [],
      includeCustomExtensions: !1
    }, i), this.options.animations.length > 0 && (this.options.trs = !0), this.processInput(t), await Promise.all(this.pending);
    const r = this, s = r.buffers, a = r.json;
    i = r.options;
    const o = r.extensionsUsed, c = r.extensionsRequired, h = new Blob(s, { type: "application/octet-stream" }), l = Object.keys(o), f = Object.keys(c);
    if (l.length > 0 && (a.extensionsUsed = l), f.length > 0 && (a.extensionsRequired = f), a.buffers && a.buffers.length > 0 && (a.buffers[0].byteLength = h.size), i.binary === !0) {
      const d = new Na();
      h.arrayBuffer().then(() => {
      }), d.readAsArrayBuffer(h), d.onloadend = function() {
        const m = sl(d.result), v = new DataView(new ArrayBuffer(fp));
        v.setUint32(0, m.byteLength, !0), v.setUint32(4, nM, !0);
        const E = sl(iM(JSON.stringify(a)), 32), _ = new DataView(new ArrayBuffer(fp));
        _.setUint32(0, E.byteLength, !0), _.setUint32(4, eM, !0);
        const p = new ArrayBuffer(lp), R = new DataView(p);
        R.setUint32(0, Qw, !0), R.setUint32(4, tM, !0);
        const M = lp + _.byteLength + E.byteLength + v.byteLength + m.byteLength;
        R.setUint32(8, M, !0);
        const P = new Blob([
          p,
          _,
          E,
          v,
          m
        ], { type: "application/octet-stream" }), W = new Na();
        W.readAsArrayBuffer(P), W.onloadend = function() {
          e(W.result);
        };
      };
    } else if (a.buffers && a.buffers.length > 0) {
      const d = new Na();
      d.readAsDataURL(h), d.onloadend = function() {
        const m = d.result;
        a.buffers[0].uri = m, e(a);
      };
    } else
      e(a);
  }
  /**
   * Serializes a userData.
   *
   * @param {THREE.Object3D|THREE.Material} object
   * @param {Object} objectDef
   */
  serializeUserData(t, e) {
    if (Object.keys(t.userData).length === 0)
      return;
    const i = this.options, r = this.extensionsUsed;
    try {
      const s = JSON.parse(JSON.stringify(t.userData));
      if (i.includeCustomExtensions && s.gltfExtensions) {
        e.extensions === void 0 && (e.extensions = {});
        for (const a in s.gltfExtensions)
          e.extensions[a] = s.gltfExtensions[a], r[a] = !0;
        delete s.gltfExtensions;
      }
      Object.keys(s).length > 0 && (e.extras = s);
    } catch (s) {
      console.warn("THREE.GLTFExporter: userData of '" + t.name + "' won't be serialized because of JSON.stringify error - " + s.message);
    }
  }
  /**
   * Returns ids for buffer attributes.
   * @param  {Object} object
   * @return {Integer}
   */
  getUID(t, e = !1) {
    if (this.uids.has(t) === !1) {
      const r = /* @__PURE__ */ new Map();
      r.set(!0, this.uid++), r.set(!1, this.uid++), this.uids.set(t, r);
    }
    return this.uids.get(t).get(e);
  }
  /**
   * Checks if normal attribute values are normalized.
   *
   * @param {BufferAttribute} normal
   * @returns {Boolean}
   */
  isNormalizedNormalAttribute(t) {
    if (this.cache.attributesNormalized.has(t))
      return !1;
    const i = new Gt();
    for (let r = 0, s = t.count; r < s; r++)
      if (Math.abs(i.fromBufferAttribute(t, r).length() - 1) > 5e-4)
        return !1;
    return !0;
  }
  /**
   * Creates normalized normal buffer attribute.
   *
   * @param {BufferAttribute} normal
   * @returns {BufferAttribute}
   *
   */
  createNormalizedNormalAttribute(t) {
    const e = this.cache;
    if (e.attributesNormalized.has(t))
      return e.attributesNormalized.get(t);
    const i = t.clone(), r = new Gt();
    for (let s = 0, a = i.count; s < a; s++)
      r.fromBufferAttribute(i, s), r.x === 0 && r.y === 0 && r.z === 0 ? r.setX(1) : r.normalize(), i.setXYZ(s, r.x, r.y, r.z);
    return e.attributesNormalized.set(t, i), i;
  }
  /**
   * Applies a texture transform, if present, to the map definition. Requires
   * the KHR_texture_transform extension.
   *
   * @param {Object} mapDef
   * @param {THREE.Texture} texture
   */
  applyTextureTransform(t, e) {
    let i = !1;
    const r = {};
    (e.offset.x !== 0 || e.offset.y !== 0) && (r.offset = e.offset.toArray(), i = !0), e.rotation !== 0 && (r.rotation = e.rotation, i = !0), (e.repeat.x !== 1 || e.repeat.y !== 1) && (r.scale = e.repeat.toArray(), i = !0), i && (t.extensions = t.extensions || {}, t.extensions.KHR_texture_transform = r, this.extensionsUsed.KHR_texture_transform = !0);
  }
  buildMetalRoughTexture(t, e) {
    if (t === e)
      return t;
    function i(m) {
      return m.colorSpace === yn ? function(E) {
        return E < 0.04045 ? E * 0.0773993808 : Math.pow(E * 0.9478672986 + 0.0521327014, 2.4);
      } : function(E) {
        return E;
      };
    }
    console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures."), t instanceof Ju && (t = il(t)), e instanceof Ju && (e = il(e));
    const r = t ? t.image : null, s = e ? e.image : null, a = Math.max(r ? r.width : 0, s ? s.width : 0), o = Math.max(r ? r.height : 0, s ? s.height : 0), c = hp();
    c.width = a, c.height = o;
    const h = c.getContext("2d");
    h.fillStyle = "#00ffff", h.fillRect(0, 0, a, o);
    const l = h.getImageData(0, 0, a, o);
    if (r) {
      h.drawImage(r, 0, 0, a, o);
      const m = i(t), v = h.getImageData(0, 0, a, o).data;
      for (let E = 2; E < v.length; E += 4)
        l.data[E] = m(v[E] / 256) * 256;
    }
    if (s) {
      h.drawImage(s, 0, 0, a, o);
      const m = i(e), v = h.getImageData(0, 0, a, o).data;
      for (let E = 1; E < v.length; E += 4)
        l.data[E] = m(v[E] / 256) * 256;
    }
    h.putImageData(l, 0, 0);
    const d = (t || e).clone();
    return d.source = new Kl(c), d.colorSpace = si, d.channel = (t || e).channel, t && e && t.channel !== e.channel && console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match."), d;
  }
  /**
   * Process a buffer to append to the default one.
   * @param  {ArrayBuffer} buffer
   * @return {Integer}
   */
  processBuffer(t) {
    const e = this.json, i = this.buffers;
    return e.buffers || (e.buffers = [{ byteLength: 0 }]), i.push(t), 0;
  }
  /**
   * Process and generate a BufferView
   * @param  {BufferAttribute} attribute
   * @param  {number} componentType
   * @param  {number} start
   * @param  {number} count
   * @param  {number} target (Optional) Target usage of the BufferView
   * @return {Object}
   */
  processBufferView(t, e, i, r, s) {
    const a = this.json;
    a.bufferViews || (a.bufferViews = []);
    let o;
    switch (e) {
      case Fe.BYTE:
      case Fe.UNSIGNED_BYTE:
        o = 1;
        break;
      case Fe.SHORT:
      case Fe.UNSIGNED_SHORT:
        o = 2;
        break;
      default:
        o = 4;
    }
    const c = Jd(r * t.itemSize * o), h = new DataView(new ArrayBuffer(c));
    let l = 0;
    for (let m = i; m < i + r; m++)
      for (let v = 0; v < t.itemSize; v++) {
        let E;
        t.itemSize > 4 ? E = t.array[m * t.itemSize + v] : (v === 0 ? E = t.getX(m) : v === 1 ? E = t.getY(m) : v === 2 ? E = t.getZ(m) : v === 3 && (E = t.getW(m)), t.normalized === !0 && (E = Ml.normalize(E, t.array))), e === Fe.FLOAT ? h.setFloat32(l, E, !0) : e === Fe.INT ? h.setInt32(l, E, !0) : e === Fe.UNSIGNED_INT ? h.setUint32(l, E, !0) : e === Fe.SHORT ? h.setInt16(l, E, !0) : e === Fe.UNSIGNED_SHORT ? h.setUint16(l, E, !0) : e === Fe.BYTE ? h.setInt8(l, E) : e === Fe.UNSIGNED_BYTE && h.setUint8(l, E), l += o;
      }
    const f = {
      buffer: this.processBuffer(h.buffer),
      byteOffset: this.byteOffset,
      byteLength: c
    };
    return s !== void 0 && (f.target = s), s === Fe.ARRAY_BUFFER && (f.byteStride = t.itemSize * o), this.byteOffset += c, a.bufferViews.push(f), {
      id: a.bufferViews.length - 1,
      byteLength: 0
    };
  }
  /**
   * Process and generate a BufferView from an image Blob.
   * @param {Blob} blob
   * @return {Promise<Integer>}
   */
  processBufferViewImage(t) {
    const e = this, i = e.json;
    return i.bufferViews || (i.bufferViews = []), new Promise(function(r) {
      const s = new Na();
      s.readAsArrayBuffer(t), s.onloadend = function() {
        const a = sl(s.result), o = {
          buffer: e.processBuffer(a),
          byteOffset: e.byteOffset,
          byteLength: a.byteLength
        };
        e.byteOffset += a.byteLength, r(i.bufferViews.push(o) - 1);
      };
    });
  }
  /**
   * Process attribute to generate an accessor
   * @param  {BufferAttribute} attribute Attribute to process
   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range
   * @param  {Integer} start (Optional)
   * @param  {Integer} count (Optional)
   * @return {Integer|null} Index of the processed accessor on the "accessors" array
   */
  processAccessor(t, e, i, r) {
    const s = this.json, a = {
      1: "SCALAR",
      2: "VEC2",
      3: "VEC3",
      4: "VEC4",
      9: "MAT3",
      16: "MAT4"
    };
    let o;
    if (t.array.constructor === Float32Array)
      o = Fe.FLOAT;
    else if (t.array.constructor === Int32Array)
      o = Fe.INT;
    else if (t.array.constructor === Uint32Array)
      o = Fe.UNSIGNED_INT;
    else if (t.array.constructor === Int16Array)
      o = Fe.SHORT;
    else if (t.array.constructor === Uint16Array)
      o = Fe.UNSIGNED_SHORT;
    else if (t.array.constructor === Int8Array)
      o = Fe.BYTE;
    else if (t.array.constructor === Uint8Array)
      o = Fe.UNSIGNED_BYTE;
    else
      throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type: " + t.array.constructor.name);
    if (i === void 0 && (i = 0), (r === void 0 || r === 1 / 0) && (r = t.count), r === 0)
      return null;
    const c = sM(t, i, r);
    let h;
    e !== void 0 && (h = t === e.index ? Fe.ELEMENT_ARRAY_BUFFER : Fe.ARRAY_BUFFER);
    const l = this.processBufferView(t, o, i, r, h), f = {
      bufferView: l.id,
      byteOffset: l.byteOffset,
      componentType: o,
      count: r,
      max: c.max,
      min: c.min,
      type: a[t.itemSize]
    };
    return t.normalized === !0 && (f.normalized = !0), s.accessors || (s.accessors = []), s.accessors.push(f) - 1;
  }
  /**
   * Process image
   * @param  {Image} image to process
   * @param  {Integer} format of the image (RGBAFormat)
   * @param  {Boolean} flipY before writing out the image
   * @param  {String} mimeType export format
   * @return {Integer}     Index of the processed texture in the "images" array
   */
  processImage(t, e, i, r = "image/png") {
    if (t !== null) {
      const s = this, a = s.cache, o = s.json, c = s.options, h = s.pending;
      a.images.has(t) || a.images.set(t, {});
      const l = a.images.get(t), f = r + ":flipY/" + i.toString();
      if (l[f] !== void 0)
        return l[f];
      o.images || (o.images = []);
      const d = { mimeType: r }, m = hp();
      m.width = Math.min(t.width, c.maxTextureSize), m.height = Math.min(t.height, c.maxTextureSize);
      const v = m.getContext("2d");
      if (i === !0 && (v.translate(0, m.height), v.scale(1, -1)), t.data !== void 0) {
        e !== yi && console.error("GLTFExporter: Only RGBAFormat is supported.", e), (t.width > c.maxTextureSize || t.height > c.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", t);
        const _ = new Uint8ClampedArray(t.height * t.width * 4);
        for (let p = 0; p < _.length; p += 4)
          _[p + 0] = t.data[p + 0], _[p + 1] = t.data[p + 1], _[p + 2] = t.data[p + 2], _[p + 3] = t.data[p + 3];
        v.putImageData(new ImageData(_, t.width, t.height), 0, 0);
      } else
        v.drawImage(t, 0, 0, m.width, m.height);
      c.binary === !0 ? h.push(
        pp(m, r).then((_) => s.processBufferViewImage(_)).then((_) => {
          d.bufferView = _;
        })
      ) : m.toDataURL !== void 0 ? d.uri = m.toDataURL(r) : h.push(
        pp(m, r).then((_) => new Na().readAsDataURL(_)).then((_) => {
          d.uri = _;
        })
      );
      const E = o.images.push(d) - 1;
      return l[f] = E, E;
    } else
      throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.");
  }
  /**
   * Process sampler
   * @param  {Texture} map Texture to process
   * @return {Integer}     Index of the processed texture in the "samplers" array
   */
  processSampler(t) {
    const e = this.json;
    e.samplers || (e.samplers = []);
    const i = {
      magFilter: ai[t.magFilter],
      minFilter: ai[t.minFilter],
      wrapS: ai[t.wrapS],
      wrapT: ai[t.wrapT]
    };
    return e.samplers.push(i) - 1;
  }
  /**
   * Process texture
   * @param  {Texture} map Map to process
   * @return {Integer} Index of the processed texture in the "textures" array
   */
  processTexture(t) {
    const i = this.options, r = this.cache, s = this.json;
    if (r.textures.has(t))
      return r.textures.get(t);
    s.textures || (s.textures = []), t instanceof Ju && (t = il(t, i.maxTextureSize));
    let a = t.userData.mimeType;
    a === "image/webp" && (a = "image/png");
    const o = {
      sampler: this.processSampler(t),
      source: this.processImage(t.image, t.format, t.flipY, a)
    };
    t.name && (o.name = t.name), this._invokeAll(function(h) {
      h.writeTexture && h.writeTexture(t, o);
    });
    const c = s.textures.push(o) - 1;
    return r.textures.set(t, c), c;
  }
  /**
   * Process material
   * @param  {THREE.Material} material Material to process
   * @return {Integer|null} Index of the processed material in the "materials" array
   */
  processMaterial(t) {
    const e = this.cache, i = this.json;
    if (e.materials.has(t))
      return e.materials.get(t);
    if (t.isShaderMaterial)
      return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."), null;
    i.materials || (i.materials = []);
    const r = { pbrMetallicRoughness: {} };
    t.isMeshStandardMaterial !== !0 && t.isMeshBasicMaterial !== !0 && console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
    const s = t.color.toArray().concat([t.opacity]);
    if (ka(s, [1, 1, 1, 1]) || (r.pbrMetallicRoughness.baseColorFactor = s), t.isMeshStandardMaterial ? (r.pbrMetallicRoughness.metallicFactor = t.metalness, r.pbrMetallicRoughness.roughnessFactor = t.roughness) : (r.pbrMetallicRoughness.metallicFactor = 0.5, r.pbrMetallicRoughness.roughnessFactor = 0.5), t.metalnessMap || t.roughnessMap) {
      const o = this.buildMetalRoughTexture(t.metalnessMap, t.roughnessMap), c = {
        index: this.processTexture(o),
        channel: o.channel
      };
      this.applyTextureTransform(c, o), r.pbrMetallicRoughness.metallicRoughnessTexture = c;
    }
    if (t.map) {
      const o = {
        index: this.processTexture(t.map),
        texCoord: t.map.channel
      };
      this.applyTextureTransform(o, t.map), r.pbrMetallicRoughness.baseColorTexture = o;
    }
    if (t.emissive) {
      const o = t.emissive;
      if (Math.max(o.r, o.g, o.b) > 0 && (r.emissiveFactor = t.emissive.toArray()), t.emissiveMap) {
        const h = {
          index: this.processTexture(t.emissiveMap),
          texCoord: t.emissiveMap.channel
        };
        this.applyTextureTransform(h, t.emissiveMap), r.emissiveTexture = h;
      }
    }
    if (t.normalMap) {
      const o = {
        index: this.processTexture(t.normalMap),
        texCoord: t.normalMap.channel
      };
      t.normalScale && t.normalScale.x !== 1 && (o.scale = t.normalScale.x), this.applyTextureTransform(o, t.normalMap), r.normalTexture = o;
    }
    if (t.aoMap) {
      const o = {
        index: this.processTexture(t.aoMap),
        texCoord: t.aoMap.channel
      };
      t.aoMapIntensity !== 1 && (o.strength = t.aoMapIntensity), this.applyTextureTransform(o, t.aoMap), r.occlusionTexture = o;
    }
    t.transparent ? r.alphaMode = "BLEND" : t.alphaTest > 0 && (r.alphaMode = "MASK", r.alphaCutoff = t.alphaTest), t.side === Mi && (r.doubleSided = !0), t.name !== "" && (r.name = t.name), this.serializeUserData(t, r), this._invokeAll(function(o) {
      o.writeMaterial && o.writeMaterial(t, r);
    });
    const a = i.materials.push(r) - 1;
    return e.materials.set(t, a), a;
  }
  /**
   * Process mesh
   * @param  {THREE.Mesh} mesh Mesh to process
   * @return {Integer|null} Index of the processed mesh in the "meshes" array
   */
  processMesh(t) {
    const e = this.cache, i = this.json, r = [t.geometry.uuid];
    if (Array.isArray(t.material))
      for (let P = 0, W = t.material.length; P < W; P++)
        r.push(t.material[P].uuid);
    else
      r.push(t.material.uuid);
    const s = r.join(":");
    if (e.meshes.has(s))
      return e.meshes.get(s);
    const a = t.geometry;
    let o;
    t.isLineSegments ? o = Fe.LINES : t.isLineLoop ? o = Fe.LINE_LOOP : t.isLine ? o = Fe.LINE_STRIP : t.isPoints ? o = Fe.POINTS : o = t.material.wireframe ? Fe.LINES : Fe.TRIANGLES;
    const c = {}, h = {}, l = [], f = [], d = {
      uv: "TEXCOORD_0",
      uv1: "TEXCOORD_1",
      uv2: "TEXCOORD_2",
      uv3: "TEXCOORD_3",
      color: "COLOR_0",
      skinWeight: "WEIGHTS_0",
      skinIndex: "JOINTS_0"
    }, m = a.getAttribute("normal");
    m !== void 0 && !this.isNormalizedNormalAttribute(m) && a.setAttribute("normal", this.createNormalizedNormalAttribute(m));
    let v = null;
    for (let P in a.attributes) {
      if (P.slice(0, 5) === "morph")
        continue;
      const W = a.attributes[P];
      if (P = d[P] || P.toUpperCase(), /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(P) || (P = "_" + P), e.attributes.has(this.getUID(W))) {
        h[P] = e.attributes.get(this.getUID(W));
        continue;
      }
      v = null;
      const D = W.array;
      P === "JOINTS_0" && !(D instanceof Uint16Array) && !(D instanceof Uint8Array) && (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), v = new gn(new Uint16Array(D), W.itemSize, W.normalized));
      const N = this.processAccessor(v || W, a);
      N !== null && (P.startsWith("_") || this.detectMeshQuantization(P, W), h[P] = N, e.attributes.set(this.getUID(W), N));
    }
    if (m !== void 0 && a.setAttribute("normal", m), Object.keys(h).length === 0)
      return null;
    if (t.morphTargetInfluences !== void 0 && t.morphTargetInfluences.length > 0) {
      const P = [], W = [], C = {};
      if (t.morphTargetDictionary !== void 0)
        for (const D in t.morphTargetDictionary)
          C[t.morphTargetDictionary[D]] = D;
      for (let D = 0; D < t.morphTargetInfluences.length; ++D) {
        const N = {};
        let A = !1;
        for (const I in a.morphAttributes) {
          if (I !== "position" && I !== "normal") {
            A || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), A = !0);
            continue;
          }
          const it = a.morphAttributes[I][D], V = I.toUpperCase(), mt = a.attributes[I];
          if (e.attributes.has(this.getUID(it, !0))) {
            N[V] = e.attributes.get(this.getUID(it, !0));
            continue;
          }
          const k = it.clone();
          if (!a.morphTargetsRelative)
            for (let B = 0, G = it.count; B < G; B++)
              for (let H = 0; H < it.itemSize; H++)
                H === 0 && k.setX(B, it.getX(B) - mt.getX(B)), H === 1 && k.setY(B, it.getY(B) - mt.getY(B)), H === 2 && k.setZ(B, it.getZ(B) - mt.getZ(B)), H === 3 && k.setW(B, it.getW(B) - mt.getW(B));
          N[V] = this.processAccessor(k, a), e.attributes.set(this.getUID(mt, !0), N[V]);
        }
        f.push(N), P.push(t.morphTargetInfluences[D]), t.morphTargetDictionary !== void 0 && W.push(C[D]);
      }
      c.weights = P, W.length > 0 && (c.extras = {}, c.extras.targetNames = W);
    }
    const E = Array.isArray(t.material);
    if (E && a.groups.length === 0)
      return null;
    let _ = !1;
    if (E && a.index === null) {
      const P = [];
      for (let W = 0, C = a.attributes.position.count; W < C; W++)
        P[W] = W;
      a.setIndex(P), _ = !0;
    }
    const p = E ? t.material : [t.material], R = E ? a.groups : [{ materialIndex: 0, start: void 0, count: void 0 }];
    for (let P = 0, W = R.length; P < W; P++) {
      const C = {
        mode: o,
        attributes: h
      };
      if (this.serializeUserData(a, C), f.length > 0 && (C.targets = f), a.index !== null) {
        let N = this.getUID(a.index);
        (R[P].start !== void 0 || R[P].count !== void 0) && (N += ":" + R[P].start + ":" + R[P].count), e.attributes.has(N) ? C.indices = e.attributes.get(N) : (C.indices = this.processAccessor(a.index, a, R[P].start, R[P].count), e.attributes.set(N, C.indices)), C.indices === null && delete C.indices;
      }
      const D = this.processMaterial(p[R[P].materialIndex]);
      D !== null && (C.material = D), l.push(C);
    }
    _ === !0 && a.setIndex(null), c.primitives = l, i.meshes || (i.meshes = []), this._invokeAll(function(P) {
      P.writeMesh && P.writeMesh(t, c);
    });
    const M = i.meshes.push(c) - 1;
    return e.meshes.set(s, M), M;
  }
  /**
   * If a vertex attribute with a
   * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)
   * is used, it is checked whether it is a valid data type according to the
   * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)
   * extension.
   * In this case the extension is automatically added to the list of used extensions.
   *
   * @param {string} attributeName
   * @param {THREE.BufferAttribute} attribute
   */
  detectMeshQuantization(t, e) {
    if (this.extensionsUsed[rl])
      return;
    let i;
    switch (e.array.constructor) {
      case Int8Array:
        i = "byte";
        break;
      case Uint8Array:
        i = "unsigned byte";
        break;
      case Int16Array:
        i = "short";
        break;
      case Uint16Array:
        i = "unsigned short";
        break;
      default:
        return;
    }
    e.normalized && (i += " normalized");
    const r = t.split("_", 1)[0];
    cp[r] && cp[r].includes(i) && (this.extensionsUsed[rl] = !0, this.extensionsRequired[rl] = !0);
  }
  /**
   * Process camera
   * @param  {THREE.Camera} camera Camera to process
   * @return {Integer}      Index of the processed mesh in the "camera" array
   */
  processCamera(t) {
    const e = this.json;
    e.cameras || (e.cameras = []);
    const i = t.isOrthographicCamera, r = {
      type: i ? "orthographic" : "perspective"
    };
    return i ? r.orthographic = {
      xmag: t.right * 2,
      ymag: t.top * 2,
      zfar: t.far <= 0 ? 1e-3 : t.far,
      znear: t.near < 0 ? 0 : t.near
    } : r.perspective = {
      aspectRatio: t.aspect,
      yfov: Ml.degToRad(t.fov),
      zfar: t.far <= 0 ? 1e-3 : t.far,
      znear: t.near < 0 ? 0 : t.near
    }, t.name !== "" && (r.name = t.type), e.cameras.push(r) - 1;
  }
  /**
   * Creates glTF animation entry from AnimationClip object.
   *
   * Status:
   * - Only properties listed in PATH_PROPERTIES may be animated.
   *
   * @param {THREE.AnimationClip} clip
   * @param {THREE.Object3D} root
   * @return {number|null}
   */
  processAnimation(t, e) {
    const i = this.json, r = this.nodeMap;
    i.animations || (i.animations = []), t = af.Utils.mergeMorphTargetTracks(t.clone(), e);
    const s = t.tracks, a = [], o = [];
    for (let c = 0; c < s.length; ++c) {
      const h = s[c], l = Ge.parseTrackName(h.name);
      let f = Ge.findNode(e, l.nodeName);
      const d = up[l.propertyName];
      if (l.objectName === "bones" && (f.isSkinnedMesh === !0 ? f = f.skeleton.getBoneByName(l.objectIndex) : f = void 0), !f || !d)
        return console.warn('THREE.GLTFExporter: Could not export animation track "%s".', h.name), null;
      const m = 1;
      let v = h.values.length / h.times.length;
      d === up.morphTargetInfluences && (v /= f.morphTargetInfluences.length);
      let E;
      h.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === !0 ? (E = "CUBICSPLINE", v /= 3) : h.getInterpolation() === Tg ? E = "STEP" : E = "LINEAR", o.push({
        input: this.processAccessor(new gn(h.times, m)),
        output: this.processAccessor(new gn(h.values, v)),
        interpolation: E
      }), a.push({
        sampler: o.length - 1,
        target: {
          node: r.get(f),
          path: d
        }
      });
    }
    return i.animations.push({
      name: t.name || "clip_" + i.animations.length,
      samplers: o,
      channels: a
    }), i.animations.length - 1;
  }
  /**
   * @param {THREE.Object3D} object
   * @return {number|null}
   */
  processSkin(t) {
    const e = this.json, i = this.nodeMap, r = e.nodes[i.get(t)], s = t.skeleton;
    if (s === void 0)
      return null;
    const a = t.skeleton.bones[0];
    if (a === void 0)
      return null;
    const o = [], c = new Float32Array(s.bones.length * 16), h = new vn();
    for (let f = 0; f < s.bones.length; ++f)
      o.push(i.get(s.bones[f])), h.copy(s.boneInverses[f]), h.multiply(t.bindMatrix).toArray(c, f * 16);
    return e.skins === void 0 && (e.skins = []), e.skins.push({
      inverseBindMatrices: this.processAccessor(new gn(c, 16)),
      joints: o,
      skeleton: i.get(a)
    }), r.skin = e.skins.length - 1;
  }
  /**
   * Process Object3D node
   * @param  {THREE.Object3D} node Object3D to processNode
   * @return {Integer} Index of the node in the nodes list
   */
  processNode(t) {
    const e = this.json, i = this.options, r = this.nodeMap;
    e.nodes || (e.nodes = []);
    const s = {};
    if (i.trs) {
      const o = t.quaternion.toArray(), c = t.position.toArray(), h = t.scale.toArray();
      ka(o, [0, 0, 0, 1]) || (s.rotation = o), ka(c, [0, 0, 0]) || (s.translation = c), ka(h, [1, 1, 1]) || (s.scale = h);
    } else
      t.matrixAutoUpdate && t.updateMatrix(), rM(t.matrix) === !1 && (s.matrix = t.matrix.elements);
    if (t.name !== "" && (s.name = String(t.name)), this.serializeUserData(t, s), t.isMesh || t.isLine || t.isPoints) {
      const o = this.processMesh(t);
      o !== null && (s.mesh = o);
    } else
      t.isCamera && (s.camera = this.processCamera(t));
    if (t.isSkinnedMesh && this.skins.push(t), t.children.length > 0) {
      const o = [];
      for (let c = 0, h = t.children.length; c < h; c++) {
        const l = t.children[c];
        if (l.visible || i.onlyVisible === !1) {
          const f = this.processNode(l);
          f !== null && o.push(f);
        }
      }
      o.length > 0 && (s.children = o);
    }
    this._invokeAll(function(o) {
      o.writeNode && o.writeNode(t, s);
    });
    const a = e.nodes.push(s) - 1;
    return r.set(t, a), a;
  }
  /**
   * Process Scene
   * @param  {Scene} node Scene to process
   */
  processScene(t) {
    const e = this.json, i = this.options;
    e.scenes || (e.scenes = [], e.scene = 0);
    const r = {};
    t.name !== "" && (r.name = t.name), e.scenes.push(r);
    const s = [];
    for (let a = 0, o = t.children.length; a < o; a++) {
      const c = t.children[a];
      if (c.visible || i.onlyVisible === !1) {
        const h = this.processNode(c);
        h !== null && s.push(h);
      }
    }
    s.length > 0 && (r.nodes = s), this.serializeUserData(t, r);
  }
  /**
   * Creates a Scene to hold a list of objects and parse it
   * @param  {Array} objects List of objects to process
   */
  processObjects(t) {
    const e = new Tl();
    e.name = "AuxScene";
    for (let i = 0; i < t.length; i++)
      e.children.push(t[i]);
    this.processScene(e);
  }
  /**
   * @param {THREE.Object3D|Array<THREE.Object3D>} input
   */
  processInput(t) {
    const e = this.options;
    t = t instanceof Array ? t : [t], this._invokeAll(function(r) {
      r.beforeParse && r.beforeParse(t);
    });
    const i = [];
    for (let r = 0; r < t.length; r++)
      t[r] instanceof Tl ? this.processScene(t[r]) : i.push(t[r]);
    i.length > 0 && this.processObjects(i);
    for (let r = 0; r < this.skins.length; ++r)
      this.processSkin(this.skins[r]);
    for (let r = 0; r < e.animations.length; ++r)
      this.processAnimation(e.animations[r], t[0]);
    this._invokeAll(function(r) {
      r.afterParse && r.afterParse(t);
    });
  }
  _invokeAll(t) {
    for (let e = 0, i = this.plugins.length; e < i; e++)
      t(this.plugins[e]);
  }
}
class oM {
  constructor(t) {
    this.writer = t, this.name = "KHR_lights_punctual";
  }
  writeNode(t, e) {
    if (!t.isLight)
      return;
    if (!t.isDirectionalLight && !t.isPointLight && !t.isSpotLight) {
      console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", t);
      return;
    }
    const i = this.writer, r = i.json, s = i.extensionsUsed, a = {};
    t.name && (a.name = t.name), a.color = t.color.toArray(), a.intensity = t.intensity, t.isDirectionalLight ? a.type = "directional" : t.isPointLight ? (a.type = "point", t.distance > 0 && (a.range = t.distance)) : t.isSpotLight && (a.type = "spot", t.distance > 0 && (a.range = t.distance), a.spot = {}, a.spot.innerConeAngle = (1 - t.penumbra) * t.angle, a.spot.outerConeAngle = t.angle), t.decay !== void 0 && t.decay !== 2 && console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."), t.target && (t.target.parent !== t || t.target.position.x !== 0 || t.target.position.y !== 0 || t.target.position.z !== -1) && console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."), s[this.name] || (r.extensions = r.extensions || {}, r.extensions[this.name] = { lights: [] }, s[this.name] = !0);
    const o = r.extensions[this.name].lights;
    o.push(a), e.extensions = e.extensions || {}, e.extensions[this.name] = { light: o.length - 1 };
  }
}
class cM {
  constructor(t) {
    this.writer = t, this.name = "KHR_materials_unlit";
  }
  writeMaterial(t, e) {
    if (!t.isMeshBasicMaterial)
      return;
    const r = this.writer.extensionsUsed;
    e.extensions = e.extensions || {}, e.extensions[this.name] = {}, r[this.name] = !0, e.pbrMetallicRoughness.metallicFactor = 0, e.pbrMetallicRoughness.roughnessFactor = 0.9;
  }
}
class uM {
  constructor(t) {
    this.writer = t, this.name = "KHR_materials_clearcoat";
  }
  writeMaterial(t, e) {
    if (!t.isMeshPhysicalMaterial || t.clearcoat === 0)
      return;
    const i = this.writer, r = i.extensionsUsed, s = {};
    if (s.clearcoatFactor = t.clearcoat, t.clearcoatMap) {
      const a = {
        index: i.processTexture(t.clearcoatMap),
        texCoord: t.clearcoatMap.channel
      };
      i.applyTextureTransform(a, t.clearcoatMap), s.clearcoatTexture = a;
    }
    if (s.clearcoatRoughnessFactor = t.clearcoatRoughness, t.clearcoatRoughnessMap) {
      const a = {
        index: i.processTexture(t.clearcoatRoughnessMap),
        texCoord: t.clearcoatRoughnessMap.channel
      };
      i.applyTextureTransform(a, t.clearcoatRoughnessMap), s.clearcoatRoughnessTexture = a;
    }
    if (t.clearcoatNormalMap) {
      const a = {
        index: i.processTexture(t.clearcoatNormalMap),
        texCoord: t.clearcoatNormalMap.channel
      };
      i.applyTextureTransform(a, t.clearcoatNormalMap), s.clearcoatNormalTexture = a;
    }
    e.extensions = e.extensions || {}, e.extensions[this.name] = s, r[this.name] = !0;
  }
}
class lM {
  constructor(t) {
    this.writer = t, this.name = "KHR_materials_iridescence";
  }
  writeMaterial(t, e) {
    if (!t.isMeshPhysicalMaterial || t.iridescence === 0)
      return;
    const i = this.writer, r = i.extensionsUsed, s = {};
    if (s.iridescenceFactor = t.iridescence, t.iridescenceMap) {
      const a = {
        index: i.processTexture(t.iridescenceMap),
        texCoord: t.iridescenceMap.channel
      };
      i.applyTextureTransform(a, t.iridescenceMap), s.iridescenceTexture = a;
    }
    if (s.iridescenceIor = t.iridescenceIOR, s.iridescenceThicknessMinimum = t.iridescenceThicknessRange[0], s.iridescenceThicknessMaximum = t.iridescenceThicknessRange[1], t.iridescenceThicknessMap) {
      const a = {
        index: i.processTexture(t.iridescenceThicknessMap),
        texCoord: t.iridescenceThicknessMap.channel
      };
      i.applyTextureTransform(a, t.iridescenceThicknessMap), s.iridescenceThicknessTexture = a;
    }
    e.extensions = e.extensions || {}, e.extensions[this.name] = s, r[this.name] = !0;
  }
}
class fM {
  constructor(t) {
    this.writer = t, this.name = "KHR_materials_transmission";
  }
  writeMaterial(t, e) {
    if (!t.isMeshPhysicalMaterial || t.transmission === 0)
      return;
    const i = this.writer, r = i.extensionsUsed, s = {};
    if (s.transmissionFactor = t.transmission, t.transmissionMap) {
      const a = {
        index: i.processTexture(t.transmissionMap),
        texCoord: t.transmissionMap.channel
      };
      i.applyTextureTransform(a, t.transmissionMap), s.transmissionTexture = a;
    }
    e.extensions = e.extensions || {}, e.extensions[this.name] = s, r[this.name] = !0;
  }
}
class hM {
  constructor(t) {
    this.writer = t, this.name = "KHR_materials_volume";
  }
  writeMaterial(t, e) {
    if (!t.isMeshPhysicalMaterial || t.transmission === 0)
      return;
    const i = this.writer, r = i.extensionsUsed, s = {};
    if (s.thicknessFactor = t.thickness, t.thicknessMap) {
      const a = {
        index: i.processTexture(t.thicknessMap),
        texCoord: t.thicknessMap.channel
      };
      i.applyTextureTransform(a, t.thicknessMap), s.thicknessTexture = a;
    }
    s.attenuationDistance = t.attenuationDistance, s.attenuationColor = t.attenuationColor.toArray(), e.extensions = e.extensions || {}, e.extensions[this.name] = s, r[this.name] = !0;
  }
}
class pM {
  constructor(t) {
    this.writer = t, this.name = "KHR_materials_ior";
  }
  writeMaterial(t, e) {
    if (!t.isMeshPhysicalMaterial || t.ior === 1.5)
      return;
    const r = this.writer.extensionsUsed, s = {};
    s.ior = t.ior, e.extensions = e.extensions || {}, e.extensions[this.name] = s, r[this.name] = !0;
  }
}
class dM {
  constructor(t) {
    this.writer = t, this.name = "KHR_materials_specular";
  }
  writeMaterial(t, e) {
    if (!t.isMeshPhysicalMaterial || t.specularIntensity === 1 && t.specularColor.equals(Jw) && !t.specularIntensityMap && !t.specularColorMap)
      return;
    const i = this.writer, r = i.extensionsUsed, s = {};
    if (t.specularIntensityMap) {
      const a = {
        index: i.processTexture(t.specularIntensityMap),
        texCoord: t.specularIntensityMap.channel
      };
      i.applyTextureTransform(a, t.specularIntensityMap), s.specularTexture = a;
    }
    if (t.specularColorMap) {
      const a = {
        index: i.processTexture(t.specularColorMap),
        texCoord: t.specularColorMap.channel
      };
      i.applyTextureTransform(a, t.specularColorMap), s.specularColorTexture = a;
    }
    s.specularFactor = t.specularIntensity, s.specularColorFactor = t.specularColor.toArray(), e.extensions = e.extensions || {}, e.extensions[this.name] = s, r[this.name] = !0;
  }
}
class mM {
  constructor(t) {
    this.writer = t, this.name = "KHR_materials_sheen";
  }
  writeMaterial(t, e) {
    if (!t.isMeshPhysicalMaterial || t.sheen == 0)
      return;
    const i = this.writer, r = i.extensionsUsed, s = {};
    if (t.sheenRoughnessMap) {
      const a = {
        index: i.processTexture(t.sheenRoughnessMap),
        texCoord: t.sheenRoughnessMap.channel
      };
      i.applyTextureTransform(a, t.sheenRoughnessMap), s.sheenRoughnessTexture = a;
    }
    if (t.sheenColorMap) {
      const a = {
        index: i.processTexture(t.sheenColorMap),
        texCoord: t.sheenColorMap.channel
      };
      i.applyTextureTransform(a, t.sheenColorMap), s.sheenColorTexture = a;
    }
    s.sheenRoughnessFactor = t.sheenRoughness, s.sheenColorFactor = t.sheenColor.toArray(), e.extensions = e.extensions || {}, e.extensions[this.name] = s, r[this.name] = !0;
  }
}
class _M {
  constructor(t) {
    this.writer = t, this.name = "KHR_materials_anisotropy";
  }
  writeMaterial(t, e) {
    if (!t.isMeshPhysicalMaterial || t.anisotropy == 0)
      return;
    const i = this.writer, r = i.extensionsUsed, s = {};
    if (t.anisotropyMap) {
      const a = { index: i.processTexture(t.anisotropyMap) };
      i.applyTextureTransform(a, t.anisotropyMap), s.anisotropyTexture = a;
    }
    s.anisotropyStrength = t.anisotropy, s.anisotropyRotation = t.anisotropyRotation, e.extensions = e.extensions || {}, e.extensions[this.name] = s, r[this.name] = !0;
  }
}
class yM {
  constructor(t) {
    this.writer = t, this.name = "KHR_materials_emissive_strength";
  }
  writeMaterial(t, e) {
    if (!t.isMeshStandardMaterial || t.emissiveIntensity === 1)
      return;
    const r = this.writer.extensionsUsed, s = {};
    s.emissiveStrength = t.emissiveIntensity, e.extensions = e.extensions || {}, e.extensions[this.name] = s, r[this.name] = !0;
  }
}
class gM {
  constructor(t) {
    this.writer = t, this.name = "EXT_materials_bump";
  }
  writeMaterial(t, e) {
    if (!t.isMeshStandardMaterial || t.bumpScale === 1 && !t.bumpMap)
      return;
    const i = this.writer, r = i.extensionsUsed, s = {};
    if (t.bumpMap) {
      const a = {
        index: i.processTexture(t.bumpMap),
        texCoord: t.bumpMap.channel
      };
      i.applyTextureTransform(a, t.bumpMap), s.bumpTexture = a;
    }
    s.bumpFactor = t.bumpScale, e.extensions = e.extensions || {}, e.extensions[this.name] = s, r[this.name] = !0;
  }
}
class vM {
  constructor(t) {
    this.writer = t, this.name = "EXT_mesh_gpu_instancing";
  }
  writeNode(t, e) {
    if (!t.isInstancedMesh)
      return;
    const i = this.writer, r = t, s = new Float32Array(r.count * 3), a = new Float32Array(r.count * 4), o = new Float32Array(r.count * 3), c = new vn(), h = new Gt(), l = new Ea(), f = new Gt();
    for (let m = 0; m < r.count; m++)
      r.getMatrixAt(m, c), c.decompose(h, l, f), h.toArray(s, m * 3), l.toArray(a, m * 4), f.toArray(o, m * 3);
    const d = {
      TRANSLATION: i.processAccessor(new gn(s, 3)),
      ROTATION: i.processAccessor(new gn(a, 4)),
      SCALE: i.processAccessor(new gn(o, 3))
    };
    r.instanceColor && (d._COLOR_0 = i.processAccessor(r.instanceColor)), e.extensions = e.extensions || {}, e.extensions[this.name] = { attributes: d }, i.extensionsUsed[this.name] = !0, i.extensionsRequired[this.name] = !0;
  }
}
af.Utils = {
  insertKeyframe: function(n, t) {
    const i = n.getValueSize(), r = new n.TimeBufferType(n.times.length + 1), s = new n.ValueBufferType(n.values.length + i), a = n.createInterpolant(new n.ValueBufferType(i));
    let o;
    if (n.times.length === 0) {
      r[0] = t;
      for (let c = 0; c < i; c++)
        s[c] = 0;
      o = 0;
    } else if (t < n.times[0]) {
      if (Math.abs(n.times[0] - t) < 1e-3)
        return 0;
      r[0] = t, r.set(n.times, 1), s.set(a.evaluate(t), 0), s.set(n.values, i), o = 0;
    } else if (t > n.times[n.times.length - 1]) {
      if (Math.abs(n.times[n.times.length - 1] - t) < 1e-3)
        return n.times.length - 1;
      r[r.length - 1] = t, r.set(n.times, 0), s.set(n.values, 0), s.set(a.evaluate(t), n.values.length), o = r.length - 1;
    } else
      for (let c = 0; c < n.times.length; c++) {
        if (Math.abs(n.times[c] - t) < 1e-3)
          return c;
        if (n.times[c] < t && n.times[c + 1] > t) {
          r.set(n.times.slice(0, c + 1), 0), r[c + 1] = t, r.set(n.times.slice(c + 1), c + 2), s.set(n.values.slice(0, (c + 1) * i), 0), s.set(a.evaluate(t), (c + 1) * i), s.set(n.values.slice((c + 1) * i), (c + 2) * i), o = c + 1;
          break;
        }
      }
    return n.times = r, n.values = s, o;
  },
  mergeMorphTargetTracks: function(n, t) {
    const e = [], i = {}, r = n.tracks;
    for (let s = 0; s < r.length; ++s) {
      let a = r[s];
      const o = Ge.parseTrackName(a.name), c = Ge.findNode(t, o.nodeName);
      if (o.propertyName !== "morphTargetInfluences" || o.propertyIndex === void 0) {
        e.push(a);
        continue;
      }
      if (a.createInterpolant !== a.InterpolantFactoryMethodDiscrete && a.createInterpolant !== a.InterpolantFactoryMethodLinear) {
        if (a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)
          throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
        console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), a = a.clone(), a.setInterpolation(Cg);
      }
      const h = c.morphTargetInfluences.length, l = c.morphTargetDictionary[o.propertyIndex];
      if (l === void 0)
        throw new Error("THREE.GLTFExporter: Morph target name not found: " + o.propertyIndex);
      let f;
      if (i[c.uuid] === void 0) {
        f = a.clone();
        const m = new f.ValueBufferType(h * f.times.length);
        for (let v = 0; v < f.times.length; v++)
          m[v * h + l] = f.values[v];
        f.name = (o.nodeName || "") + ".morphTargetInfluences", f.values = m, i[c.uuid] = f, e.push(f);
        continue;
      }
      const d = a.createInterpolant(new a.ValueBufferType(1));
      f = i[c.uuid];
      for (let m = 0; m < f.times.length; m++)
        f.values[m * h + l] = d.evaluate(f.times[m]);
      for (let m = 0; m < a.times.length; m++) {
        const v = this.insertKeyframe(f, a.times[m]);
        f.values[v * h + l] = a.values[m];
      }
    }
    return n.tracks = e, n;
  }
};
function xM(n, t, e) {
  e === void 0 && (e = {});
  var i = { type: "Feature" };
  return (e.id === 0 || e.id) && (i.id = e.id), e.bbox && (i.bbox = e.bbox), i.properties = t || {}, i.geometry = n, i;
}
function bM(n, t, e) {
  if (e === void 0 && (e = {}), !n)
    throw new Error("coordinates is required");
  if (!Array.isArray(n))
    throw new Error("coordinates must be an Array");
  if (n.length < 2)
    throw new Error("coordinates must be at least 2 numbers long");
  if (!Ll(n[0]) || !Ll(n[1]))
    throw new Error("coordinates must contain numbers");
  var i = {
    type: "Point",
    coordinates: n
  };
  return xM(i, t, e);
}
function Ll(n) {
  return !isNaN(n) && n !== null && !Array.isArray(n);
}
function of(n, t, e) {
  if (n !== null)
    for (var i, r, s, a, o, c, h, l = 0, f = 0, d, m = n.type, v = m === "FeatureCollection", E = m === "Feature", _ = v ? n.features.length : 1, p = 0; p < _; p++) {
      h = v ? n.features[p].geometry : E ? n.geometry : n, d = h ? h.type === "GeometryCollection" : !1, o = d ? h.geometries.length : 1;
      for (var R = 0; R < o; R++) {
        var M = 0, P = 0;
        if (a = d ? h.geometries[R] : h, a !== null) {
          c = a.coordinates;
          var W = a.type;
          switch (l = e && (W === "Polygon" || W === "MultiPolygon") ? 1 : 0, W) {
            case null:
              break;
            case "Point":
              if (t(
                c,
                f,
                p,
                M,
                P
              ) === !1)
                return !1;
              f++, M++;
              break;
            case "LineString":
            case "MultiPoint":
              for (i = 0; i < c.length; i++) {
                if (t(
                  c[i],
                  f,
                  p,
                  M,
                  P
                ) === !1)
                  return !1;
                f++, W === "MultiPoint" && M++;
              }
              W === "LineString" && M++;
              break;
            case "Polygon":
            case "MultiLineString":
              for (i = 0; i < c.length; i++) {
                for (r = 0; r < c[i].length - l; r++) {
                  if (t(
                    c[i][r],
                    f,
                    p,
                    M,
                    P
                  ) === !1)
                    return !1;
                  f++;
                }
                W === "MultiLineString" && M++, W === "Polygon" && P++;
              }
              W === "Polygon" && M++;
              break;
            case "MultiPolygon":
              for (i = 0; i < c.length; i++) {
                for (P = 0, r = 0; r < c[i].length; r++) {
                  for (s = 0; s < c[i][r].length - l; s++) {
                    if (t(
                      c[i][r][s],
                      f,
                      p,
                      M,
                      P
                    ) === !1)
                      return !1;
                    f++;
                  }
                  P++;
                }
                M++;
              }
              break;
            case "GeometryCollection":
              for (i = 0; i < a.geometries.length; i++)
                if (of(a.geometries[i], t, e) === !1)
                  return !1;
              break;
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
}
function EM(n) {
  if (!n)
    throw new Error("geojson is required");
  switch (n.type) {
    case "Feature":
      return Qd(n);
    case "FeatureCollection":
      return wM(n);
    case "Point":
    case "LineString":
    case "Polygon":
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
    case "GeometryCollection":
      return cf(n);
    default:
      throw new Error("unknown GeoJSON type");
  }
}
function Qd(n) {
  var t = { type: "Feature" };
  return Object.keys(n).forEach(function(e) {
    switch (e) {
      case "type":
      case "properties":
      case "geometry":
        return;
      default:
        t[e] = n[e];
    }
  }), t.properties = tm(n.properties), t.geometry = cf(n.geometry), t;
}
function tm(n) {
  var t = {};
  return n && Object.keys(n).forEach(function(e) {
    var i = n[e];
    typeof i == "object" ? i === null ? t[e] = null : Array.isArray(i) ? t[e] = i.map(function(r) {
      return r;
    }) : t[e] = tm(i) : t[e] = i;
  }), t;
}
function wM(n) {
  var t = { type: "FeatureCollection" };
  return Object.keys(n).forEach(function(e) {
    switch (e) {
      case "type":
      case "features":
        return;
      default:
        t[e] = n[e];
    }
  }), t.features = n.features.map(function(e) {
    return Qd(e);
  }), t;
}
function cf(n) {
  var t = { type: n.type };
  return n.bbox && (t.bbox = n.bbox), n.type === "GeometryCollection" ? (t.geometries = n.geometries.map(function(e) {
    return cf(e);
  }), t) : (t.coordinates = em(n.coordinates), t);
}
function em(n) {
  var t = n;
  return typeof t[0] != "object" ? t.slice() : t.map(function(e) {
    return em(e);
  });
}
function MM(n, t) {
  return t === void 0 && (t = {}), SM(n, "mercator", t);
}
function SM(n, t, e) {
  e === void 0 && (e = {}), e = e || {};
  var i = e.mutate;
  if (!n)
    throw new Error("geojson is required");
  return Array.isArray(n) && Ll(n[0]) ? n = t === "mercator" ? dp(n) : mp(n) : (i !== !0 && (n = EM(n)), of(n, function(r) {
    var s = t === "mercator" ? dp(r) : mp(r);
    r[0] = s[0], r[1] = s[1];
  })), n;
}
function dp(n) {
  var t = Math.PI / 180, e = 6378137, i = 20037508342789244e-9, r = Math.abs(n[0]) <= 180 ? n[0] : n[0] - AM(n[0]) * 360, s = [
    e * r * t,
    e * Math.log(Math.tan(Math.PI * 0.25 + 0.5 * n[1] * t))
  ];
  return s[0] > i && (s[0] = i), s[0] < -i && (s[0] = -i), s[1] > i && (s[1] = i), s[1] < -i && (s[1] = -i), s;
}
function mp(n) {
  var t = 180 / Math.PI, e = 6378137;
  return [
    n[0] * t / e,
    (Math.PI * 0.5 - 2 * Math.atan(Math.exp(-n[1] / e))) * t
  ];
}
function AM(n) {
  return n < 0 ? -1 : n > 0 ? 1 : 0;
}
function Ol(n) {
  var t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  return of(n, function(e) {
    t[0] > e[0] && (t[0] = e[0]), t[1] > e[1] && (t[1] = e[1]), t[2] < e[0] && (t[2] = e[0]), t[3] < e[1] && (t[3] = e[1]);
  }), t;
}
Ol.default = Ol;
function TM(n, t) {
  t === void 0 && (t = {});
  var e = Ol(n), i = (e[0] + e[2]) / 2, r = (e[1] + e[3]) / 2;
  return bM([i, r], t.properties, t);
}
const Bc = new Ue();
class CM extends Is {
  constructor() {
    super();
  }
  parseWithUrl() {
  }
  /**
   * 
   * @param {{size : number , currentSize : number}} data 
   */
  _emitProgress(t) {
    const e = {
      type: "progress",
      data: t
    };
    this.dispatchEvent(e);
  }
  /**
   * 
   * @param {{filed : string , style : Array<{range:[number , number] , color : string}> , defaultColor : string}} colors 
   */
  setColorJson(t) {
    this.colors = t;
  }
  /**
   * 
   * @param {ArrayBuffer} buffer 
   * @param {{height : string , center : boolean}} option 
   * 
   * 
   */
  async parseWithBuffer(t, e) {
    console.log("=======parse SHP=======");
    const i = await this._getGeoJson(t), r = MM(i, {
      mutate: !0
    }), s = TM(r);
    if (console.log("========parse SHP Done======"), this._emitProgress({
      currentSize: 0,
      size: r.features.length
    }), ["Polygon", "MultiPolygon"].includes(r.features[0].geometry.type)) {
      const a = this._dealPolygon(r.features, e.height), o = new vn().makeRotationX(-Math.PI / 2);
      e.center && o.multiply(new vn().makeTranslation(new Gt(s.geometry.coordinates[0], s.geometry.coordinates[1], 0).negate())), a.applyMatrix4(o);
      const c = new Bi(a, new Gw({
        side: Mi,
        vertexColors: !!this.colors
      }));
      return await this._toGlb(c);
    }
  }
  /**
   * 
   * @param {Object3D} object 
   */
  async _toGlb(t) {
    return await new af().parseAsync(t, {
      binary: !0
    });
  }
  /**
   * 
   * @param {Array<import("@turf/helpers").Feature<import("@turf/helpers").Polygon | import("@turf/helpers").MultiPolygon>>} data 
   * @param {string} height 
   */
  _dealPolygon(t, e) {
    const i = [];
    for (let s = 0; s < t.length; s++) {
      this._emitProgress({
        size: t.length,
        currentSize: s
      });
      const a = t[s];
      a.geometry.type === "Polygon" && e && (i.push(ap.polygonToGeometry(a.geometry, a.properties[e])), this.colors && this._setBufferGeometryColor(i.at(-1), this._getColor(a))), a.geometry.type === "MultiPolygon" && e && a.geometry.coordinates.forEach((o) => {
        i.push(ap.polygonToGeometry(
          {
            type: "Polygon",
            coordinates: o
          }
        ), a.properties[e]), this.colors && this._setBufferGeometryColor(i.at(-1), this._getColor(a));
      });
    }
    return Zw(i, !0);
  }
  /**
   * 
   * @param {import("@turf/helpers").Feature} fe 
   */
  _getColor(t) {
    const e = t.properties[this.colors.filed];
    let i;
    return e != null && (i = this.colors.style.find((r) => r.range[0] < e && r.range[1] > e)), i ? i.color : this.colors.defaultColor;
  }
  /**
   * 
   * @param {BufferGeometry} geometry 
   * @param {string} color 
   */
  _setBufferGeometryColor(t, e) {
    const i = t.getAttribute("position");
    Bc.set(e);
    const r = [];
    for (let a = 0; a < i.array.length; a += 3)
      r.push(
        Bc.r,
        Bc.g,
        Bc.b
      );
    const s = new gn(new Float32Array(r), 3);
    t.setAttribute("color", s);
  }
  /**
   * 
   * @param {Array<import("@turf/helpers").LineString | import("@turf/helpers").MultiLineString>} geojson 
   */
  _dealPolyline(t) {
  }
  /**
   * 
   * @param {ArrayBuffer | string} data 
   * @returns {import("@turf/helpers").FeatureCollection}
   */
  async _getGeoJson(t) {
    return await By(t);
  }
}
var nm = { exports: {} };
const Xe = /* @__PURE__ */ Fy(Ny);
(function(n) {
  const t = Xe;
  if (process.env.NODE_ENV === "production") {
    n.exports = Ui(t.join(__dirname, "Build/Cesium/index.cjs"));
    return;
  }
  n.exports = Ui(t.join(
    __dirname,
    "Build/CesiumUnminified/index.cjs"
  ));
})(nm);
var Be = nm.exports;
const RM = Be, IM = RM.defined;
var im = PM;
function PM(n, t) {
  return IM(n.extensionsUsed) && n.extensionsUsed.indexOf(t) >= 0;
}
const LM = Be, uf = im, De = LM.defined;
var Ln = he;
function he() {
}
he.objectLegacy = function(n, t) {
  if (De(n)) {
    for (const e in n)
      if (Object.prototype.hasOwnProperty.call(n, e)) {
        const i = n[e], r = t(i, e);
        if (De(r))
          return r;
      }
  }
};
he.object = function(n, t) {
  if (De(n)) {
    const e = n.length;
    for (let i = 0; i < e; i++) {
      const r = n[i], s = t(r, i);
      if (De(s))
        return s;
    }
  }
};
he.topLevel = function(n, t, e) {
  const i = n[t];
  return De(i) && !Array.isArray(i) ? he.objectLegacy(i, e) : he.object(i, e);
};
he.accessor = function(n, t) {
  return he.topLevel(n, "accessors", t);
};
he.accessorWithSemantic = function(n, t, e) {
  const i = {};
  return he.mesh(n, function(r) {
    return he.meshPrimitive(r, function(s) {
      const a = he.meshPrimitiveAttribute(
        s,
        function(o, c) {
          if (c.indexOf(t) === 0 && !De(i[o])) {
            i[o] = !0;
            const h = e(o);
            if (De(h))
              return h;
          }
        }
      );
      return De(a) ? a : he.meshPrimitiveTarget(s, function(o) {
        return he.meshPrimitiveTargetAttribute(
          o,
          function(c, h) {
            if (h.indexOf(t) === 0 && !De(i[c])) {
              i[c] = !0;
              const l = e(c);
              if (De(l))
                return l;
            }
          }
        );
      });
    });
  });
};
he.accessorContainingVertexAttributeData = function(n, t) {
  const e = {};
  return he.mesh(n, function(i) {
    return he.meshPrimitive(i, function(r) {
      const s = he.meshPrimitiveAttribute(
        r,
        function(a) {
          if (!De(e[a])) {
            e[a] = !0;
            const o = t(a);
            if (De(o))
              return o;
          }
        }
      );
      return De(s) ? s : he.meshPrimitiveTarget(r, function(a) {
        return he.meshPrimitiveTargetAttribute(
          a,
          function(o) {
            if (!De(e[o])) {
              e[o] = !0;
              const c = t(o);
              if (De(c))
                return c;
            }
          }
        );
      });
    });
  });
};
he.accessorContainingIndexData = function(n, t) {
  const e = {};
  return he.mesh(n, function(i) {
    return he.meshPrimitive(i, function(r) {
      const s = r.indices;
      if (De(s) && !De(e[s])) {
        e[s] = !0;
        const a = t(s);
        if (De(a))
          return a;
      }
    });
  });
};
he.animation = function(n, t) {
  return he.topLevel(n, "animations", t);
};
he.animationChannel = function(n, t) {
  const e = n.channels;
  return he.object(e, t);
};
he.animationSampler = function(n, t) {
  const e = n.samplers;
  return he.object(e, t);
};
he.buffer = function(n, t) {
  return he.topLevel(n, "buffers", t);
};
he.bufferView = function(n, t) {
  return he.topLevel(n, "bufferViews", t);
};
he.camera = function(n, t) {
  return he.topLevel(n, "cameras", t);
};
he.image = function(n, t) {
  return he.topLevel(n, "images", t);
};
he.material = function(n, t) {
  return he.topLevel(n, "materials", t);
};
he.materialValue = function(n, t) {
  let e = n.values;
  De(n.extensions) && De(n.extensions.KHR_techniques_webgl) && (e = n.extensions.KHR_techniques_webgl.values);
  for (const i in e)
    if (Object.prototype.hasOwnProperty.call(e, i)) {
      const r = t(e[i], i);
      if (De(r))
        return r;
    }
};
he.mesh = function(n, t) {
  return he.topLevel(n, "meshes", t);
};
he.meshPrimitive = function(n, t) {
  const e = n.primitives;
  if (De(e)) {
    const i = e.length;
    for (let r = 0; r < i; r++) {
      const s = e[r], a = t(s, r);
      if (De(a))
        return a;
    }
  }
};
he.meshPrimitiveAttribute = function(n, t) {
  const e = n.attributes;
  for (const i in e)
    if (Object.prototype.hasOwnProperty.call(e, i)) {
      const r = t(e[i], i);
      if (De(r))
        return r;
    }
};
he.meshPrimitiveTarget = function(n, t) {
  const e = n.targets;
  if (De(e)) {
    const i = e.length;
    for (let r = 0; r < i; ++r) {
      const s = t(e[r], r);
      if (De(s))
        return s;
    }
  }
};
he.meshPrimitiveTargetAttribute = function(n, t) {
  for (const e in n)
    if (Object.prototype.hasOwnProperty.call(n, e)) {
      const i = n[e], r = t(i, e);
      if (De(r))
        return r;
    }
};
he.node = function(n, t) {
  return he.topLevel(n, "nodes", t);
};
he.nodeInTree = function(n, t, e) {
  const i = n.nodes;
  if (De(i)) {
    const r = t.length;
    for (let s = 0; s < r; s++) {
      const a = t[s], o = i[a];
      if (De(o)) {
        let c = e(o, a);
        if (De(c))
          return c;
        const h = o.children;
        if (De(h) && (c = he.nodeInTree(n, h, e), De(c)))
          return c;
      }
    }
  }
};
he.nodeInScene = function(n, t, e) {
  const i = t.nodes;
  if (De(i))
    return he.nodeInTree(n, i, e);
};
he.program = function(n, t) {
  return uf(n, "KHR_techniques_webgl") ? he.object(
    n.extensions.KHR_techniques_webgl.programs,
    t
  ) : he.topLevel(n, "programs", t);
};
he.sampler = function(n, t) {
  return he.topLevel(n, "samplers", t);
};
he.scene = function(n, t) {
  return he.topLevel(n, "scenes", t);
};
he.shader = function(n, t) {
  return uf(n, "KHR_techniques_webgl") ? he.object(
    n.extensions.KHR_techniques_webgl.shaders,
    t
  ) : he.topLevel(n, "shaders", t);
};
he.skin = function(n, t) {
  return he.topLevel(n, "skins", t);
};
he.skinJoint = function(n, t) {
  const e = n.joints;
  if (De(e)) {
    const i = e.length;
    for (let r = 0; r < i; r++) {
      const s = e[r], a = t(s);
      if (De(a))
        return a;
    }
  }
};
he.techniqueAttribute = function(n, t) {
  const e = n.attributes;
  for (const i in e)
    if (Object.prototype.hasOwnProperty.call(e, i)) {
      const r = t(e[i], i);
      if (De(r))
        return r;
    }
};
he.techniqueUniform = function(n, t) {
  const e = n.uniforms;
  for (const i in e)
    if (Object.prototype.hasOwnProperty.call(e, i)) {
      const r = t(e[i], i);
      if (De(r))
        return r;
    }
};
he.techniqueParameter = function(n, t) {
  const e = n.parameters;
  for (const i in e)
    if (Object.prototype.hasOwnProperty.call(e, i)) {
      const r = t(e[i], i);
      if (De(r))
        return r;
    }
};
he.technique = function(n, t) {
  return uf(n, "KHR_techniques_webgl") ? he.object(
    n.extensions.KHR_techniques_webgl.techniques,
    t
  ) : he.topLevel(n, "techniques", t);
};
he.texture = function(n, t) {
  return he.topLevel(n, "textures", t);
};
const OM = Be, al = Ln, _p = OM.defined;
var lf = DM;
function DM(n) {
  return al.shader(n, function(t) {
    kc(t);
  }), al.buffer(n, function(t) {
    kc(t);
  }), al.image(n, function(t) {
    kc(t);
  }), kc(n), n;
}
function kc(n) {
  n.extras = _p(n.extras) ? n.extras : {}, n.extras._pipeline = _p(n.extras._pipeline) ? n.extras._pipeline : {};
}
const NM = Be, FM = NM.defined;
var UM = BM;
function BM(n, t) {
  const e = n.extensionsRequired;
  if (FM(e)) {
    const i = e.indexOf(t);
    i >= 0 && e.splice(i, 1), e.length === 0 && delete n.extensionsRequired;
  }
}
const kM = Be, zM = UM, GM = kM.defined;
var rm = VM;
function VM(n, t) {
  const e = n.extensionsUsed;
  if (GM(e)) {
    const i = e.indexOf(t);
    i >= 0 && e.splice(i, 1), zM(n, t), e.length === 0 && delete n.extensionsUsed;
  }
}
const lo = Be, sm = lf, HM = rm, jM = lo.defaultValue, Xa = lo.defined, WM = lo.getMagic, am = lo.getStringFromTypedArray, Dl = lo.RuntimeError, qM = 4;
var om = $M;
function $M(n) {
  if (WM(n) !== "glTF")
    throw new Dl("File is not valid binary glTF");
  const e = cm(n, 0, 5), i = e[1];
  if (i !== 1 && i !== 2)
    throw new Dl("Binary glTF version is not 1 or 2");
  return i === 1 ? XM(n, e) : YM(n, e);
}
function cm(n, t, e) {
  const i = new DataView(n.buffer), r = new Array(e);
  for (let s = 0; s < e; ++s)
    r[s] = i.getUint32(
      n.byteOffset + t + s * qM,
      !0
    );
  return r;
}
function XM(n, t) {
  const e = t[2], i = t[3];
  if (t[4] !== 0)
    throw new Dl("Binary glTF scene format is not JSON");
  const s = 20, a = s + i, o = am(n, s, i), c = JSON.parse(o);
  sm(c);
  const h = n.subarray(a, e), l = c.buffers;
  if (Xa(l) && Object.keys(l).length > 0) {
    const f = jM(
      l.binary_glTF,
      l.KHR_binary_glTF
    );
    Xa(f) && (f.extras._pipeline.source = h, delete f.uri);
  }
  return HM(c, "KHR_binary_glTF"), c;
}
function YM(n, t) {
  const e = t[2];
  let i = 12, r, s;
  for (; i < e; ) {
    const a = cm(n, i, 2), o = a[0], c = a[1];
    i += 8;
    const h = n.subarray(i, i + o);
    if (i += o, c === 1313821514) {
      const l = am(h);
      r = JSON.parse(l), sm(r);
    } else
      c === 5130562 && (s = h);
  }
  if (Xa(r) && Xa(s)) {
    const a = r.buffers;
    if (Xa(a) && a.length > 0) {
      const o = a[0];
      o.extras._pipeline.source = s;
    }
  }
  return r;
}
const KM = Be, ZM = KM.defaultValue;
var JM = QM;
function QM(n, t) {
  t = ZM(t, 0);
  let e = JSON.stringify(n);
  const i = 8, r = Buffer.byteLength(e), s = (t + r) % i, a = s === 0 ? 0 : i - s;
  let o = "";
  for (let c = 0; c < a; ++c)
    o += " ";
  return e += o, Buffer.from(e);
}
var um = { exports: {} };
/* @preserve
 * The MIT License (MIT)
 * 
 * Copyright (c) 2013-2018 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
(function(n, t) {
  (function(e) {
    n.exports = e();
  })(function() {
    return function e(i, r, s) {
      function a(h, l) {
        if (!r[h]) {
          if (!i[h]) {
            var f = typeof _dereq_ == "function" && _dereq_;
            if (!l && f)
              return f(h, !0);
            if (o)
              return o(h, !0);
            var d = new Error("Cannot find module '" + h + "'");
            throw d.code = "MODULE_NOT_FOUND", d;
          }
          var m = r[h] = { exports: {} };
          i[h][0].call(m.exports, function(v) {
            var E = i[h][1][v];
            return a(E || v);
          }, m, m.exports, e, i, r, s);
        }
        return r[h].exports;
      }
      for (var o = typeof _dereq_ == "function" && _dereq_, c = 0; c < s.length; c++)
        a(s[c]);
      return a;
    }({ 1: [function(e, i, r) {
      i.exports = function(s) {
        var a = s._SomePromiseArray;
        function o(c) {
          var h = new a(c), l = h.promise();
          return h.setHowMany(1), h.setUnwrap(), h.init(), l;
        }
        s.any = function(c) {
          return o(c);
        }, s.prototype.any = function() {
          return o(this);
        };
      };
    }, {}], 2: [function(e, i, r) {
      var s;
      try {
        throw new Error();
      } catch (v) {
        s = v;
      }
      var a = e("./schedule"), o = e("./queue");
      function c() {
        this._customScheduler = !1, this._isTickUsed = !1, this._lateQueue = new o(16), this._normalQueue = new o(16), this._haveDrainedQueues = !1;
        var v = this;
        this.drainQueues = function() {
          v._drainQueues();
        }, this._schedule = a;
      }
      c.prototype.setScheduler = function(v) {
        var E = this._schedule;
        return this._schedule = v, this._customScheduler = !0, E;
      }, c.prototype.hasCustomScheduler = function() {
        return this._customScheduler;
      }, c.prototype.haveItemsQueued = function() {
        return this._isTickUsed || this._haveDrainedQueues;
      }, c.prototype.fatalError = function(v, E) {
        E ? (process.stderr.write("Fatal " + (v instanceof Error ? v.stack : v) + `
`), process.exit(2)) : this.throwLater(v);
      }, c.prototype.throwLater = function(v, E) {
        if (arguments.length === 1 && (E = v, v = function() {
          throw E;
        }), typeof setTimeout < "u")
          setTimeout(function() {
            v(E);
          }, 0);
        else
          try {
            this._schedule(function() {
              v(E);
            });
          } catch {
            throw new Error(`No async scheduler available

    See http://goo.gl/MqrFmX
`);
          }
      };
      function h(v, E, _) {
        this._lateQueue.push(v, E, _), this._queueTick();
      }
      function l(v, E, _) {
        this._normalQueue.push(v, E, _), this._queueTick();
      }
      function f(v) {
        this._normalQueue._pushOne(v), this._queueTick();
      }
      c.prototype.invokeLater = h, c.prototype.invoke = l, c.prototype.settlePromises = f;
      function d(v) {
        for (; v.length() > 0; )
          m(v);
      }
      function m(v) {
        var E = v.shift();
        if (typeof E != "function")
          E._settlePromises();
        else {
          var _ = v.shift(), p = v.shift();
          E.call(_, p);
        }
      }
      c.prototype._drainQueues = function() {
        d(this._normalQueue), this._reset(), this._haveDrainedQueues = !0, d(this._lateQueue);
      }, c.prototype._queueTick = function() {
        this._isTickUsed || (this._isTickUsed = !0, this._schedule(this.drainQueues));
      }, c.prototype._reset = function() {
        this._isTickUsed = !1;
      }, i.exports = c, i.exports.firstLineError = s;
    }, { "./queue": 26, "./schedule": 29 }], 3: [function(e, i, r) {
      i.exports = function(s, a, o, c) {
        var h = !1, l = function(v, E) {
          this._reject(E);
        }, f = function(v, E) {
          E.promiseRejectionQueued = !0, E.bindingPromise._then(l, l, null, this, v);
        }, d = function(v, E) {
          this._bitField & 50397184 || this._resolveCallback(E.target);
        }, m = function(v, E) {
          E.promiseRejectionQueued || this._reject(v);
        };
        s.prototype.bind = function(v) {
          h || (h = !0, s.prototype._propagateFrom = c.propagateFromFunction(), s.prototype._boundValue = c.boundValueFunction());
          var E = o(v), _ = new s(a);
          _._propagateFrom(this, 1);
          var p = this._target();
          if (_._setBoundTo(E), E instanceof s) {
            var R = {
              promiseRejectionQueued: !1,
              promise: _,
              target: p,
              bindingPromise: E
            };
            p._then(a, f, void 0, _, R), E._then(
              d,
              m,
              void 0,
              _,
              R
            ), _._setOnCancel(E);
          } else
            _._resolveCallback(p);
          return _;
        }, s.prototype._setBoundTo = function(v) {
          v !== void 0 ? (this._bitField = this._bitField | 2097152, this._boundTo = v) : this._bitField = this._bitField & -2097153;
        }, s.prototype._isBound = function() {
          return (this._bitField & 2097152) === 2097152;
        }, s.bind = function(v, E) {
          return s.resolve(E).bind(v);
        };
      };
    }, {}], 4: [function(e, i, r) {
      var s;
      typeof Promise < "u" && (s = Promise);
      function a() {
        try {
          Promise === o && (Promise = s);
        } catch {
        }
        return o;
      }
      var o = e("./promise")();
      o.noConflict = a, i.exports = o;
    }, { "./promise": 22 }], 5: [function(e, i, r) {
      var s = Object.create;
      if (s) {
        var a = s(null), o = s(null);
        a[" size"] = o[" size"] = 0;
      }
      i.exports = function(c) {
        var h = e("./util"), l = h.canEvaluate;
        h.isIdentifier;
        var f;
        function d(_, p) {
          var R;
          if (_ != null && (R = _[p]), typeof R != "function") {
            var M = "Object " + h.classString(_) + " has no method '" + h.toString(p) + "'";
            throw new c.TypeError(M);
          }
          return R;
        }
        function m(_) {
          var p = this.pop(), R = d(_, p);
          return R.apply(_, this);
        }
        c.prototype.call = function(_) {
          var p = [].slice.call(arguments, 1);
          return p.push(_), this._then(m, void 0, void 0, p, void 0);
        };
        function v(_) {
          return _[this];
        }
        function E(_) {
          var p = +this;
          return p < 0 && (p = Math.max(0, p + _.length)), _[p];
        }
        c.prototype.get = function(_) {
          var p = typeof _ == "number", R;
          if (p)
            R = E;
          else if (l) {
            var M = f(_);
            R = M !== null ? M : v;
          } else
            R = v;
          return this._then(R, void 0, void 0, _, void 0);
        };
      };
    }, { "./util": 36 }], 6: [function(e, i, r) {
      i.exports = function(s, a, o, c) {
        var h = e("./util"), l = h.tryCatch, f = h.errorObj, d = s._async;
        s.prototype.break = s.prototype.cancel = function() {
          if (!c.cancellation())
            return this._warn("cancellation is disabled");
          for (var m = this, v = m; m._isCancellable(); ) {
            if (!m._cancelBy(v)) {
              v._isFollowing() ? v._followee().cancel() : v._cancelBranched();
              break;
            }
            var E = m._cancellationParent;
            if (E == null || !E._isCancellable()) {
              m._isFollowing() ? m._followee().cancel() : m._cancelBranched();
              break;
            } else
              m._isFollowing() && m._followee().cancel(), m._setWillBeCancelled(), v = m, m = E;
          }
        }, s.prototype._branchHasCancelled = function() {
          this._branchesRemainingToCancel--;
        }, s.prototype._enoughBranchesHaveCancelled = function() {
          return this._branchesRemainingToCancel === void 0 || this._branchesRemainingToCancel <= 0;
        }, s.prototype._cancelBy = function(m) {
          return m === this ? (this._branchesRemainingToCancel = 0, this._invokeOnCancel(), !0) : (this._branchHasCancelled(), this._enoughBranchesHaveCancelled() ? (this._invokeOnCancel(), !0) : !1);
        }, s.prototype._cancelBranched = function() {
          this._enoughBranchesHaveCancelled() && this._cancel();
        }, s.prototype._cancel = function() {
          this._isCancellable() && (this._setCancelled(), d.invoke(this._cancelPromises, this, void 0));
        }, s.prototype._cancelPromises = function() {
          this._length() > 0 && this._settlePromises();
        }, s.prototype._unsetOnCancel = function() {
          this._onCancelField = void 0;
        }, s.prototype._isCancellable = function() {
          return this.isPending() && !this._isCancelled();
        }, s.prototype.isCancellable = function() {
          return this.isPending() && !this.isCancelled();
        }, s.prototype._doInvokeOnCancel = function(m, v) {
          if (h.isArray(m))
            for (var E = 0; E < m.length; ++E)
              this._doInvokeOnCancel(m[E], v);
          else if (m !== void 0)
            if (typeof m == "function") {
              if (!v) {
                var _ = l(m).call(this._boundValue());
                _ === f && (this._attachExtraTrace(_.e), d.throwLater(_.e));
              }
            } else
              m._resultCancelled(this);
        }, s.prototype._invokeOnCancel = function() {
          var m = this._onCancel();
          this._unsetOnCancel(), d.invoke(this._doInvokeOnCancel, this, m);
        }, s.prototype._invokeInternalOnCancel = function() {
          this._isCancellable() && (this._doInvokeOnCancel(this._onCancel(), !0), this._unsetOnCancel());
        }, s.prototype._resultCancelled = function() {
          this.cancel();
        };
      };
    }, { "./util": 36 }], 7: [function(e, i, r) {
      i.exports = function(s) {
        var a = e("./util"), o = e("./es5").keys, c = a.tryCatch, h = a.errorObj;
        function l(f, d, m) {
          return function(v) {
            var E = m._boundValue();
            t:
              for (var _ = 0; _ < f.length; ++_) {
                var p = f[_];
                if (p === Error || p != null && p.prototype instanceof Error) {
                  if (v instanceof p)
                    return c(d).call(E, v);
                } else if (typeof p == "function") {
                  var R = c(p).call(E, v);
                  if (R === h)
                    return R;
                  if (R)
                    return c(d).call(E, v);
                } else if (a.isObject(v)) {
                  for (var M = o(p), P = 0; P < M.length; ++P) {
                    var W = M[P];
                    if (p[W] != v[W])
                      continue t;
                  }
                  return c(d).call(E, v);
                }
              }
            return s;
          };
        }
        return l;
      };
    }, { "./es5": 13, "./util": 36 }], 8: [function(e, i, r) {
      i.exports = function(s) {
        var a = !1, o = [];
        s.prototype._promiseCreated = function() {
        }, s.prototype._pushContext = function() {
        }, s.prototype._popContext = function() {
          return null;
        }, s._peekContext = s.prototype._peekContext = function() {
        };
        function c() {
          this._trace = new c.CapturedTrace(l());
        }
        c.prototype._pushContext = function() {
          this._trace !== void 0 && (this._trace._promiseCreated = null, o.push(this._trace));
        }, c.prototype._popContext = function() {
          if (this._trace !== void 0) {
            var f = o.pop(), d = f._promiseCreated;
            return f._promiseCreated = null, d;
          }
          return null;
        };
        function h() {
          if (a)
            return new c();
        }
        function l() {
          var f = o.length - 1;
          if (f >= 0)
            return o[f];
        }
        return c.CapturedTrace = null, c.create = h, c.deactivateLongStackTraces = function() {
        }, c.activateLongStackTraces = function() {
          var f = s.prototype._pushContext, d = s.prototype._popContext, m = s._peekContext, v = s.prototype._peekContext, E = s.prototype._promiseCreated;
          c.deactivateLongStackTraces = function() {
            s.prototype._pushContext = f, s.prototype._popContext = d, s._peekContext = m, s.prototype._peekContext = v, s.prototype._promiseCreated = E, a = !1;
          }, a = !0, s.prototype._pushContext = c.prototype._pushContext, s.prototype._popContext = c.prototype._popContext, s._peekContext = s.prototype._peekContext = l, s.prototype._promiseCreated = function() {
            var _ = this._peekContext();
            _ && _._promiseCreated == null && (_._promiseCreated = this);
          };
        }, c;
      };
    }, {}], 9: [function(e, i, r) {
      i.exports = function(s, a, o, c) {
        var h = s._async, l = e("./errors").Warning, f = e("./util"), d = e("./es5"), m = f.canAttachTrace, v, E, _ = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/, p = /\((?:timers\.js):\d+:\d+\)/, R = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/, M = null, P = null, W = !1, C, D = f.env("BLUEBIRD_DEBUG") != 0, N = !!(f.env("BLUEBIRD_WARNINGS") != 0 && (D || f.env("BLUEBIRD_WARNINGS"))), A = !!(f.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (D || f.env("BLUEBIRD_LONG_STACK_TRACES"))), I = f.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (N || !!f.env("BLUEBIRD_W_FORGOTTEN_RETURN")), it;
        (function() {
          var ft = [];
          function nt() {
            for (var Rt = 0; Rt < ft.length; ++Rt)
              ft[Rt]._notifyUnhandledRejection();
            J();
          }
          function J() {
            ft.length = 0;
          }
          it = function(Rt) {
            ft.push(Rt), setTimeout(nt, 1);
          }, d.defineProperty(s, "_unhandledRejectionCheck", {
            value: nt
          }), d.defineProperty(s, "_unhandledRejectionClear", {
            value: J
          });
        })(), s.prototype.suppressUnhandledRejections = function() {
          var ft = this._target();
          ft._bitField = ft._bitField & -1048577 | 524288;
        }, s.prototype._ensurePossibleRejectionHandled = function() {
          this._bitField & 524288 || (this._setRejectionIsUnhandled(), it(this));
        }, s.prototype._notifyUnhandledRejectionIsHandled = function() {
          S(
            "rejectionHandled",
            v,
            void 0,
            this
          );
        }, s.prototype._setReturnedNonUndefined = function() {
          this._bitField = this._bitField | 268435456;
        }, s.prototype._returnedNonUndefined = function() {
          return (this._bitField & 268435456) !== 0;
        }, s.prototype._notifyUnhandledRejection = function() {
          if (this._isRejectionUnhandled()) {
            var ft = this._settledValue();
            this._setUnhandledRejectionIsNotified(), S(
              "unhandledRejection",
              E,
              ft,
              this
            );
          }
        }, s.prototype._setUnhandledRejectionIsNotified = function() {
          this._bitField = this._bitField | 262144;
        }, s.prototype._unsetUnhandledRejectionIsNotified = function() {
          this._bitField = this._bitField & -262145;
        }, s.prototype._isUnhandledRejectionNotified = function() {
          return (this._bitField & 262144) > 0;
        }, s.prototype._setRejectionIsUnhandled = function() {
          this._bitField = this._bitField | 1048576;
        }, s.prototype._unsetRejectionIsUnhandled = function() {
          this._bitField = this._bitField & -1048577, this._isUnhandledRejectionNotified() && (this._unsetUnhandledRejectionIsNotified(), this._notifyUnhandledRejectionIsHandled());
        }, s.prototype._isRejectionUnhandled = function() {
          return (this._bitField & 1048576) > 0;
        }, s.prototype._warn = function(ft, nt, J) {
          return Et(ft, nt, J || this);
        }, s.onPossiblyUnhandledRejection = function(ft) {
          var nt = s._getContext();
          E = f.contextBind(nt, ft);
        }, s.onUnhandledRejectionHandled = function(ft) {
          var nt = s._getContext();
          v = f.contextBind(nt, ft);
        };
        var V = function() {
        };
        s.longStackTraces = function() {
          if (h.haveItemsQueued() && !z.longStackTraces)
            throw new Error(`cannot enable long stack traces after promises have been created

    See http://goo.gl/MqrFmX
`);
          if (!z.longStackTraces && tt()) {
            var ft = s.prototype._captureStackTrace, nt = s.prototype._attachExtraTrace, J = s.prototype._dereferenceTrace;
            z.longStackTraces = !0, V = function() {
              if (h.haveItemsQueued() && !z.longStackTraces)
                throw new Error(`cannot enable long stack traces after promises have been created

    See http://goo.gl/MqrFmX
`);
              s.prototype._captureStackTrace = ft, s.prototype._attachExtraTrace = nt, s.prototype._dereferenceTrace = J, a.deactivateLongStackTraces(), z.longStackTraces = !1;
            }, s.prototype._captureStackTrace = L, s.prototype._attachExtraTrace = j, s.prototype._dereferenceTrace = Y, a.activateLongStackTraces();
          }
        }, s.hasLongStackTraces = function() {
          return z.longStackTraces && tt();
        };
        var mt = {
          unhandledrejection: {
            before: function() {
              var ft = f.global.onunhandledrejection;
              return f.global.onunhandledrejection = null, ft;
            },
            after: function(ft) {
              f.global.onunhandledrejection = ft;
            }
          },
          rejectionhandled: {
            before: function() {
              var ft = f.global.onrejectionhandled;
              return f.global.onrejectionhandled = null, ft;
            },
            after: function(ft) {
              f.global.onrejectionhandled = ft;
            }
          }
        }, k = function() {
          var ft = function(J, Rt) {
            if (J) {
              var Nt;
              try {
                return Nt = J.before(), !f.global.dispatchEvent(Rt);
              } finally {
                J.after(Nt);
              }
            } else
              return !f.global.dispatchEvent(Rt);
          };
          try {
            if (typeof CustomEvent == "function") {
              var nt = new CustomEvent("CustomEvent");
              return f.global.dispatchEvent(nt), function(J, Rt) {
                J = J.toLowerCase();
                var Nt = {
                  detail: Rt,
                  cancelable: !0
                }, Yt = new CustomEvent(J, Nt);
                return d.defineProperty(
                  Yt,
                  "promise",
                  { value: Rt.promise }
                ), d.defineProperty(
                  Yt,
                  "reason",
                  { value: Rt.reason }
                ), ft(mt[J], Yt);
              };
            } else if (typeof Event == "function") {
              var nt = new Event("CustomEvent");
              return f.global.dispatchEvent(nt), function(Rt, Nt) {
                Rt = Rt.toLowerCase();
                var Yt = new Event(Rt, {
                  cancelable: !0
                });
                return Yt.detail = Nt, d.defineProperty(Yt, "promise", { value: Nt.promise }), d.defineProperty(Yt, "reason", { value: Nt.reason }), ft(mt[Rt], Yt);
              };
            } else {
              var nt = document.createEvent("CustomEvent");
              return nt.initCustomEvent("testingtheevent", !1, !0, {}), f.global.dispatchEvent(nt), function(Rt, Nt) {
                Rt = Rt.toLowerCase();
                var Yt = document.createEvent("CustomEvent");
                return Yt.initCustomEvent(
                  Rt,
                  !1,
                  !0,
                  Nt
                ), ft(mt[Rt], Yt);
              };
            }
          } catch {
          }
          return function() {
            return !1;
          };
        }(), B = function() {
          return f.isNode ? function() {
            return process.emit.apply(process, arguments);
          } : f.global ? function(ft) {
            var nt = "on" + ft.toLowerCase(), J = f.global[nt];
            return J ? (J.apply(f.global, [].slice.call(arguments, 1)), !0) : !1;
          } : function() {
            return !1;
          };
        }();
        function G(ft, nt) {
          return { promise: nt };
        }
        var H = {
          promiseCreated: G,
          promiseFulfilled: G,
          promiseRejected: G,
          promiseResolved: G,
          promiseCancelled: G,
          promiseChained: function(ft, nt, J) {
            return { promise: nt, child: J };
          },
          warning: function(ft, nt) {
            return { warning: nt };
          },
          unhandledRejection: function(ft, nt, J) {
            return { reason: nt, promise: J };
          },
          rejectionHandled: G
        }, w = function(ft) {
          var nt = !1;
          try {
            nt = B.apply(null, arguments);
          } catch (Rt) {
            h.throwLater(Rt), nt = !0;
          }
          var J = !1;
          try {
            J = k(
              ft,
              H[ft].apply(null, arguments)
            );
          } catch (Rt) {
            h.throwLater(Rt), J = !0;
          }
          return J || nt;
        };
        s.config = function(ft) {
          if (ft = Object(ft), "longStackTraces" in ft && (ft.longStackTraces ? s.longStackTraces() : !ft.longStackTraces && s.hasLongStackTraces() && V()), "warnings" in ft) {
            var nt = ft.warnings;
            z.warnings = !!nt, I = z.warnings, f.isObject(nt) && "wForgottenReturn" in nt && (I = !!nt.wForgottenReturn);
          }
          if ("cancellation" in ft && ft.cancellation && !z.cancellation) {
            if (h.haveItemsQueued())
              throw new Error(
                "cannot enable cancellation after promises are in use"
              );
            s.prototype._clearCancellationData = rt, s.prototype._propagateFrom = b, s.prototype._onCancel = vt, s.prototype._setOnCancel = F, s.prototype._attachCancellationCallback = _t, s.prototype._execute = pt, q = b, z.cancellation = !0;
          }
          if ("monitoring" in ft && (ft.monitoring && !z.monitoring ? (z.monitoring = !0, s.prototype._fireEvent = w) : !ft.monitoring && z.monitoring && (z.monitoring = !1, s.prototype._fireEvent = ut)), "asyncHooks" in ft && f.nodeSupportsAsyncResource) {
            var J = z.asyncHooks, Rt = !!ft.asyncHooks;
            J !== Rt && (z.asyncHooks = Rt, Rt ? o() : c());
          }
          return s;
        };
        function ut() {
          return !1;
        }
        s.prototype._fireEvent = ut, s.prototype._execute = function(ft, nt, J) {
          try {
            ft(nt, J);
          } catch (Rt) {
            return Rt;
          }
        }, s.prototype._onCancel = function() {
        }, s.prototype._setOnCancel = function(ft) {
        }, s.prototype._attachCancellationCallback = function(ft) {
        }, s.prototype._captureStackTrace = function() {
        }, s.prototype._attachExtraTrace = function() {
        }, s.prototype._dereferenceTrace = function() {
        }, s.prototype._clearCancellationData = function() {
        }, s.prototype._propagateFrom = function(ft, nt) {
        };
        function pt(ft, nt, J) {
          var Rt = this;
          try {
            ft(nt, J, function(Nt) {
              if (typeof Nt != "function")
                throw new TypeError("onCancel must be a function, got: " + f.toString(Nt));
              Rt._attachCancellationCallback(Nt);
            });
          } catch (Nt) {
            return Nt;
          }
        }
        function _t(ft) {
          if (!this._isCancellable())
            return this;
          var nt = this._onCancel();
          nt !== void 0 ? f.isArray(nt) ? nt.push(ft) : this._setOnCancel([nt, ft]) : this._setOnCancel(ft);
        }
        function vt() {
          return this._onCancelField;
        }
        function F(ft) {
          this._onCancelField = ft;
        }
        function rt() {
          this._cancellationParent = void 0, this._onCancelField = void 0;
        }
        function b(ft, nt) {
          if (nt & 1) {
            this._cancellationParent = ft;
            var J = ft._branchesRemainingToCancel;
            J === void 0 && (J = 0), ft._branchesRemainingToCancel = J + 1;
          }
          nt & 2 && ft._isBound() && this._setBoundTo(ft._boundTo);
        }
        function lt(ft, nt) {
          nt & 2 && ft._isBound() && this._setBoundTo(ft._boundTo);
        }
        var q = lt;
        function U() {
          var ft = this._boundTo;
          return ft !== void 0 && ft instanceof s ? ft.isFulfilled() ? ft.value() : void 0 : ft;
        }
        function L() {
          this._trace = new ht(this._peekContext());
        }
        function j(ft, nt) {
          if (m(ft)) {
            var J = this._trace;
            if (J !== void 0 && nt && (J = J._parent), J !== void 0)
              J.attachExtraTrace(ft);
            else if (!ft.__stackCleaned__) {
              var Rt = y(ft);
              f.notEnumerableProp(
                ft,
                "stack",
                Rt.message + `
` + Rt.stack.join(`
`)
              ), f.notEnumerableProp(ft, "__stackCleaned__", !0);
            }
          }
        }
        function Y() {
          this._trace = void 0;
        }
        function K(ft, nt, J, Rt, Nt) {
          if (ft === void 0 && nt !== null && I) {
            if (Nt !== void 0 && Nt._returnedNonUndefined() || !(Rt._bitField & 65535))
              return;
            J && (J = J + " ");
            var Yt = "", Ht = "";
            if (nt._trace) {
              for (var Pt = nt._trace.stack.split(`
`), Mt = wt(Pt), $t = Mt.length - 1; $t >= 0; --$t) {
                var Kt = Mt[$t];
                if (!p.test(Kt)) {
                  var te = Kt.match(R);
                  te && (Yt = "at " + te[1] + ":" + te[2] + ":" + te[3] + " ");
                  break;
                }
              }
              if (Mt.length > 0) {
                for (var Qt = Mt[0], $t = 0; $t < Pt.length; ++$t)
                  if (Pt[$t] === Qt) {
                    $t > 0 && (Ht = `
` + Pt[$t - 1]);
                    break;
                  }
              }
            }
            var ee = "a promise was created in a " + J + "handler " + Yt + "but was not returned from it, see http://goo.gl/rRqMUw" + Ht;
            Rt._warn(ee, !0, nt);
          }
        }
        function yt(ft, nt) {
          var J = ft + " is deprecated and will be removed in a future version.";
          return nt && (J += " Use " + nt + " instead."), Et(J);
        }
        function Et(ft, nt, J) {
          if (z.warnings) {
            var Rt = new l(ft), Nt;
            if (nt)
              J._attachExtraTrace(Rt);
            else if (z.longStackTraces && (Nt = s._peekContext()))
              Nt.attachExtraTrace(Rt);
            else {
              var Yt = y(Rt);
              Rt.stack = Yt.message + `
` + Yt.stack.join(`
`);
            }
            w("warning", Rt) || g(Rt, "", !0);
          }
        }
        function Ct(ft, nt) {
          for (var J = 0; J < nt.length - 1; ++J)
            nt[J].push("From previous event:"), nt[J] = nt[J].join(`
`);
          return J < nt.length && (nt[J] = nt[J].join(`
`)), ft + `
` + nt.join(`
`);
        }
        function Lt(ft) {
          for (var nt = 0; nt < ft.length; ++nt)
            (ft[nt].length === 0 || nt + 1 < ft.length && ft[nt][0] === ft[nt + 1][0]) && (ft.splice(nt, 1), nt--);
        }
        function Wt(ft) {
          for (var nt = ft[0], J = 1; J < ft.length; ++J) {
            for (var Rt = ft[J], Nt = nt.length - 1, Yt = nt[Nt], Ht = -1, Pt = Rt.length - 1; Pt >= 0; --Pt)
              if (Rt[Pt] === Yt) {
                Ht = Pt;
                break;
              }
            for (var Pt = Ht; Pt >= 0; --Pt) {
              var Mt = Rt[Pt];
              if (nt[Nt] === Mt)
                nt.pop(), Nt--;
              else
                break;
            }
            nt = Rt;
          }
        }
        function wt(ft) {
          for (var nt = [], J = 0; J < ft.length; ++J) {
            var Rt = ft[J], Nt = Rt === "    (No stack trace)" || M.test(Rt), Yt = Nt && gt(Rt);
            Nt && !Yt && (W && Rt.charAt(0) !== " " && (Rt = "    " + Rt), nt.push(Rt));
          }
          return nt;
        }
        function Q(ft) {
          for (var nt = ft.stack.replace(/\s+$/g, "").split(`
`), J = 0; J < nt.length; ++J) {
            var Rt = nt[J];
            if (Rt === "    (No stack trace)" || M.test(Rt))
              break;
          }
          return J > 0 && ft.name != "SyntaxError" && (nt = nt.slice(J)), nt;
        }
        function y(ft) {
          var nt = ft.stack, J = ft.toString();
          return nt = typeof nt == "string" && nt.length > 0 ? Q(ft) : ["    (No stack trace)"], {
            message: J,
            stack: ft.name == "SyntaxError" ? nt : wt(nt)
          };
        }
        function g(ft, nt, J) {
          if (typeof console < "u") {
            var Rt;
            if (f.isObject(ft)) {
              var Nt = ft.stack;
              Rt = nt + P(Nt, ft);
            } else
              Rt = nt + String(ft);
            typeof C == "function" ? C(Rt, J) : (typeof console.log == "function" || typeof console.log == "object") && console.log(Rt);
          }
        }
        function S(ft, nt, J, Rt) {
          var Nt = !1;
          try {
            typeof nt == "function" && (Nt = !0, ft === "rejectionHandled" ? nt(Rt) : nt(J, Rt));
          } catch (Yt) {
            h.throwLater(Yt);
          }
          ft === "unhandledRejection" ? !w(ft, J, Rt) && !Nt && g(J, "Unhandled rejection ") : w(ft, Rt);
        }
        function O(ft) {
          var nt;
          if (typeof ft == "function")
            nt = "[function " + (ft.name || "anonymous") + "]";
          else {
            nt = ft && typeof ft.toString == "function" ? ft.toString() : f.toString(ft);
            var J = /\[object [a-zA-Z0-9$_]+\]/;
            if (J.test(nt))
              try {
                var Rt = JSON.stringify(ft);
                nt = Rt;
              } catch {
              }
            nt.length === 0 && (nt = "(empty array)");
          }
          return "(<" + Z(nt) + ">, no stack trace)";
        }
        function Z(ft) {
          var nt = 41;
          return ft.length < nt ? ft : ft.substr(0, nt - 3) + "...";
        }
        function tt() {
          return typeof It == "function";
        }
        var gt = function() {
          return !1;
        }, st = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
        function Tt(ft) {
          var nt = ft.match(st);
          if (nt)
            return {
              fileName: nt[1],
              line: parseInt(nt[2], 10)
            };
        }
        function Ft(ft, nt) {
          if (tt()) {
            for (var J = (ft.stack || "").split(`
`), Rt = (nt.stack || "").split(`
`), Nt = -1, Yt = -1, Ht, Pt, Mt = 0; Mt < J.length; ++Mt) {
              var $t = Tt(J[Mt]);
              if ($t) {
                Ht = $t.fileName, Nt = $t.line;
                break;
              }
            }
            for (var Mt = 0; Mt < Rt.length; ++Mt) {
              var $t = Tt(Rt[Mt]);
              if ($t) {
                Pt = $t.fileName, Yt = $t.line;
                break;
              }
            }
            Nt < 0 || Yt < 0 || !Ht || !Pt || Ht !== Pt || Nt >= Yt || (gt = function(Kt) {
              if (_.test(Kt))
                return !0;
              var te = Tt(Kt);
              return !!(te && te.fileName === Ht && Nt <= te.line && te.line <= Yt);
            });
          }
        }
        function ht(ft) {
          this._parent = ft, this._promisesCreated = 0;
          var nt = this._length = 1 + (ft === void 0 ? 0 : ft._length);
          It(this, ht), nt > 32 && this.uncycle();
        }
        f.inherits(ht, Error), a.CapturedTrace = ht, ht.prototype.uncycle = function() {
          var ft = this._length;
          if (!(ft < 2)) {
            for (var nt = [], J = {}, Rt = 0, Nt = this; Nt !== void 0; ++Rt)
              nt.push(Nt), Nt = Nt._parent;
            ft = this._length = Rt;
            for (var Rt = ft - 1; Rt >= 0; --Rt) {
              var Yt = nt[Rt].stack;
              J[Yt] === void 0 && (J[Yt] = Rt);
            }
            for (var Rt = 0; Rt < ft; ++Rt) {
              var Ht = nt[Rt].stack, Pt = J[Ht];
              if (Pt !== void 0 && Pt !== Rt) {
                Pt > 0 && (nt[Pt - 1]._parent = void 0, nt[Pt - 1]._length = 1), nt[Rt]._parent = void 0, nt[Rt]._length = 1;
                var Mt = Rt > 0 ? nt[Rt - 1] : this;
                Pt < ft - 1 ? (Mt._parent = nt[Pt + 1], Mt._parent.uncycle(), Mt._length = Mt._parent._length + 1) : (Mt._parent = void 0, Mt._length = 1);
                for (var $t = Mt._length + 1, Kt = Rt - 2; Kt >= 0; --Kt)
                  nt[Kt]._length = $t, $t++;
                return;
              }
            }
          }
        }, ht.prototype.attachExtraTrace = function(ft) {
          if (!ft.__stackCleaned__) {
            this.uncycle();
            for (var nt = y(ft), J = nt.message, Rt = [nt.stack], Nt = this; Nt !== void 0; )
              Rt.push(wt(Nt.stack.split(`
`))), Nt = Nt._parent;
            Wt(Rt), Lt(Rt), f.notEnumerableProp(ft, "stack", Ct(J, Rt)), f.notEnumerableProp(ft, "__stackCleaned__", !0);
          }
        };
        var It = function() {
          var nt = /^\s*at\s*/, J = function(Ht, Pt) {
            return typeof Ht == "string" ? Ht : Pt.name !== void 0 && Pt.message !== void 0 ? Pt.toString() : O(Pt);
          };
          if (typeof Error.stackTraceLimit == "number" && typeof Error.captureStackTrace == "function") {
            Error.stackTraceLimit += 6, M = nt, P = J;
            var Rt = Error.captureStackTrace;
            return gt = function(Ht) {
              return _.test(Ht);
            }, function(Ht, Pt) {
              Error.stackTraceLimit += 6, Rt(Ht, Pt), Error.stackTraceLimit -= 6;
            };
          }
          var Nt = new Error();
          if (typeof Nt.stack == "string" && Nt.stack.split(`
`)[0].indexOf("stackDetection@") >= 0)
            return M = /@/, P = J, W = !0, function(Pt) {
              Pt.stack = new Error().stack;
            };
          var Yt;
          try {
            throw new Error();
          } catch (Ht) {
            Yt = "stack" in Ht;
          }
          return !("stack" in Nt) && Yt && typeof Error.stackTraceLimit == "number" ? (M = nt, P = J, function(Pt) {
            Error.stackTraceLimit += 6;
            try {
              throw new Error();
            } catch (Mt) {
              Pt.stack = Mt.stack;
            }
            Error.stackTraceLimit -= 6;
          }) : (P = function(Ht, Pt) {
            return typeof Ht == "string" ? Ht : (typeof Pt == "object" || typeof Pt == "function") && Pt.name !== void 0 && Pt.message !== void 0 ? Pt.toString() : O(Pt);
          }, null);
        }();
        typeof console < "u" && typeof console.warn < "u" && (C = function(ft) {
          console.warn(ft);
        }, f.isNode && process.stderr.isTTY ? C = function(ft, nt) {
          var J = nt ? "\x1B[33m" : "\x1B[31m";
          console.warn(J + ft + `\x1B[0m
`);
        } : !f.isNode && typeof new Error().stack == "string" && (C = function(ft, nt) {
          console.warn(
            "%c" + ft,
            nt ? "color: darkorange" : "color: red"
          );
        }));
        var z = {
          warnings: N,
          longStackTraces: !1,
          cancellation: !1,
          monitoring: !1,
          asyncHooks: !1
        };
        return A && s.longStackTraces(), {
          asyncHooks: function() {
            return z.asyncHooks;
          },
          longStackTraces: function() {
            return z.longStackTraces;
          },
          warnings: function() {
            return z.warnings;
          },
          cancellation: function() {
            return z.cancellation;
          },
          monitoring: function() {
            return z.monitoring;
          },
          propagateFromFunction: function() {
            return q;
          },
          boundValueFunction: function() {
            return U;
          },
          checkForgottenReturns: K,
          setBounds: Ft,
          warn: Et,
          deprecated: yt,
          CapturedTrace: ht,
          fireDomEvent: k,
          fireGlobalEvent: B
        };
      };
    }, { "./errors": 12, "./es5": 13, "./util": 36 }], 10: [function(e, i, r) {
      i.exports = function(s) {
        function a() {
          return this.value;
        }
        function o() {
          throw this.reason;
        }
        s.prototype.return = s.prototype.thenReturn = function(c) {
          return c instanceof s && c.suppressUnhandledRejections(), this._then(
            a,
            void 0,
            void 0,
            { value: c },
            void 0
          );
        }, s.prototype.throw = s.prototype.thenThrow = function(c) {
          return this._then(
            o,
            void 0,
            void 0,
            { reason: c },
            void 0
          );
        }, s.prototype.catchThrow = function(c) {
          if (arguments.length <= 1)
            return this._then(
              void 0,
              o,
              void 0,
              { reason: c },
              void 0
            );
          var h = arguments[1], l = function() {
            throw h;
          };
          return this.caught(c, l);
        }, s.prototype.catchReturn = function(c) {
          if (arguments.length <= 1)
            return c instanceof s && c.suppressUnhandledRejections(), this._then(
              void 0,
              a,
              void 0,
              { value: c },
              void 0
            );
          var h = arguments[1];
          h instanceof s && h.suppressUnhandledRejections();
          var l = function() {
            return h;
          };
          return this.caught(c, l);
        };
      };
    }, {}], 11: [function(e, i, r) {
      i.exports = function(s, a) {
        var o = s.reduce, c = s.all;
        function h() {
          return c(this);
        }
        function l(f, d) {
          return o(f, d, a, a);
        }
        s.prototype.each = function(f) {
          return o(this, f, a, 0)._then(h, void 0, void 0, this, void 0);
        }, s.prototype.mapSeries = function(f) {
          return o(this, f, a, a);
        }, s.each = function(f, d) {
          return o(f, d, a, 0)._then(h, void 0, void 0, f, void 0);
        }, s.mapSeries = l;
      };
    }, {}], 12: [function(e, i, r) {
      var s = e("./es5"), a = s.freeze, o = e("./util"), c = o.inherits, h = o.notEnumerableProp;
      function l(C, D) {
        function N(A) {
          if (!(this instanceof N))
            return new N(A);
          h(
            this,
            "message",
            typeof A == "string" ? A : D
          ), h(this, "name", C), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : Error.call(this);
        }
        return c(N, Error), N;
      }
      var f, d, m = l("Warning", "warning"), v = l("CancellationError", "cancellation error"), E = l("TimeoutError", "timeout error"), _ = l("AggregateError", "aggregate error");
      try {
        f = TypeError, d = RangeError;
      } catch {
        f = l("TypeError", "type error"), d = l("RangeError", "range error");
      }
      for (var p = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" "), R = 0; R < p.length; ++R)
        typeof Array.prototype[p[R]] == "function" && (_.prototype[p[R]] = Array.prototype[p[R]]);
      s.defineProperty(_.prototype, "length", {
        value: 0,
        configurable: !1,
        writable: !0,
        enumerable: !0
      }), _.prototype.isOperational = !0;
      var M = 0;
      _.prototype.toString = function() {
        var C = Array(M * 4 + 1).join(" "), D = `
` + C + `AggregateError of:
`;
        M++, C = Array(M * 4 + 1).join(" ");
        for (var N = 0; N < this.length; ++N) {
          for (var A = this[N] === this ? "[Circular AggregateError]" : this[N] + "", I = A.split(`
`), it = 0; it < I.length; ++it)
            I[it] = C + I[it];
          A = I.join(`
`), D += A + `
`;
        }
        return M--, D;
      };
      function P(C) {
        if (!(this instanceof P))
          return new P(C);
        h(this, "name", "OperationalError"), h(this, "message", C), this.cause = C, this.isOperational = !0, C instanceof Error ? (h(this, "message", C.message), h(this, "stack", C.stack)) : Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
      }
      c(P, Error);
      var W = Error.__BluebirdErrorTypes__;
      W || (W = a({
        CancellationError: v,
        TimeoutError: E,
        OperationalError: P,
        RejectionError: P,
        AggregateError: _
      }), s.defineProperty(Error, "__BluebirdErrorTypes__", {
        value: W,
        writable: !1,
        enumerable: !1,
        configurable: !1
      })), i.exports = {
        Error,
        TypeError: f,
        RangeError: d,
        CancellationError: W.CancellationError,
        OperationalError: W.OperationalError,
        TimeoutError: W.TimeoutError,
        AggregateError: W.AggregateError,
        Warning: m
      };
    }, { "./es5": 13, "./util": 36 }], 13: [function(e, i, r) {
      var s = /* @__PURE__ */ function() {
        return this === void 0;
      }();
      if (s)
        i.exports = {
          freeze: Object.freeze,
          defineProperty: Object.defineProperty,
          getDescriptor: Object.getOwnPropertyDescriptor,
          keys: Object.keys,
          names: Object.getOwnPropertyNames,
          getPrototypeOf: Object.getPrototypeOf,
          isArray: Array.isArray,
          isES5: s,
          propertyIsWritable: function(E, _) {
            var p = Object.getOwnPropertyDescriptor(E, _);
            return !!(!p || p.writable || p.set);
          }
        };
      else {
        var a = {}.hasOwnProperty, o = {}.toString, c = {}.constructor.prototype, h = function(E) {
          var _ = [];
          for (var p in E)
            a.call(E, p) && _.push(p);
          return _;
        }, l = function(E, _) {
          return { value: E[_] };
        }, f = function(E, _, p) {
          return E[_] = p.value, E;
        }, d = function(E) {
          return E;
        }, m = function(E) {
          try {
            return Object(E).constructor.prototype;
          } catch {
            return c;
          }
        }, v = function(E) {
          try {
            return o.call(E) === "[object Array]";
          } catch {
            return !1;
          }
        };
        i.exports = {
          isArray: v,
          keys: h,
          names: h,
          defineProperty: f,
          getDescriptor: l,
          freeze: d,
          getPrototypeOf: m,
          isES5: s,
          propertyIsWritable: function() {
            return !0;
          }
        };
      }
    }, {}], 14: [function(e, i, r) {
      i.exports = function(s, a) {
        var o = s.map;
        s.prototype.filter = function(c, h) {
          return o(this, c, h, a);
        }, s.filter = function(c, h, l) {
          return o(c, h, l, a);
        };
      };
    }, {}], 15: [function(e, i, r) {
      i.exports = function(s, a, o) {
        var c = e("./util"), h = s.CancellationError, l = c.errorObj, f = e("./catch_filter")(o);
        function d(R, M, P) {
          this.promise = R, this.type = M, this.handler = P, this.called = !1, this.cancelPromise = null;
        }
        d.prototype.isFinallyHandler = function() {
          return this.type === 0;
        };
        function m(R) {
          this.finallyHandler = R;
        }
        m.prototype._resultCancelled = function() {
          v(this.finallyHandler);
        };
        function v(R, M) {
          return R.cancelPromise != null ? (arguments.length > 1 ? R.cancelPromise._reject(M) : R.cancelPromise._cancel(), R.cancelPromise = null, !0) : !1;
        }
        function E() {
          return p.call(this, this.promise._target()._settledValue());
        }
        function _(R) {
          if (!v(this, R))
            return l.e = R, l;
        }
        function p(R) {
          var M = this.promise, P = this.handler;
          if (!this.called) {
            this.called = !0;
            var W = this.isFinallyHandler() ? P.call(M._boundValue()) : P.call(M._boundValue(), R);
            if (W === o)
              return W;
            if (W !== void 0) {
              M._setReturnedNonUndefined();
              var C = a(W, M);
              if (C instanceof s) {
                if (this.cancelPromise != null)
                  if (C._isCancelled()) {
                    var D = new h("late cancellation observer");
                    return M._attachExtraTrace(D), l.e = D, l;
                  } else
                    C.isPending() && C._attachCancellationCallback(
                      new m(this)
                    );
                return C._then(
                  E,
                  _,
                  void 0,
                  this,
                  void 0
                );
              }
            }
          }
          return M.isRejected() ? (v(this), l.e = R, l) : (v(this), R);
        }
        return s.prototype._passThrough = function(R, M, P, W) {
          return typeof R != "function" ? this.then() : this._then(
            P,
            W,
            void 0,
            new d(this, M, R),
            void 0
          );
        }, s.prototype.lastly = s.prototype.finally = function(R) {
          return this._passThrough(
            R,
            0,
            p,
            p
          );
        }, s.prototype.tap = function(R) {
          return this._passThrough(R, 1, p);
        }, s.prototype.tapCatch = function(R) {
          var M = arguments.length;
          if (M === 1)
            return this._passThrough(
              R,
              1,
              void 0,
              p
            );
          var P = new Array(M - 1), W = 0, C;
          for (C = 0; C < M - 1; ++C) {
            var D = arguments[C];
            if (c.isObject(D))
              P[W++] = D;
            else
              return s.reject(new TypeError(
                "tapCatch statement predicate: expecting an object but got " + c.classString(D)
              ));
          }
          P.length = W;
          var N = arguments[C];
          return this._passThrough(
            f(P, N, this),
            1,
            void 0,
            p
          );
        }, d;
      };
    }, { "./catch_filter": 7, "./util": 36 }], 16: [function(e, i, r) {
      i.exports = function(s, a, o, c, h, l) {
        var f = e("./errors"), d = f.TypeError, m = e("./util"), v = m.errorObj, E = m.tryCatch, _ = [];
        function p(M, P, W) {
          for (var C = 0; C < P.length; ++C) {
            W._pushContext();
            var D = E(P[C])(M);
            if (W._popContext(), D === v) {
              W._pushContext();
              var N = s.reject(v.e);
              return W._popContext(), N;
            }
            var A = c(D, W);
            if (A instanceof s)
              return A;
          }
          return null;
        }
        function R(M, P, W, C) {
          if (l.cancellation()) {
            var D = new s(o), N = this._finallyPromise = new s(o);
            this._promise = D.lastly(function() {
              return N;
            }), D._captureStackTrace(), D._setOnCancel(this);
          } else {
            var A = this._promise = new s(o);
            A._captureStackTrace();
          }
          this._stack = C, this._generatorFunction = M, this._receiver = P, this._generator = void 0, this._yieldHandlers = typeof W == "function" ? [W].concat(_) : _, this._yieldedPromise = null, this._cancellationPhase = !1;
        }
        m.inherits(R, h), R.prototype._isResolved = function() {
          return this._promise === null;
        }, R.prototype._cleanup = function() {
          this._promise = this._generator = null, l.cancellation() && this._finallyPromise !== null && (this._finallyPromise._fulfill(), this._finallyPromise = null);
        }, R.prototype._promiseCancelled = function() {
          if (!this._isResolved()) {
            var M = typeof this._generator.return < "u", P;
            if (M)
              this._promise._pushContext(), P = E(this._generator.return).call(
                this._generator,
                void 0
              ), this._promise._popContext();
            else {
              var W = new s.CancellationError(
                "generator .return() sentinel"
              );
              s.coroutine.returnSentinel = W, this._promise._attachExtraTrace(W), this._promise._pushContext(), P = E(this._generator.throw).call(
                this._generator,
                W
              ), this._promise._popContext();
            }
            this._cancellationPhase = !0, this._yieldedPromise = null, this._continue(P);
          }
        }, R.prototype._promiseFulfilled = function(M) {
          this._yieldedPromise = null, this._promise._pushContext();
          var P = E(this._generator.next).call(this._generator, M);
          this._promise._popContext(), this._continue(P);
        }, R.prototype._promiseRejected = function(M) {
          this._yieldedPromise = null, this._promise._attachExtraTrace(M), this._promise._pushContext();
          var P = E(this._generator.throw).call(this._generator, M);
          this._promise._popContext(), this._continue(P);
        }, R.prototype._resultCancelled = function() {
          if (this._yieldedPromise instanceof s) {
            var M = this._yieldedPromise;
            this._yieldedPromise = null, M.cancel();
          }
        }, R.prototype.promise = function() {
          return this._promise;
        }, R.prototype._run = function() {
          this._generator = this._generatorFunction.call(this._receiver), this._receiver = this._generatorFunction = void 0, this._promiseFulfilled(void 0);
        }, R.prototype._continue = function(M) {
          var P = this._promise;
          if (M === v)
            return this._cleanup(), this._cancellationPhase ? P.cancel() : P._rejectCallback(M.e, !1);
          var W = M.value;
          if (M.done === !0)
            return this._cleanup(), this._cancellationPhase ? P.cancel() : P._resolveCallback(W);
          var C = c(W, this._promise);
          if (!(C instanceof s) && (C = p(
            C,
            this._yieldHandlers,
            this._promise
          ), C === null)) {
            this._promiseRejected(
              new d(
                `A value %s was yielded that could not be treated as a promise

    See http://goo.gl/MqrFmX

`.replace("%s", String(W)) + `From coroutine:
` + this._stack.split(`
`).slice(1, -7).join(`
`)
              )
            );
            return;
          }
          C = C._target();
          var D = C._bitField;
          D & 50397184 ? D & 33554432 ? s._async.invoke(
            this._promiseFulfilled,
            this,
            C._value()
          ) : D & 16777216 ? s._async.invoke(
            this._promiseRejected,
            this,
            C._reason()
          ) : this._promiseCancelled() : (this._yieldedPromise = C, C._proxy(this, null));
        }, s.coroutine = function(M, P) {
          if (typeof M != "function")
            throw new d(`generatorFunction must be a function

    See http://goo.gl/MqrFmX
`);
          var W = Object(P).yieldHandler, C = R, D = new Error().stack;
          return function() {
            var N = M.apply(this, arguments), A = new C(
              void 0,
              void 0,
              W,
              D
            ), I = A.promise();
            return A._generator = N, A._promiseFulfilled(void 0), I;
          };
        }, s.coroutine.addYieldHandler = function(M) {
          if (typeof M != "function")
            throw new d("expecting a function but got " + m.classString(M));
          _.push(M);
        }, s.spawn = function(M) {
          if (l.deprecated("Promise.spawn()", "Promise.coroutine()"), typeof M != "function")
            return a(`generatorFunction must be a function

    See http://goo.gl/MqrFmX
`);
          var P = new R(M, this), W = P.promise();
          return P._run(s.spawn), W;
        };
      };
    }, { "./errors": 12, "./util": 36 }], 17: [function(e, i, r) {
      i.exports = function(s, a, o, c, h) {
        var l = e("./util");
        l.canEvaluate, l.tryCatch, l.errorObj, s.join = function() {
          var f = arguments.length - 1, d;
          if (f > 0 && typeof arguments[f] == "function") {
            d = arguments[f];
            var v;
          }
          var m = [].slice.call(arguments);
          d && m.pop();
          var v = new a(m).promise();
          return d !== void 0 ? v.spread(d) : v;
        };
      };
    }, { "./util": 36 }], 18: [function(e, i, r) {
      i.exports = function(s, a, o, c, h, l) {
        var f = e("./util"), d = f.tryCatch, m = f.errorObj, v = s._async;
        function E(p, R, M, P) {
          this.constructor$(p), this._promise._captureStackTrace();
          var W = s._getContext();
          if (this._callback = f.contextBind(W, R), this._preservedValues = P === h ? new Array(this.length()) : null, this._limit = M, this._inFlight = 0, this._queue = [], v.invoke(this._asyncInit, this, void 0), f.isArray(p))
            for (var C = 0; C < p.length; ++C) {
              var D = p[C];
              D instanceof s && D.suppressUnhandledRejections();
            }
        }
        f.inherits(E, a), E.prototype._asyncInit = function() {
          this._init$(void 0, -2);
        }, E.prototype._init = function() {
        }, E.prototype._promiseFulfilled = function(p, R) {
          var M = this._values, P = this.length(), W = this._preservedValues, C = this._limit;
          if (R < 0) {
            if (R = R * -1 - 1, M[R] = p, C >= 1 && (this._inFlight--, this._drainQueue(), this._isResolved()))
              return !0;
          } else {
            if (C >= 1 && this._inFlight >= C)
              return M[R] = p, this._queue.push(R), !1;
            W !== null && (W[R] = p);
            var D = this._promise, N = this._callback, A = D._boundValue();
            D._pushContext();
            var I = d(N).call(A, p, R, P), it = D._popContext();
            if (l.checkForgottenReturns(
              I,
              it,
              W !== null ? "Promise.filter" : "Promise.map",
              D
            ), I === m)
              return this._reject(I.e), !0;
            var V = c(I, this._promise);
            if (V instanceof s) {
              V = V._target();
              var mt = V._bitField;
              if (mt & 50397184)
                if (mt & 33554432)
                  I = V._value();
                else
                  return mt & 16777216 ? (this._reject(V._reason()), !0) : (this._cancel(), !0);
              else
                return C >= 1 && this._inFlight++, M[R] = V, V._proxy(this, (R + 1) * -1), !1;
            }
            M[R] = I;
          }
          var k = ++this._totalResolved;
          return k >= P ? (W !== null ? this._filter(M, W) : this._resolve(M), !0) : !1;
        }, E.prototype._drainQueue = function() {
          for (var p = this._queue, R = this._limit, M = this._values; p.length > 0 && this._inFlight < R; ) {
            if (this._isResolved())
              return;
            var P = p.pop();
            this._promiseFulfilled(M[P], P);
          }
        }, E.prototype._filter = function(p, R) {
          for (var M = R.length, P = new Array(M), W = 0, C = 0; C < M; ++C)
            p[C] && (P[W++] = R[C]);
          P.length = W, this._resolve(P);
        }, E.prototype.preservedValues = function() {
          return this._preservedValues;
        };
        function _(p, R, M, P) {
          if (typeof R != "function")
            return o("expecting a function but got " + f.classString(R));
          var W = 0;
          if (M !== void 0)
            if (typeof M == "object" && M !== null) {
              if (typeof M.concurrency != "number")
                return s.reject(
                  new TypeError("'concurrency' must be a number but it is " + f.classString(M.concurrency))
                );
              W = M.concurrency;
            } else
              return s.reject(new TypeError(
                "options argument must be an object but it is " + f.classString(M)
              ));
          return W = typeof W == "number" && isFinite(W) && W >= 1 ? W : 0, new E(p, R, W, P).promise();
        }
        s.prototype.map = function(p, R) {
          return _(this, p, R, null);
        }, s.map = function(p, R, M, P) {
          return _(p, R, M, P);
        };
      };
    }, { "./util": 36 }], 19: [function(e, i, r) {
      i.exports = function(s, a, o, c, h) {
        var l = e("./util"), f = l.tryCatch;
        s.method = function(d) {
          if (typeof d != "function")
            throw new s.TypeError("expecting a function but got " + l.classString(d));
          return function() {
            var m = new s(a);
            m._captureStackTrace(), m._pushContext();
            var v = f(d).apply(this, arguments), E = m._popContext();
            return h.checkForgottenReturns(
              v,
              E,
              "Promise.method",
              m
            ), m._resolveFromSyncValue(v), m;
          };
        }, s.attempt = s.try = function(d) {
          if (typeof d != "function")
            return c("expecting a function but got " + l.classString(d));
          var m = new s(a);
          m._captureStackTrace(), m._pushContext();
          var v;
          if (arguments.length > 1) {
            h.deprecated("calling Promise.try with more than 1 argument");
            var E = arguments[1], _ = arguments[2];
            v = l.isArray(E) ? f(d).apply(_, E) : f(d).call(_, E);
          } else
            v = f(d)();
          var p = m._popContext();
          return h.checkForgottenReturns(
            v,
            p,
            "Promise.try",
            m
          ), m._resolveFromSyncValue(v), m;
        }, s.prototype._resolveFromSyncValue = function(d) {
          d === l.errorObj ? this._rejectCallback(d.e, !1) : this._resolveCallback(d, !0);
        };
      };
    }, { "./util": 36 }], 20: [function(e, i, r) {
      var s = e("./util"), a = s.maybeWrapAsError, o = e("./errors"), c = o.OperationalError, h = e("./es5");
      function l(v) {
        return v instanceof Error && h.getPrototypeOf(v) === Error.prototype;
      }
      var f = /^(?:name|message|stack|cause)$/;
      function d(v) {
        var E;
        if (l(v)) {
          E = new c(v), E.name = v.name, E.message = v.message, E.stack = v.stack;
          for (var _ = h.keys(v), p = 0; p < _.length; ++p) {
            var R = _[p];
            f.test(R) || (E[R] = v[R]);
          }
          return E;
        }
        return s.markAsOriginatingFromRejection(v), v;
      }
      function m(v, E) {
        return function(_, p) {
          if (v !== null) {
            if (_) {
              var R = d(a(_));
              v._attachExtraTrace(R), v._reject(R);
            } else if (!E)
              v._fulfill(p);
            else {
              var M = [].slice.call(arguments, 1);
              v._fulfill(M);
            }
            v = null;
          }
        };
      }
      i.exports = m;
    }, { "./errors": 12, "./es5": 13, "./util": 36 }], 21: [function(e, i, r) {
      i.exports = function(s) {
        var a = e("./util"), o = s._async, c = a.tryCatch, h = a.errorObj;
        function l(m, v) {
          var E = this;
          if (!a.isArray(m))
            return f.call(E, m, v);
          var _ = c(v).apply(E._boundValue(), [null].concat(m));
          _ === h && o.throwLater(_.e);
        }
        function f(m, v) {
          var E = this, _ = E._boundValue(), p = m === void 0 ? c(v).call(_, null) : c(v).call(_, null, m);
          p === h && o.throwLater(p.e);
        }
        function d(m, v) {
          var E = this;
          if (!m) {
            var _ = new Error(m + "");
            _.cause = m, m = _;
          }
          var p = c(v).call(E._boundValue(), m);
          p === h && o.throwLater(p.e);
        }
        s.prototype.asCallback = s.prototype.nodeify = function(m, v) {
          if (typeof m == "function") {
            var E = f;
            v !== void 0 && Object(v).spread && (E = l), this._then(
              E,
              d,
              void 0,
              this,
              m
            );
          }
          return this;
        };
      };
    }, { "./util": 36 }], 22: [function(e, i, r) {
      i.exports = function() {
        var s = function() {
          return new D(`circular promise resolution chain

    See http://goo.gl/MqrFmX
`);
        }, a = function() {
          return new F.PromiseInspection(this._target());
        }, o = function(q) {
          return F.reject(new D(q));
        };
        function c() {
        }
        var h = {}, l = e("./util");
        l.setReflectHandler(a);
        var f = function() {
          var q = process.domain;
          return q === void 0 ? null : q;
        }, d = function() {
          return null;
        }, m = function() {
          return {
            domain: f(),
            async: null
          };
        }, v = l.isNode && l.nodeSupportsAsyncResource ? e("async_hooks").AsyncResource : null, E = function() {
          return {
            domain: f(),
            async: new v("Bluebird::Promise")
          };
        }, _ = l.isNode ? m : d;
        l.notEnumerableProp(F, "_getContext", _);
        var p = function() {
          _ = E, l.notEnumerableProp(F, "_getContext", E);
        }, R = function() {
          _ = m, l.notEnumerableProp(F, "_getContext", m);
        }, M = e("./es5"), P = e("./async"), W = new P();
        M.defineProperty(F, "_async", { value: W });
        var C = e("./errors"), D = F.TypeError = C.TypeError;
        F.RangeError = C.RangeError;
        var N = F.CancellationError = C.CancellationError;
        F.TimeoutError = C.TimeoutError, F.OperationalError = C.OperationalError, F.RejectionError = C.OperationalError, F.AggregateError = C.AggregateError;
        var A = function() {
        }, I = {}, it = {}, V = e("./thenables")(F, A), mt = e("./promise_array")(
          F,
          A,
          V,
          o,
          c
        ), k = e("./context")(F), B = k.create, G = e("./debuggability")(
          F,
          k,
          p,
          R
        );
        G.CapturedTrace;
        var H = e("./finally")(F, V, it), w = e("./catch_filter")(it), ut = e("./nodeback"), pt = l.errorObj, _t = l.tryCatch;
        function vt(q, U) {
          if (q == null || q.constructor !== F)
            throw new D(`the promise constructor cannot be invoked directly

    See http://goo.gl/MqrFmX
`);
          if (typeof U != "function")
            throw new D("expecting a function but got " + l.classString(U));
        }
        function F(q) {
          q !== A && vt(this, q), this._bitField = 0, this._fulfillmentHandler0 = void 0, this._rejectionHandler0 = void 0, this._promise0 = void 0, this._receiver0 = void 0, this._resolveFromExecutor(q), this._promiseCreated(), this._fireEvent("promiseCreated", this);
        }
        F.prototype.toString = function() {
          return "[object Promise]";
        }, F.prototype.caught = F.prototype.catch = function(q) {
          var U = arguments.length;
          if (U > 1) {
            var L = new Array(U - 1), j = 0, Y;
            for (Y = 0; Y < U - 1; ++Y) {
              var K = arguments[Y];
              if (l.isObject(K))
                L[j++] = K;
              else
                return o("Catch statement predicate: expecting an object but got " + l.classString(K));
            }
            if (L.length = j, q = arguments[Y], typeof q != "function")
              throw new D("The last argument to .catch() must be a function, got " + l.toString(q));
            return this.then(void 0, w(L, q, this));
          }
          return this.then(void 0, q);
        }, F.prototype.reflect = function() {
          return this._then(
            a,
            a,
            void 0,
            this,
            void 0
          );
        }, F.prototype.then = function(q, U) {
          if (G.warnings() && arguments.length > 0 && typeof q != "function" && typeof U != "function") {
            var L = ".then() only accepts functions but was passed: " + l.classString(q);
            arguments.length > 1 && (L += ", " + l.classString(U)), this._warn(L);
          }
          return this._then(q, U, void 0, void 0, void 0);
        }, F.prototype.done = function(q, U) {
          var L = this._then(q, U, void 0, void 0, void 0);
          L._setIsFinal();
        }, F.prototype.spread = function(q) {
          return typeof q != "function" ? o("expecting a function but got " + l.classString(q)) : this.all()._then(q, void 0, void 0, I, void 0);
        }, F.prototype.toJSON = function() {
          var q = {
            isFulfilled: !1,
            isRejected: !1,
            fulfillmentValue: void 0,
            rejectionReason: void 0
          };
          return this.isFulfilled() ? (q.fulfillmentValue = this.value(), q.isFulfilled = !0) : this.isRejected() && (q.rejectionReason = this.reason(), q.isRejected = !0), q;
        }, F.prototype.all = function() {
          return arguments.length > 0 && this._warn(".all() was passed arguments but it does not take any"), new mt(this).promise();
        }, F.prototype.error = function(q) {
          return this.caught(l.originatesFromRejection, q);
        }, F.getNewLibraryCopy = i.exports, F.is = function(q) {
          return q instanceof F;
        }, F.fromNode = F.fromCallback = function(q) {
          var U = new F(A);
          U._captureStackTrace();
          var L = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : !1, j = _t(q)(ut(U, L));
          return j === pt && U._rejectCallback(j.e, !0), U._isFateSealed() || U._setAsyncGuaranteed(), U;
        }, F.all = function(q) {
          return new mt(q).promise();
        }, F.cast = function(q) {
          var U = V(q);
          return U instanceof F || (U = new F(A), U._captureStackTrace(), U._setFulfilled(), U._rejectionHandler0 = q), U;
        }, F.resolve = F.fulfilled = F.cast, F.reject = F.rejected = function(q) {
          var U = new F(A);
          return U._captureStackTrace(), U._rejectCallback(q, !0), U;
        }, F.setScheduler = function(q) {
          if (typeof q != "function")
            throw new D("expecting a function but got " + l.classString(q));
          return W.setScheduler(q);
        }, F.prototype._then = function(q, U, L, j, Y) {
          var K = Y !== void 0, yt = K ? Y : new F(A), Et = this._target(), Ct = Et._bitField;
          K || (yt._propagateFrom(this, 3), yt._captureStackTrace(), j === void 0 && this._bitField & 2097152 && (Ct & 50397184 ? j = this._boundValue() : j = Et === this ? void 0 : this._boundTo), this._fireEvent("promiseChained", this, yt));
          var Lt = _();
          if (Ct & 50397184) {
            var Wt, wt, Q = Et._settlePromiseCtx;
            Ct & 33554432 ? (wt = Et._rejectionHandler0, Wt = q) : Ct & 16777216 ? (wt = Et._fulfillmentHandler0, Wt = U, Et._unsetRejectionIsUnhandled()) : (Q = Et._settlePromiseLateCancellationObserver, wt = new N("late cancellation observer"), Et._attachExtraTrace(wt), Wt = U), W.invoke(Q, Et, {
              handler: l.contextBind(Lt, Wt),
              promise: yt,
              receiver: j,
              value: wt
            });
          } else
            Et._addCallbacks(
              q,
              U,
              yt,
              j,
              Lt
            );
          return yt;
        }, F.prototype._length = function() {
          return this._bitField & 65535;
        }, F.prototype._isFateSealed = function() {
          return (this._bitField & 117506048) !== 0;
        }, F.prototype._isFollowing = function() {
          return (this._bitField & 67108864) === 67108864;
        }, F.prototype._setLength = function(q) {
          this._bitField = this._bitField & -65536 | q & 65535;
        }, F.prototype._setFulfilled = function() {
          this._bitField = this._bitField | 33554432, this._fireEvent("promiseFulfilled", this);
        }, F.prototype._setRejected = function() {
          this._bitField = this._bitField | 16777216, this._fireEvent("promiseRejected", this);
        }, F.prototype._setFollowing = function() {
          this._bitField = this._bitField | 67108864, this._fireEvent("promiseResolved", this);
        }, F.prototype._setIsFinal = function() {
          this._bitField = this._bitField | 4194304;
        }, F.prototype._isFinal = function() {
          return (this._bitField & 4194304) > 0;
        }, F.prototype._unsetCancelled = function() {
          this._bitField = this._bitField & -65537;
        }, F.prototype._setCancelled = function() {
          this._bitField = this._bitField | 65536, this._fireEvent("promiseCancelled", this);
        }, F.prototype._setWillBeCancelled = function() {
          this._bitField = this._bitField | 8388608;
        }, F.prototype._setAsyncGuaranteed = function() {
          if (!W.hasCustomScheduler()) {
            var q = this._bitField;
            this._bitField = q | (q & 536870912) >> 2 ^ 134217728;
          }
        }, F.prototype._setNoAsyncGuarantee = function() {
          this._bitField = (this._bitField | 536870912) & -134217729;
        }, F.prototype._receiverAt = function(q) {
          var U = q === 0 ? this._receiver0 : this[q * 4 - 4 + 3];
          if (U !== h)
            return U === void 0 && this._isBound() ? this._boundValue() : U;
        }, F.prototype._promiseAt = function(q) {
          return this[q * 4 - 4 + 2];
        }, F.prototype._fulfillmentHandlerAt = function(q) {
          return this[q * 4 - 4 + 0];
        }, F.prototype._rejectionHandlerAt = function(q) {
          return this[q * 4 - 4 + 1];
        }, F.prototype._boundValue = function() {
        }, F.prototype._migrateCallback0 = function(q) {
          q._bitField;
          var U = q._fulfillmentHandler0, L = q._rejectionHandler0, j = q._promise0, Y = q._receiverAt(0);
          Y === void 0 && (Y = h), this._addCallbacks(U, L, j, Y, null);
        }, F.prototype._migrateCallbackAt = function(q, U) {
          var L = q._fulfillmentHandlerAt(U), j = q._rejectionHandlerAt(U), Y = q._promiseAt(U), K = q._receiverAt(U);
          K === void 0 && (K = h), this._addCallbacks(L, j, Y, K, null);
        }, F.prototype._addCallbacks = function(q, U, L, j, Y) {
          var K = this._length();
          if (K >= 65531 && (K = 0, this._setLength(0)), K === 0)
            this._promise0 = L, this._receiver0 = j, typeof q == "function" && (this._fulfillmentHandler0 = l.contextBind(Y, q)), typeof U == "function" && (this._rejectionHandler0 = l.contextBind(Y, U));
          else {
            var yt = K * 4 - 4;
            this[yt + 2] = L, this[yt + 3] = j, typeof q == "function" && (this[yt + 0] = l.contextBind(Y, q)), typeof U == "function" && (this[yt + 1] = l.contextBind(Y, U));
          }
          return this._setLength(K + 1), K;
        }, F.prototype._proxy = function(q, U) {
          this._addCallbacks(void 0, void 0, U, q, null);
        }, F.prototype._resolveCallback = function(q, U) {
          if (!(this._bitField & 117506048)) {
            if (q === this)
              return this._rejectCallback(s(), !1);
            var L = V(q, this);
            if (!(L instanceof F))
              return this._fulfill(q);
            U && this._propagateFrom(L, 2);
            var j = L._target();
            if (j === this) {
              this._reject(s());
              return;
            }
            var Y = j._bitField;
            if (Y & 50397184)
              if (Y & 33554432)
                this._fulfill(j._value());
              else if (Y & 16777216)
                this._reject(j._reason());
              else {
                var Et = new N("late cancellation observer");
                j._attachExtraTrace(Et), this._reject(Et);
              }
            else {
              var K = this._length();
              K > 0 && j._migrateCallback0(this);
              for (var yt = 1; yt < K; ++yt)
                j._migrateCallbackAt(this, yt);
              this._setFollowing(), this._setLength(0), this._setFollowee(L);
            }
          }
        }, F.prototype._rejectCallback = function(q, U, L) {
          var j = l.ensureErrorObject(q), Y = j === q;
          if (!Y && !L && G.warnings()) {
            var K = "a promise was rejected with a non-error: " + l.classString(q);
            this._warn(K, !0);
          }
          this._attachExtraTrace(j, U ? Y : !1), this._reject(q);
        }, F.prototype._resolveFromExecutor = function(q) {
          if (q !== A) {
            var U = this;
            this._captureStackTrace(), this._pushContext();
            var L = !0, j = this._execute(q, function(Y) {
              U._resolveCallback(Y);
            }, function(Y) {
              U._rejectCallback(Y, L);
            });
            L = !1, this._popContext(), j !== void 0 && U._rejectCallback(j, !0);
          }
        }, F.prototype._settlePromiseFromHandler = function(q, U, L, j) {
          var Y = j._bitField;
          if (!(Y & 65536)) {
            j._pushContext();
            var K;
            U === I ? !L || typeof L.length != "number" ? (K = pt, K.e = new D("cannot .spread() a non-array: " + l.classString(L))) : K = _t(q).apply(this._boundValue(), L) : K = _t(q).call(U, L);
            var yt = j._popContext();
            Y = j._bitField, !(Y & 65536) && (K === it ? j._reject(L) : K === pt ? j._rejectCallback(K.e, !1) : (G.checkForgottenReturns(K, yt, "", j, this), j._resolveCallback(K)));
          }
        }, F.prototype._target = function() {
          for (var q = this; q._isFollowing(); )
            q = q._followee();
          return q;
        }, F.prototype._followee = function() {
          return this._rejectionHandler0;
        }, F.prototype._setFollowee = function(q) {
          this._rejectionHandler0 = q;
        }, F.prototype._settlePromise = function(q, U, L, j) {
          var Y = q instanceof F, K = this._bitField, yt = (K & 134217728) !== 0;
          K & 65536 ? (Y && q._invokeInternalOnCancel(), L instanceof H && L.isFinallyHandler() ? (L.cancelPromise = q, _t(U).call(L, j) === pt && q._reject(pt.e)) : U === a ? q._fulfill(a.call(L)) : L instanceof c ? L._promiseCancelled(q) : Y || q instanceof mt ? q._cancel() : L.cancel()) : typeof U == "function" ? Y ? (yt && q._setAsyncGuaranteed(), this._settlePromiseFromHandler(U, L, j, q)) : U.call(L, j, q) : L instanceof c ? L._isResolved() || (K & 33554432 ? L._promiseFulfilled(j, q) : L._promiseRejected(j, q)) : Y && (yt && q._setAsyncGuaranteed(), K & 33554432 ? q._fulfill(j) : q._reject(j));
        }, F.prototype._settlePromiseLateCancellationObserver = function(q) {
          var U = q.handler, L = q.promise, j = q.receiver, Y = q.value;
          typeof U == "function" ? L instanceof F ? this._settlePromiseFromHandler(U, j, Y, L) : U.call(j, Y, L) : L instanceof F && L._reject(Y);
        }, F.prototype._settlePromiseCtx = function(q) {
          this._settlePromise(q.promise, q.handler, q.receiver, q.value);
        }, F.prototype._settlePromise0 = function(q, U, L) {
          var j = this._promise0, Y = this._receiverAt(0);
          this._promise0 = void 0, this._receiver0 = void 0, this._settlePromise(j, q, Y, U);
        }, F.prototype._clearCallbackDataAtIndex = function(q) {
          var U = q * 4 - 4;
          this[U + 2] = this[U + 3] = this[U + 0] = this[U + 1] = void 0;
        }, F.prototype._fulfill = function(q) {
          var U = this._bitField;
          if (!((U & 117506048) >>> 16)) {
            if (q === this) {
              var L = s();
              return this._attachExtraTrace(L), this._reject(L);
            }
            this._setFulfilled(), this._rejectionHandler0 = q, (U & 65535) > 0 && (U & 134217728 ? this._settlePromises() : W.settlePromises(this), this._dereferenceTrace());
          }
        }, F.prototype._reject = function(q) {
          var U = this._bitField;
          if (!((U & 117506048) >>> 16)) {
            if (this._setRejected(), this._fulfillmentHandler0 = q, this._isFinal())
              return W.fatalError(q, l.isNode);
            (U & 65535) > 0 ? W.settlePromises(this) : this._ensurePossibleRejectionHandled();
          }
        }, F.prototype._fulfillPromises = function(q, U) {
          for (var L = 1; L < q; L++) {
            var j = this._fulfillmentHandlerAt(L), Y = this._promiseAt(L), K = this._receiverAt(L);
            this._clearCallbackDataAtIndex(L), this._settlePromise(Y, j, K, U);
          }
        }, F.prototype._rejectPromises = function(q, U) {
          for (var L = 1; L < q; L++) {
            var j = this._rejectionHandlerAt(L), Y = this._promiseAt(L), K = this._receiverAt(L);
            this._clearCallbackDataAtIndex(L), this._settlePromise(Y, j, K, U);
          }
        }, F.prototype._settlePromises = function() {
          var q = this._bitField, U = q & 65535;
          if (U > 0) {
            if (q & 16842752) {
              var L = this._fulfillmentHandler0;
              this._settlePromise0(this._rejectionHandler0, L, q), this._rejectPromises(U, L);
            } else {
              var j = this._rejectionHandler0;
              this._settlePromise0(this._fulfillmentHandler0, j, q), this._fulfillPromises(U, j);
            }
            this._setLength(0);
          }
          this._clearCancellationData();
        }, F.prototype._settledValue = function() {
          var q = this._bitField;
          if (q & 33554432)
            return this._rejectionHandler0;
          if (q & 16777216)
            return this._fulfillmentHandler0;
        }, typeof Symbol < "u" && Symbol.toStringTag && M.defineProperty(F.prototype, Symbol.toStringTag, {
          get: function() {
            return "Object";
          }
        });
        function rt(q) {
          this.promise._resolveCallback(q);
        }
        function b(q) {
          this.promise._rejectCallback(q, !1);
        }
        F.defer = F.pending = function() {
          G.deprecated("Promise.defer", "new Promise");
          var q = new F(A);
          return {
            promise: q,
            resolve: rt,
            reject: b
          };
        }, l.notEnumerableProp(
          F,
          "_makeSelfResolutionError",
          s
        ), e("./method")(
          F,
          A,
          V,
          o,
          G
        ), e("./bind")(F, A, V, G), e("./cancel")(F, mt, o, G), e("./direct_resolve")(F), e("./synchronous_inspection")(F), e("./join")(
          F,
          mt,
          V,
          A,
          W
        ), F.Promise = F, F.version = "3.7.2", e("./call_get.js")(F), e("./generators.js")(F, o, A, V, c, G), e("./map.js")(F, mt, o, V, A, G), e("./nodeify.js")(F), e("./promisify.js")(F, A), e("./props.js")(F, mt, V, o), e("./race.js")(F, A, V, o), e("./reduce.js")(F, mt, o, V, A, G), e("./settle.js")(F, mt, G), e("./some.js")(F, mt, o), e("./timers.js")(F, A, G), e("./using.js")(F, o, V, B, A, G), e("./any.js")(F), e("./each.js")(F, A), e("./filter.js")(F, A), l.toFastProperties(F), l.toFastProperties(F.prototype);
        function lt(q) {
          var U = new F(A);
          U._fulfillmentHandler0 = q, U._rejectionHandler0 = q, U._promise0 = q, U._receiver0 = q;
        }
        return lt({ a: 1 }), lt({ b: 2 }), lt({ c: 3 }), lt(1), lt(function() {
        }), lt(void 0), lt(!1), lt(new F(A)), G.setBounds(P.firstLineError, l.lastLineError), F;
      };
    }, { "./any.js": 1, "./async": 2, "./bind": 3, "./call_get.js": 5, "./cancel": 6, "./catch_filter": 7, "./context": 8, "./debuggability": 9, "./direct_resolve": 10, "./each.js": 11, "./errors": 12, "./es5": 13, "./filter.js": 14, "./finally": 15, "./generators.js": 16, "./join": 17, "./map.js": 18, "./method": 19, "./nodeback": 20, "./nodeify.js": 21, "./promise_array": 23, "./promisify.js": 24, "./props.js": 25, "./race.js": 27, "./reduce.js": 28, "./settle.js": 30, "./some.js": 31, "./synchronous_inspection": 32, "./thenables": 33, "./timers.js": 34, "./using.js": 35, "./util": 36, async_hooks: void 0 }], 23: [function(e, i, r) {
      i.exports = function(s, a, o, c, h) {
        var l = e("./util");
        l.isArray;
        function f(m) {
          switch (m) {
            case -2:
              return [];
            case -3:
              return {};
            case -6:
              return /* @__PURE__ */ new Map();
          }
        }
        function d(m) {
          var v = this._promise = new s(a);
          m instanceof s && (v._propagateFrom(m, 3), m.suppressUnhandledRejections()), v._setOnCancel(this), this._values = m, this._length = 0, this._totalResolved = 0, this._init(void 0, -2);
        }
        return l.inherits(d, h), d.prototype.length = function() {
          return this._length;
        }, d.prototype.promise = function() {
          return this._promise;
        }, d.prototype._init = function m(v, E) {
          var _ = o(this._values, this._promise);
          if (_ instanceof s) {
            _ = _._target();
            var p = _._bitField;
            if (this._values = _, p & 50397184)
              if (p & 33554432)
                _ = _._value();
              else
                return p & 16777216 ? this._reject(_._reason()) : this._cancel();
            else
              return this._promise._setAsyncGuaranteed(), _._then(
                m,
                this._reject,
                void 0,
                this,
                E
              );
          }
          if (_ = l.asArray(_), _ === null) {
            var R = c(
              "expecting an array or an iterable object but got " + l.classString(_)
            ).reason();
            this._promise._rejectCallback(R, !1);
            return;
          }
          if (_.length === 0) {
            E === -5 ? this._resolveEmptyArray() : this._resolve(f(E));
            return;
          }
          this._iterate(_);
        }, d.prototype._iterate = function(m) {
          var v = this.getActualLength(m.length);
          this._length = v, this._values = this.shouldCopyValues() ? new Array(v) : this._values;
          for (var E = this._promise, _ = !1, p = null, R = 0; R < v; ++R) {
            var M = o(m[R], E);
            M instanceof s ? (M = M._target(), p = M._bitField) : p = null, _ ? p !== null && M.suppressUnhandledRejections() : p !== null ? p & 50397184 ? p & 33554432 ? _ = this._promiseFulfilled(M._value(), R) : p & 16777216 ? _ = this._promiseRejected(M._reason(), R) : _ = this._promiseCancelled(R) : (M._proxy(this, R), this._values[R] = M) : _ = this._promiseFulfilled(M, R);
          }
          _ || E._setAsyncGuaranteed();
        }, d.prototype._isResolved = function() {
          return this._values === null;
        }, d.prototype._resolve = function(m) {
          this._values = null, this._promise._fulfill(m);
        }, d.prototype._cancel = function() {
          this._isResolved() || !this._promise._isCancellable() || (this._values = null, this._promise._cancel());
        }, d.prototype._reject = function(m) {
          this._values = null, this._promise._rejectCallback(m, !1);
        }, d.prototype._promiseFulfilled = function(m, v) {
          this._values[v] = m;
          var E = ++this._totalResolved;
          return E >= this._length ? (this._resolve(this._values), !0) : !1;
        }, d.prototype._promiseCancelled = function() {
          return this._cancel(), !0;
        }, d.prototype._promiseRejected = function(m) {
          return this._totalResolved++, this._reject(m), !0;
        }, d.prototype._resultCancelled = function() {
          if (!this._isResolved()) {
            var m = this._values;
            if (this._cancel(), m instanceof s)
              m.cancel();
            else
              for (var v = 0; v < m.length; ++v)
                m[v] instanceof s && m[v].cancel();
          }
        }, d.prototype.shouldCopyValues = function() {
          return !0;
        }, d.prototype.getActualLength = function(m) {
          return m;
        }, d;
      };
    }, { "./util": 36 }], 24: [function(e, i, r) {
      i.exports = function(s, a) {
        var o = {}, c = e("./util"), h = e("./nodeback"), l = c.withAppended, f = c.maybeWrapAsError, d = c.canEvaluate, m = e("./errors").TypeError, v = "Async", E = { __isPromisified__: !0 }, _ = [
          "arity",
          "length",
          "name",
          "arguments",
          "caller",
          "callee",
          "prototype",
          "__isPromisified__"
        ], p = new RegExp("^(?:" + _.join("|") + ")$"), R = function(k) {
          return c.isIdentifier(k) && k.charAt(0) !== "_" && k !== "constructor";
        };
        function M(k) {
          return !p.test(k);
        }
        function P(k) {
          try {
            return k.__isPromisified__ === !0;
          } catch {
            return !1;
          }
        }
        function W(k, B, G) {
          var H = c.getDataPropertyOrDefault(
            k,
            B + G,
            E
          );
          return H ? P(H) : !1;
        }
        function C(k, B, G) {
          for (var H = 0; H < k.length; H += 2) {
            var w = k[H];
            if (G.test(w)) {
              for (var ut = w.replace(G, ""), pt = 0; pt < k.length; pt += 2)
                if (k[pt] === ut)
                  throw new m(`Cannot promisify an API that has normal methods with '%s'-suffix

    See http://goo.gl/MqrFmX
`.replace("%s", B));
            }
          }
        }
        function D(k, B, G, H) {
          for (var w = c.inheritedDataKeys(k), ut = [], pt = 0; pt < w.length; ++pt) {
            var _t = w[pt], vt = k[_t], F = H === R ? !0 : R(_t);
            typeof vt == "function" && !P(vt) && !W(k, _t, B) && H(_t, vt, k, F) && ut.push(_t, vt);
          }
          return C(ut, B, G), ut;
        }
        var N = function(k) {
          return k.replace(/([$])/, "\\$");
        }, A;
        function I(k, B, G, H, w, ut) {
          var pt = /* @__PURE__ */ function() {
            return this;
          }(), _t = k;
          typeof _t == "string" && (k = H);
          function vt() {
            var F = B;
            B === o && (F = this);
            var rt = new s(a);
            rt._captureStackTrace();
            var b = typeof _t == "string" && this !== pt ? this[_t] : k, lt = h(rt, ut);
            try {
              b.apply(F, l(arguments, lt));
            } catch (q) {
              rt._rejectCallback(f(q), !0, !0);
            }
            return rt._isFateSealed() || rt._setAsyncGuaranteed(), rt;
          }
          return c.notEnumerableProp(vt, "__isPromisified__", !0), vt;
        }
        var it = d ? A : I;
        function V(k, B, G, H, w) {
          for (var ut = new RegExp(N(B) + "$"), pt = D(k, B, ut, G), _t = 0, vt = pt.length; _t < vt; _t += 2) {
            var F = pt[_t], rt = pt[_t + 1], b = F + B;
            if (H === it)
              k[b] = it(F, o, F, rt, B, w);
            else {
              var lt = H(rt, function() {
                return it(
                  F,
                  o,
                  F,
                  rt,
                  B,
                  w
                );
              });
              c.notEnumerableProp(lt, "__isPromisified__", !0), k[b] = lt;
            }
          }
          return c.toFastProperties(k), k;
        }
        function mt(k, B, G) {
          return it(
            k,
            B,
            void 0,
            k,
            null,
            G
          );
        }
        s.promisify = function(k, B) {
          if (typeof k != "function")
            throw new m("expecting a function but got " + c.classString(k));
          if (P(k))
            return k;
          B = Object(B);
          var G = B.context === void 0 ? o : B.context, H = !!B.multiArgs, w = mt(k, G, H);
          return c.copyDescriptors(k, w, M), w;
        }, s.promisifyAll = function(k, B) {
          if (typeof k != "function" && typeof k != "object")
            throw new m(`the target of promisifyAll must be an object or a function

    See http://goo.gl/MqrFmX
`);
          B = Object(B);
          var G = !!B.multiArgs, H = B.suffix;
          typeof H != "string" && (H = v);
          var w = B.filter;
          typeof w != "function" && (w = R);
          var ut = B.promisifier;
          if (typeof ut != "function" && (ut = it), !c.isIdentifier(H))
            throw new RangeError(`suffix must be a valid identifier

    See http://goo.gl/MqrFmX
`);
          for (var pt = c.inheritedDataKeys(k), _t = 0; _t < pt.length; ++_t) {
            var vt = k[pt[_t]];
            pt[_t] !== "constructor" && c.isClass(vt) && (V(
              vt.prototype,
              H,
              w,
              ut,
              G
            ), V(vt, H, w, ut, G));
          }
          return V(k, H, w, ut, G);
        };
      };
    }, { "./errors": 12, "./nodeback": 20, "./util": 36 }], 25: [function(e, i, r) {
      i.exports = function(s, a, o, c) {
        var h = e("./util"), l = h.isObject, f = e("./es5"), d;
        typeof Map == "function" && (d = Map);
        var m = /* @__PURE__ */ function() {
          var p = 0, R = 0;
          function M(P, W) {
            this[p] = P, this[p + R] = W, p++;
          }
          return function(W) {
            R = W.size, p = 0;
            var C = new Array(W.size * 2);
            return W.forEach(M, C), C;
          };
        }(), v = function(p) {
          for (var R = new d(), M = p.length / 2 | 0, P = 0; P < M; ++P) {
            var W = p[M + P], C = p[P];
            R.set(W, C);
          }
          return R;
        };
        function E(p) {
          var R = !1, M;
          if (d !== void 0 && p instanceof d)
            M = m(p), R = !0;
          else {
            var P = f.keys(p), W = P.length;
            M = new Array(W * 2);
            for (var C = 0; C < W; ++C) {
              var D = P[C];
              M[C] = p[D], M[C + W] = D;
            }
          }
          this.constructor$(M), this._isMap = R, this._init$(void 0, R ? -6 : -3);
        }
        h.inherits(E, a), E.prototype._init = function() {
        }, E.prototype._promiseFulfilled = function(p, R) {
          this._values[R] = p;
          var M = ++this._totalResolved;
          if (M >= this._length) {
            var P;
            if (this._isMap)
              P = v(this._values);
            else {
              P = {};
              for (var W = this.length(), C = 0, D = this.length(); C < D; ++C)
                P[this._values[C + W]] = this._values[C];
            }
            return this._resolve(P), !0;
          }
          return !1;
        }, E.prototype.shouldCopyValues = function() {
          return !1;
        }, E.prototype.getActualLength = function(p) {
          return p >> 1;
        };
        function _(p) {
          var R, M = o(p);
          if (l(M))
            M instanceof s ? R = M._then(
              s.props,
              void 0,
              void 0,
              void 0,
              void 0
            ) : R = new E(M).promise();
          else
            return c(`cannot await properties of a non-object

    See http://goo.gl/MqrFmX
`);
          return M instanceof s && R._propagateFrom(M, 2), R;
        }
        s.prototype.props = function() {
          return _(this);
        }, s.props = function(p) {
          return _(p);
        };
      };
    }, { "./es5": 13, "./util": 36 }], 26: [function(e, i, r) {
      function s(o, c, h, l, f) {
        for (var d = 0; d < f; ++d)
          h[d + l] = o[d + c], o[d + c] = void 0;
      }
      function a(o) {
        this._capacity = o, this._length = 0, this._front = 0;
      }
      a.prototype._willBeOverCapacity = function(o) {
        return this._capacity < o;
      }, a.prototype._pushOne = function(o) {
        var c = this.length();
        this._checkCapacity(c + 1);
        var h = this._front + c & this._capacity - 1;
        this[h] = o, this._length = c + 1;
      }, a.prototype.push = function(o, c, h) {
        var l = this.length() + 3;
        if (this._willBeOverCapacity(l)) {
          this._pushOne(o), this._pushOne(c), this._pushOne(h);
          return;
        }
        var f = this._front + l - 3;
        this._checkCapacity(l);
        var d = this._capacity - 1;
        this[f + 0 & d] = o, this[f + 1 & d] = c, this[f + 2 & d] = h, this._length = l;
      }, a.prototype.shift = function() {
        var o = this._front, c = this[o];
        return this[o] = void 0, this._front = o + 1 & this._capacity - 1, this._length--, c;
      }, a.prototype.length = function() {
        return this._length;
      }, a.prototype._checkCapacity = function(o) {
        this._capacity < o && this._resizeTo(this._capacity << 1);
      }, a.prototype._resizeTo = function(o) {
        var c = this._capacity;
        this._capacity = o;
        var h = this._front, l = this._length, f = h + l & c - 1;
        s(this, 0, this, c, f);
      }, i.exports = a;
    }, {}], 27: [function(e, i, r) {
      i.exports = function(s, a, o, c) {
        var h = e("./util"), l = function(d) {
          return d.then(function(m) {
            return f(m, d);
          });
        };
        function f(d, m) {
          var v = o(d);
          if (v instanceof s)
            return l(v);
          if (d = h.asArray(d), d === null)
            return c("expecting an array or an iterable object but got " + h.classString(d));
          var E = new s(a);
          m !== void 0 && E._propagateFrom(m, 3);
          for (var _ = E._fulfill, p = E._reject, R = 0, M = d.length; R < M; ++R) {
            var P = d[R];
            P === void 0 && !(R in d) || s.cast(P)._then(_, p, void 0, E, null);
          }
          return E;
        }
        s.race = function(d) {
          return f(d, void 0);
        }, s.prototype.race = function() {
          return f(this, void 0);
        };
      };
    }, { "./util": 36 }], 28: [function(e, i, r) {
      i.exports = function(s, a, o, c, h, l) {
        var f = e("./util"), d = f.tryCatch;
        function m(R, M, P, W) {
          this.constructor$(R);
          var C = s._getContext();
          this._fn = f.contextBind(C, M), P !== void 0 && (P = s.resolve(P), P._attachCancellationCallback(this)), this._initialValue = P, this._currentCancellable = null, W === h ? this._eachValues = Array(this._length) : W === 0 ? this._eachValues = null : this._eachValues = void 0, this._promise._captureStackTrace(), this._init$(void 0, -5);
        }
        f.inherits(m, a), m.prototype._gotAccum = function(R) {
          this._eachValues !== void 0 && this._eachValues !== null && R !== h && this._eachValues.push(R);
        }, m.prototype._eachComplete = function(R) {
          return this._eachValues !== null && this._eachValues.push(R), this._eachValues;
        }, m.prototype._init = function() {
        }, m.prototype._resolveEmptyArray = function() {
          this._resolve(this._eachValues !== void 0 ? this._eachValues : this._initialValue);
        }, m.prototype.shouldCopyValues = function() {
          return !1;
        }, m.prototype._resolve = function(R) {
          this._promise._resolveCallback(R), this._values = null;
        }, m.prototype._resultCancelled = function(R) {
          if (R === this._initialValue)
            return this._cancel();
          this._isResolved() || (this._resultCancelled$(), this._currentCancellable instanceof s && this._currentCancellable.cancel(), this._initialValue instanceof s && this._initialValue.cancel());
        }, m.prototype._iterate = function(R) {
          this._values = R;
          var M, P, W = R.length;
          this._initialValue !== void 0 ? (M = this._initialValue, P = 0) : (M = s.resolve(R[0]), P = 1), this._currentCancellable = M;
          for (var C = P; C < W; ++C) {
            var D = R[C];
            D instanceof s && D.suppressUnhandledRejections();
          }
          if (!M.isRejected())
            for (; P < W; ++P) {
              var N = {
                accum: null,
                value: R[P],
                index: P,
                length: W,
                array: this
              };
              M = M._then(_, void 0, void 0, N, void 0), P & 127 || M._setNoAsyncGuarantee();
            }
          this._eachValues !== void 0 && (M = M._then(this._eachComplete, void 0, void 0, this, void 0)), M._then(v, v, void 0, M, this);
        }, s.prototype.reduce = function(R, M) {
          return E(this, R, M, null);
        }, s.reduce = function(R, M, P, W) {
          return E(R, M, P, W);
        };
        function v(R, M) {
          this.isFulfilled() ? M._resolve(R) : M._reject(R);
        }
        function E(R, M, P, W) {
          if (typeof M != "function")
            return o("expecting a function but got " + f.classString(M));
          var C = new m(R, M, P, W);
          return C.promise();
        }
        function _(R) {
          this.accum = R, this.array._gotAccum(R);
          var M = c(this.value, this.array._promise);
          return M instanceof s ? (this.array._currentCancellable = M, M._then(p, void 0, void 0, this, void 0)) : p.call(this, M);
        }
        function p(R) {
          var M = this.array, P = M._promise, W = d(M._fn);
          P._pushContext();
          var C;
          M._eachValues !== void 0 ? C = W.call(P._boundValue(), R, this.index, this.length) : C = W.call(
            P._boundValue(),
            this.accum,
            R,
            this.index,
            this.length
          ), C instanceof s && (M._currentCancellable = C);
          var D = P._popContext();
          return l.checkForgottenReturns(
            C,
            D,
            M._eachValues !== void 0 ? "Promise.each" : "Promise.reduce",
            P
          ), C;
        }
      };
    }, { "./util": 36 }], 29: [function(e, i, r) {
      var s = e("./util"), a, o = function() {
        throw new Error(`No async scheduler available

    See http://goo.gl/MqrFmX
`);
      }, c = s.getNativePromise();
      if (s.isNode && typeof MutationObserver > "u") {
        var h = cn.setImmediate, l = process.nextTick;
        a = s.isRecentNode ? function(d) {
          h.call(cn, d);
        } : function(d) {
          l.call(process, d);
        };
      } else if (typeof c == "function" && typeof c.resolve == "function") {
        var f = c.resolve();
        a = function(d) {
          f.then(d);
        };
      } else
        typeof MutationObserver < "u" && !(typeof window < "u" && window.navigator && (window.navigator.standalone || window.cordova)) && "classList" in document.documentElement ? a = function() {
          var d = document.createElement("div"), m = { attributes: !0 }, v = !1, E = document.createElement("div"), _ = new MutationObserver(function() {
            d.classList.toggle("foo"), v = !1;
          });
          _.observe(E, m);
          var p = function() {
            v || (v = !0, E.classList.toggle("foo"));
          };
          return function(M) {
            var P = new MutationObserver(function() {
              P.disconnect(), M();
            });
            P.observe(d, m), p();
          };
        }() : typeof setImmediate < "u" ? a = function(d) {
          setImmediate(d);
        } : typeof setTimeout < "u" ? a = function(d) {
          setTimeout(d, 0);
        } : a = o;
      i.exports = a;
    }, { "./util": 36 }], 30: [function(e, i, r) {
      i.exports = function(s, a, o) {
        var c = s.PromiseInspection, h = e("./util");
        function l(f) {
          this.constructor$(f);
        }
        h.inherits(l, a), l.prototype._promiseResolved = function(f, d) {
          this._values[f] = d;
          var m = ++this._totalResolved;
          return m >= this._length ? (this._resolve(this._values), !0) : !1;
        }, l.prototype._promiseFulfilled = function(f, d) {
          var m = new c();
          return m._bitField = 33554432, m._settledValueField = f, this._promiseResolved(d, m);
        }, l.prototype._promiseRejected = function(f, d) {
          var m = new c();
          return m._bitField = 16777216, m._settledValueField = f, this._promiseResolved(d, m);
        }, s.settle = function(f) {
          return o.deprecated(".settle()", ".reflect()"), new l(f).promise();
        }, s.allSettled = function(f) {
          return new l(f).promise();
        }, s.prototype.settle = function() {
          return s.settle(this);
        };
      };
    }, { "./util": 36 }], 31: [function(e, i, r) {
      i.exports = function(s, a, o) {
        var c = e("./util"), h = e("./errors").RangeError, l = e("./errors").AggregateError, f = c.isArray, d = {};
        function m(E) {
          this.constructor$(E), this._howMany = 0, this._unwrap = !1, this._initialized = !1;
        }
        c.inherits(m, a), m.prototype._init = function() {
          if (this._initialized) {
            if (this._howMany === 0) {
              this._resolve([]);
              return;
            }
            this._init$(void 0, -5);
            var E = f(this._values);
            !this._isResolved() && E && this._howMany > this._canPossiblyFulfill() && this._reject(this._getRangeError(this.length()));
          }
        }, m.prototype.init = function() {
          this._initialized = !0, this._init();
        }, m.prototype.setUnwrap = function() {
          this._unwrap = !0;
        }, m.prototype.howMany = function() {
          return this._howMany;
        }, m.prototype.setHowMany = function(E) {
          this._howMany = E;
        }, m.prototype._promiseFulfilled = function(E) {
          return this._addFulfilled(E), this._fulfilled() === this.howMany() ? (this._values.length = this.howMany(), this.howMany() === 1 && this._unwrap ? this._resolve(this._values[0]) : this._resolve(this._values), !0) : !1;
        }, m.prototype._promiseRejected = function(E) {
          return this._addRejected(E), this._checkOutcome();
        }, m.prototype._promiseCancelled = function() {
          return this._values instanceof s || this._values == null ? this._cancel() : (this._addRejected(d), this._checkOutcome());
        }, m.prototype._checkOutcome = function() {
          if (this.howMany() > this._canPossiblyFulfill()) {
            for (var E = new l(), _ = this.length(); _ < this._values.length; ++_)
              this._values[_] !== d && E.push(this._values[_]);
            return E.length > 0 ? this._reject(E) : this._cancel(), !0;
          }
          return !1;
        }, m.prototype._fulfilled = function() {
          return this._totalResolved;
        }, m.prototype._rejected = function() {
          return this._values.length - this.length();
        }, m.prototype._addRejected = function(E) {
          this._values.push(E);
        }, m.prototype._addFulfilled = function(E) {
          this._values[this._totalResolved++] = E;
        }, m.prototype._canPossiblyFulfill = function() {
          return this.length() - this._rejected();
        }, m.prototype._getRangeError = function(E) {
          var _ = "Input array must contain at least " + this._howMany + " items but contains only " + E + " items";
          return new h(_);
        }, m.prototype._resolveEmptyArray = function() {
          this._reject(this._getRangeError(0));
        };
        function v(E, _) {
          if ((_ | 0) !== _ || _ < 0)
            return o(`expecting a positive integer

    See http://goo.gl/MqrFmX
`);
          var p = new m(E), R = p.promise();
          return p.setHowMany(_), p.init(), R;
        }
        s.some = function(E, _) {
          return v(E, _);
        }, s.prototype.some = function(E) {
          return v(this, E);
        }, s._SomePromiseArray = m;
      };
    }, { "./errors": 12, "./util": 36 }], 32: [function(e, i, r) {
      i.exports = function(s) {
        function a(m) {
          m !== void 0 ? (m = m._target(), this._bitField = m._bitField, this._settledValueField = m._isFateSealed() ? m._settledValue() : void 0) : (this._bitField = 0, this._settledValueField = void 0);
        }
        a.prototype._settledValue = function() {
          return this._settledValueField;
        };
        var o = a.prototype.value = function() {
          if (!this.isFulfilled())
            throw new TypeError(`cannot get fulfillment value of a non-fulfilled promise

    See http://goo.gl/MqrFmX
`);
          return this._settledValue();
        }, c = a.prototype.error = a.prototype.reason = function() {
          if (!this.isRejected())
            throw new TypeError(`cannot get rejection reason of a non-rejected promise

    See http://goo.gl/MqrFmX
`);
          return this._settledValue();
        }, h = a.prototype.isFulfilled = function() {
          return (this._bitField & 33554432) !== 0;
        }, l = a.prototype.isRejected = function() {
          return (this._bitField & 16777216) !== 0;
        }, f = a.prototype.isPending = function() {
          return (this._bitField & 50397184) === 0;
        }, d = a.prototype.isResolved = function() {
          return (this._bitField & 50331648) !== 0;
        };
        a.prototype.isCancelled = function() {
          return (this._bitField & 8454144) !== 0;
        }, s.prototype.__isCancelled = function() {
          return (this._bitField & 65536) === 65536;
        }, s.prototype._isCancelled = function() {
          return this._target().__isCancelled();
        }, s.prototype.isCancelled = function() {
          return (this._target()._bitField & 8454144) !== 0;
        }, s.prototype.isPending = function() {
          return f.call(this._target());
        }, s.prototype.isRejected = function() {
          return l.call(this._target());
        }, s.prototype.isFulfilled = function() {
          return h.call(this._target());
        }, s.prototype.isResolved = function() {
          return d.call(this._target());
        }, s.prototype.value = function() {
          return o.call(this._target());
        }, s.prototype.reason = function() {
          var m = this._target();
          return m._unsetRejectionIsUnhandled(), c.call(m);
        }, s.prototype._value = function() {
          return this._settledValue();
        }, s.prototype._reason = function() {
          return this._unsetRejectionIsUnhandled(), this._settledValue();
        }, s.PromiseInspection = a;
      };
    }, {}], 33: [function(e, i, r) {
      i.exports = function(s, a) {
        var o = e("./util"), c = o.errorObj, h = o.isObject;
        function l(_, p) {
          if (h(_)) {
            if (_ instanceof s)
              return _;
            var R = d(_);
            if (R === c) {
              p && p._pushContext();
              var M = s.reject(R.e);
              return p && p._popContext(), M;
            } else if (typeof R == "function") {
              if (v(_)) {
                var M = new s(a);
                return _._then(
                  M._fulfill,
                  M._reject,
                  void 0,
                  M,
                  null
                ), M;
              }
              return E(_, R, p);
            }
          }
          return _;
        }
        function f(_) {
          return _.then;
        }
        function d(_) {
          try {
            return f(_);
          } catch (p) {
            return c.e = p, c;
          }
        }
        var m = {}.hasOwnProperty;
        function v(_) {
          try {
            return m.call(_, "_promise0");
          } catch {
            return !1;
          }
        }
        function E(_, p, R) {
          var M = new s(a), P = M;
          R && R._pushContext(), M._captureStackTrace(), R && R._popContext();
          var W = !0, C = o.tryCatch(p).call(_, D, N);
          W = !1, M && C === c && (M._rejectCallback(C.e, !0, !0), M = null);
          function D(A) {
            M && (M._resolveCallback(A), M = null);
          }
          function N(A) {
            M && (M._rejectCallback(A, W, !0), M = null);
          }
          return P;
        }
        return l;
      };
    }, { "./util": 36 }], 34: [function(e, i, r) {
      i.exports = function(s, a, o) {
        var c = e("./util"), h = s.TimeoutError;
        function l(_) {
          this.handle = _;
        }
        l.prototype._resultCancelled = function() {
          clearTimeout(this.handle);
        };
        var f = function(_) {
          return d(+this).thenReturn(_);
        }, d = s.delay = function(_, p) {
          var R, M;
          return p !== void 0 ? (R = s.resolve(p)._then(f, null, null, _, void 0), o.cancellation() && p instanceof s && R._setOnCancel(p)) : (R = new s(a), M = setTimeout(function() {
            R._fulfill();
          }, +_), o.cancellation() && R._setOnCancel(new l(M)), R._captureStackTrace()), R._setAsyncGuaranteed(), R;
        };
        s.prototype.delay = function(_) {
          return d(_, this);
        };
        var m = function(_, p, R) {
          var M;
          typeof p != "string" ? p instanceof Error ? M = p : M = new h("operation timed out") : M = new h(p), c.markAsOriginatingFromRejection(M), _._attachExtraTrace(M), _._reject(M), R != null && R.cancel();
        };
        function v(_) {
          return clearTimeout(this.handle), _;
        }
        function E(_) {
          throw clearTimeout(this.handle), _;
        }
        s.prototype.timeout = function(_, p) {
          _ = +_;
          var R, M, P = new l(setTimeout(function() {
            R.isPending() && m(R, p, M);
          }, _));
          return o.cancellation() ? (M = this.then(), R = M._then(
            v,
            E,
            void 0,
            P,
            void 0
          ), R._setOnCancel(P)) : R = this._then(
            v,
            E,
            void 0,
            P,
            void 0
          ), R;
        };
      };
    }, { "./util": 36 }], 35: [function(e, i, r) {
      i.exports = function(s, a, o, c, h, l) {
        var f = e("./util"), d = e("./errors").TypeError, m = e("./util").inherits, v = f.errorObj, E = f.tryCatch, _ = {};
        function p(N) {
          setTimeout(function() {
            throw N;
          }, 0);
        }
        function R(N) {
          var A = o(N);
          return A !== N && typeof N._isDisposable == "function" && typeof N._getDisposer == "function" && N._isDisposable() && A._setDisposable(N._getDisposer()), A;
        }
        function M(N, A) {
          var I = 0, it = N.length, V = new s(h);
          function mt() {
            if (I >= it)
              return V._fulfill();
            var k = R(N[I++]);
            if (k instanceof s && k._isDisposable()) {
              try {
                k = o(
                  k._getDisposer().tryDispose(A),
                  N.promise
                );
              } catch (B) {
                return p(B);
              }
              if (k instanceof s)
                return k._then(
                  mt,
                  p,
                  null,
                  null,
                  null
                );
            }
            mt();
          }
          return mt(), V;
        }
        function P(N, A, I) {
          this._data = N, this._promise = A, this._context = I;
        }
        P.prototype.data = function() {
          return this._data;
        }, P.prototype.promise = function() {
          return this._promise;
        }, P.prototype.resource = function() {
          return this.promise().isFulfilled() ? this.promise().value() : _;
        }, P.prototype.tryDispose = function(N) {
          var A = this.resource(), I = this._context;
          I !== void 0 && I._pushContext();
          var it = A !== _ ? this.doDispose(A, N) : null;
          return I !== void 0 && I._popContext(), this._promise._unsetDisposable(), this._data = null, it;
        }, P.isDisposer = function(N) {
          return N != null && typeof N.resource == "function" && typeof N.tryDispose == "function";
        };
        function W(N, A, I) {
          this.constructor$(N, A, I);
        }
        m(W, P), W.prototype.doDispose = function(N, A) {
          var I = this.data();
          return I.call(N, N, A);
        };
        function C(N) {
          return P.isDisposer(N) ? (this.resources[this.index]._setDisposable(N), N.promise()) : N;
        }
        function D(N) {
          this.length = N, this.promise = null, this[N - 1] = null;
        }
        D.prototype._resultCancelled = function() {
          for (var N = this.length, A = 0; A < N; ++A) {
            var I = this[A];
            I instanceof s && I.cancel();
          }
        }, s.using = function() {
          var N = arguments.length;
          if (N < 2)
            return a(
              "you must pass at least 2 arguments to Promise.using"
            );
          var A = arguments[N - 1];
          if (typeof A != "function")
            return a("expecting a function but got " + f.classString(A));
          var I, it = !0;
          N === 2 && Array.isArray(arguments[0]) ? (I = arguments[0], N = I.length, it = !1) : (I = arguments, N--);
          for (var V = new D(N), mt = 0; mt < N; ++mt) {
            var k = I[mt];
            if (P.isDisposer(k)) {
              var B = k;
              k = k.promise(), k._setDisposable(B);
            } else {
              var G = o(k);
              G instanceof s && (k = G._then(C, null, null, {
                resources: V,
                index: mt
              }, void 0));
            }
            V[mt] = k;
          }
          for (var H = new Array(V.length), mt = 0; mt < H.length; ++mt)
            H[mt] = s.resolve(V[mt]).reflect();
          var w = s.all(H).then(function(pt) {
            for (var _t = 0; _t < pt.length; ++_t) {
              var vt = pt[_t];
              if (vt.isRejected())
                return v.e = vt.error(), v;
              if (!vt.isFulfilled()) {
                w.cancel();
                return;
              }
              pt[_t] = vt.value();
            }
            ut._pushContext(), A = E(A);
            var F = it ? A.apply(void 0, pt) : A(pt), rt = ut._popContext();
            return l.checkForgottenReturns(
              F,
              rt,
              "Promise.using",
              ut
            ), F;
          }), ut = w.lastly(function() {
            var pt = new s.PromiseInspection(w);
            return M(V, pt);
          });
          return V.promise = ut, ut._setOnCancel(V), ut;
        }, s.prototype._setDisposable = function(N) {
          this._bitField = this._bitField | 131072, this._disposer = N;
        }, s.prototype._isDisposable = function() {
          return (this._bitField & 131072) > 0;
        }, s.prototype._getDisposer = function() {
          return this._disposer;
        }, s.prototype._unsetDisposable = function() {
          this._bitField = this._bitField & -131073, this._disposer = void 0;
        }, s.prototype.disposer = function(N) {
          if (typeof N == "function")
            return new W(N, this, c());
          throw new d();
        };
      };
    }, { "./errors": 12, "./util": 36 }], 36: [function(e, i, r) {
      var s = e("./es5"), a = typeof navigator > "u", o = { e: {} }, c, h = typeof self < "u" ? self : typeof window < "u" ? window : typeof cn < "u" ? cn : this !== void 0 ? this : null;
      function l() {
        try {
          var U = c;
          return c = null, U.apply(this, arguments);
        } catch (L) {
          return o.e = L, o;
        }
      }
      function f(U) {
        return c = U, l;
      }
      var d = function(U, L) {
        var j = {}.hasOwnProperty;
        function Y() {
          this.constructor = U, this.constructor$ = L;
          for (var K in L.prototype)
            j.call(L.prototype, K) && K.charAt(K.length - 1) !== "$" && (this[K + "$"] = L.prototype[K]);
        }
        return Y.prototype = L.prototype, U.prototype = new Y(), U.prototype;
      };
      function m(U) {
        return U == null || U === !0 || U === !1 || typeof U == "string" || typeof U == "number";
      }
      function v(U) {
        return typeof U == "function" || typeof U == "object" && U !== null;
      }
      function E(U) {
        return m(U) ? new Error(it(U)) : U;
      }
      function _(U, L) {
        var j = U.length, Y = new Array(j + 1), K;
        for (K = 0; K < j; ++K)
          Y[K] = U[K];
        return Y[K] = L, Y;
      }
      function p(U, L, j) {
        if (s.isES5) {
          var Y = Object.getOwnPropertyDescriptor(U, L);
          if (Y != null)
            return Y.get == null && Y.set == null ? Y.value : j;
        } else
          return {}.hasOwnProperty.call(U, L) ? U[L] : void 0;
      }
      function R(U, L, j) {
        if (m(U))
          return U;
        var Y = {
          value: j,
          configurable: !0,
          enumerable: !1,
          writable: !0
        };
        return s.defineProperty(U, L, Y), U;
      }
      function M(U) {
        throw U;
      }
      var P = function() {
        var U = [
          Array.prototype,
          Object.prototype,
          Function.prototype
        ], L = function(K) {
          for (var yt = 0; yt < U.length; ++yt)
            if (U[yt] === K)
              return !0;
          return !1;
        };
        if (s.isES5) {
          var j = Object.getOwnPropertyNames;
          return function(K) {
            for (var yt = [], Et = /* @__PURE__ */ Object.create(null); K != null && !L(K); ) {
              var Ct;
              try {
                Ct = j(K);
              } catch {
                return yt;
              }
              for (var Lt = 0; Lt < Ct.length; ++Lt) {
                var Wt = Ct[Lt];
                if (!Et[Wt]) {
                  Et[Wt] = !0;
                  var wt = Object.getOwnPropertyDescriptor(K, Wt);
                  wt != null && wt.get == null && wt.set == null && yt.push(Wt);
                }
              }
              K = s.getPrototypeOf(K);
            }
            return yt;
          };
        } else {
          var Y = {}.hasOwnProperty;
          return function(K) {
            if (L(K))
              return [];
            var yt = [];
            t:
              for (var Et in K)
                if (Y.call(K, Et))
                  yt.push(Et);
                else {
                  for (var Ct = 0; Ct < U.length; ++Ct)
                    if (Y.call(U[Ct], Et))
                      continue t;
                  yt.push(Et);
                }
            return yt;
          };
        }
      }(), W = /this\s*\.\s*\S+\s*=/;
      function C(U) {
        try {
          if (typeof U == "function") {
            var L = s.names(U.prototype), j = s.isES5 && L.length > 1, Y = L.length > 0 && !(L.length === 1 && L[0] === "constructor"), K = W.test(U + "") && s.names(U).length > 0;
            if (j || Y || K)
              return !0;
          }
          return !1;
        } catch {
          return !1;
        }
      }
      function D(U) {
        function L() {
        }
        L.prototype = U;
        var j = new L();
        function Y() {
          return typeof j.foo;
        }
        return Y(), Y(), U;
      }
      var N = /^[a-z$_][a-z$_0-9]*$/i;
      function A(U) {
        return N.test(U);
      }
      function I(U, L, j) {
        for (var Y = new Array(U), K = 0; K < U; ++K)
          Y[K] = L + K + j;
        return Y;
      }
      function it(U) {
        try {
          return U + "";
        } catch {
          return "[no string representation]";
        }
      }
      function V(U) {
        return U instanceof Error || U !== null && typeof U == "object" && typeof U.message == "string" && typeof U.name == "string";
      }
      function mt(U) {
        try {
          R(U, "isOperational", !0);
        } catch {
        }
      }
      function k(U) {
        return U == null ? !1 : U instanceof Error.__BluebirdErrorTypes__.OperationalError || U.isOperational === !0;
      }
      function B(U) {
        return V(U) && s.propertyIsWritable(U, "stack");
      }
      var G = function() {
        return "stack" in new Error() ? function(U) {
          return B(U) ? U : new Error(it(U));
        } : function(U) {
          if (B(U))
            return U;
          try {
            throw new Error(it(U));
          } catch (L) {
            return L;
          }
        };
      }();
      function H(U) {
        return {}.toString.call(U);
      }
      function w(U, L, j) {
        for (var Y = s.names(U), K = 0; K < Y.length; ++K) {
          var yt = Y[K];
          if (j(yt))
            try {
              s.defineProperty(L, yt, s.getDescriptor(U, yt));
            } catch {
            }
        }
      }
      var ut = function(U) {
        return s.isArray(U) ? U : null;
      };
      if (typeof Symbol < "u" && Symbol.iterator) {
        var pt = typeof Array.from == "function" ? function(U) {
          return Array.from(U);
        } : function(U) {
          for (var L = [], j = U[Symbol.iterator](), Y; !(Y = j.next()).done; )
            L.push(Y.value);
          return L;
        };
        ut = function(U) {
          return s.isArray(U) ? U : U != null && typeof U[Symbol.iterator] == "function" ? pt(U) : null;
        };
      }
      var _t = typeof process < "u" && H(process).toLowerCase() === "[object process]", vt = typeof process < "u" && typeof process.env < "u";
      function F(U) {
        return vt ? process.env[U] : void 0;
      }
      function rt() {
        if (typeof Promise == "function")
          try {
            var U = new Promise(function() {
            });
            if (H(U) === "[object Promise]")
              return Promise;
          } catch {
          }
      }
      var b;
      function lt(U, L) {
        if (U === null || typeof L != "function" || L === b)
          return L;
        U.domain !== null && (L = U.domain.bind(L));
        var j = U.async;
        if (j !== null) {
          var Y = L;
          L = function() {
            var K = new Array(2).concat([].slice.call(arguments));
            return K[0] = Y, K[1] = this, j.runInAsyncScope.apply(j, K);
          };
        }
        return L;
      }
      var q = {
        setReflectHandler: function(U) {
          b = U;
        },
        isClass: C,
        isIdentifier: A,
        inheritedDataKeys: P,
        getDataPropertyOrDefault: p,
        thrower: M,
        isArray: s.isArray,
        asArray: ut,
        notEnumerableProp: R,
        isPrimitive: m,
        isObject: v,
        isError: V,
        canEvaluate: a,
        errorObj: o,
        tryCatch: f,
        inherits: d,
        withAppended: _,
        maybeWrapAsError: E,
        toFastProperties: D,
        filledRange: I,
        toString: it,
        canAttachTrace: B,
        ensureErrorObject: G,
        originatesFromRejection: k,
        markAsOriginatingFromRejection: mt,
        classString: H,
        copyDescriptors: w,
        isNode: _t,
        hasEnvVariables: vt,
        env: F,
        global: h,
        getNativePromise: rt,
        contextBind: lt
      };
      q.isRecentNode = q.isNode && function() {
        var U;
        return process.versions && process.versions.node ? U = process.versions.node.split(".").map(Number) : process.version && (U = process.version.split(".").map(Number)), U[0] === 0 && U[1] > 10 || U[0] > 0;
      }(), q.nodeSupportsAsyncResource = q.isNode && function() {
        var U = !1;
        try {
          var L = e("async_hooks").AsyncResource;
          U = typeof L.prototype.runInAsyncScope == "function";
        } catch {
          U = !1;
        }
        return U;
      }(), q.isNode && q.toFastProperties(process);
      try {
        throw new Error();
      } catch (U) {
        q.lastLineError = U;
      }
      i.exports = q;
    }, { "./es5": 13, async_hooks: void 0 }] }, {}, [4])(4);
  }), typeof window < "u" && window !== null ? window.P = window.Promise : typeof self < "u" && self !== null && (self.P = self.Promise);
})(um);
var ff = um.exports;
const tS = Be, eS = tS.defaultValue;
var Wr = nS;
function nS(n, t, e) {
  if (e = eS(e, !1), e) {
    const i = n.indexOf(t);
    if (i > -1)
      return i;
  }
  return n.push(t), n.length - 1;
}
var Ma = iS;
function iS(n) {
  switch (n) {
    case "SCALAR":
      return 1;
    case "VEC2":
      return 2;
    case "VEC3":
      return 3;
    case "VEC4":
    case "MAT2":
      return 4;
    case "MAT3":
      return 9;
    case "MAT4":
      return 16;
  }
}
const lm = Be, rS = Ma, sS = lm.ComponentDatatype, yp = lm.defined;
var _u = aS;
function aS(n, t) {
  const e = t.bufferView;
  if (yp(e)) {
    const i = n.bufferViews[e];
    if (yp(i.byteStride) && i.byteStride > 0)
      return i.byteStride;
  }
  return sS.getSizeInBytes(t.componentType) * rS(t.type);
}
const hf = Be, oS = Wr, Kn = Ln, cS = _u, Ye = hf.defaultValue, on = hf.defined, Fa = hf.WebGLConstants;
var uS = lS;
function lS(n) {
  Kn.accessor(n, function(e) {
    on(e.bufferView) && (e.byteOffset = Ye(e.byteOffset, 0));
  }), Kn.bufferView(n, function(e) {
    on(e.buffer) && (e.byteOffset = Ye(e.byteOffset, 0));
  }), Kn.mesh(n, function(e) {
    Kn.meshPrimitive(e, function(i) {
      if (i.mode = Ye(i.mode, Fa.TRIANGLES), !on(i.material)) {
        on(n.materials) || (n.materials = []);
        const r = {
          name: "default"
        };
        i.material = oS(n.materials, r);
      }
    });
  }), Kn.accessorContainingVertexAttributeData(n, function(e) {
    const i = n.accessors[e], r = i.bufferView;
    if (i.normalized = Ye(i.normalized, !1), on(r)) {
      const s = n.bufferViews[r];
      s.byteStride = cS(n, i), s.target = Fa.ARRAY_BUFFER;
    }
  }), Kn.accessorContainingIndexData(n, function(e) {
    const r = n.accessors[e].bufferView;
    if (on(r)) {
      const s = n.bufferViews[r];
      s.target = Fa.ELEMENT_ARRAY_BUFFER;
    }
  }), Kn.material(n, function(e) {
    const i = Ye(
      e.extensions,
      Ye.EMPTY_OBJECT
    ), r = i.KHR_materials_common;
    if (on(r)) {
      const c = r.technique, h = on(r.values) ? r.values : {};
      r.values = h, h.ambient = on(h.ambient) ? h.ambient : [0, 0, 0, 1], h.emission = on(h.emission) ? h.emission : [0, 0, 0, 1], h.transparency = Ye(h.transparency, 1), c !== "CONSTANT" && (h.diffuse = on(h.diffuse) ? h.diffuse : [0, 0, 0, 1], c !== "LAMBERT" && (h.specular = on(h.specular) ? h.specular : [0, 0, 0, 1], h.shininess = Ye(h.shininess, 0))), r.transparent = Ye(
        r.transparent,
        !1
      ), r.doubleSided = Ye(
        r.doubleSided,
        !1
      );
      return;
    }
    e.emissiveFactor = Ye(
      e.emissiveFactor,
      [0, 0, 0]
    ), e.alphaMode = Ye(e.alphaMode, "OPAQUE"), e.doubleSided = Ye(e.doubleSided, !1), e.alphaMode === "MASK" && (e.alphaCutoff = Ye(e.alphaCutoff, 0.5));
    const s = i.KHR_techniques_webgl;
    on(s) && Kn.materialValue(e, function(c) {
      on(c.index) && gs(c);
    }), gs(e.emissiveTexture), gs(e.normalTexture), gs(e.occlusionTexture);
    const a = e.pbrMetallicRoughness;
    on(a) && (a.baseColorFactor = Ye(
      a.baseColorFactor,
      [1, 1, 1, 1]
    ), a.metallicFactor = Ye(
      a.metallicFactor,
      1
    ), a.roughnessFactor = Ye(
      a.roughnessFactor,
      1
    ), gs(a.baseColorTexture), gs(a.metallicRoughnessTexture));
    const o = i.KHR_materials_pbrSpecularGlossiness;
    on(o) && (o.diffuseFactor = Ye(
      o.diffuseFactor,
      [1, 1, 1, 1]
    ), o.specularFactor = Ye(
      o.specularFactor,
      [1, 1, 1]
    ), o.glossinessFactor = Ye(
      o.glossinessFactor,
      1
    ), gs(o.specularGlossinessTexture));
  }), Kn.animation(n, function(e) {
    Kn.animationSampler(e, function(i) {
      i.interpolation = Ye(i.interpolation, "LINEAR");
    });
  });
  const t = fS(n);
  return Kn.node(n, function(e, i) {
    on(t[i]) || on(e.translation) || on(e.rotation) || on(e.scale) ? (e.translation = Ye(e.translation, [0, 0, 0]), e.rotation = Ye(e.rotation, [0, 0, 0, 1]), e.scale = Ye(e.scale, [1, 1, 1])) : e.matrix = Ye(
      e.matrix,
      [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]
    );
  }), Kn.sampler(n, function(e) {
    e.wrapS = Ye(e.wrapS, Fa.REPEAT), e.wrapT = Ye(e.wrapT, Fa.REPEAT);
  }), on(n.scenes) && !on(n.scene) && (n.scene = 0), n;
}
function fS(n) {
  const t = {};
  return Kn.animation(n, function(e) {
    Kn.animationChannel(e, function(i) {
      const r = i.target, s = r.node, a = r.path;
      (a === "translation" || a === "rotation" || a === "scale") && (t[s] = !0);
    });
  }), t;
}
function gs(n) {
  on(n) && (n.texCoord = Ye(n.texCoord, 0));
}
const pf = Be, Vr = Ln, mi = pf.defined, ol = pf.isDataUri, vs = pf.WebGLConstants;
var hS = pS;
function pS(n, t) {
  const e = new hm();
  if (mi(t)) {
    const r = _S(n, t);
    return e.numberOfDrawCalls = r.numberOfDrawCalls, e.numberOfRenderedPrimitives = r.numberOfRenderedPrimitives, e;
  }
  const i = yS(n);
  return e.buffersByteLength = dS(n), e.numberOfImages = mi(n.images) ? n.images.length : 0, e.numberOfExternalRequests = mS(n), e.numberOfDrawCalls = i.numberOfDrawCalls, e.numberOfRenderedPrimitives = i.numberOfRenderedPrimitives, e.numberOfNodes = mi(n.nodes) ? n.nodes.length : 0, e.numberOfMeshes = mi(n.meshes) ? n.meshes.length : 0, e.numberOfMaterials = mi(n.materials) ? n.materials.length : 0, e.numberOfAnimations = mi(n.animations) ? n.animations.length : 0, e;
}
function dS(n) {
  let t = 0;
  return Vr.buffer(n, function(e) {
    t += e.byteLength;
  }), t;
}
function mS(n) {
  let t = 0;
  return Vr.buffer(n, function(e) {
    mi(e.uri) && !ol(e.uri) && t++;
  }), Vr.image(n, function(e) {
    mi(e.uri) && !ol(e.uri) && t++;
  }), Vr.shader(n, function(e) {
    mi(e.uri) && !ol(e.uri) && t++;
  }), t;
}
function fm(n, t) {
  let e = 0;
  switch (mi(t.indices) ? e = n.accessors[t.indices].count : mi(t.attributes.POSITION) && (e = n.accessors[t.attributes.POSITION].count), t.mode) {
    case vs.POINTS:
      return e;
    case vs.LINES:
      return e / 2;
    case vs.LINE_LOOP:
      return e;
    case vs.LINE_STRIP:
      return Math.max(e - 1, 0);
    case vs.TRIANGLES:
      return e / 3;
    case vs.TRIANGLE_STRIP:
    case vs.TRIANGLE_FAN:
      return Math.max(e - 2, 0);
    default:
      return e / 3;
  }
}
function _S(n, t) {
  let e = 0, i = 0;
  return Vr.nodeInTree(n, [t], function(r) {
    const s = n.meshes[r.mesh];
    mi(s) && Vr.meshPrimitive(s, function(a) {
      e++, i += fm(
        n,
        a
      );
    });
  }), {
    numberOfDrawCalls: e,
    numberOfRenderedPrimitives: i
  };
}
function yS(n) {
  let t = 0, e = 0;
  return Vr.mesh(n, function(i) {
    Vr.meshPrimitive(i, function(r) {
      t++, e += fm(
        n,
        r
      );
    });
  }), {
    numberOfDrawCalls: t,
    numberOfRenderedPrimitives: e
  };
}
function hm() {
  this.buffersByteLength = 0, this.numberOfImages = 0, this.numberOfExternalRequests = 0, this.numberOfDrawCalls = 0, this.numberOfRenderedPrimitives = 0, this.numberOfNodes = 0, this.numberOfMeshes = 0, this.numberOfMaterials = 0, this.numberOfAnimations = 0;
}
hm.prototype.toString = function() {
  return `Total byte length of all buffers: ${this.buffersByteLength} bytes
Images: ${this.numberOfImages}
Draw calls: ${this.numberOfDrawCalls}
Rendered primitives (e.g., triangles): ${this.numberOfRenderedPrimitives}
Nodes: ${this.numberOfNodes}
Meshes: ${this.numberOfMeshes}
Materials: ${this.numberOfMaterials}
Animations: ${this.numberOfAnimations}
External requests (not data uris): ${this.numberOfExternalRequests}`;
};
var Xn = {}, En = {};
En.fromCallback = function(n) {
  return Object.defineProperty(function(...t) {
    if (typeof t[t.length - 1] == "function")
      n.apply(this, t);
    else
      return new Promise((e, i) => {
        t.push((r, s) => r != null ? i(r) : e(s)), n.apply(this, t);
      });
  }, "name", { value: n.name });
};
En.fromPromise = function(n) {
  return Object.defineProperty(function(...t) {
    const e = t[t.length - 1];
    if (typeof e != "function")
      return n.apply(this, t);
    t.pop(), n.apply(this, t).then((i) => e(null, i), e);
  }, "name", { value: n.name });
};
var Ir = Xe, gS = process.cwd, Kc = null, vS = process.env.GRACEFUL_FS_PLATFORM || process.platform;
process.cwd = function() {
  return Kc || (Kc = gS.call(process)), Kc;
};
try {
  process.cwd();
} catch {
}
if (typeof process.chdir == "function") {
  var gp = process.chdir;
  process.chdir = function(n) {
    Kc = null, gp.call(process, n);
  }, Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, gp);
}
var xS = bS;
function bS(n) {
  Ir.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) && t(n), n.lutimes || e(n), n.chown = s(n.chown), n.fchown = s(n.fchown), n.lchown = s(n.lchown), n.chmod = i(n.chmod), n.fchmod = i(n.fchmod), n.lchmod = i(n.lchmod), n.chownSync = a(n.chownSync), n.fchownSync = a(n.fchownSync), n.lchownSync = a(n.lchownSync), n.chmodSync = r(n.chmodSync), n.fchmodSync = r(n.fchmodSync), n.lchmodSync = r(n.lchmodSync), n.stat = o(n.stat), n.fstat = o(n.fstat), n.lstat = o(n.lstat), n.statSync = c(n.statSync), n.fstatSync = c(n.fstatSync), n.lstatSync = c(n.lstatSync), n.chmod && !n.lchmod && (n.lchmod = function(l, f, d) {
    d && process.nextTick(d);
  }, n.lchmodSync = function() {
  }), n.chown && !n.lchown && (n.lchown = function(l, f, d, m) {
    m && process.nextTick(m);
  }, n.lchownSync = function() {
  }), vS === "win32" && (n.rename = typeof n.rename != "function" ? n.rename : function(l) {
    function f(d, m, v) {
      var E = Date.now(), _ = 0;
      l(d, m, function p(R) {
        if (R && (R.code === "EACCES" || R.code === "EPERM" || R.code === "EBUSY") && Date.now() - E < 6e4) {
          setTimeout(function() {
            n.stat(m, function(M, P) {
              M && M.code === "ENOENT" ? l(d, m, p) : v(R);
            });
          }, _), _ < 100 && (_ += 10);
          return;
        }
        v && v(R);
      });
    }
    return Object.setPrototypeOf && Object.setPrototypeOf(f, l), f;
  }(n.rename)), n.read = typeof n.read != "function" ? n.read : function(l) {
    function f(d, m, v, E, _, p) {
      var R;
      if (p && typeof p == "function") {
        var M = 0;
        R = function(P, W, C) {
          if (P && P.code === "EAGAIN" && M < 10)
            return M++, l.call(n, d, m, v, E, _, R);
          p.apply(this, arguments);
        };
      }
      return l.call(n, d, m, v, E, _, R);
    }
    return Object.setPrototypeOf && Object.setPrototypeOf(f, l), f;
  }(n.read), n.readSync = typeof n.readSync != "function" ? n.readSync : /* @__PURE__ */ function(l) {
    return function(f, d, m, v, E) {
      for (var _ = 0; ; )
        try {
          return l.call(n, f, d, m, v, E);
        } catch (p) {
          if (p.code === "EAGAIN" && _ < 10) {
            _++;
            continue;
          }
          throw p;
        }
    };
  }(n.readSync);
  function t(l) {
    l.lchmod = function(f, d, m) {
      l.open(
        f,
        Ir.O_WRONLY | Ir.O_SYMLINK,
        d,
        function(v, E) {
          if (v) {
            m && m(v);
            return;
          }
          l.fchmod(E, d, function(_) {
            l.close(E, function(p) {
              m && m(_ || p);
            });
          });
        }
      );
    }, l.lchmodSync = function(f, d) {
      var m = l.openSync(f, Ir.O_WRONLY | Ir.O_SYMLINK, d), v = !0, E;
      try {
        E = l.fchmodSync(m, d), v = !1;
      } finally {
        if (v)
          try {
            l.closeSync(m);
          } catch {
          }
        else
          l.closeSync(m);
      }
      return E;
    };
  }
  function e(l) {
    Ir.hasOwnProperty("O_SYMLINK") && l.futimes ? (l.lutimes = function(f, d, m, v) {
      l.open(f, Ir.O_SYMLINK, function(E, _) {
        if (E) {
          v && v(E);
          return;
        }
        l.futimes(_, d, m, function(p) {
          l.close(_, function(R) {
            v && v(p || R);
          });
        });
      });
    }, l.lutimesSync = function(f, d, m) {
      var v = l.openSync(f, Ir.O_SYMLINK), E, _ = !0;
      try {
        E = l.futimesSync(v, d, m), _ = !1;
      } finally {
        if (_)
          try {
            l.closeSync(v);
          } catch {
          }
        else
          l.closeSync(v);
      }
      return E;
    }) : l.futimes && (l.lutimes = function(f, d, m, v) {
      v && process.nextTick(v);
    }, l.lutimesSync = function() {
    });
  }
  function i(l) {
    return l && function(f, d, m) {
      return l.call(n, f, d, function(v) {
        h(v) && (v = null), m && m.apply(this, arguments);
      });
    };
  }
  function r(l) {
    return l && function(f, d) {
      try {
        return l.call(n, f, d);
      } catch (m) {
        if (!h(m))
          throw m;
      }
    };
  }
  function s(l) {
    return l && function(f, d, m, v) {
      return l.call(n, f, d, m, function(E) {
        h(E) && (E = null), v && v.apply(this, arguments);
      });
    };
  }
  function a(l) {
    return l && function(f, d, m) {
      try {
        return l.call(n, f, d, m);
      } catch (v) {
        if (!h(v))
          throw v;
      }
    };
  }
  function o(l) {
    return l && function(f, d, m) {
      typeof d == "function" && (m = d, d = null);
      function v(E, _) {
        _ && (_.uid < 0 && (_.uid += 4294967296), _.gid < 0 && (_.gid += 4294967296)), m && m.apply(this, arguments);
      }
      return d ? l.call(n, f, d, v) : l.call(n, f, v);
    };
  }
  function c(l) {
    return l && function(f, d) {
      var m = d ? l.call(n, f, d) : l.call(n, f);
      return m && (m.uid < 0 && (m.uid += 4294967296), m.gid < 0 && (m.gid += 4294967296)), m;
    };
  }
  function h(l) {
    if (!l || l.code === "ENOSYS")
      return !0;
    var f = !process.getuid || process.getuid() !== 0;
    return !!(f && (l.code === "EINVAL" || l.code === "EPERM"));
  }
}
var vp = Xe.Stream, ES = wS;
function wS(n) {
  return {
    ReadStream: t,
    WriteStream: e
  };
  function t(i, r) {
    if (!(this instanceof t))
      return new t(i, r);
    vp.call(this);
    var s = this;
    this.path = i, this.fd = null, this.readable = !0, this.paused = !1, this.flags = "r", this.mode = 438, this.bufferSize = 64 * 1024, r = r || {};
    for (var a = Object.keys(r), o = 0, c = a.length; o < c; o++) {
      var h = a[o];
      this[h] = r[h];
    }
    if (this.encoding && this.setEncoding(this.encoding), this.start !== void 0) {
      if (typeof this.start != "number")
        throw TypeError("start must be a Number");
      if (this.end === void 0)
        this.end = 1 / 0;
      else if (typeof this.end != "number")
        throw TypeError("end must be a Number");
      if (this.start > this.end)
        throw new Error("start must be <= end");
      this.pos = this.start;
    }
    if (this.fd !== null) {
      process.nextTick(function() {
        s._read();
      });
      return;
    }
    n.open(this.path, this.flags, this.mode, function(l, f) {
      if (l) {
        s.emit("error", l), s.readable = !1;
        return;
      }
      s.fd = f, s.emit("open", f), s._read();
    });
  }
  function e(i, r) {
    if (!(this instanceof e))
      return new e(i, r);
    vp.call(this), this.path = i, this.fd = null, this.writable = !0, this.flags = "w", this.encoding = "binary", this.mode = 438, this.bytesWritten = 0, r = r || {};
    for (var s = Object.keys(r), a = 0, o = s.length; a < o; a++) {
      var c = s[a];
      this[c] = r[c];
    }
    if (this.start !== void 0) {
      if (typeof this.start != "number")
        throw TypeError("start must be a Number");
      if (this.start < 0)
        throw new Error("start must be >= zero");
      this.pos = this.start;
    }
    this.busy = !1, this._queue = [], this.fd === null && (this._open = n.open, this._queue.push([this._open, this.path, this.flags, this.mode, void 0]), this.flush());
  }
}
var MS = AS, SS = Object.getPrototypeOf || function(n) {
  return n.__proto__;
};
function AS(n) {
  if (n === null || typeof n != "object")
    return n;
  if (n instanceof Object)
    var t = { __proto__: SS(n) };
  else
    var t = /* @__PURE__ */ Object.create(null);
  return Object.getOwnPropertyNames(n).forEach(function(e) {
    Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e));
  }), t;
}
var un = Xe, TS = xS, CS = ES, RS = MS, zc = Xe, Pn, uu;
typeof Symbol == "function" && typeof Symbol.for == "function" ? (Pn = Symbol.for("graceful-fs.queue"), uu = Symbol.for("graceful-fs.previous")) : (Pn = "___graceful-fs.queue", uu = "___graceful-fs.previous");
function IS() {
}
function pm(n, t) {
  Object.defineProperty(n, Pn, {
    get: function() {
      return t;
    }
  });
}
var Ts = IS;
zc.debuglog ? Ts = zc.debuglog("gfs4") : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && (Ts = function() {
  var n = zc.format.apply(zc, arguments);
  n = "GFS4: " + n.split(/\n/).join(`
GFS4: `), console.error(n);
});
if (!un[Pn]) {
  var PS = cn[Pn] || [];
  pm(un, PS), un.close = function(n) {
    function t(e, i) {
      return n.call(un, e, function(r) {
        r || xp(), typeof i == "function" && i.apply(this, arguments);
      });
    }
    return Object.defineProperty(t, uu, {
      value: n
    }), t;
  }(un.close), un.closeSync = function(n) {
    function t(e) {
      n.apply(un, arguments), xp();
    }
    return Object.defineProperty(t, uu, {
      value: n
    }), t;
  }(un.closeSync), /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && process.on("exit", function() {
    Ts(un[Pn]), Xe.equal(un[Pn].length, 0);
  });
}
cn[Pn] || pm(cn, un[Pn]);
var Sa = df(RS(un));
process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !un.__patched && (Sa = df(un), un.__patched = !0);
function df(n) {
  TS(n), n.gracefulify = df, n.createReadStream = W, n.createWriteStream = C;
  var t = n.readFile;
  n.readFile = e;
  function e(A, I, it) {
    return typeof I == "function" && (it = I, I = null), V(A, I, it);
    function V(mt, k, B, G) {
      return t(mt, k, function(H) {
        H && (H.code === "EMFILE" || H.code === "ENFILE") ? ia([V, [mt, k, B], H, G || Date.now(), Date.now()]) : typeof B == "function" && B.apply(this, arguments);
      });
    }
  }
  var i = n.writeFile;
  n.writeFile = r;
  function r(A, I, it, V) {
    return typeof it == "function" && (V = it, it = null), mt(A, I, it, V);
    function mt(k, B, G, H, w) {
      return i(k, B, G, function(ut) {
        ut && (ut.code === "EMFILE" || ut.code === "ENFILE") ? ia([mt, [k, B, G, H], ut, w || Date.now(), Date.now()]) : typeof H == "function" && H.apply(this, arguments);
      });
    }
  }
  var s = n.appendFile;
  s && (n.appendFile = a);
  function a(A, I, it, V) {
    return typeof it == "function" && (V = it, it = null), mt(A, I, it, V);
    function mt(k, B, G, H, w) {
      return s(k, B, G, function(ut) {
        ut && (ut.code === "EMFILE" || ut.code === "ENFILE") ? ia([mt, [k, B, G, H], ut, w || Date.now(), Date.now()]) : typeof H == "function" && H.apply(this, arguments);
      });
    }
  }
  var o = n.copyFile;
  o && (n.copyFile = c);
  function c(A, I, it, V) {
    return typeof it == "function" && (V = it, it = 0), mt(A, I, it, V);
    function mt(k, B, G, H, w) {
      return o(k, B, G, function(ut) {
        ut && (ut.code === "EMFILE" || ut.code === "ENFILE") ? ia([mt, [k, B, G, H], ut, w || Date.now(), Date.now()]) : typeof H == "function" && H.apply(this, arguments);
      });
    }
  }
  var h = n.readdir;
  n.readdir = f;
  var l = /^v[0-5]\./;
  function f(A, I, it) {
    typeof I == "function" && (it = I, I = null);
    var V = l.test(process.version) ? function(B, G, H, w) {
      return h(B, mt(
        B,
        G,
        H,
        w
      ));
    } : function(B, G, H, w) {
      return h(B, G, mt(
        B,
        G,
        H,
        w
      ));
    };
    return V(A, I, it);
    function mt(k, B, G, H) {
      return function(w, ut) {
        w && (w.code === "EMFILE" || w.code === "ENFILE") ? ia([
          V,
          [k, B, G],
          w,
          H || Date.now(),
          Date.now()
        ]) : (ut && ut.sort && ut.sort(), typeof G == "function" && G.call(this, w, ut));
      };
    }
  }
  if (process.version.substr(0, 4) === "v0.8") {
    var d = CS(n);
    p = d.ReadStream, M = d.WriteStream;
  }
  var m = n.ReadStream;
  m && (p.prototype = Object.create(m.prototype), p.prototype.open = R);
  var v = n.WriteStream;
  v && (M.prototype = Object.create(v.prototype), M.prototype.open = P), Object.defineProperty(n, "ReadStream", {
    get: function() {
      return p;
    },
    set: function(A) {
      p = A;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(n, "WriteStream", {
    get: function() {
      return M;
    },
    set: function(A) {
      M = A;
    },
    enumerable: !0,
    configurable: !0
  });
  var E = p;
  Object.defineProperty(n, "FileReadStream", {
    get: function() {
      return E;
    },
    set: function(A) {
      E = A;
    },
    enumerable: !0,
    configurable: !0
  });
  var _ = M;
  Object.defineProperty(n, "FileWriteStream", {
    get: function() {
      return _;
    },
    set: function(A) {
      _ = A;
    },
    enumerable: !0,
    configurable: !0
  });
  function p(A, I) {
    return this instanceof p ? (m.apply(this, arguments), this) : p.apply(Object.create(p.prototype), arguments);
  }
  function R() {
    var A = this;
    N(A.path, A.flags, A.mode, function(I, it) {
      I ? (A.autoClose && A.destroy(), A.emit("error", I)) : (A.fd = it, A.emit("open", it), A.read());
    });
  }
  function M(A, I) {
    return this instanceof M ? (v.apply(this, arguments), this) : M.apply(Object.create(M.prototype), arguments);
  }
  function P() {
    var A = this;
    N(A.path, A.flags, A.mode, function(I, it) {
      I ? (A.destroy(), A.emit("error", I)) : (A.fd = it, A.emit("open", it));
    });
  }
  function W(A, I) {
    return new n.ReadStream(A, I);
  }
  function C(A, I) {
    return new n.WriteStream(A, I);
  }
  var D = n.open;
  n.open = N;
  function N(A, I, it, V) {
    return typeof it == "function" && (V = it, it = null), mt(A, I, it, V);
    function mt(k, B, G, H, w) {
      return D(k, B, G, function(ut, pt) {
        ut && (ut.code === "EMFILE" || ut.code === "ENFILE") ? ia([mt, [k, B, G, H], ut, w || Date.now(), Date.now()]) : typeof H == "function" && H.apply(this, arguments);
      });
    }
  }
  return n;
}
function ia(n) {
  Ts("ENQUEUE", n[0].name, n[1]), un[Pn].push(n), mf();
}
var Gc;
function xp() {
  for (var n = Date.now(), t = 0; t < un[Pn].length; ++t)
    un[Pn][t].length > 2 && (un[Pn][t][3] = n, un[Pn][t][4] = n);
  mf();
}
function mf() {
  if (clearTimeout(Gc), Gc = void 0, un[Pn].length !== 0) {
    var n = un[Pn].shift(), t = n[0], e = n[1], i = n[2], r = n[3], s = n[4];
    if (r === void 0)
      Ts("RETRY", t.name, e), t.apply(null, e);
    else if (Date.now() - r >= 6e4) {
      Ts("TIMEOUT", t.name, e);
      var a = e.pop();
      typeof a == "function" && a.call(null, i);
    } else {
      var o = Date.now() - s, c = Math.max(s - r, 1), h = Math.min(c * 1.2, 100);
      o >= h ? (Ts("RETRY", t.name, e), t.apply(null, e.concat([r]))) : un[Pn].push(n);
    }
    Gc === void 0 && (Gc = setTimeout(mf, 0));
  }
}
(function(n) {
  const t = En.fromCallback, e = Sa, i = [
    "access",
    "appendFile",
    "chmod",
    "chown",
    "close",
    "copyFile",
    "fchmod",
    "fchown",
    "fdatasync",
    "fstat",
    "fsync",
    "ftruncate",
    "futimes",
    "lchmod",
    "lchown",
    "link",
    "lstat",
    "mkdir",
    "mkdtemp",
    "open",
    "opendir",
    "readdir",
    "readFile",
    "readlink",
    "realpath",
    "rename",
    "rm",
    "rmdir",
    "stat",
    "symlink",
    "truncate",
    "unlink",
    "utimes",
    "writeFile"
  ].filter((r) => typeof e[r] == "function");
  Object.assign(n, e), i.forEach((r) => {
    n[r] = t(e[r]);
  }), n.exists = function(r, s) {
    return typeof s == "function" ? e.exists(r, s) : new Promise((a) => e.exists(r, a));
  }, n.read = function(r, s, a, o, c, h) {
    return typeof h == "function" ? e.read(r, s, a, o, c, h) : new Promise((l, f) => {
      e.read(r, s, a, o, c, (d, m, v) => {
        if (d)
          return f(d);
        l({ bytesRead: m, buffer: v });
      });
    });
  }, n.write = function(r, s, ...a) {
    return typeof a[a.length - 1] == "function" ? e.write(r, s, ...a) : new Promise((o, c) => {
      e.write(r, s, ...a, (h, l, f) => {
        if (h)
          return c(h);
        o({ bytesWritten: l, buffer: f });
      });
    });
  }, n.readv = function(r, s, ...a) {
    return typeof a[a.length - 1] == "function" ? e.readv(r, s, ...a) : new Promise((o, c) => {
      e.readv(r, s, ...a, (h, l, f) => {
        if (h)
          return c(h);
        o({ bytesRead: l, buffers: f });
      });
    });
  }, n.writev = function(r, s, ...a) {
    return typeof a[a.length - 1] == "function" ? e.writev(r, s, ...a) : new Promise((o, c) => {
      e.writev(r, s, ...a, (h, l, f) => {
        if (h)
          return c(h);
        o({ bytesWritten: l, buffers: f });
      });
    });
  }, typeof e.realpath.native == "function" ? n.realpath.native = t(e.realpath.native) : process.emitWarning(
    "fs.realpath.native is not a function. Is fs being monkey-patched?",
    "Warning",
    "fs-extra-WARN0003"
  );
})(Xn);
var _f = {}, dm = {};
const LS = Xe;
dm.checkPath = function(t) {
  if (process.platform === "win32" && /[<>:"|?*]/.test(t.replace(LS.parse(t).root, ""))) {
    const i = new Error(`Path contains invalid characters: ${t}`);
    throw i.code = "EINVAL", i;
  }
};
const mm = Xn, { checkPath: _m } = dm, ym = (n) => {
  const t = { mode: 511 };
  return typeof n == "number" ? n : { ...t, ...n }.mode;
};
_f.makeDir = async (n, t) => (_m(n), mm.mkdir(n, {
  mode: ym(t),
  recursive: !0
}));
_f.makeDirSync = (n, t) => (_m(n), mm.mkdirSync(n, {
  mode: ym(t),
  recursive: !0
}));
const OS = En.fromPromise, { makeDir: DS, makeDirSync: cl } = _f, ul = OS(DS);
var Gi = {
  mkdirs: ul,
  mkdirsSync: cl,
  // alias
  mkdirp: ul,
  mkdirpSync: cl,
  ensureDir: ul,
  ensureDirSync: cl
};
const NS = En.fromPromise, gm = Xn;
function FS(n) {
  return gm.access(n).then(() => !0).catch(() => !1);
}
var Ls = {
  pathExists: NS(FS),
  pathExistsSync: gm.existsSync
};
const da = Xn, US = En.fromPromise;
async function BS(n, t, e) {
  const i = await da.open(n, "r+");
  let r = null;
  try {
    await da.futimes(i, t, e);
  } finally {
    try {
      await da.close(i);
    } catch (s) {
      r = s;
    }
  }
  if (r)
    throw r;
}
function kS(n, t, e) {
  const i = da.openSync(n, "r+");
  return da.futimesSync(i, t, e), da.closeSync(i);
}
var vm = {
  utimesMillis: US(BS),
  utimesMillisSync: kS
};
const xa = Xn, Tn = Xe, bp = En.fromPromise;
function zS(n, t, e) {
  const i = e.dereference ? (r) => xa.stat(r, { bigint: !0 }) : (r) => xa.lstat(r, { bigint: !0 });
  return Promise.all([
    i(n),
    i(t).catch((r) => {
      if (r.code === "ENOENT")
        return null;
      throw r;
    })
  ]).then(([r, s]) => ({ srcStat: r, destStat: s }));
}
function GS(n, t, e) {
  let i;
  const r = e.dereference ? (a) => xa.statSync(a, { bigint: !0 }) : (a) => xa.lstatSync(a, { bigint: !0 }), s = r(n);
  try {
    i = r(t);
  } catch (a) {
    if (a.code === "ENOENT")
      return { srcStat: s, destStat: null };
    throw a;
  }
  return { srcStat: s, destStat: i };
}
async function VS(n, t, e, i) {
  const { srcStat: r, destStat: s } = await zS(n, t, i);
  if (s) {
    if (fo(r, s)) {
      const a = Tn.basename(n), o = Tn.basename(t);
      if (e === "move" && a !== o && a.toLowerCase() === o.toLowerCase())
        return { srcStat: r, destStat: s, isChangingCase: !0 };
      throw new Error("Source and destination must not be the same.");
    }
    if (r.isDirectory() && !s.isDirectory())
      throw new Error(`Cannot overwrite non-directory '${t}' with directory '${n}'.`);
    if (!r.isDirectory() && s.isDirectory())
      throw new Error(`Cannot overwrite directory '${t}' with non-directory '${n}'.`);
  }
  if (r.isDirectory() && yf(n, t))
    throw new Error(yu(n, t, e));
  return { srcStat: r, destStat: s };
}
function HS(n, t, e, i) {
  const { srcStat: r, destStat: s } = GS(n, t, i);
  if (s) {
    if (fo(r, s)) {
      const a = Tn.basename(n), o = Tn.basename(t);
      if (e === "move" && a !== o && a.toLowerCase() === o.toLowerCase())
        return { srcStat: r, destStat: s, isChangingCase: !0 };
      throw new Error("Source and destination must not be the same.");
    }
    if (r.isDirectory() && !s.isDirectory())
      throw new Error(`Cannot overwrite non-directory '${t}' with directory '${n}'.`);
    if (!r.isDirectory() && s.isDirectory())
      throw new Error(`Cannot overwrite directory '${t}' with non-directory '${n}'.`);
  }
  if (r.isDirectory() && yf(n, t))
    throw new Error(yu(n, t, e));
  return { srcStat: r, destStat: s };
}
async function xm(n, t, e, i) {
  const r = Tn.resolve(Tn.dirname(n)), s = Tn.resolve(Tn.dirname(e));
  if (s === r || s === Tn.parse(s).root)
    return;
  let a;
  try {
    a = await xa.stat(s, { bigint: !0 });
  } catch (o) {
    if (o.code === "ENOENT")
      return;
    throw o;
  }
  if (fo(t, a))
    throw new Error(yu(n, e, i));
  return xm(n, t, s, i);
}
function bm(n, t, e, i) {
  const r = Tn.resolve(Tn.dirname(n)), s = Tn.resolve(Tn.dirname(e));
  if (s === r || s === Tn.parse(s).root)
    return;
  let a;
  try {
    a = xa.statSync(s, { bigint: !0 });
  } catch (o) {
    if (o.code === "ENOENT")
      return;
    throw o;
  }
  if (fo(t, a))
    throw new Error(yu(n, e, i));
  return bm(n, t, s, i);
}
function fo(n, t) {
  return t.ino && t.dev && t.ino === n.ino && t.dev === n.dev;
}
function yf(n, t) {
  const e = Tn.resolve(n).split(Tn.sep).filter((r) => r), i = Tn.resolve(t).split(Tn.sep).filter((r) => r);
  return e.every((r, s) => i[s] === r);
}
function yu(n, t, e) {
  return `Cannot ${e} '${n}' to a subdirectory of itself, '${t}'.`;
}
var Aa = {
  // checkPaths
  checkPaths: bp(VS),
  checkPathsSync: HS,
  // checkParent
  checkParentPaths: bp(xm),
  checkParentPathsSync: bm,
  // Misc
  isSrcSubdir: yf,
  areIdentical: fo
};
const kn = Xn, no = Xe, { mkdirs: jS } = Gi, { pathExists: WS } = Ls, { utimesMillis: qS } = vm, io = Aa;
async function $S(n, t, e = {}) {
  typeof e == "function" && (e = { filter: e }), e.clobber = "clobber" in e ? !!e.clobber : !0, e.overwrite = "overwrite" in e ? !!e.overwrite : e.clobber, e.preserveTimestamps && process.arch === "ia32" && process.emitWarning(
    `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
    "Warning",
    "fs-extra-WARN0001"
  );
  const { srcStat: i, destStat: r } = await io.checkPaths(n, t, "copy", e);
  if (await io.checkParentPaths(n, i, t, "copy"), !await Em(n, t, e))
    return;
  const a = no.dirname(t);
  await WS(a) || await jS(a), await wm(r, n, t, e);
}
async function Em(n, t, e) {
  return e.filter ? e.filter(n, t) : !0;
}
async function wm(n, t, e, i) {
  const s = await (i.dereference ? kn.stat : kn.lstat)(t);
  if (s.isDirectory())
    return ZS(s, n, t, e, i);
  if (s.isFile() || s.isCharacterDevice() || s.isBlockDevice())
    return XS(s, n, t, e, i);
  if (s.isSymbolicLink())
    return JS(n, t, e, i);
  throw s.isSocket() ? new Error(`Cannot copy a socket file: ${t}`) : s.isFIFO() ? new Error(`Cannot copy a FIFO pipe: ${t}`) : new Error(`Unknown file: ${t}`);
}
async function XS(n, t, e, i, r) {
  if (!t)
    return Ep(n, e, i, r);
  if (r.overwrite)
    return await kn.unlink(i), Ep(n, e, i, r);
  if (r.errorOnExist)
    throw new Error(`'${i}' already exists`);
}
async function Ep(n, t, e, i) {
  if (await kn.copyFile(t, e), i.preserveTimestamps) {
    YS(n.mode) && await KS(e, n.mode);
    const r = await kn.stat(t);
    await qS(e, r.atime, r.mtime);
  }
  return kn.chmod(e, n.mode);
}
function YS(n) {
  return (n & 128) === 0;
}
function KS(n, t) {
  return kn.chmod(n, t | 128);
}
async function ZS(n, t, e, i, r) {
  t || await kn.mkdir(i);
  const s = await kn.readdir(e);
  await Promise.all(s.map(async (a) => {
    const o = no.join(e, a), c = no.join(i, a);
    if (!await Em(o, c, r))
      return;
    const { destStat: l } = await io.checkPaths(o, c, "copy", r);
    return wm(l, o, c, r);
  })), t || await kn.chmod(i, n.mode);
}
async function JS(n, t, e, i) {
  let r = await kn.readlink(t);
  if (i.dereference && (r = no.resolve(process.cwd(), r)), !n)
    return kn.symlink(r, e);
  let s = null;
  try {
    s = await kn.readlink(e);
  } catch (a) {
    if (a.code === "EINVAL" || a.code === "UNKNOWN")
      return kn.symlink(r, e);
    throw a;
  }
  if (i.dereference && (s = no.resolve(process.cwd(), s)), io.isSrcSubdir(r, s))
    throw new Error(`Cannot copy '${r}' to a subdirectory of itself, '${s}'.`);
  if (io.isSrcSubdir(s, r))
    throw new Error(`Cannot overwrite '${s}' with '${r}'.`);
  return await kn.unlink(e), kn.symlink(r, e);
}
var QS = $S;
const Wn = Sa, ro = Xe, tA = Gi.mkdirsSync, eA = vm.utimesMillisSync, so = Aa;
function nA(n, t, e) {
  typeof e == "function" && (e = { filter: e }), e = e || {}, e.clobber = "clobber" in e ? !!e.clobber : !0, e.overwrite = "overwrite" in e ? !!e.overwrite : e.clobber, e.preserveTimestamps && process.arch === "ia32" && process.emitWarning(
    `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
    "Warning",
    "fs-extra-WARN0002"
  );
  const { srcStat: i, destStat: r } = so.checkPathsSync(n, t, "copy", e);
  if (so.checkParentPathsSync(n, i, t, "copy"), e.filter && !e.filter(n, t))
    return;
  const s = ro.dirname(t);
  return Wn.existsSync(s) || tA(s), Mm(r, n, t, e);
}
function Mm(n, t, e, i) {
  const s = (i.dereference ? Wn.statSync : Wn.lstatSync)(t);
  if (s.isDirectory())
    return uA(s, n, t, e, i);
  if (s.isFile() || s.isCharacterDevice() || s.isBlockDevice())
    return iA(s, n, t, e, i);
  if (s.isSymbolicLink())
    return hA(n, t, e, i);
  throw s.isSocket() ? new Error(`Cannot copy a socket file: ${t}`) : s.isFIFO() ? new Error(`Cannot copy a FIFO pipe: ${t}`) : new Error(`Unknown file: ${t}`);
}
function iA(n, t, e, i, r) {
  return t ? rA(n, e, i, r) : Sm(n, e, i, r);
}
function rA(n, t, e, i) {
  if (i.overwrite)
    return Wn.unlinkSync(e), Sm(n, t, e, i);
  if (i.errorOnExist)
    throw new Error(`'${e}' already exists`);
}
function Sm(n, t, e, i) {
  return Wn.copyFileSync(t, e), i.preserveTimestamps && sA(n.mode, t, e), gf(e, n.mode);
}
function sA(n, t, e) {
  return aA(n) && oA(e, n), cA(t, e);
}
function aA(n) {
  return (n & 128) === 0;
}
function oA(n, t) {
  return gf(n, t | 128);
}
function gf(n, t) {
  return Wn.chmodSync(n, t);
}
function cA(n, t) {
  const e = Wn.statSync(n);
  return eA(t, e.atime, e.mtime);
}
function uA(n, t, e, i, r) {
  return t ? Am(e, i, r) : lA(n.mode, e, i, r);
}
function lA(n, t, e, i) {
  return Wn.mkdirSync(e), Am(t, e, i), gf(e, n);
}
function Am(n, t, e) {
  Wn.readdirSync(n).forEach((i) => fA(i, n, t, e));
}
function fA(n, t, e, i) {
  const r = ro.join(t, n), s = ro.join(e, n);
  if (i.filter && !i.filter(r, s))
    return;
  const { destStat: a } = so.checkPathsSync(r, s, "copy", i);
  return Mm(a, r, s, i);
}
function hA(n, t, e, i) {
  let r = Wn.readlinkSync(t);
  if (i.dereference && (r = ro.resolve(process.cwd(), r)), n) {
    let s;
    try {
      s = Wn.readlinkSync(e);
    } catch (a) {
      if (a.code === "EINVAL" || a.code === "UNKNOWN")
        return Wn.symlinkSync(r, e);
      throw a;
    }
    if (i.dereference && (s = ro.resolve(process.cwd(), s)), so.isSrcSubdir(r, s))
      throw new Error(`Cannot copy '${r}' to a subdirectory of itself, '${s}'.`);
    if (so.isSrcSubdir(s, r))
      throw new Error(`Cannot overwrite '${s}' with '${r}'.`);
    return pA(r, e);
  } else
    return Wn.symlinkSync(r, e);
}
function pA(n, t) {
  return Wn.unlinkSync(t), Wn.symlinkSync(n, t);
}
var dA = nA;
const mA = En.fromPromise;
var vf = {
  copy: mA(QS),
  copySync: dA
};
const Tm = Sa, _A = En.fromCallback;
function yA(n, t) {
  Tm.rm(n, { recursive: !0, force: !0 }, t);
}
function gA(n) {
  Tm.rmSync(n, { recursive: !0, force: !0 });
}
var gu = {
  remove: _A(yA),
  removeSync: gA
};
const vA = En.fromPromise, Cm = Xn, Rm = Xe, Im = Gi, Pm = gu, wp = vA(async function(t) {
  let e;
  try {
    e = await Cm.readdir(t);
  } catch {
    return Im.mkdirs(t);
  }
  return Promise.all(e.map((i) => Pm.remove(Rm.join(t, i))));
});
function Mp(n) {
  let t;
  try {
    t = Cm.readdirSync(n);
  } catch {
    return Im.mkdirsSync(n);
  }
  t.forEach((e) => {
    e = Rm.join(n, e), Pm.removeSync(e);
  });
}
var xA = {
  emptyDirSync: Mp,
  emptydirSync: Mp,
  emptyDir: wp,
  emptydir: wp
};
const bA = En.fromPromise, Lm = Xe, ar = Xn, Om = Gi;
async function EA(n) {
  let t;
  try {
    t = await ar.stat(n);
  } catch {
  }
  if (t && t.isFile())
    return;
  const e = Lm.dirname(n);
  let i = null;
  try {
    i = await ar.stat(e);
  } catch (r) {
    if (r.code === "ENOENT") {
      await Om.mkdirs(e), await ar.writeFile(n, "");
      return;
    } else
      throw r;
  }
  i.isDirectory() ? await ar.writeFile(n, "") : await ar.readdir(e);
}
function wA(n) {
  let t;
  try {
    t = ar.statSync(n);
  } catch {
  }
  if (t && t.isFile())
    return;
  const e = Lm.dirname(n);
  try {
    ar.statSync(e).isDirectory() || ar.readdirSync(e);
  } catch (i) {
    if (i && i.code === "ENOENT")
      Om.mkdirsSync(e);
    else
      throw i;
  }
  ar.writeFileSync(n, "");
}
var MA = {
  createFile: bA(EA),
  createFileSync: wA
};
const SA = En.fromPromise, Dm = Xe, Or = Xn, Nm = Gi, { pathExists: AA } = Ls, { areIdentical: Fm } = Aa;
async function TA(n, t) {
  let e;
  try {
    e = await Or.lstat(t);
  } catch {
  }
  let i;
  try {
    i = await Or.lstat(n);
  } catch (a) {
    throw a.message = a.message.replace("lstat", "ensureLink"), a;
  }
  if (e && Fm(i, e))
    return;
  const r = Dm.dirname(t);
  await AA(r) || await Nm.mkdirs(r), await Or.link(n, t);
}
function CA(n, t) {
  let e;
  try {
    e = Or.lstatSync(t);
  } catch {
  }
  try {
    const s = Or.lstatSync(n);
    if (e && Fm(s, e))
      return;
  } catch (s) {
    throw s.message = s.message.replace("lstat", "ensureLink"), s;
  }
  const i = Dm.dirname(t);
  return Or.existsSync(i) || Nm.mkdirsSync(i), Or.linkSync(n, t);
}
var RA = {
  createLink: SA(TA),
  createLinkSync: CA
};
const Ur = Xe, Ya = Xn, { pathExists: IA } = Ls, PA = En.fromPromise;
async function LA(n, t) {
  if (Ur.isAbsolute(n)) {
    try {
      await Ya.lstat(n);
    } catch (s) {
      throw s.message = s.message.replace("lstat", "ensureSymlink"), s;
    }
    return {
      toCwd: n,
      toDst: n
    };
  }
  const e = Ur.dirname(t), i = Ur.join(e, n);
  if (await IA(i))
    return {
      toCwd: i,
      toDst: n
    };
  try {
    await Ya.lstat(n);
  } catch (s) {
    throw s.message = s.message.replace("lstat", "ensureSymlink"), s;
  }
  return {
    toCwd: n,
    toDst: Ur.relative(e, n)
  };
}
function OA(n, t) {
  if (Ur.isAbsolute(n)) {
    if (!Ya.existsSync(n))
      throw new Error("absolute srcpath does not exist");
    return {
      toCwd: n,
      toDst: n
    };
  }
  const e = Ur.dirname(t), i = Ur.join(e, n);
  if (Ya.existsSync(i))
    return {
      toCwd: i,
      toDst: n
    };
  if (!Ya.existsSync(n))
    throw new Error("relative srcpath does not exist");
  return {
    toCwd: n,
    toDst: Ur.relative(e, n)
  };
}
var DA = {
  symlinkPaths: PA(LA),
  symlinkPathsSync: OA
};
const Um = Xn, NA = En.fromPromise;
async function FA(n, t) {
  if (t)
    return t;
  let e;
  try {
    e = await Um.lstat(n);
  } catch {
    return "file";
  }
  return e && e.isDirectory() ? "dir" : "file";
}
function UA(n, t) {
  if (t)
    return t;
  let e;
  try {
    e = Um.lstatSync(n);
  } catch {
    return "file";
  }
  return e && e.isDirectory() ? "dir" : "file";
}
var BA = {
  symlinkType: NA(FA),
  symlinkTypeSync: UA
};
const kA = En.fromPromise, Bm = Xe, Ni = Xn, { mkdirs: zA, mkdirsSync: GA } = Gi, { symlinkPaths: VA, symlinkPathsSync: HA } = DA, { symlinkType: jA, symlinkTypeSync: WA } = BA, { pathExists: qA } = Ls, { areIdentical: km } = Aa;
async function $A(n, t, e) {
  let i;
  try {
    i = await Ni.lstat(t);
  } catch {
  }
  if (i && i.isSymbolicLink()) {
    const [o, c] = await Promise.all([
      Ni.stat(n),
      Ni.stat(t)
    ]);
    if (km(o, c))
      return;
  }
  const r = await VA(n, t);
  n = r.toDst;
  const s = await jA(r.toCwd, e), a = Bm.dirname(t);
  return await qA(a) || await zA(a), Ni.symlink(n, t, s);
}
function XA(n, t, e) {
  let i;
  try {
    i = Ni.lstatSync(t);
  } catch {
  }
  if (i && i.isSymbolicLink()) {
    const o = Ni.statSync(n), c = Ni.statSync(t);
    if (km(o, c))
      return;
  }
  const r = HA(n, t);
  n = r.toDst, e = WA(r.toCwd, e);
  const s = Bm.dirname(t);
  return Ni.existsSync(s) || GA(s), Ni.symlinkSync(n, t, e);
}
var YA = {
  createSymlink: kA($A),
  createSymlinkSync: XA
};
const { createFile: Sp, createFileSync: Ap } = MA, { createLink: Tp, createLinkSync: Cp } = RA, { createSymlink: Rp, createSymlinkSync: Ip } = YA;
var KA = {
  // file
  createFile: Sp,
  createFileSync: Ap,
  ensureFile: Sp,
  ensureFileSync: Ap,
  // link
  createLink: Tp,
  createLinkSync: Cp,
  ensureLink: Tp,
  ensureLinkSync: Cp,
  // symlink
  createSymlink: Rp,
  createSymlinkSync: Ip,
  ensureSymlink: Rp,
  ensureSymlinkSync: Ip
};
function ZA(n, { EOL: t = `
`, finalEOL: e = !0, replacer: i = null, spaces: r } = {}) {
  const s = e ? t : "";
  return JSON.stringify(n, i, r).replace(/\n/g, t) + s;
}
function JA(n) {
  return Buffer.isBuffer(n) && (n = n.toString("utf8")), n.replace(/^\uFEFF/, "");
}
var xf = { stringify: ZA, stripBom: JA };
let ba;
try {
  ba = Sa;
} catch {
  ba = Xe;
}
const vu = En, { stringify: zm, stripBom: Gm } = xf;
async function QA(n, t = {}) {
  typeof t == "string" && (t = { encoding: t });
  const e = t.fs || ba, i = "throws" in t ? t.throws : !0;
  let r = await vu.fromCallback(e.readFile)(n, t);
  r = Gm(r);
  let s;
  try {
    s = JSON.parse(r, t ? t.reviver : null);
  } catch (a) {
    if (i)
      throw a.message = `${n}: ${a.message}`, a;
    return null;
  }
  return s;
}
const tT = vu.fromPromise(QA);
function eT(n, t = {}) {
  typeof t == "string" && (t = { encoding: t });
  const e = t.fs || ba, i = "throws" in t ? t.throws : !0;
  try {
    let r = e.readFileSync(n, t);
    return r = Gm(r), JSON.parse(r, t.reviver);
  } catch (r) {
    if (i)
      throw r.message = `${n}: ${r.message}`, r;
    return null;
  }
}
async function nT(n, t, e = {}) {
  const i = e.fs || ba, r = zm(t, e);
  await vu.fromCallback(i.writeFile)(n, r, e);
}
const iT = vu.fromPromise(nT);
function rT(n, t, e = {}) {
  const i = e.fs || ba, r = zm(t, e);
  return i.writeFileSync(n, r, e);
}
const sT = {
  readFile: tT,
  readFileSync: eT,
  writeFile: iT,
  writeFileSync: rT
};
var aT = sT;
const Vc = aT;
var oT = {
  // jsonfile exports
  readJson: Vc.readFile,
  readJsonSync: Vc.readFileSync,
  writeJson: Vc.writeFile,
  writeJsonSync: Vc.writeFileSync
};
const cT = En.fromPromise, Nl = Xn, Vm = Xe, Hm = Gi, uT = Ls.pathExists;
async function lT(n, t, e = "utf-8") {
  const i = Vm.dirname(n);
  return await uT(i) || await Hm.mkdirs(i), Nl.writeFile(n, t, e);
}
function fT(n, ...t) {
  const e = Vm.dirname(n);
  Nl.existsSync(e) || Hm.mkdirsSync(e), Nl.writeFileSync(n, ...t);
}
var bf = {
  outputFile: cT(lT),
  outputFileSync: fT
};
const { stringify: hT } = xf, { outputFile: pT } = bf;
async function dT(n, t, e = {}) {
  const i = hT(t, e);
  await pT(n, i, e);
}
var mT = dT;
const { stringify: _T } = xf, { outputFileSync: yT } = bf;
function gT(n, t, e) {
  const i = _T(t, e);
  yT(n, i, e);
}
var vT = gT;
const xT = En.fromPromise, $n = oT;
$n.outputJson = xT(mT);
$n.outputJsonSync = vT;
$n.outputJSON = $n.outputJson;
$n.outputJSONSync = $n.outputJsonSync;
$n.writeJSON = $n.writeJson;
$n.writeJSONSync = $n.writeJsonSync;
$n.readJSON = $n.readJson;
$n.readJSONSync = $n.readJsonSync;
var bT = $n;
const ET = Xn, Pp = Xe, { copy: wT } = vf, { remove: jm } = gu, { mkdirp: MT } = Gi, { pathExists: ST } = Ls, Lp = Aa;
async function AT(n, t, e = {}) {
  const i = e.overwrite || e.clobber || !1, { srcStat: r, isChangingCase: s = !1 } = await Lp.checkPaths(n, t, "move", e);
  await Lp.checkParentPaths(n, r, t, "move");
  const a = Pp.dirname(t);
  return Pp.parse(a).root !== a && await MT(a), TT(n, t, i, s);
}
async function TT(n, t, e, i) {
  if (!i) {
    if (e)
      await jm(t);
    else if (await ST(t))
      throw new Error("dest already exists.");
  }
  try {
    await ET.rename(n, t);
  } catch (r) {
    if (r.code !== "EXDEV")
      throw r;
    await CT(n, t, e);
  }
}
async function CT(n, t, e) {
  return await wT(n, t, {
    overwrite: e,
    errorOnExist: !0,
    preserveTimestamps: !0
  }), jm(n);
}
var RT = AT;
const Wm = Sa, Fl = Xe, IT = vf.copySync, qm = gu.removeSync, PT = Gi.mkdirpSync, Op = Aa;
function LT(n, t, e) {
  e = e || {};
  const i = e.overwrite || e.clobber || !1, { srcStat: r, isChangingCase: s = !1 } = Op.checkPathsSync(n, t, "move", e);
  return Op.checkParentPathsSync(n, r, t, "move"), OT(t) || PT(Fl.dirname(t)), DT(n, t, i, s);
}
function OT(n) {
  const t = Fl.dirname(n);
  return Fl.parse(t).root === t;
}
function DT(n, t, e, i) {
  if (i)
    return ll(n, t, e);
  if (e)
    return qm(t), ll(n, t, e);
  if (Wm.existsSync(t))
    throw new Error("dest already exists.");
  return ll(n, t, e);
}
function ll(n, t, e) {
  try {
    Wm.renameSync(n, t);
  } catch (i) {
    if (i.code !== "EXDEV")
      throw i;
    return NT(n, t, e);
  }
}
function NT(n, t, e) {
  return IT(n, t, {
    overwrite: e,
    errorOnExist: !0,
    preserveTimestamps: !0
  }), qm(n);
}
var FT = LT;
const UT = En.fromPromise;
var BT = {
  move: UT(RT),
  moveSync: FT
}, kT = {
  // Export promiseified graceful-fs:
  ...Xn,
  // Export extra methods:
  ...vf,
  ...xA,
  ...KA,
  ...bT,
  ...Gi,
  ...BT,
  ...bf,
  ...Ls,
  ...gu
}, zT = GT;
function GT(n) {
  const t = n.slice(n.indexOf(",") + 1);
  return n.indexOf("base64") >= 0 ? Buffer.from(t, "base64") : Buffer.from(t, "utf8");
}
const { Check: VT, RuntimeError: ao } = Be, HT = Xe, Dp = Xe, { domainToUnicode: jT, URL: $m } = Xe;
var WT = {
  fileURLToPath: n2,
  pathToFileURL: i2
};
const Ul = HT.platform() === "win32", qT = /\//g, $T = 97, XT = 122, YT = 47, KT = 92, ZT = /%/g, JT = /\\/g, QT = /\n/g, t2 = /\r/g, e2 = /\t/g;
function n2(n) {
  if (VT.defined("path", n), typeof n == "string" && (n = new $m(n)), n.protocol !== "file:")
    throw new ao("Expected path.protocol to start with file:");
  return Ul ? r2(n) : s2(n);
}
function i2(n) {
  let t = Dp.resolve(n);
  const e = n.charCodeAt(n.length - 1);
  (e === YT || Ul && e === KT) && t[t.length - 1] !== Dp.sep && (t += "/");
  const i = new $m("file://");
  return t.includes("%") && (t = t.replace(ZT, "%25")), !Ul && t.includes("\\") && (t = t.replace(JT, "%5C")), t.includes(`
`) && (t = t.replace(QT, "%0A")), t.includes("\r") && (t = t.replace(t2, "%0D")), t.includes("	") && (t = t.replace(e2, "%09")), i.pathname = t, i;
}
function r2(n) {
  const t = n.hostname;
  let e = n.pathname;
  for (let s = 0; s < e.length; s++)
    if (e[s] === "%") {
      const a = e.codePointAt(s + 2) | 32;
      if (e[s + 1] === "2" && a === 102 || // 2f 2F /
      e[s + 1] === "5" && a === 99)
        throw new ao(
          "file URL must not include encoded \\ or / characters"
        );
    }
  if (e = e.replace(qT, "\\"), e = decodeURIComponent(e), t !== "")
    return `\\\\${jT(t)}${e}`;
  const i = e.codePointAt(1) | 32, r = e[2];
  if (i < $T || i > XT || // a..z A..Z
  r !== ":")
    throw new ao("file URL must be absolute");
  return e.slice(1);
}
function s2(n) {
  if (n.hostname !== "")
    throw new ao("Invalid platform");
  const t = n.pathname;
  for (let e = 0; e < t.length; e++)
    if (t[e] === "%") {
      const i = t.codePointAt(e + 2) | 32;
      if (t[e + 1] === "2" && i === 102)
        throw new ao(
          "file URL must not include encoded \\ or / characters"
        );
    }
  return decodeURIComponent(t);
}
const xu = Be, a2 = kT, la = Xe, Dr = ff, { URL: o2 } = Xe, c2 = lf, u2 = zT, { fileURLToPath: l2, pathToFileURL: f2 } = WT, fl = Ln, or = xu.defined, Xm = xu.defaultValue, h2 = xu.isDataUri, p2 = xu.RuntimeError;
var d2 = m2;
function m2(n, t) {
  c2(n), t = Xm(t, {}), t.resourceDirectory = or(t.resourceDirectory) ? la.resolve(t.resourceDirectory) + la.sep : void 0;
  const e = [], i = [];
  return fl.buffer(n, function(r) {
    e.push(_2(n, r, t));
  }), Dr.all(e).then(function() {
    return fl.shader(n, function(r) {
      i.push(g2(n, r, t));
    }), fl.image(n, function(r) {
      i.push(y2(n, r, t));
    }), Dr.all(i);
  }).then(function() {
    return n;
  });
}
function _2(n, t, e) {
  return Ef(n, t, !1, e).then(function(i) {
    or(i) && (t.extras._pipeline.source = i);
  });
}
function y2(n, t, e) {
  return Ef(n, t, !0, e).then(function(i) {
    t.extras._pipeline.source = i;
  });
}
function g2(n, t, e) {
  return Ef(n, t, !0, e).then(function(i) {
    t.extras._pipeline.source = i.toString();
  });
}
function Ef(n, t, e, i) {
  const r = t.uri;
  delete t.uri;
  const s = t.extras._pipeline.source;
  if (or(s))
    return Dr.resolve(Buffer.from(s));
  const a = t.extensions;
  if (or(a)) {
    const o = a.KHR_binary_glTF;
    if (or(o))
      return Dr.resolve(
        Np(n, o.bufferView, t, e)
      );
  }
  return or(t.bufferView) ? Dr.resolve(
    Np(n, t.bufferView, t, e)
  ) : or(r) ? h2(r) ? Dr.resolve(u2(r)) : v2(t, r, e, i) : Dr.resolve(void 0);
}
function Np(n, t, e, i) {
  i && (e.extras._pipeline.resourceId = t);
  const r = n.bufferViews[t], a = n.buffers[r.buffer].extras._pipeline.source, o = Xm(r.byteOffset, 0);
  return a.slice(o, o + r.byteLength);
}
function v2(n, t, e, i) {
  const r = i.resourceDirectory, s = or(r);
  let a;
  try {
    a = new o2(
      t,
      s ? f2(r) : void 0
    );
  } catch {
    return Dr.reject(
      new p2(
        "glTF model references separate files but no resourceDirectory is supplied"
      )
    );
  }
  const o = l2(a), c = s ? la.relative(r, o) : la.basename(o);
  if (!or(n.name)) {
    const h = la.extname(c);
    n.name = la.basename(c, h);
  }
  return e && (n.extras._pipeline.resourceId = o), n.extras._pipeline.absolutePath = o, n.extras._pipeline.relativePath = c, a2.readFile(o);
}
const Ym = Be, Fp = Ln, x2 = Ym.defined, hl = Ym.Matrix4;
var b2 = E2;
function E2(n) {
  return Fp.node(n, function(t) {
    x2(t.matrix) && hl.equals(hl.fromArray(t.matrix), hl.IDENTITY) && delete t.matrix;
  }), Fp.accessor(n, function(t) {
    t.normalized === !1 && delete t.normalized;
  }), n;
}
const w2 = Be, pl = Ln, Up = w2.defined;
var M2 = S2;
function S2(n) {
  return pl.shader(n, function(t) {
    Hc(t);
  }), pl.buffer(n, function(t) {
    Hc(t);
  }), pl.image(n, function(t) {
    Hc(t);
  }), Hc(n), n;
}
function Hc(n) {
  Up(n.extras) && (Up(n.extras._pipeline) && delete n.extras._pipeline, Object.keys(n.extras).length === 0 && delete n.extras);
}
const Km = Be, A2 = Ln, Bp = Km.Check, ke = Km.defined;
var T2 = C2;
function C2(n, t) {
  Bp.typeOf.object("material", n), Bp.defined("handler", t);
  const e = n.pbrMetallicRoughness;
  if (ke(e)) {
    if (ke(e.baseColorTexture)) {
      const r = e.baseColorTexture, s = t(r.index, r);
      if (ke(s))
        return s;
    }
    if (ke(e.metallicRoughnessTexture)) {
      const r = e.metallicRoughnessTexture, s = t(r.index, r);
      if (ke(s))
        return s;
    }
  }
  if (ke(n.extensions)) {
    const r = n.extensions.KHR_materials_pbrSpecularGlossiness;
    if (ke(r)) {
      if (ke(r.diffuseTexture)) {
        const a = r.diffuseTexture, o = t(a.index, a);
        if (ke(o))
          return o;
      }
      if (ke(r.specularGlossinessTexture)) {
        const a = r.specularGlossinessTexture, o = t(a.index, a);
        if (ke(o))
          return o;
      }
    }
    const s = n.extensions.KHR_materials_common;
    if (ke(s) && ke(s.values)) {
      const a = s.values.diffuse, o = s.values.ambient, c = s.values.emission, h = s.values.specular;
      if (ke(a) && ke(a.index)) {
        const l = t(a.index, a);
        if (ke(l))
          return l;
      }
      if (ke(o) && ke(o.index)) {
        const l = t(o.index, o);
        if (ke(l))
          return l;
      }
      if (ke(c) && ke(c.index)) {
        const l = t(c.index, c);
        if (ke(l))
          return l;
      }
      if (ke(h) && ke(h.index)) {
        const l = t(h.index, h);
        if (ke(l))
          return l;
      }
    }
  }
  const i = A2.materialValue(n, function(r) {
    if (ke(r.index)) {
      const s = t(r.index, r);
      if (ke(s))
        return s;
    }
  });
  if (ke(i))
    return i;
  if (ke(n.emissiveTexture)) {
    const r = n.emissiveTexture, s = t(r.index, r);
    if (ke(s))
      return s;
  }
  if (ke(n.normalTexture)) {
    const r = n.normalTexture, s = t(r.index, r);
    if (ke(s))
      return s;
  }
  if (ke(n.occlusionTexture)) {
    const r = n.occlusionTexture, s = t(r.index, r);
    if (ke(s))
      return s;
  }
}
const Zm = Be, de = Ln, Jm = T2, Jn = im, R2 = Zm.defaultValue, ie = Zm.defined;
var ho = I2;
const kp = [
  "mesh",
  "node",
  "material",
  "accessor",
  "bufferView",
  "buffer",
  "texture",
  "sampler",
  "image"
];
function I2(n, t) {
  return t = R2(t, kp), kp.forEach(function(e) {
    t.indexOf(e) > -1 && L2(n, e);
  }), n;
}
const P2 = {
  accessor: "accessors",
  buffer: "buffers",
  bufferView: "bufferViews",
  image: "images",
  node: "nodes",
  material: "materials",
  mesh: "meshes",
  sampler: "samplers",
  texture: "textures"
};
function L2(n, t) {
  const e = P2[t], i = n[e];
  if (ie(i)) {
    let r = 0;
    const s = Hi[t](n), a = i.length;
    for (let o = 0; o < a; ++o)
      s[o] || (Vi[t](n, o - r), r++);
  }
}
function Vi() {
}
Vi.accessor = function(n, t) {
  n.accessors.splice(t, 1), de.mesh(n, function(i) {
    de.meshPrimitive(i, function(r) {
      de.meshPrimitiveAttribute(
        r,
        function(o, c) {
          o > t && r.attributes[c]--;
        }
      ), de.meshPrimitiveTarget(r, function(o) {
        de.meshPrimitiveTargetAttribute(
          o,
          function(c, h) {
            c > t && o[h]--;
          }
        );
      });
      const s = r.indices;
      ie(s) && s > t && r.indices--;
      const a = r.extensions;
      ie(a) && ie(a.CESIUM_primitive_outline) && a.CESIUM_primitive_outline.indices > t && --a.CESIUM_primitive_outline.indices;
    });
  }), de.skin(n, function(i) {
    ie(i.inverseBindMatrices) && i.inverseBindMatrices > t && i.inverseBindMatrices--;
  }), de.animation(n, function(i) {
    de.animationSampler(i, function(r) {
      ie(r.input) && r.input > t && r.input--, ie(r.output) && r.output > t && r.output--;
    });
  });
};
Vi.buffer = function(n, t) {
  n.buffers.splice(t, 1), de.bufferView(n, function(i) {
    ie(i.buffer) && i.buffer > t && i.buffer--, ie(i.extensions) && ie(i.extensions.EXT_meshopt_compression) && i.extensions.EXT_meshopt_compression.buffer--;
  });
};
Vi.bufferView = function(n, t) {
  if (n.bufferViews.splice(t, 1), de.accessor(n, function(i) {
    ie(i.bufferView) && i.bufferView > t && i.bufferView--;
  }), de.shader(n, function(i) {
    ie(i.bufferView) && i.bufferView > t && i.bufferView--;
  }), de.image(n, function(i) {
    ie(i.bufferView) && i.bufferView > t && i.bufferView--;
  }), Jn(n, "KHR_draco_mesh_compression") && de.mesh(n, function(i) {
    de.meshPrimitive(i, function(r) {
      ie(r.extensions) && ie(r.extensions.KHR_draco_mesh_compression) && r.extensions.KHR_draco_mesh_compression.bufferView > t && r.extensions.KHR_draco_mesh_compression.bufferView--;
    });
  }), Jn(n, "EXT_feature_metadata")) {
    const r = n.extensions.EXT_feature_metadata.featureTables;
    for (const s in r)
      if (r.hasOwnProperty(s)) {
        const o = r[s].properties;
        if (ie(o)) {
          for (const c in o)
            if (o.hasOwnProperty(c)) {
              const h = o[c];
              ie(h.bufferView) && h.bufferView > t && h.bufferView--, ie(h.arrayOffsetBufferView) && h.arrayOffsetBufferView > t && h.arrayOffsetBufferView--, ie(h.stringOffsetBufferView) && h.stringOffsetBufferView > t && h.stringOffsetBufferView--;
            }
        }
      }
  }
  if (Jn(n, "EXT_structural_metadata")) {
    const r = n.extensions.EXT_structural_metadata.propertyTables;
    if (ie(r)) {
      const s = r.length;
      for (let a = 0; a < s; ++a) {
        const c = r[a].properties;
        for (const h in c)
          if (c.hasOwnProperty(h)) {
            const l = c[h];
            ie(l.values) && l.values > t && l.values--, ie(l.arrayOffsets) && l.arrayOffsets > t && l.arrayOffsets--, ie(l.stringOffsets) && l.stringOffsets > t && l.stringOffsets--;
          }
      }
    }
  }
};
Vi.image = function(n, t) {
  n.images.splice(t, 1), de.texture(n, function(i) {
    ie(i.source) && i.source > t && --i.source;
    const r = i.extensions;
    ie(r) && ie(r.EXT_texture_webp) && r.EXT_texture_webp.source > t ? --i.extensions.EXT_texture_webp.source : ie(r) && ie(r.KHR_texture_basisu) && r.KHR_texture_basisu.source > t && --i.extensions.KHR_texture_basisu.source;
  });
};
Vi.mesh = function(n, t) {
  n.meshes.splice(t, 1), de.node(n, function(i) {
    ie(i.mesh) && (i.mesh > t ? i.mesh-- : i.mesh === t && delete i.mesh);
  });
};
Vi.node = function(n, t) {
  n.nodes.splice(t, 1), de.skin(n, function(i) {
    ie(i.skeleton) && i.skeleton > t && i.skeleton--, i.joints = i.joints.map(function(r) {
      return r > t ? r - 1 : r;
    });
  }), de.animation(n, function(i) {
    de.animationChannel(i, function(r) {
      ie(r.target) && ie(r.target.node) && r.target.node > t && r.target.node--;
    });
  }), de.technique(n, function(i) {
    de.techniqueUniform(i, function(r) {
      ie(r.node) && r.node > t && r.node--;
    });
  }), de.node(n, function(i) {
    ie(i.children) && (i.children = i.children.filter(function(r) {
      return r !== t;
    }).map(function(r) {
      return r > t ? r - 1 : r;
    }));
  }), de.scene(n, function(i) {
    i.nodes = i.nodes.filter(function(r) {
      return r !== t;
    }).map(function(r) {
      return r > t ? r - 1 : r;
    });
  });
};
Vi.material = function(n, t) {
  n.materials.splice(t, 1), de.mesh(n, function(i) {
    de.meshPrimitive(i, function(r) {
      ie(r.material) && r.material > t && r.material--;
    });
  });
};
Vi.sampler = function(n, t) {
  n.samplers.splice(t, 1), de.texture(n, function(i) {
    ie(i.sampler) && i.sampler > t && --i.sampler;
  });
};
Vi.texture = function(n, t) {
  if (n.textures.splice(t, 1), de.material(n, function(i) {
    Jm(i, function(r, s) {
      s.index > t && --s.index;
    });
  }), Jn(n, "EXT_feature_metadata")) {
    de.mesh(n, function(s) {
      de.meshPrimitive(s, function(a) {
        const o = a.extensions;
        if (ie(o) && ie(o.EXT_feature_metadata)) {
          const h = o.EXT_feature_metadata.featureIdTextures;
          if (ie(h)) {
            const l = h.length;
            for (let f = 0; f < l; ++f) {
              const m = h[f].featureIds.texture;
              m.index > t && --m.index;
            }
          }
        }
      });
    });
    const r = n.extensions.EXT_feature_metadata.featureTextures;
    for (const s in r)
      if (r.hasOwnProperty(s)) {
        const o = r[s].properties;
        if (ie(o)) {
          for (const c in o)
            if (o.hasOwnProperty(c)) {
              const l = o[c].texture;
              l.index > t && --l.index;
            }
        }
      }
  }
  if (Jn(n, "EXT_mesh_features") && de.mesh(n, function(i) {
    de.meshPrimitive(i, function(r) {
      const s = r.extensions;
      if (ie(s) && ie(s.EXT_mesh_features)) {
        const o = s.EXT_mesh_features.featureIds;
        if (ie(o)) {
          const c = o.length;
          for (let h = 0; h < c; ++h) {
            const l = o[h];
            ie(l.texture) && l.texture.index > t && --l.texture.index;
          }
        }
      }
    });
  }), Jn(n, "EXT_structural_metadata")) {
    const r = n.extensions.EXT_structural_metadata.propertyTextures;
    if (ie(r)) {
      const s = r.length;
      for (let a = 0; a < s; ++a) {
        const c = r[a].properties;
        for (const h in c)
          if (c.hasOwnProperty(h)) {
            const l = c[h];
            l.index > t && --l.index;
          }
      }
    }
  }
};
function Hi() {
}
Hi.accessor = function(n) {
  const t = {};
  return de.mesh(n, function(e) {
    de.meshPrimitive(e, function(i) {
      de.meshPrimitiveAttribute(i, function(s) {
        t[s] = !0;
      }), de.meshPrimitiveTarget(i, function(s) {
        de.meshPrimitiveTargetAttribute(s, function(a) {
          t[a] = !0;
        });
      });
      const r = i.indices;
      ie(r) && (t[r] = !0);
    });
  }), de.skin(n, function(e) {
    ie(e.inverseBindMatrices) && (t[e.inverseBindMatrices] = !0);
  }), de.animation(n, function(e) {
    de.animationSampler(e, function(i) {
      ie(i.input) && (t[i.input] = !0), ie(i.output) && (t[i.output] = !0);
    });
  }), Jn(n, "EXT_mesh_gpu_instancing") && de.node(n, function(e) {
    ie(e.extensions) && ie(e.extensions.EXT_mesh_gpu_instancing) && Object.keys(e.extensions.EXT_mesh_gpu_instancing.attributes).forEach(
      function(i) {
        const r = e.extensions.EXT_mesh_gpu_instancing.attributes[i];
        t[r] = !0;
      }
    );
  }), Jn(n, "CESIUM_primitive_outline") && de.mesh(n, function(e) {
    de.meshPrimitive(e, function(i) {
      const r = i.extensions;
      if (ie(r) && ie(r.CESIUM_primitive_outline)) {
        const a = r.CESIUM_primitive_outline.indices;
        ie(a) && (t[a] = !0);
      }
    });
  }), t;
};
Hi.buffer = function(n) {
  const t = {};
  return de.bufferView(n, function(e) {
    ie(e.buffer) && (t[e.buffer] = !0), ie(e.extensions) && ie(e.extensions.EXT_meshopt_compression) && (t[e.extensions.EXT_meshopt_compression.buffer] = !0);
  }), t;
};
Hi.bufferView = function(n) {
  const t = {};
  if (de.accessor(n, function(e) {
    ie(e.bufferView) && (t[e.bufferView] = !0);
  }), de.shader(n, function(e) {
    ie(e.bufferView) && (t[e.bufferView] = !0);
  }), de.image(n, function(e) {
    ie(e.bufferView) && (t[e.bufferView] = !0);
  }), Jn(n, "KHR_draco_mesh_compression") && de.mesh(n, function(e) {
    de.meshPrimitive(e, function(i) {
      ie(i.extensions) && ie(i.extensions.KHR_draco_mesh_compression) && (t[i.extensions.KHR_draco_mesh_compression.bufferView] = !0);
    });
  }), Jn(n, "EXT_feature_metadata")) {
    const i = n.extensions.EXT_feature_metadata.featureTables;
    for (const r in i)
      if (i.hasOwnProperty(r)) {
        const a = i[r].properties;
        if (ie(a)) {
          for (const o in a)
            if (a.hasOwnProperty(o)) {
              const c = a[o];
              ie(c.bufferView) && (t[c.bufferView] = !0), ie(c.arrayOffsetBufferView) && (t[c.arrayOffsetBufferView] = !0), ie(c.stringOffsetBufferView) && (t[c.stringOffsetBufferView] = !0);
            }
        }
      }
  }
  if (Jn(n, "EXT_structural_metadata")) {
    const i = n.extensions.EXT_structural_metadata.propertyTables;
    if (ie(i)) {
      const r = i.length;
      for (let s = 0; s < r; ++s) {
        const o = i[s].properties;
        for (const c in o)
          if (o.hasOwnProperty(c)) {
            const h = o[c];
            ie(h.values) && (t[h.values] = !0), ie(h.arrayOffsets) && (t[h.arrayOffsets] = !0), ie(h.stringOffsets) && (t[h.stringOffsets] = !0);
          }
      }
    }
  }
  return t;
};
Hi.image = function(n) {
  const t = {};
  return de.texture(n, function(e) {
    ie(e.source) && (t[e.source] = !0), ie(e.extensions) && ie(e.extensions.EXT_texture_webp) ? t[e.extensions.EXT_texture_webp.source] = !0 : ie(e.extensions) && ie(e.extensions.KHR_texture_basisu) && (t[e.extensions.KHR_texture_basisu.source] = !0);
  }), t;
};
Hi.mesh = function(n) {
  const t = {};
  return de.node(n, function(e) {
    if (ie(e.mesh && ie(n.meshes))) {
      const i = n.meshes[e.mesh];
      ie(i) && ie(i.primitives) && i.primitives.length > 0 && (t[e.mesh] = !0);
    }
  }), t;
};
function Qm(n, t, e) {
  const i = n.nodes[t];
  return ie(i.mesh) || ie(i.camera) || ie(i.skin) || ie(i.weights) || ie(i.extras) || ie(i.extensions) && Object.keys(i.extensions).length !== 0 || ie(e[t]) ? !1 : !ie(i.children) || i.children.filter(function(r) {
    return !Qm(n, r, e);
  }).length === 0;
}
Hi.node = function(n) {
  const t = {};
  return de.skin(n, function(e) {
    ie(e.skeleton) && (t[e.skeleton] = !0), de.skinJoint(e, function(i) {
      t[i] = !0;
    });
  }), de.animation(n, function(e) {
    de.animationChannel(e, function(i) {
      ie(i.target) && ie(i.target.node) && (t[i.target.node] = !0);
    });
  }), de.technique(n, function(e) {
    de.techniqueUniform(e, function(i) {
      ie(i.node) && (t[i.node] = !0);
    });
  }), de.node(n, function(e, i) {
    Qm(n, i, t) || (t[i] = !0);
  }), t;
};
Hi.material = function(n) {
  const t = {};
  return de.mesh(n, function(e) {
    de.meshPrimitive(e, function(i) {
      ie(i.material) && (t[i.material] = !0);
    });
  }), t;
};
Hi.texture = function(n) {
  const t = {};
  if (de.material(n, function(e) {
    Jm(e, function(i) {
      t[i] = !0;
    });
  }), Jn(n, "EXT_feature_metadata")) {
    de.mesh(n, function(r) {
      de.meshPrimitive(r, function(s) {
        const a = s.extensions;
        if (ie(a) && ie(a.EXT_feature_metadata)) {
          const c = a.EXT_feature_metadata.featureIdTextures;
          if (ie(c)) {
            const h = c.length;
            for (let l = 0; l < h; ++l) {
              const d = c[l].featureIds.texture;
              t[d.index] = !0;
            }
          }
        }
      });
    });
    const i = n.extensions.EXT_feature_metadata.featureTextures;
    for (const r in i)
      if (i.hasOwnProperty(r)) {
        const a = i[r].properties;
        if (ie(a)) {
          for (const o in a)
            if (a.hasOwnProperty(o)) {
              const h = a[o].texture;
              t[h.index] = !0;
            }
        }
      }
  }
  if (Jn(n, "EXT_mesh_features") && de.mesh(n, function(e) {
    de.meshPrimitive(e, function(i) {
      const r = i.extensions;
      if (ie(r) && ie(r.EXT_mesh_features)) {
        const a = r.EXT_mesh_features.featureIds;
        if (ie(a)) {
          const o = a.length;
          for (let c = 0; c < o; ++c) {
            const h = a[c];
            ie(h.texture) && (t[h.texture.index] = !0);
          }
        }
      }
    });
  }), Jn(n, "EXT_structural_metadata")) {
    const i = n.extensions.EXT_structural_metadata.propertyTextures;
    if (ie(i)) {
      const r = i.length;
      for (let s = 0; s < r; ++s) {
        const o = i[s].properties;
        for (const c in o)
          if (o.hasOwnProperty(c)) {
            const h = o[c];
            t[h.index] = !0;
          }
      }
    }
  }
  return t;
};
Hi.sampler = function(n) {
  const t = {};
  return de.texture(n, function(e) {
    ie(e.sampler) && (t[e.sampler] = !0);
  }), t;
};
const O2 = Be, D2 = Wr, N2 = O2.defined;
var po = F2;
function F2(n, t) {
  let e = n.extensionsUsed;
  N2(e) || (e = [], n.extensionsUsed = e), D2(e, t, !0);
}
const U2 = Be, Pr = U2.ComponentDatatype;
var t_ = B2;
function B2(n) {
  switch (n) {
    case Pr.BYTE:
      return function(t, e, i, r, s) {
        for (let a = 0; a < i; ++a)
          s[a] = t.getInt8(
            e + a * r
          );
      };
    case Pr.UNSIGNED_BYTE:
      return function(t, e, i, r, s) {
        for (let a = 0; a < i; ++a)
          s[a] = t.getUint8(
            e + a * r
          );
      };
    case Pr.SHORT:
      return function(t, e, i, r, s) {
        for (let a = 0; a < i; ++a)
          s[a] = t.getInt16(
            e + a * r,
            !0
          );
      };
    case Pr.UNSIGNED_SHORT:
      return function(t, e, i, r, s) {
        for (let a = 0; a < i; ++a)
          s[a] = t.getUint16(
            e + a * r,
            !0
          );
      };
    case Pr.INT:
      return function(t, e, i, r, s) {
        for (let a = 0; a < i; ++a)
          s[a] = t.getInt32(
            e + a * r,
            !0
          );
      };
    case Pr.UNSIGNED_INT:
      return function(t, e, i, r, s) {
        for (let a = 0; a < i; ++a)
          s[a] = t.getUint32(
            e + a * r,
            !0
          );
      };
    case Pr.FLOAT:
      return function(t, e, i, r, s) {
        for (let a = 0; a < i; ++a)
          s[a] = t.getFloat32(
            e + a * r,
            !0
          );
      };
    case Pr.DOUBLE:
      return function(t, e, i, r, s) {
        for (let a = 0; a < i; ++a)
          s[a] = t.getFloat64(
            e + a * r,
            !0
          );
      };
  }
}
const e_ = Be, k2 = e_.ComponentDatatype, z2 = e_.defined, G2 = _u, V2 = t_, H2 = Ma;
var n_ = j2;
function j2(n, t) {
  const e = n.bufferViews, i = n.buffers, r = t.bufferView, s = H2(t.type);
  if (!z2(t.bufferView))
    return {
      min: new Array(s).fill(0),
      max: new Array(s).fill(0)
    };
  const a = new Array(s).fill(Number.POSITIVE_INFINITY), o = new Array(s).fill(Number.NEGATIVE_INFINITY), c = e[r], h = c.buffer, f = i[h].extras._pipeline.source, d = t.count, m = G2(n, t);
  let v = t.byteOffset + c.byteOffset + f.byteOffset;
  const E = t.componentType, _ = k2.getSizeInBytes(E), p = new DataView(f.buffer), R = new Array(s), M = V2(E);
  for (let P = 0; P < d; P++) {
    M(
      p,
      v,
      s,
      _,
      R
    );
    for (let W = 0; W < s; W++) {
      const C = R[W];
      a[W] = Math.min(a[W], C), o[W] = Math.max(o[W], C);
    }
    v += m;
  }
  return {
    min: a,
    max: o
  };
}
const wf = Be, W2 = po, dl = Ln, q2 = wf.defaultValue, Ei = wf.defined, Sn = wf.WebGLConstants;
var $2 = J2;
const X2 = [Sn.FUNC_ADD, Sn.FUNC_ADD], Y2 = [
  Sn.ONE,
  Sn.ZERO,
  Sn.ONE,
  Sn.ZERO
];
function zp(n, t) {
  const e = n.enable;
  return Ei(e) ? e.indexOf(t) > -1 : !1;
}
const K2 = [
  Sn.ZERO,
  Sn.ONE,
  Sn.SRC_COLOR,
  Sn.ONE_MINUS_SRC_COLOR,
  Sn.SRC_ALPHA,
  Sn.ONE_MINUS_SRC_ALPHA,
  Sn.DST_ALPHA,
  Sn.ONE_MINUS_DST_ALPHA,
  Sn.DST_COLOR,
  Sn.ONE_MINUS_DST_COLOR
];
function Z2(n, t) {
  if (!Ei(n))
    return t;
  for (let e = 0; e < 4; e++)
    if (K2.indexOf(n[e]) === -1)
      return t;
  return n;
}
function J2(n) {
  const t = {}, e = {}, i = n.techniques;
  return Ei(i) && (dl.technique(n, function(r, s) {
    const a = r.states;
    if (Ei(a)) {
      const o = e[s] = {};
      if (zp(a, Sn.BLEND)) {
        o.alphaMode = "BLEND";
        const c = a.functions;
        Ei(c) && (Ei(c.blendEquationSeparate) || Ei(c.blendFuncSeparate)) && (t[s] = {
          blendEquation: q2(
            c.blendEquationSeparate,
            X2
          ),
          blendFactors: Z2(
            c.blendFuncSeparate,
            Y2
          )
        });
      }
      zp(a, Sn.CULL_FACE) || (o.doubleSided = !0), delete r.states;
    }
  }), Object.keys(t).length > 0 && (Ei(n.extensions) || (n.extensions = {}), W2(n, "KHR_blend")), dl.material(n, function(r) {
    if (Ei(r.technique)) {
      const s = e[r.technique];
      dl.objectLegacy(s, function(o, c) {
        r[c] = o;
      });
      const a = t[r.technique];
      Ei(a) && (Ei(r.extensions) || (r.extensions = {}), r.extensions.KHR_blend = a);
    }
  })), n;
}
const Q2 = Be, tC = po, eC = Wr, nC = Q2.defined;
var i_ = iC;
function iC(n, t) {
  let e = n.extensionsRequired;
  nC(e) || (e = [], n.extensionsRequired = e), eC(e, t, !0), tC(n, t);
}
const rC = Be, sC = po, aC = i_, jc = Wr, Ua = Ln, Lr = rC.defined;
var oC = cC;
function cC(n) {
  const t = n.techniques, e = {}, i = {}, r = {};
  if (Lr(t)) {
    const s = {
      programs: [],
      shaders: [],
      techniques: []
    }, a = n.glExtensionsUsed;
    delete n.glExtensionsUsed, Ua.technique(n, function(o, c) {
      const h = {
        name: o.name,
        program: void 0,
        attributes: {},
        uniforms: {}
      };
      let l;
      if (Ua.techniqueAttribute(
        o,
        function(f, d) {
          l = o.parameters[f], h.attributes[d] = {
            semantic: l.semantic
          };
        }
      ), Ua.techniqueUniform(
        o,
        function(f, d) {
          l = o.parameters[f], h.uniforms[d] = {
            count: l.count,
            node: l.node,
            type: l.type,
            semantic: l.semantic,
            value: l.value
          }, Lr(e[c]) || (e[c] = {}), e[c][f] = d;
        }
      ), Lr(r[o.program]))
        h.program = r[o.program];
      else {
        const f = n.programs[o.program], d = {
          name: f.name,
          fragmentShader: void 0,
          vertexShader: void 0,
          glExtensions: a
        }, m = n.shaders[f.fragmentShader];
        d.fragmentShader = jc(s.shaders, m, !0);
        const v = n.shaders[f.vertexShader];
        d.vertexShader = jc(s.shaders, v, !0), h.program = jc(s.programs, d), r[o.program] = h.program;
      }
      i[c] = jc(
        s.techniques,
        h
      );
    }), s.techniques.length > 0 && (Lr(n.extensions) || (n.extensions = {}), n.extensions.KHR_techniques_webgl = s, sC(n, "KHR_techniques_webgl"), aC(n, "KHR_techniques_webgl"));
  }
  return Ua.material(n, function(s) {
    if (Lr(s.technique)) {
      const a = {
        technique: i[s.technique]
      };
      Ua.objectLegacy(s.values, function(o, c) {
        Lr(a.values) || (a.values = {});
        const h = e[s.technique][c];
        Lr(h) && (a.values[h] = o);
      }), Lr(s.extensions) || (s.extensions = {}), s.extensions.KHR_techniques_webgl = a;
    }
    delete s.technique, delete s.values;
  }), delete n.techniques, delete n.programs, delete n.shaders, n;
}
const Gp = Wr;
var mo = uC;
function uC(n, t) {
  const e = {
    byteLength: t.length,
    extras: {
      _pipeline: {
        source: t
      }
    }
  }, r = {
    buffer: Gp(n.buffers, e),
    byteOffset: 0,
    byteLength: t.length
  };
  return Gp(n.bufferViews, r);
}
const r_ = Be, lC = _u, fC = t_, hC = Ma, pC = r_.ComponentDatatype, dC = r_.defined;
var Mf = mC;
function mC(n, t) {
  const e = lC(n, t), i = pC.getSizeInBytes(
    t.componentType
  ), r = hC(t.type), s = t.count, a = new Array(r * s);
  if (!dC(t.bufferView))
    return a.fill(0);
  const o = n.bufferViews[t.bufferView], c = n.buffers[o.buffer].extras._pipeline.source;
  let h = t.byteOffset + o.byteOffset + c.byteOffset;
  const l = new DataView(c.buffer), f = new Array(r), d = fC(t.componentType);
  for (let m = 0; m < s; ++m) {
    d(
      l,
      h,
      r,
      i,
      f
    );
    for (let v = 0; v < r; ++v)
      a[m * r + v] = f[v];
    h += e;
  }
  return a;
}
const s_ = Be, _C = mo, Vp = Ln, yC = Mf, za = s_.ComponentDatatype, Ba = s_.WebGLConstants;
var gC = vC;
function vC(n) {
  let t;
  return Vp.accessorWithSemantic(n, "JOINTS_0", function(e) {
    const i = n.accessors[e];
    t = i.componentType, t === Ba.BYTE ? Wc(n, i, za.UNSIGNED_BYTE) : t !== Ba.UNSIGNED_BYTE && t !== Ba.UNSIGNED_SHORT && Wc(n, i, za.UNSIGNED_SHORT);
  }), Vp.accessorWithSemantic(n, "WEIGHTS_0", function(e) {
    const i = n.accessors[e];
    t = i.componentType, t === Ba.BYTE ? Wc(n, i, za.UNSIGNED_BYTE) : t === Ba.SHORT && Wc(n, i, za.UNSIGNED_SHORT);
  }), n;
}
function Wc(n, t, e) {
  const i = za.createTypedArray(
    e,
    yC(n, t)
  ), r = new Uint8Array(i.buffer);
  t.bufferView = _C(n, r), t.componentType = e, t.byteOffset = 0;
}
const xC = Be, Hp = Ln, bC = rm, jp = xC.defined;
var EC = wC;
function wC(n, t) {
  return bC(n, t), t === "CESIUM_RTC" && MC(n), Bl(n, t);
}
function MC(n) {
  Hp.technique(n, function(t) {
    Hp.techniqueUniform(t, function(e) {
      e.semantic === "CESIUM_RTC_MODELVIEW" && (e.semantic = "MODELVIEW");
    });
  });
}
function Bl(n, t) {
  if (Array.isArray(n)) {
    const e = n.length;
    for (let i = 0; i < e; ++i)
      Bl(n[i], t);
  } else if (n !== null && typeof n == "object" && n.constructor === Object) {
    const e = n.extensions;
    let i;
    jp(e) && (i = e[t], jp(i) && (delete e[t], Object.keys(e).length === 0 && delete n.extensions));
    for (const r in n)
      Object.prototype.hasOwnProperty.call(n, r) && Bl(n[r], t);
    return i;
  }
}
const hr = Be, a_ = po, o_ = Wr, Sf = n_, Se = Ln, SC = _u, AC = Ma, TC = $2, CC = oC, RC = ho, IC = gC, kl = EC, Br = hr.Cartesian3, Wp = hr.Cartesian4, PC = hr.clone, LC = hr.ComponentDatatype, sn = hr.defaultValue, ae = hr.defined, qp = hr.Matrix4, Ka = hr.Quaternion, OC = hr.WebGLConstants;
var DC = NC;
const qc = {
  0.8: zC,
  "1.0": o3,
  "2.0": void 0
};
function NC(n, t) {
  t = sn(t, sn.EMPTY_OBJECT);
  const e = t.targetVersion;
  let i = n.version;
  n.asset = sn(n.asset, {
    version: "1.0"
  }), n.asset.version = sn(n.asset.version, "1.0"), i = sn(i, n.asset.version).toString(), Object.prototype.hasOwnProperty.call(qc, i) || (ae(i) && (i = i.substring(0, 3)), Object.prototype.hasOwnProperty.call(qc, i) || (i = "1.0"));
  let r = qc[i];
  for (; ae(r) && i !== e; )
    r(n, t), i = n.asset.version, r = qc[i];
  return t.keepLegacyExtensions || (l3(n, t), f3(n)), n;
}
function c_(n) {
  const t = n.materials;
  for (const e in t)
    if (Object.prototype.hasOwnProperty.call(t, e)) {
      const i = t[e], r = i.instanceTechnique;
      ae(r) && (i.technique = r.technique, i.values = r.values, delete i.instanceTechnique);
    }
}
function FC(n) {
  const t = n.meshes;
  for (const e in t)
    if (Object.prototype.hasOwnProperty.call(t, e)) {
      const r = t[e].primitives;
      if (ae(r)) {
        const s = r.length;
        for (let a = 0; a < s; ++a) {
          const o = r[a], c = sn(
            o.primitive,
            OC.TRIANGLES
          );
          o.mode = sn(o.mode, c), delete o.primitive;
        }
      }
    }
}
function UC(n) {
  const t = n.nodes, e = new Br(), i = new Ka();
  for (const r in t)
    if (Object.prototype.hasOwnProperty.call(t, r)) {
      const s = t[r];
      if (ae(s.rotation)) {
        const o = s.rotation;
        Br.fromArray(o, 0, e), Ka.fromAxisAngle(e, o[3], i), s.rotation = [i.x, i.y, i.z, i.w];
      }
      const a = s.instanceSkin;
      ae(a) && (s.skeletons = a.skeletons, s.skin = a.skin, s.meshes = a.meshes, delete s.instanceSkin);
    }
}
function BC(n) {
  const t = n.animations, e = n.accessors, i = n.bufferViews, r = n.buffers, s = {}, a = new Br(), o = new Ka();
  for (const c in t)
    if (Object.prototype.hasOwnProperty.call(t, c)) {
      const h = t[c], l = h.channels, f = h.parameters, d = h.samplers;
      if (ae(l)) {
        const m = l.length;
        for (let v = 0; v < m; ++v) {
          const E = l[v];
          if (E.target.path === "rotation") {
            const _ = f[d[E.sampler].output];
            if (ae(s[_]))
              continue;
            s[_] = !0;
            const p = e[_], R = i[p.bufferView], P = r[R.buffer].extras._pipeline.source, W = P.byteOffset + R.byteOffset + p.byteOffset, C = p.componentType, D = p.count, N = AC(p.type), A = p.count * N, I = LC.createArrayBufferView(
              C,
              P.buffer,
              W,
              A
            );
            for (let it = 0; it < D; it++) {
              const V = it * N;
              Br.unpack(I, V, a);
              const mt = I[V + 3];
              Ka.fromAxisAngle(a, mt, o), Ka.pack(o, I, V);
            }
          }
        }
      }
    }
}
function kC(n) {
  const t = n.techniques;
  for (const e in t)
    if (Object.prototype.hasOwnProperty.call(t, e)) {
      const i = t[e], r = i.passes;
      if (ae(r)) {
        const s = sn(i.pass, "defaultPass");
        if (Object.prototype.hasOwnProperty.call(r, s)) {
          const a = r[s], o = a.instanceProgram;
          i.attributes = sn(
            i.attributes,
            o.attributes
          ), i.program = sn(
            i.program,
            o.program
          ), i.uniforms = sn(
            i.uniforms,
            o.uniforms
          ), i.states = sn(i.states, a.states);
        }
        delete i.passes, delete i.pass;
      }
    }
}
function zC(n) {
  ae(n.asset) || (n.asset = {});
  const t = n.asset;
  if (t.version = "1.0", typeof t.profile == "string") {
    const e = t.profile.split(" ");
    t.profile = {
      api: e[0],
      version: e[1]
    };
  } else
    t.profile = {};
  if (ae(n.version) && delete n.version, c_(n), FC(n), UC(n), BC(n), kC(n), ae(n.allExtensions) && (n.extensionsUsed = n.allExtensions, delete n.allExtensions), ae(n.lights)) {
    const e = sn(n.extensions, {});
    n.extensions = e;
    const i = sn(e.KHR_materials_common, {});
    e.KHR_materials_common = i, i.lights = n.lights, delete n.lights, a_(n, "KHR_materials_common");
  }
}
function GC(n) {
  const t = n.animations;
  for (const e in t)
    if (Object.prototype.hasOwnProperty.call(t, e)) {
      const i = t[e], r = i.parameters;
      if (ae(r)) {
        const s = i.samplers;
        for (const a in s)
          if (Object.prototype.hasOwnProperty.call(s, a)) {
            const o = s[a];
            o.input = r[o.input], o.output = r[o.output];
          }
        delete i.parameters;
      }
    }
}
function $p(n, t) {
  const e = [];
  for (const i in n)
    if (Object.prototype.hasOwnProperty.call(n, i)) {
      const r = n[i];
      t[i] = e.length, e.push(r), ae(r.name) || (r.name = i);
    }
  return e;
}
function VC(n) {
  let t;
  const e = {
    accessors: {},
    animations: {},
    buffers: {},
    bufferViews: {},
    cameras: {},
    images: {},
    materials: {},
    meshes: {},
    nodes: {},
    programs: {},
    samplers: {},
    scenes: {},
    shaders: {},
    skins: {},
    textures: {},
    techniques: {}
  };
  let i;
  const r = {}, s = n.nodes;
  for (const a in s)
    Object.prototype.hasOwnProperty.call(s, a) && (i = s[a].jointName, ae(i) && (r[i] = a));
  for (const a in n)
    if (Object.prototype.hasOwnProperty.call(n, a) && ae(e[a])) {
      const o = {}, c = n[a];
      n[a] = $p(c, o), e[a] = o;
    }
  for (i in r)
    Object.prototype.hasOwnProperty.call(r, i) && (r[i] = e.nodes[r[i]]);
  ae(n.scene) && (n.scene = e.scenes[n.scene]), Se.bufferView(n, function(a) {
    ae(a.buffer) && (a.buffer = e.buffers[a.buffer]);
  }), Se.accessor(n, function(a) {
    ae(a.bufferView) && (a.bufferView = e.bufferViews[a.bufferView]);
  }), Se.shader(n, function(a) {
    const o = a.extensions;
    if (ae(o)) {
      const c = o.KHR_binary_glTF;
      ae(c) && (a.bufferView = e.bufferViews[c.bufferView], delete o.KHR_binary_glTF), Object.keys(o).length === 0 && delete a.extensions;
    }
  }), Se.program(n, function(a) {
    ae(a.vertexShader) && (a.vertexShader = e.shaders[a.vertexShader]), ae(a.fragmentShader) && (a.fragmentShader = e.shaders[a.fragmentShader]);
  }), Se.technique(n, function(a) {
    ae(a.program) && (a.program = e.programs[a.program]), Se.techniqueParameter(a, function(o) {
      ae(o.node) && (o.node = e.nodes[o.node]);
      const c = o.value;
      typeof c == "string" && (o.value = {
        index: e.textures[c]
      });
    });
  }), Se.mesh(n, function(a) {
    Se.meshPrimitive(a, function(o) {
      ae(o.indices) && (o.indices = e.accessors[o.indices]), Se.meshPrimitiveAttribute(
        o,
        function(c, h) {
          o.attributes[h] = e.accessors[c];
        }
      ), ae(o.material) && (o.material = e.materials[o.material]);
    });
  }), Se.node(n, function(a) {
    let o = a.children;
    if (ae(o)) {
      const c = o.length;
      for (t = 0; t < c; ++t)
        o[t] = e.nodes[o[t]];
    }
    if (ae(a.meshes)) {
      const c = a.meshes, h = c.length;
      if (h > 0)
        for (a.mesh = e.meshes[c[0]], t = 1; t < h; ++t) {
          const l = {
            mesh: e.meshes[c[t]]
          }, f = o_(n.nodes, l);
          ae(o) || (o = [], a.children = o), o.push(f);
        }
      delete a.meshes;
    }
    if (ae(a.camera) && (a.camera = e.cameras[a.camera]), ae(a.skin) && (a.skin = e.skins[a.skin]), ae(a.skeletons)) {
      const c = a.skeletons;
      if (c.length > 0 && ae(a.skin)) {
        const l = n.skins[a.skin];
        l.skeleton = e.nodes[c[0]];
      }
      delete a.skeletons;
    }
    ae(a.jointName) && delete a.jointName;
  }), Se.skin(n, function(a) {
    ae(a.inverseBindMatrices) && (a.inverseBindMatrices = e.accessors[a.inverseBindMatrices]);
    const o = a.jointNames;
    if (ae(o)) {
      const c = [], h = o.length;
      for (t = 0; t < h; ++t)
        c[t] = r[o[t]];
      a.joints = c, delete a.jointNames;
    }
  }), Se.scene(n, function(a) {
    const o = a.nodes;
    if (ae(o)) {
      const c = o.length;
      for (t = 0; t < c; ++t)
        o[t] = e.nodes[o[t]];
    }
  }), Se.animation(n, function(a) {
    const o = {};
    a.samplers = $p(a.samplers, o), Se.animationSampler(a, function(c) {
      c.input = e.accessors[c.input], c.output = e.accessors[c.output];
    }), Se.animationChannel(a, function(c) {
      c.sampler = o[c.sampler];
      const h = c.target;
      ae(h) && (h.node = e.nodes[h.id], delete h.id);
    });
  }), Se.material(n, function(a) {
    ae(a.technique) && (a.technique = e.techniques[a.technique]), Se.materialValue(a, function(c, h) {
      typeof c == "string" && (a.values[h] = {
        index: e.textures[c]
      });
    });
    const o = a.extensions;
    if (ae(o)) {
      const c = o.KHR_materials_common;
      ae(c) && ae(c.values) && Se.materialValue(c, function(h, l) {
        typeof h == "string" && (c.values[l] = {
          index: e.textures[h]
        });
      });
    }
  }), Se.image(n, function(a) {
    const o = a.extensions;
    if (ae(o)) {
      const c = o.KHR_binary_glTF;
      ae(c) && (a.bufferView = e.bufferViews[c.bufferView], a.mimeType = c.mimeType, delete o.KHR_binary_glTF), Object.keys(o).length === 0 && delete a.extensions;
    }
  }), Se.texture(n, function(a) {
    ae(a.sampler) && (a.sampler = e.samplers[a.sampler]), ae(a.source) && (a.source = e.images[a.source]);
  });
}
function HC(n) {
  Se.animation(n, function(t) {
    Se.animationSampler(t, function(e) {
      delete e.name;
    });
  });
}
function jC(n) {
  for (const t in n)
    if (Object.prototype.hasOwnProperty.call(n, t)) {
      const e = n[t];
      Array.isArray(e) && e.length === 0 && delete n[t];
    }
  Se.node(n, function(t) {
    ae(t.children) && t.children.length === 0 && delete t.children;
  });
}
function WC(n) {
  const t = n.asset;
  delete t.profile, delete t.premultipliedAlpha;
}
const qC = {
  CESIUM_RTC: !0,
  KHR_materials_common: !0,
  WEB3D_quantized_attributes: !0
};
function $C(n) {
  const t = n.extensionsUsed;
  if (n.extensionsRequired = sn(n.extensionsRequired, []), ae(t)) {
    const e = t.length;
    for (let i = 0; i < e; ++i) {
      const r = t[i];
      ae(qC[r]) && n.extensionsRequired.push(r);
    }
  }
}
function XC(n) {
  Se.buffer(n, function(t) {
    delete t.type;
  });
}
function YC(n) {
  Se.texture(n, function(t) {
    delete t.format, delete t.internalFormat, delete t.target, delete t.type;
  });
}
function KC(n) {
  Se.mesh(n, function(t) {
    Se.meshPrimitive(t, function(e) {
      Se.meshPrimitiveAttribute(
        e,
        function(i, r) {
          r === "TEXCOORD" ? e.attributes.TEXCOORD_0 = i : r === "COLOR" && (e.attributes.COLOR_0 = i);
        }
      ), delete e.attributes.TEXCOORD, delete e.attributes.COLOR;
    });
  }), Se.technique(n, function(t) {
    Se.techniqueParameter(t, function(e) {
      const i = e.semantic;
      ae(i) && (i === "TEXCOORD" ? e.semantic = "TEXCOORD_0" : i === "COLOR" && (e.semantic = "COLOR_0"));
    });
  });
}
const ZC = {
  POSITION: !0,
  NORMAL: !0,
  TANGENT: !0
}, JC = {
  COLOR: "COLOR",
  JOINT: "JOINTS",
  JOINTS: "JOINTS",
  TEXCOORD: "TEXCOORD",
  WEIGHT: "WEIGHTS",
  WEIGHTS: "WEIGHTS"
};
function QC(n) {
  const t = {};
  Se.mesh(n, function(e) {
    Se.meshPrimitive(e, function(i) {
      Se.meshPrimitiveAttribute(
        i,
        function(r, s) {
          if (s.charAt(0) !== "_") {
            const a = s.search(/_[0-9]+/g);
            let o = s, c = "_0";
            a >= 0 && (o = s.substring(0, a), c = s.substring(a));
            let h;
            const l = JC[o];
            ae(l) ? (h = l + c, t[s] = h) : ae(ZC[o]) || (h = `_${s}`, t[s] = h);
          }
        }
      );
      for (const r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          const s = t[r], a = i.attributes[r];
          ae(a) && (delete i.attributes[r], i.attributes[s] = a);
        }
    });
  }), Se.technique(n, function(e) {
    Se.techniqueParameter(e, function(i) {
      const r = t[i.semantic];
      ae(r) && (i.semantic = r);
    });
  });
}
function t3(n) {
  Se.camera(n, function(t) {
    const e = t.perspective;
    if (ae(e)) {
      const i = e.aspectRatio;
      ae(i) && i === 0 && delete e.aspectRatio;
      const r = e.yfov;
      ae(r) && r === 0 && (e.yfov = 1);
    }
  });
}
function zl(n, t) {
  return ae(t.byteStride) && t.byteStride !== 0 ? t.byteStride : SC(n, t);
}
function e3(n) {
  Se.buffer(n, function(t) {
    ae(t.byteLength) || (t.byteLength = t.extras._pipeline.source.length);
  }), Se.accessor(n, function(t) {
    const e = t.bufferView;
    if (ae(e)) {
      const i = n.bufferViews[e], r = zl(n, t), s = t.byteOffset + t.count * r;
      i.byteLength = Math.max(
        sn(i.byteLength, 0),
        s
      );
    }
  });
}
function n3(n) {
  let t, e, i;
  const r = n.bufferViews, s = {};
  Se.accessorContainingVertexAttributeData(n, function(o) {
    const c = n.accessors[o];
    ae(c.bufferView) && (s[c.bufferView] = !0);
  });
  const a = {};
  Se.accessor(n, function(o) {
    ae(o.bufferView) && (a[o.bufferView] = sn(
      a[o.bufferView],
      []
    ), a[o.bufferView].push(o));
  });
  for (const o in a)
    if (Object.prototype.hasOwnProperty.call(a, o)) {
      i = r[o];
      const c = a[o];
      c.sort(function(d, m) {
        return d.byteOffset - m.byteOffset;
      });
      let h = 0, l = 0;
      const f = c.length;
      for (t = 0; t < f; ++t) {
        let d = c[t];
        const m = zl(n, d), v = d.byteOffset, E = d.count * m;
        delete d.byteStride;
        const _ = t < f - 1, p = _ ? zl(n, c[t + 1]) : void 0;
        if (m !== p) {
          const R = PC(i, !0);
          s[o] && (R.byteStride = m), R.byteOffset += h, R.byteLength = v + E - h;
          const M = o_(r, R);
          for (e = l; e <= t; ++e)
            d = c[e], d.bufferView = M, d.byteOffset = d.byteOffset - h;
          h = _ ? c[t + 1].byteOffset : void 0, l = t + 1;
        }
      }
    }
  RC(n, ["accessor", "bufferView", "buffer"]);
}
function i3(n) {
  Se.accessorWithSemantic(n, "POSITION", function(t) {
    const e = n.accessors[t];
    if (!ae(e.min) || !ae(e.max)) {
      const i = Sf(n, e);
      e.min = i.min, e.max = i.max;
    }
  });
}
function u_(n) {
  return (!ae(n.children) || n.children.length === 0) && (!ae(n.meshes) || n.meshes.length === 0) && !ae(n.camera) && !ae(n.skin) && !ae(n.skeletons) && !ae(n.jointName) && (!ae(n.translation) || Br.fromArray(n.translation).equals(Br.ZERO)) && (!ae(n.scale) || Br.fromArray(n.scale).equals(new Br(1, 1, 1))) && (!ae(n.rotation) || Wp.fromArray(n.rotation).equals(
    new Wp(0, 0, 0, 1)
  )) && (!ae(n.matrix) || qp.fromColumnMajorArray(n.matrix).equals(qp.IDENTITY)) && !ae(n.extensions) && !ae(n.extras);
}
function l_(n, t) {
  Se.scene(n, function(e) {
    const i = e.nodes;
    if (ae(i)) {
      const r = i.length;
      for (let s = r; s >= 0; --s)
        if (i[s] === t) {
          i.splice(s, 1);
          return;
        }
    }
  }), Se.node(n, function(e, i) {
    if (ae(e.children)) {
      const r = e.children.indexOf(t);
      r > -1 && (e.children.splice(r, 1), u_(e) && l_(n, i));
    }
  }), delete n.nodes[t];
}
function r3(n) {
  return Se.node(n, function(t, e) {
    u_(t) && l_(n, e);
  }), n;
}
function s3(n) {
  Se.animation(n, function(t) {
    Se.animationSampler(t, function(e) {
      const i = n.accessors[e.input];
      if (!ae(i.min) || !ae(i.max)) {
        const r = Sf(n, i);
        i.min = r.min, i.max = r.max;
      }
    });
  });
}
function a3(n) {
  Se.accessor(n, function(t) {
    if (ae(t.min) || ae(t.max)) {
      const e = Sf(n, t);
      ae(t.min) && (t.min = e.min), ae(t.max) && (t.max = e.max);
    }
  });
}
function o3(n) {
  n.asset = sn(n.asset, {}), n.asset.version = "2.0", c_(n), GC(n), r3(n), VC(n), HC(n), WC(n), $C(n), e3(n), n3(n), i3(n), s3(n), a3(n), XC(n), YC(n), KC(n), QC(n), IC(n), t3(n), TC(n), CC(n), jC(n);
}
const c3 = [
  "u_tex",
  "u_diffuse",
  "u_emission",
  "u_diffuse_tex"
], u3 = ["u_diffuse", "u_diffuse_mat"];
function Gl(n) {
  n.pbrMetallicRoughness = ae(n.pbrMetallicRoughness) ? n.pbrMetallicRoughness : {}, n.pbrMetallicRoughness.roughnessFactor = 1, n.pbrMetallicRoughness.metallicFactor = 0;
}
function Zc(n) {
  return ae(n.index);
}
function Jc(n) {
  return Array.isArray(n) && n.length === 4;
}
function f_(n) {
  const t = new Array(4);
  t[3] = n[3];
  for (let e = 0; e < 3; e++) {
    const i = n[e];
    i <= 0.04045 ? t[e] = n[e] * 0.07739938080495357 : t[e] = Math.pow(
      // eslint-disable-next-line no-loss-of-precision
      (i + 0.055) * 0.9478672985781991,
      2.4
    );
  }
  return t;
}
function l3(n, t) {
  t = sn(t, sn.EMPTY_OBJECT);
  const e = sn(
    t.baseColorTextureNames,
    c3
  ), i = sn(
    t.baseColorFactorNames,
    u3
  );
  Se.material(n, function(r) {
    Se.materialValue(r, function(s, a) {
      e.indexOf(a) !== -1 && Zc(s) ? (Gl(r), r.pbrMetallicRoughness.baseColorTexture = s) : i.indexOf(a) !== -1 && Jc(s) && (Gl(r), r.pbrMetallicRoughness.baseColorFactor = f_(s));
    });
  }), kl(n, "KHR_techniques_webgl"), kl(n, "KHR_blend");
}
function f3(n) {
  Se.material(n, function(t) {
    const e = sn(
      t.extensions,
      sn.EMPTY_OBJECT
    ).KHR_materials_common;
    if (ae(e)) {
      e.technique === "CONSTANT" && (a_(n, "KHR_materials_unlit"), t.extensions = ae(t.extensions) ? t.extensions : {}, t.extensions.KHR_materials_unlit = {});
      const r = ae(e.values) ? e.values : {}, s = r.ambient, a = r.diffuse, o = r.emission, c = r.transparency, h = e.doubleSided, l = e.transparent;
      Gl(t), ae(s) && (Jc(s) ? t.emissiveFactor = s.slice(0, 3) : Zc(s) && (t.emissiveTexture = s)), ae(a) && (Jc(a) ? t.pbrMetallicRoughness.baseColorFactor = f_(a) : Zc(a) && (t.pbrMetallicRoughness.baseColorTexture = a)), ae(h) && (t.doubleSided = h), ae(o) && (Jc(o) ? t.emissiveFactor = o.slice(0, 3) : Zc(o) && (t.emissiveTexture = o)), ae(c) && (ae(t.pbrMetallicRoughness.baseColorFactor) ? t.pbrMetallicRoughness.baseColorFactor[3] *= c : t.pbrMetallicRoughness.baseColorFactor = [
        1,
        1,
        1,
        c
      ]), ae(l) && (t.alphaMode = l ? "BLEND" : "OPAQUE");
    }
  }), kl(n, "KHR_materials_common");
}
function bu() {
  this._types = /* @__PURE__ */ Object.create(null), this._extensions = /* @__PURE__ */ Object.create(null);
  for (let n = 0; n < arguments.length; n++)
    this.define(arguments[n]);
  this.define = this.define.bind(this), this.getType = this.getType.bind(this), this.getExtension = this.getExtension.bind(this);
}
bu.prototype.define = function(n, t) {
  for (let e in n) {
    let i = n[e].map(function(r) {
      return r.toLowerCase();
    });
    e = e.toLowerCase();
    for (let r = 0; r < i.length; r++) {
      const s = i[r];
      if (s[0] !== "*") {
        if (!t && s in this._types)
          throw new Error(
            'Attempt to change mapping for "' + s + '" extension from "' + this._types[s] + '" to "' + e + '". Pass `force=true` to allow this, otherwise remove "' + s + '" from the list of extensions for "' + e + '".'
          );
        this._types[s] = e;
      }
    }
    if (t || !this._extensions[e]) {
      const r = i[0];
      this._extensions[e] = r[0] !== "*" ? r : r.substr(1);
    }
  }
};
bu.prototype.getType = function(n) {
  n = String(n);
  let t = n.replace(/^.*[/\\]/, "").toLowerCase(), e = t.replace(/^.*\./, "").toLowerCase(), i = t.length < n.length;
  return (e.length < t.length - 1 || !i) && this._types[e] || null;
};
bu.prototype.getExtension = function(n) {
  return n = /^\s*([^;\s]*)/.test(n) && RegExp.$1, n && this._extensions[n.toLowerCase()] || null;
};
var h3 = bu, p3 = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] }, d3 = { "application/prs.cww": ["cww"], "application/vnd.1000minds.decision-model+xml": ["1km"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.keynote": ["key"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.numbers": ["numbers"], "application/vnd.apple.pages": ["pages"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.balsamiq.bmml+xml": ["bmml"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.citationstyles.style+xml": ["csl"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dbf": ["dbf"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mapbox-vector-tile": ["mvt"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["*stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.ac+xml": ["*ac"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openblox.game+xml": ["obgx"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openstreetmap.data+xml": ["osm"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.rar": ["rar"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.software602.filler.form+xml": ["fo"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.syncml.dmddf+xml": ["ddf"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": ["*dmg"], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": ["*bdoc"], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["*deb", "udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": ["*iso"], "application/x-iwork-keynote-sffkey": ["*key"], "application/x-iwork-numbers-sffnumbers": ["*numbers"], "application/x-iwork-pages-sffpages": ["*pages"], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-keepass2": ["kdbx"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": ["*exe"], "application/x-msdownload": ["*exe", "*dll", "com", "bat", "*msi"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["*wmf", "*wmz", "*emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": ["*prc", "*pdb"], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["*rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["*obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["*xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": ["*m4a"], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": ["*ra"], "audio/x-wav": ["*wav"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "image/prs.btif": ["btif"], "image/prs.pti": ["pti"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.airzip.accelerator.azv": ["azv"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": ["*sub"], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.microsoft.icon": ["ico"], "image/vnd.ms-dds": ["dds"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.pco.b16": ["b16"], "image/vnd.tencent.tap": ["tap"], "image/vnd.valve.source.texture": ["vtf"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/vnd.zbrush.pcx": ["pcx"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["*ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": ["*bmp"], "image/x-pcx": ["*pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/vnd.wfa.wsc": ["wsc"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.opengex": ["ogex"], "model/vnd.parasolid.transmit.binary": ["x_b"], "model/vnd.parasolid.transmit.text": ["x_t"], "model/vnd.sap.vds": ["vds"], "model/vnd.usdz+zip": ["usdz"], "model/vnd.valve.source.compiled-map": ["bsp"], "model/vnd.vtu": ["vtu"], "text/prs.lines.tag": ["dsc"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": ["*org"], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
let m3 = h3;
var _3 = new m3(p3, d3);
const y3 = Be, g3 = y3.RuntimeError;
var v3 = x3;
function x3(n) {
  const t = n.slice(0, 2), e = n.slice(0, 4), i = n.slice(8, 12);
  if (t.equals(Buffer.from([66, 77])))
    return ".bmp";
  if (t.equals(Buffer.from([71, 73])))
    return ".gif";
  if (t.equals(Buffer.from([255, 216])))
    return ".jpg";
  if (t.equals(Buffer.from([137, 80])))
    return ".png";
  if (t.equals(Buffer.from([171, 75])))
    return ".ktx2";
  if (t.equals(Buffer.from([115, 66])))
    return ".basis";
  if (e.equals(Buffer.from([82, 73, 70, 70])) && i.equals(Buffer.from([87, 69, 66, 80])))
    return ".webp";
  throw new g3("Image data does not have valid header");
}
const b3 = 2147479552, E3 = Xe.constants.MAX_LENGTH, w3 = Math.min(b3, E3), h_ = Be, Vl = Ln, fa = h_.defaultValue, Li = h_.defined;
var M3 = Af;
function Af(n, t, e) {
  let i = t;
  Li(i) || (Vl.buffer(n, function(d) {
    i = fa(i, d.name);
  }), i = fa(i, "buffer"));
  let r = 0;
  const s = [], a = [];
  Vl.buffer(n, function(d, m) {
    const v = d.extras._pipeline.source;
    Li(v) ? r += v.length : (s.push(d), a.push(m));
    const _ = fa(
      d.extensions,
      fa.EMPTY_OBJECT
    ).EXT_meshopt_compression;
    Li(_) && _.fallback && (d.extras._pipeline.mergedBufferName = `meshopt-fallback-${m}`);
  });
  const o = r > Af._getBufferMaxByteLength(), c = {}, h = {};
  Xp(n, function(d) {
    const m = n.buffers[d.buffer], v = m.extras._pipeline.source;
    if (!Li(v))
      return;
    let E = m.extras._pipeline.mergedBufferName;
    E = Li(E) ? `${i}-${E}` : i, o && (Li(h[E]) || (h[E] = 0), E += `-${h[E]++}`), e && (E = i), Li(c[E]) || (c[E] = {
      buffers: [],
      byteLength: 0,
      index: Object.keys(c).length
    });
    const _ = c[E].buffers;
    let p = c[E].byteLength;
    const R = c[E].index, M = Buffer.from(
      v.slice(
        d.byteOffset,
        d.byteOffset + d.byteLength
      )
    ), P = Yp(p);
    Li(P) && (_.push(P), p += P.byteLength), d.byteOffset = p, d.buffer = R, _.push(M), p += M.byteLength, c[E].byteLength = p;
  });
  const l = Object.keys(c).length;
  n.buffers = new Array(l);
  for (const d in c)
    if (Object.prototype.hasOwnProperty.call(c, d)) {
      const m = c[d].buffers, v = c[d].byteLength, E = c[d].index, _ = Yp(v);
      Li(_) && m.push(_);
      const p = m.length > 1 ? Buffer.concat(m) : m[0];
      n.buffers[E] = {
        name: d,
        byteLength: p.byteLength,
        extras: {
          _pipeline: {
            source: p
          }
        }
      };
    }
  const f = s.length;
  for (let d = 0; d < f; ++d) {
    const m = s[d], v = a[d], E = n.buffers.length;
    Xp(n, function(_) {
      _.buffer === v && (_.buffer = E);
    }), n.buffers.push(m);
  }
  return n;
}
function Xp(n, t) {
  Vl.bufferView(n, function(e) {
    t(e);
    const r = fa(
      e.extensions,
      fa.EMPTY_OBJECT
    ).EXT_meshopt_compression;
    Li(r) && t(r);
  });
}
function Yp(n) {
  const e = n % 8, i = e === 0 ? 0 : 8 - e;
  if (i > 0)
    return Buffer.alloc(i);
}
Af._getBufferMaxByteLength = function() {
  return w3;
};
const Tf = Be, _o = _3, S3 = mo, Qc = Ln, A3 = v3, T3 = M3, C3 = ho, ra = Tf.defaultValue, Cn = Tf.defined, R3 = Tf.WebGLConstants;
_o.define({ "text/plain": ["glsl"] }, !0);
_o.define({ "image/basis": ["basis"] }, !0);
_o.define({ "image/ktx2": ["ktx2"] }, !0);
var I3 = P3;
function P3(n, t) {
  t = ra(t, {}), t.separateBuffers = ra(t.separateBuffers, !1), t.separateTextures = ra(t.separateTextures, !1), t.separateShaders = ra(t.separateShaders, !1), t.dataUris = ra(t.dataUris, !1), t.forceMergeBuffers = ra(t.forceMergeBuffers, !1);
  const e = {};
  return Qc.image(n, function(i, r) {
    D3(n, i, r, e, t);
  }), Qc.shader(n, function(i, r) {
    N3(n, i, r, e, t);
  }), C3(n, ["accessor", "bufferView", "buffer"]), T3(n, t.name, t.forceMergeBuffers), Qc.buffer(n, function(i, r) {
    L3(n, i, r, e, t);
  }), n;
}
function L3(n, t, e, i, r) {
  Cn(t.extras._pipeline.source) && (Cn(r.bufferStorage) && !r.separateBuffers ? O3(t, r) : Cf(
    n,
    t,
    e,
    r.separateBuffers,
    !0,
    ".bin",
    i,
    r
  ));
}
function O3(n, t) {
  let e = t.bufferStorage.buffer;
  e = Cn(e) ? e : Buffer.alloc(0), e = Buffer.concat([
    e,
    n.extras._pipeline.source
  ]), t.bufferStorage.buffer = e;
}
function D3(n, t, e, i, r) {
  const s = A3(t.extras._pipeline.source);
  Cf(
    n,
    t,
    e,
    r.separateTextures,
    r.dataUris,
    s,
    i,
    r
  ), Cn(t.bufferView) && (t.mimeType = _o.getType(s));
}
function N3(n, t, e, i, r) {
  Cf(
    n,
    t,
    e,
    r.separateShaders,
    r.dataUris,
    ".glsl",
    i,
    r
  );
}
function Cf(n, t, e, i, r, s, a, o) {
  i ? G3(n, t, e, s, a, o) : r ? F3(t, s) : U3(n, t, a);
}
function F3(n, t) {
  delete n.bufferView;
  const e = n.extras._pipeline.source, i = _o.getType(t);
  n.uri = `data:${i};base64,${e.toString("base64")}`;
}
function U3(n, t, e) {
  delete t.uri;
  const i = t.extras._pipeline.resourceId;
  if (Cn(i) && Cn(e[i])) {
    t.bufferView = e[i];
    return;
  }
  let r = t.extras._pipeline.source;
  typeof r == "string" && (r = Buffer.from(r)), t.bufferView = S3(n, r), Cn(i) && (e[i] = t.bufferView);
}
function B3(n, t) {
  return Qc.program(n, function(e, i) {
    if (e.fragmentShader === t || e.vertexShader === t)
      return {
        program: e,
        index: i
      };
  });
}
function k3(n, t, e, i, r) {
  const s = r.name, a = t.name;
  if (Cn(a))
    return a;
  if (i === ".bin")
    return Cn(s) ? s + e : `buffer${e}`;
  if (i === ".glsl") {
    const o = B3(n, e), c = o.program, h = o.index, l = c.name, f = t.type === R3.FRAGMENT_SHADER ? "FS" : "VS";
    return Cn(l) ? l + f : Cn(s) ? s + f + h : f.toLowerCase() + h;
  }
  return Cn(s) ? s + e : `image${e}`;
}
function z3(n, t, e, i, r) {
  let a = t.extras._pipeline.relativePath;
  if (Cn(a))
    return a.replace(/\\/g, "/");
  const o = k3(n, t, e, i, r);
  a = o + i;
  let c = 1;
  for (; Cn(r.separateResources[a]); )
    a = `${o}_${c}${i}`, c++;
  return a;
}
function G3(n, t, e, i, r, s) {
  delete t.bufferView;
  const a = t.extras._pipeline.resourceId;
  if (Cn(a) && Cn(r[a])) {
    t.uri = r[a];
    return;
  }
  const o = t.extras._pipeline.source, c = z3(n, t, e, i, s);
  t.uri = c, Cn(s.separateResources) && (s.separateResources[c] = o), Cn(a) && (r[a] = t.uri);
}
var p_ = { exports: {} };
(function(n, t) {
  var e = e || {};
  e.scope = {}, e.arrayIteratorImpl = function(r) {
    var s = 0;
    return function() {
      return s < r.length ? { done: !1, value: r[s++] } : { done: !0 };
    };
  }, e.arrayIterator = function(r) {
    return { next: e.arrayIteratorImpl(r) };
  }, e.makeIterator = function(r) {
    var s = typeof Symbol < "u" && Symbol.iterator && r[Symbol.iterator];
    return s ? s.call(r) : e.arrayIterator(r);
  }, e.ASSUME_ES5 = !1, e.ASSUME_NO_NATIVE_MAP = !1, e.ASSUME_NO_NATIVE_SET = !1, e.SIMPLE_FROUND_POLYFILL = !1, e.ISOLATE_POLYFILLS = !1, e.FORCE_POLYFILL_PROMISE = !1, e.FORCE_POLYFILL_PROMISE_WHEN_NO_UNHANDLED_REJECTION = !1, e.getGlobal = function(r) {
    r = [typeof globalThis == "object" && globalThis, r, typeof window == "object" && window, typeof self == "object" && self, typeof cn == "object" && cn];
    for (var s = 0; s < r.length; ++s) {
      var a = r[s];
      if (a && a.Math == Math)
        return a;
    }
    throw Error("Cannot find global object");
  }, e.global = e.getGlobal(cn), e.defineProperty = e.ASSUME_ES5 || typeof Object.defineProperties == "function" ? Object.defineProperty : function(r, s, a) {
    return r == Array.prototype || r == Object.prototype || (r[s] = a.value), r;
  }, e.IS_SYMBOL_NATIVE = typeof Symbol == "function" && typeof Symbol("x") == "symbol", e.TRUST_ES6_POLYFILLS = !e.ISOLATE_POLYFILLS || e.IS_SYMBOL_NATIVE, e.polyfills = {}, e.propertyToPolyfillSymbol = {}, e.POLYFILL_PREFIX = "$jscp$", e.polyfill = function(r, s, a, o) {
    s && (e.ISOLATE_POLYFILLS ? e.polyfillIsolated(r, s, a, o) : e.polyfillUnisolated(r, s, a, o));
  }, e.polyfillUnisolated = function(r, s, a, o) {
    for (a = e.global, r = r.split("."), o = 0; o < r.length - 1; o++) {
      var c = r[o];
      if (!(c in a))
        return;
      a = a[c];
    }
    r = r[r.length - 1], o = a[r], s = s(o), s != o && s != null && e.defineProperty(a, r, { configurable: !0, writable: !0, value: s });
  }, e.polyfillIsolated = function(r, s, a, o) {
    var c = r.split(".");
    r = c.length === 1, o = c[0], o = !r && o in e.polyfills ? e.polyfills : e.global;
    for (var h = 0; h < c.length - 1; h++) {
      var l = c[h];
      if (!(l in o))
        return;
      o = o[l];
    }
    c = c[c.length - 1], a = e.IS_SYMBOL_NATIVE && a === "es6" ? o[c] : null, s = s(a), s != null && (r ? e.defineProperty(e.polyfills, c, { configurable: !0, writable: !0, value: s }) : s !== a && (e.propertyToPolyfillSymbol[c] === void 0 && (a = 1e9 * Math.random() >>> 0, e.propertyToPolyfillSymbol[c] = e.IS_SYMBOL_NATIVE ? e.global.Symbol(c) : e.POLYFILL_PREFIX + a + "$" + c), e.defineProperty(o, e.propertyToPolyfillSymbol[c], { configurable: !0, writable: !0, value: s })));
  }, e.polyfill("Promise", function(r) {
    function s() {
      this.batch_ = null;
    }
    function a(l) {
      return l instanceof c ? l : new c(function(f, d) {
        f(l);
      });
    }
    if (r && (!(e.FORCE_POLYFILL_PROMISE || e.FORCE_POLYFILL_PROMISE_WHEN_NO_UNHANDLED_REJECTION && typeof e.global.PromiseRejectionEvent > "u") || !e.global.Promise || e.global.Promise.toString().indexOf("[native code]") === -1))
      return r;
    s.prototype.asyncExecute = function(l) {
      if (this.batch_ == null) {
        this.batch_ = [];
        var f = this;
        this.asyncExecuteFunction(function() {
          f.executeBatch_();
        });
      }
      this.batch_.push(l);
    };
    var o = e.global.setTimeout;
    s.prototype.asyncExecuteFunction = function(l) {
      o(l, 0);
    }, s.prototype.executeBatch_ = function() {
      for (; this.batch_ && this.batch_.length; ) {
        var l = this.batch_;
        this.batch_ = [];
        for (var f = 0; f < l.length; ++f) {
          var d = l[f];
          l[f] = null;
          try {
            d();
          } catch (m) {
            this.asyncThrow_(m);
          }
        }
      }
      this.batch_ = null;
    }, s.prototype.asyncThrow_ = function(l) {
      this.asyncExecuteFunction(function() {
        throw l;
      });
    };
    var c = function(l) {
      this.state_ = 0, this.result_ = void 0, this.onSettledCallbacks_ = [], this.isRejectionHandled_ = !1;
      var f = this.createResolveAndReject_();
      try {
        l(f.resolve, f.reject);
      } catch (d) {
        f.reject(d);
      }
    };
    c.prototype.createResolveAndReject_ = function() {
      function l(m) {
        return function(v) {
          d || (d = !0, m.call(f, v));
        };
      }
      var f = this, d = !1;
      return { resolve: l(this.resolveTo_), reject: l(this.reject_) };
    }, c.prototype.resolveTo_ = function(l) {
      if (l === this)
        this.reject_(new TypeError("A Promise cannot resolve to itself"));
      else if (l instanceof c)
        this.settleSameAsPromise_(l);
      else {
        t:
          switch (typeof l) {
            case "object":
              var f = l != null;
              break t;
            case "function":
              f = !0;
              break t;
            default:
              f = !1;
          }
        f ? this.resolveToNonPromiseObj_(l) : this.fulfill_(l);
      }
    }, c.prototype.resolveToNonPromiseObj_ = function(l) {
      var f = void 0;
      try {
        f = l.then;
      } catch (d) {
        this.reject_(d);
        return;
      }
      typeof f == "function" ? this.settleSameAsThenable_(f, l) : this.fulfill_(l);
    }, c.prototype.reject_ = function(l) {
      this.settle_(2, l);
    }, c.prototype.fulfill_ = function(l) {
      this.settle_(1, l);
    }, c.prototype.settle_ = function(l, f) {
      if (this.state_ != 0)
        throw Error("Cannot settle(" + l + ", " + f + "): Promise already settled in state" + this.state_);
      this.state_ = l, this.result_ = f, this.state_ === 2 && this.scheduleUnhandledRejectionCheck_(), this.executeOnSettledCallbacks_();
    }, c.prototype.scheduleUnhandledRejectionCheck_ = function() {
      var l = this;
      o(function() {
        if (l.notifyUnhandledRejection_()) {
          var f = e.global.console;
          typeof f < "u" && f.error(l.result_);
        }
      }, 1);
    }, c.prototype.notifyUnhandledRejection_ = function() {
      if (this.isRejectionHandled_)
        return !1;
      var l = e.global.CustomEvent, f = e.global.Event, d = e.global.dispatchEvent;
      return typeof d > "u" ? !0 : (typeof l == "function" ? l = new l("unhandledrejection", { cancelable: !0 }) : typeof f == "function" ? l = new f("unhandledrejection", { cancelable: !0 }) : (l = e.global.document.createEvent("CustomEvent"), l.initCustomEvent("unhandledrejection", !1, !0, l)), l.promise = this, l.reason = this.result_, d(l));
    }, c.prototype.executeOnSettledCallbacks_ = function() {
      if (this.onSettledCallbacks_ != null) {
        for (var l = 0; l < this.onSettledCallbacks_.length; ++l)
          h.asyncExecute(this.onSettledCallbacks_[l]);
        this.onSettledCallbacks_ = null;
      }
    };
    var h = new s();
    return c.prototype.settleSameAsPromise_ = function(l) {
      var f = this.createResolveAndReject_();
      l.callWhenSettled_(f.resolve, f.reject);
    }, c.prototype.settleSameAsThenable_ = function(l, f) {
      var d = this.createResolveAndReject_();
      try {
        l.call(f, d.resolve, d.reject);
      } catch (m) {
        d.reject(m);
      }
    }, c.prototype.then = function(l, f) {
      function d(_, p) {
        return typeof _ == "function" ? function(R) {
          try {
            m(_(R));
          } catch (M) {
            v(M);
          }
        } : p;
      }
      var m, v, E = new c(function(_, p) {
        m = _, v = p;
      });
      return this.callWhenSettled_(d(l, m), d(f, v)), E;
    }, c.prototype.catch = function(l) {
      return this.then(void 0, l);
    }, c.prototype.callWhenSettled_ = function(l, f) {
      function d() {
        switch (m.state_) {
          case 1:
            l(m.result_);
            break;
          case 2:
            f(m.result_);
            break;
          default:
            throw Error("Unexpected state: " + m.state_);
        }
      }
      var m = this;
      this.onSettledCallbacks_ == null ? h.asyncExecute(d) : this.onSettledCallbacks_.push(d), this.isRejectionHandled_ = !0;
    }, c.resolve = a, c.reject = function(l) {
      return new c(function(f, d) {
        d(l);
      });
    }, c.race = function(l) {
      return new c(function(f, d) {
        for (var m = e.makeIterator(l), v = m.next(); !v.done; v = m.next())
          a(v.value).callWhenSettled_(f, d);
      });
    }, c.all = function(l) {
      var f = e.makeIterator(l), d = f.next();
      return d.done ? a([]) : new c(function(m, v) {
        function E(R) {
          return function(M) {
            _[R] = M, p--, p == 0 && m(_);
          };
        }
        var _ = [], p = 0;
        do
          _.push(void 0), p++, a(d.value).callWhenSettled_(E(_.length - 1), v), d = f.next();
        while (!d.done);
      });
    }, c;
  }, "es6", "es3"), e.owns = function(r, s) {
    return Object.prototype.hasOwnProperty.call(r, s);
  }, e.assign = e.TRUST_ES6_POLYFILLS && typeof Object.assign == "function" ? Object.assign : function(r, s) {
    for (var a = 1; a < arguments.length; a++) {
      var o = arguments[a];
      if (o)
        for (var c in o)
          e.owns(o, c) && (r[c] = o[c]);
    }
    return r;
  }, e.polyfill("Object.assign", function(r) {
    return r || e.assign;
  }, "es6", "es3"), e.checkStringArgs = function(r, s, a) {
    if (r == null)
      throw new TypeError("The 'this' value for String.prototype." + a + " must not be null or undefined");
    if (s instanceof RegExp)
      throw new TypeError("First argument to String.prototype." + a + " must not be a regular expression");
    return r + "";
  }, e.polyfill("String.prototype.startsWith", function(r) {
    return r || function(s, a) {
      var o = e.checkStringArgs(this, s, "startsWith");
      s += "";
      var c = o.length, h = s.length;
      a = Math.max(0, Math.min(a | 0, o.length));
      for (var l = 0; l < h && a < c; )
        if (o[a++] != s[l++])
          return !1;
      return l >= h;
    };
  }, "es6", "es3"), e.polyfill("Array.prototype.copyWithin", function(r) {
    function s(a) {
      return a = Number(a), a === 1 / 0 || a === -1 / 0 ? a : a | 0;
    }
    return r || function(a, o, c) {
      var h = this.length;
      if (a = s(a), o = s(o), c = c === void 0 ? h : s(c), a = 0 > a ? Math.max(h + a, 0) : Math.min(a, h), o = 0 > o ? Math.max(h + o, 0) : Math.min(o, h), c = 0 > c ? Math.max(h + c, 0) : Math.min(c, h), a < o)
        for (; o < c; )
          o in this ? this[a++] = this[o++] : (delete this[a++], o++);
      else
        for (c = Math.min(c, h + o - a), a += c - o; c > o; )
          --c in this ? this[--a] = this[c] : delete this[--a];
      return this;
    };
  }, "es6", "es3"), e.typedArrayCopyWithin = function(r) {
    return r || Array.prototype.copyWithin;
  }, e.polyfill("Int8Array.prototype.copyWithin", e.typedArrayCopyWithin, "es6", "es5"), e.polyfill("Uint8Array.prototype.copyWithin", e.typedArrayCopyWithin, "es6", "es5"), e.polyfill("Uint8ClampedArray.prototype.copyWithin", e.typedArrayCopyWithin, "es6", "es5"), e.polyfill("Int16Array.prototype.copyWithin", e.typedArrayCopyWithin, "es6", "es5"), e.polyfill("Uint16Array.prototype.copyWithin", e.typedArrayCopyWithin, "es6", "es5"), e.polyfill("Int32Array.prototype.copyWithin", e.typedArrayCopyWithin, "es6", "es5"), e.polyfill("Uint32Array.prototype.copyWithin", e.typedArrayCopyWithin, "es6", "es5"), e.polyfill("Float32Array.prototype.copyWithin", e.typedArrayCopyWithin, "es6", "es5"), e.polyfill("Float64Array.prototype.copyWithin", e.typedArrayCopyWithin, "es6", "es5");
  var i = function() {
    var r = typeof document < "u" && document.currentScript ? document.currentScript.src : void 0;
    return typeof __filename < "u" && (r = r || __filename), function(s) {
      function a(at) {
        return w.locateFile ? w.locateFile(at, q) : q + at;
      }
      function o() {
        var at = Ct.buffer;
        w.HEAP8 = Wt = new Int8Array(at), w.HEAP16 = Q = new Int16Array(at), w.HEAP32 = y = new Int32Array(at), w.HEAPU8 = wt = new Uint8Array(at), w.HEAPU16 = new Uint16Array(at), w.HEAPU32 = g = new Uint32Array(at), w.HEAPF32 = S = new Float32Array(at), w.HEAPF64 = new Float64Array(at);
      }
      function c(at) {
        throw w.onAbort && w.onAbort(at), at = "Aborted(" + at + ")", yt(at), Lt = !0, at = new WebAssembly.RuntimeError(at + ". Build with -sASSERTIONS for more info."), pt(at), at;
      }
      function h(at) {
        try {
          if (at == Ft && Et)
            return new Uint8Array(Et);
          if (Y)
            return Y(at);
          throw "both async and sync fetching of the wasm failed";
        } catch (xt) {
          c(xt);
        }
      }
      function l() {
        if (!Et && (rt || b)) {
          if (typeof fetch == "function" && !Ft.startsWith("file://"))
            return fetch(Ft, { credentials: "same-origin" }).then(function(at) {
              if (!at.ok)
                throw "failed to load wasm binary file at '" + Ft + "'";
              return at.arrayBuffer();
            }).catch(function() {
              return h(Ft);
            });
          if (K)
            return new Promise(function(at, xt) {
              K(Ft, function(Ot) {
                at(new Uint8Array(Ot));
              }, xt);
            });
        }
        return Promise.resolve().then(function() {
          return h(Ft);
        });
      }
      function f(at) {
        for (; 0 < at.length; )
          at.shift()(w);
      }
      function d(at) {
        this.excPtr = at, this.ptr = at - 24, this.set_type = function(xt) {
          g[this.ptr + 4 >> 2] = xt;
        }, this.get_type = function() {
          return g[this.ptr + 4 >> 2];
        }, this.set_destructor = function(xt) {
          g[this.ptr + 8 >> 2] = xt;
        }, this.get_destructor = function() {
          return g[this.ptr + 8 >> 2];
        }, this.set_refcount = function(xt) {
          y[this.ptr >> 2] = xt;
        }, this.set_caught = function(xt) {
          Wt[this.ptr + 12 >> 0] = xt ? 1 : 0;
        }, this.get_caught = function() {
          return Wt[this.ptr + 12 >> 0] != 0;
        }, this.set_rethrown = function(xt) {
          Wt[this.ptr + 13 >> 0] = xt ? 1 : 0;
        }, this.get_rethrown = function() {
          return Wt[this.ptr + 13 >> 0] != 0;
        }, this.init = function(xt, Ot) {
          this.set_adjusted_ptr(0), this.set_type(xt), this.set_destructor(Ot), this.set_refcount(0), this.set_caught(!1), this.set_rethrown(!1);
        }, this.add_ref = function() {
          y[this.ptr >> 2] += 1;
        }, this.release_ref = function() {
          var xt = y[this.ptr >> 2];
          return y[this.ptr >> 2] = xt - 1, xt === 1;
        }, this.set_adjusted_ptr = function(xt) {
          g[this.ptr + 16 >> 2] = xt;
        }, this.get_adjusted_ptr = function() {
          return g[this.ptr + 16 >> 2];
        }, this.get_exception_ptr = function() {
          if (Ci(this.get_type()))
            return g[this.excPtr >> 2];
          var xt = this.get_adjusted_ptr();
          return xt !== 0 ? xt : this.excPtr;
        };
      }
      function m() {
        function at() {
          if (!Yi && (Yi = !0, w.calledRun = !0, !Lt)) {
            if (gt = !0, f(Z), ut(w), w.onRuntimeInitialized && w.onRuntimeInitialized(), w.postRun)
              for (typeof w.postRun == "function" && (w.postRun = [w.postRun]); w.postRun.length; )
                tt.unshift(w.postRun.shift());
            f(tt);
          }
        }
        if (!(0 < st)) {
          if (w.preRun)
            for (typeof w.preRun == "function" && (w.preRun = [w.preRun]); w.preRun.length; )
              O.unshift(w.preRun.shift());
          f(O), 0 < st || (w.setStatus ? (w.setStatus("Running..."), setTimeout(function() {
            setTimeout(function() {
              w.setStatus("");
            }, 1), at();
          }, 1)) : at());
        }
      }
      function v() {
      }
      function E(at) {
        return (at || v).__cache__;
      }
      function _(at, xt) {
        var Ot = E(xt), Bt = Ot[at];
        return Bt || (Bt = Object.create((xt || v).prototype), Bt.ptr = at, Ot[at] = Bt);
      }
      function p(at) {
        if (typeof at == "string") {
          for (var xt = 0, Ot = 0; Ot < at.length; ++Ot) {
            var Bt = at.charCodeAt(Ot);
            127 >= Bt ? xt++ : 2047 >= Bt ? xt += 2 : 55296 <= Bt && 57343 >= Bt ? (xt += 4, ++Ot) : xt += 3;
          }
          if (xt = Array(xt + 1), Ot = 0, Bt = xt.length, 0 < Bt) {
            Bt = Ot + Bt - 1;
            for (var Zt = 0; Zt < at.length; ++Zt) {
              var pe = at.charCodeAt(Zt);
              if (55296 <= pe && 57343 >= pe) {
                var Ri = at.charCodeAt(++Zt);
                pe = 65536 + ((pe & 1023) << 10) | Ri & 1023;
              }
              if (127 >= pe) {
                if (Ot >= Bt)
                  break;
                xt[Ot++] = pe;
              } else {
                if (2047 >= pe) {
                  if (Ot + 1 >= Bt)
                    break;
                  xt[Ot++] = 192 | pe >> 6;
                } else {
                  if (65535 >= pe) {
                    if (Ot + 2 >= Bt)
                      break;
                    xt[Ot++] = 224 | pe >> 12;
                  } else {
                    if (Ot + 3 >= Bt)
                      break;
                    xt[Ot++] = 240 | pe >> 18, xt[Ot++] = 128 | pe >> 12 & 63;
                  }
                  xt[Ot++] = 128 | pe >> 6 & 63;
                }
                xt[Ot++] = 128 | pe & 63;
              }
            }
            xt[Ot] = 0;
          }
          return at = _e.alloc(xt, Wt), _e.copy(xt, Wt, at), at;
        }
        return at;
      }
      function R(at) {
        if (typeof at == "object") {
          var xt = _e.alloc(at, Wt);
          return _e.copy(at, Wt, xt), xt;
        }
        return at;
      }
      function M(at) {
        if (typeof at == "object") {
          var xt = _e.alloc(at, Q);
          return _e.copy(at, Q, xt), xt;
        }
        return at;
      }
      function P(at) {
        if (typeof at == "object") {
          var xt = _e.alloc(at, y);
          return _e.copy(at, y, xt), xt;
        }
        return at;
      }
      function W(at) {
        if (typeof at == "object") {
          var xt = _e.alloc(at, S);
          return _e.copy(at, S, xt), xt;
        }
        return at;
      }
      function C() {
        throw "cannot construct a VoidPtr, no constructor in IDL";
      }
      function D() {
        this.ptr = z(), E(D)[this.ptr] = this;
      }
      function N() {
        this.ptr = nt(), E(N)[this.ptr] = this;
      }
      function A() {
        this.ptr = te(), E(A)[this.ptr] = this;
      }
      function I() {
        this.ptr = Ne(), E(I)[this.ptr] = this;
      }
      function it() {
        this.ptr = zn(), E(it)[this.ptr] = this;
      }
      function V() {
        this.ptr = Gn(), E(V)[this.ptr] = this;
      }
      function mt() {
        this.ptr = ji(), E(mt)[this.ptr] = this;
      }
      function k() {
        this.ptr = Xt(), E(k)[this.ptr] = this;
      }
      function B() {
        this.ptr = Qe(), E(B)[this.ptr] = this;
      }
      function G() {
        this.ptr = ti(), E(G)[this.ptr] = this;
      }
      function H(at) {
        at && typeof at == "object" && (at = at.ptr), this.ptr = Zr(at), E(H)[this.ptr] = this;
      }
      s = s === void 0 ? {} : s;
      var w = typeof s < "u" ? s : {}, ut, pt;
      w.ready = new Promise(function(at, xt) {
        ut = at, pt = xt;
      });
      var _t = !1, vt = !1;
      w.onRuntimeInitialized = function() {
        _t = !0, vt && typeof w.onModuleLoaded == "function" && w.onModuleLoaded(w);
      }, w.onModuleParsed = function() {
        vt = !0, _t && typeof w.onModuleLoaded == "function" && w.onModuleLoaded(w);
      }, w.isVersionSupported = function(at) {
        return typeof at != "string" ? !1 : (at = at.split("."), 2 > at.length || 3 < at.length ? !1 : at[0] == 1 && 0 <= at[1] && 5 >= at[1] ? !0 : !(at[0] != 0 || 10 < at[1]));
      };
      var F = Object.assign({}, w), rt = typeof window == "object", b = typeof importScripts == "function", lt = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string", q = "";
      if (lt) {
        var U = Xe, L = Xe;
        q = b ? L.dirname(q) + "/" : __dirname + "/";
        var j = function(at, xt) {
          return at = at.startsWith("file://") ? new URL(at) : L.normalize(at), U.readFileSync(at, xt ? void 0 : "utf8");
        }, Y = function(at) {
          return at = j(at, !0), at.buffer || (at = new Uint8Array(at)), at;
        }, K = function(at, xt, Ot) {
          at = at.startsWith("file://") ? new URL(at) : L.normalize(at), U.readFile(at, function(Bt, Zt) {
            Bt ? Ot(Bt) : xt(Zt.buffer);
          });
        };
        1 < process.argv.length && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2), w.inspect = function() {
          return "[Emscripten Module object]";
        };
      } else
        (rt || b) && (b ? q = self.location.href : typeof document < "u" && document.currentScript && (q = document.currentScript.src), r && (q = r), q = q.indexOf("blob:") !== 0 ? q.substr(0, q.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", j = function(at) {
          var xt = new XMLHttpRequest();
          return xt.open("GET", at, !1), xt.send(null), xt.responseText;
        }, b && (Y = function(at) {
          var xt = new XMLHttpRequest();
          return xt.open("GET", at, !1), xt.responseType = "arraybuffer", xt.send(null), new Uint8Array(xt.response);
        }), K = function(at, xt, Ot) {
          var Bt = new XMLHttpRequest();
          Bt.open("GET", at, !0), Bt.responseType = "arraybuffer", Bt.onload = function() {
            Bt.status == 200 || Bt.status == 0 && Bt.response ? xt(Bt.response) : Ot();
          }, Bt.onerror = Ot, Bt.send(null);
        });
      w.print || console.log.bind(console);
      var yt = w.printErr || console.warn.bind(console);
      Object.assign(w, F), F = null;
      var Et;
      w.wasmBinary && (Et = w.wasmBinary), typeof WebAssembly != "object" && c("no native wasm support detected");
      var Ct, Lt = !1, Wt, wt, Q, y, g, S, O = [], Z = [], tt = [], gt = !1, st = 0, Tt = null, Ft = "draco_encoder.wasm";
      Ft.startsWith("data:application/octet-stream;base64,") || (Ft = a(Ft));
      var ht = { b: function(at, xt, Ot) {
        throw new d(at).init(xt, Ot), at;
      }, a: function() {
        c("");
      }, d: function(at, xt, Ot) {
        wt.copyWithin(at, xt, xt + Ot);
      }, c: function(at) {
        var xt = wt.length;
        if (at >>>= 0, 2147483648 < at)
          return !1;
        for (var Ot = 1; 4 >= Ot; Ot *= 2) {
          var Bt = xt * (1 + 0.2 / Ot);
          Bt = Math.min(Bt, at + 100663296);
          var Zt = Math;
          Bt = Math.max(at, Bt), Zt = Zt.min.call(
            Zt,
            2147483648,
            Bt + (65536 - Bt % 65536) % 65536
          );
          t: {
            Bt = Ct.buffer;
            try {
              Ct.grow(Zt - Bt.byteLength + 65535 >>> 16), o();
              var pe = 1;
              break t;
            } catch {
            }
            pe = void 0;
          }
          if (pe)
            return !0;
        }
        return !1;
      } };
      (function() {
        function at(Zt, pe) {
          w.asm = Zt.exports, Ct = w.asm.e, o(), Z.unshift(w.asm.f), st--, w.monitorRunDependencies && w.monitorRunDependencies(st), st == 0 && Tt && (Zt = Tt, Tt = null, Zt());
        }
        function xt(Zt) {
          at(Zt.instance);
        }
        function Ot(Zt) {
          return l().then(function(pe) {
            return WebAssembly.instantiate(pe, Bt);
          }).then(function(pe) {
            return pe;
          }).then(Zt, function(pe) {
            yt("failed to asynchronously prepare wasm: " + pe), c(pe);
          });
        }
        var Bt = { a: ht };
        if (st++, w.monitorRunDependencies && w.monitorRunDependencies(st), w.instantiateWasm)
          try {
            return w.instantiateWasm(Bt, at);
          } catch (Zt) {
            yt("Module.instantiateWasm callback failed with error: " + Zt), pt(Zt);
          }
        return function() {
          return Et || typeof WebAssembly.instantiateStreaming != "function" || Ft.startsWith("data:application/octet-stream;base64,") || Ft.startsWith("file://") || lt || typeof fetch != "function" ? Ot(xt) : fetch(Ft, { credentials: "same-origin" }).then(function(Zt) {
            return WebAssembly.instantiateStreaming(Zt, Bt).then(
              xt,
              function(pe) {
                return yt("wasm streaming compile failed: " + pe), yt("falling back to ArrayBuffer instantiation"), Ot(xt);
              }
            );
          });
        }().catch(pt), {};
      })();
      var It = w._emscripten_bind_VoidPtr___destroy___0 = function() {
        return (It = w._emscripten_bind_VoidPtr___destroy___0 = w.asm.h).apply(null, arguments);
      }, z = w._emscripten_bind_GeometryAttribute_GeometryAttribute_0 = function() {
        return (z = w._emscripten_bind_GeometryAttribute_GeometryAttribute_0 = w.asm.i).apply(null, arguments);
      }, ft = w._emscripten_bind_GeometryAttribute___destroy___0 = function() {
        return (ft = w._emscripten_bind_GeometryAttribute___destroy___0 = w.asm.j).apply(null, arguments);
      }, nt = w._emscripten_bind_PointAttribute_PointAttribute_0 = function() {
        return (nt = w._emscripten_bind_PointAttribute_PointAttribute_0 = w.asm.k).apply(null, arguments);
      }, J = w._emscripten_bind_PointAttribute_size_0 = function() {
        return (J = w._emscripten_bind_PointAttribute_size_0 = w.asm.l).apply(null, arguments);
      }, Rt = w._emscripten_bind_PointAttribute_attribute_type_0 = function() {
        return (Rt = w._emscripten_bind_PointAttribute_attribute_type_0 = w.asm.m).apply(null, arguments);
      }, Nt = w._emscripten_bind_PointAttribute_data_type_0 = function() {
        return (Nt = w._emscripten_bind_PointAttribute_data_type_0 = w.asm.n).apply(null, arguments);
      }, Yt = w._emscripten_bind_PointAttribute_num_components_0 = function() {
        return (Yt = w._emscripten_bind_PointAttribute_num_components_0 = w.asm.o).apply(null, arguments);
      }, Ht = w._emscripten_bind_PointAttribute_normalized_0 = function() {
        return (Ht = w._emscripten_bind_PointAttribute_normalized_0 = w.asm.p).apply(null, arguments);
      }, Pt = w._emscripten_bind_PointAttribute_byte_stride_0 = function() {
        return (Pt = w._emscripten_bind_PointAttribute_byte_stride_0 = w.asm.q).apply(null, arguments);
      }, Mt = w._emscripten_bind_PointAttribute_byte_offset_0 = function() {
        return (Mt = w._emscripten_bind_PointAttribute_byte_offset_0 = w.asm.r).apply(null, arguments);
      }, $t = w._emscripten_bind_PointAttribute_unique_id_0 = function() {
        return ($t = w._emscripten_bind_PointAttribute_unique_id_0 = w.asm.s).apply(null, arguments);
      }, Kt = w._emscripten_bind_PointAttribute___destroy___0 = function() {
        return (Kt = w._emscripten_bind_PointAttribute___destroy___0 = w.asm.t).apply(null, arguments);
      }, te = w._emscripten_bind_PointCloud_PointCloud_0 = function() {
        return (te = w._emscripten_bind_PointCloud_PointCloud_0 = w.asm.u).apply(null, arguments);
      }, Qt = w._emscripten_bind_PointCloud_num_attributes_0 = function() {
        return (Qt = w._emscripten_bind_PointCloud_num_attributes_0 = w.asm.v).apply(null, arguments);
      }, ee = w._emscripten_bind_PointCloud_num_points_0 = function() {
        return (ee = w._emscripten_bind_PointCloud_num_points_0 = w.asm.w).apply(null, arguments);
      }, Pe = w._emscripten_bind_PointCloud___destroy___0 = function() {
        return (Pe = w._emscripten_bind_PointCloud___destroy___0 = w.asm.x).apply(null, arguments);
      }, Ne = w._emscripten_bind_Mesh_Mesh_0 = function() {
        return (Ne = w._emscripten_bind_Mesh_Mesh_0 = w.asm.y).apply(null, arguments);
      }, Je = w._emscripten_bind_Mesh_num_faces_0 = function() {
        return (Je = w._emscripten_bind_Mesh_num_faces_0 = w.asm.z).apply(null, arguments);
      }, ve = w._emscripten_bind_Mesh_num_attributes_0 = function() {
        return (ve = w._emscripten_bind_Mesh_num_attributes_0 = w.asm.A).apply(null, arguments);
      }, tn = w._emscripten_bind_Mesh_num_points_0 = function() {
        return (tn = w._emscripten_bind_Mesh_num_points_0 = w.asm.B).apply(null, arguments);
      }, dn = w._emscripten_bind_Mesh_set_num_points_1 = function() {
        return (dn = w._emscripten_bind_Mesh_set_num_points_1 = w.asm.C).apply(null, arguments);
      }, Qn = w._emscripten_bind_Mesh___destroy___0 = function() {
        return (Qn = w._emscripten_bind_Mesh___destroy___0 = w.asm.D).apply(null, arguments);
      }, zn = w._emscripten_bind_Metadata_Metadata_0 = function() {
        return (zn = w._emscripten_bind_Metadata_Metadata_0 = w.asm.E).apply(null, arguments);
      }, Rn = w._emscripten_bind_Metadata___destroy___0 = function() {
        return (Rn = w._emscripten_bind_Metadata___destroy___0 = w.asm.F).apply(null, arguments);
      }, Gn = w._emscripten_bind_DracoInt8Array_DracoInt8Array_0 = function() {
        return (Gn = w._emscripten_bind_DracoInt8Array_DracoInt8Array_0 = w.asm.G).apply(null, arguments);
      }, ci = w._emscripten_bind_DracoInt8Array_GetValue_1 = function() {
        return (ci = w._emscripten_bind_DracoInt8Array_GetValue_1 = w.asm.H).apply(null, arguments);
      }, Ai = w._emscripten_bind_DracoInt8Array_size_0 = function() {
        return (Ai = w._emscripten_bind_DracoInt8Array_size_0 = w.asm.I).apply(null, arguments);
      }, ui = w._emscripten_bind_DracoInt8Array___destroy___0 = function() {
        return (ui = w._emscripten_bind_DracoInt8Array___destroy___0 = w.asm.J).apply(null, arguments);
      }, ji = w._emscripten_bind_MetadataBuilder_MetadataBuilder_0 = function() {
        return (ji = w._emscripten_bind_MetadataBuilder_MetadataBuilder_0 = w.asm.K).apply(null, arguments);
      }, Wi = w._emscripten_bind_MetadataBuilder_AddStringEntry_3 = function() {
        return (Wi = w._emscripten_bind_MetadataBuilder_AddStringEntry_3 = w.asm.L).apply(null, arguments);
      }, qi = w._emscripten_bind_MetadataBuilder_AddIntEntry_3 = function() {
        return (qi = w._emscripten_bind_MetadataBuilder_AddIntEntry_3 = w.asm.M).apply(null, arguments);
      }, St = w._emscripten_bind_MetadataBuilder_AddIntEntryArray_4 = function() {
        return (St = w._emscripten_bind_MetadataBuilder_AddIntEntryArray_4 = w.asm.N).apply(null, arguments);
      }, kt = w._emscripten_bind_MetadataBuilder_AddDoubleEntry_3 = function() {
        return (kt = w._emscripten_bind_MetadataBuilder_AddDoubleEntry_3 = w.asm.O).apply(null, arguments);
      }, qt = w._emscripten_bind_MetadataBuilder___destroy___0 = function() {
        return (qt = w._emscripten_bind_MetadataBuilder___destroy___0 = w.asm.P).apply(null, arguments);
      }, Xt = w._emscripten_bind_PointCloudBuilder_PointCloudBuilder_0 = function() {
        return (Xt = w._emscripten_bind_PointCloudBuilder_PointCloudBuilder_0 = w.asm.Q).apply(null, arguments);
      }, jt = w._emscripten_bind_PointCloudBuilder_AddFloatAttribute_5 = function() {
        return (jt = w._emscripten_bind_PointCloudBuilder_AddFloatAttribute_5 = w.asm.R).apply(null, arguments);
      }, le = w._emscripten_bind_PointCloudBuilder_AddInt8Attribute_5 = function() {
        return (le = w._emscripten_bind_PointCloudBuilder_AddInt8Attribute_5 = w.asm.S).apply(null, arguments);
      }, me = w._emscripten_bind_PointCloudBuilder_AddUInt8Attribute_5 = function() {
        return (me = w._emscripten_bind_PointCloudBuilder_AddUInt8Attribute_5 = w.asm.T).apply(null, arguments);
      }, ye = w._emscripten_bind_PointCloudBuilder_AddInt16Attribute_5 = function() {
        return (ye = w._emscripten_bind_PointCloudBuilder_AddInt16Attribute_5 = w.asm.U).apply(null, arguments);
      }, xe = w._emscripten_bind_PointCloudBuilder_AddUInt16Attribute_5 = function() {
        return (xe = w._emscripten_bind_PointCloudBuilder_AddUInt16Attribute_5 = w.asm.V).apply(null, arguments);
      }, Te = w._emscripten_bind_PointCloudBuilder_AddInt32Attribute_5 = function() {
        return (Te = w._emscripten_bind_PointCloudBuilder_AddInt32Attribute_5 = w.asm.W).apply(null, arguments);
      }, Ee = w._emscripten_bind_PointCloudBuilder_AddUInt32Attribute_5 = function() {
        return (Ee = w._emscripten_bind_PointCloudBuilder_AddUInt32Attribute_5 = w.asm.X).apply(null, arguments);
      }, we = w._emscripten_bind_PointCloudBuilder_AddMetadata_2 = function() {
        return (we = w._emscripten_bind_PointCloudBuilder_AddMetadata_2 = w.asm.Y).apply(null, arguments);
      }, We = w._emscripten_bind_PointCloudBuilder_SetMetadataForAttribute_3 = function() {
        return (We = w._emscripten_bind_PointCloudBuilder_SetMetadataForAttribute_3 = w.asm.Z).apply(null, arguments);
      }, fn = w._emscripten_bind_PointCloudBuilder___destroy___0 = function() {
        return (fn = w._emscripten_bind_PointCloudBuilder___destroy___0 = w.asm._).apply(null, arguments);
      }, Qe = w._emscripten_bind_MeshBuilder_MeshBuilder_0 = function() {
        return (Qe = w._emscripten_bind_MeshBuilder_MeshBuilder_0 = w.asm.$).apply(null, arguments);
      }, wn = w._emscripten_bind_MeshBuilder_AddFacesToMesh_3 = function() {
        return (wn = w._emscripten_bind_MeshBuilder_AddFacesToMesh_3 = w.asm.aa).apply(null, arguments);
      }, Ve = w._emscripten_bind_MeshBuilder_AddFloatAttributeToMesh_5 = function() {
        return (Ve = w._emscripten_bind_MeshBuilder_AddFloatAttributeToMesh_5 = w.asm.ba).apply(null, arguments);
      }, Ae = w._emscripten_bind_MeshBuilder_AddInt32AttributeToMesh_5 = function() {
        return (Ae = w._emscripten_bind_MeshBuilder_AddInt32AttributeToMesh_5 = w.asm.ca).apply(null, arguments);
      }, li = w._emscripten_bind_MeshBuilder_AddMetadataToMesh_2 = function() {
        return (li = w._emscripten_bind_MeshBuilder_AddMetadataToMesh_2 = w.asm.da).apply(null, arguments);
      }, ze = w._emscripten_bind_MeshBuilder_AddFloatAttribute_5 = function() {
        return (ze = w._emscripten_bind_MeshBuilder_AddFloatAttribute_5 = w.asm.ea).apply(null, arguments);
      }, On = w._emscripten_bind_MeshBuilder_AddInt8Attribute_5 = function() {
        return (On = w._emscripten_bind_MeshBuilder_AddInt8Attribute_5 = w.asm.fa).apply(null, arguments);
      }, hn = w._emscripten_bind_MeshBuilder_AddUInt8Attribute_5 = function() {
        return (hn = w._emscripten_bind_MeshBuilder_AddUInt8Attribute_5 = w.asm.ga).apply(null, arguments);
      }, Yn = w._emscripten_bind_MeshBuilder_AddInt16Attribute_5 = function() {
        return (Yn = w._emscripten_bind_MeshBuilder_AddInt16Attribute_5 = w.asm.ha).apply(null, arguments);
      }, fi = w._emscripten_bind_MeshBuilder_AddUInt16Attribute_5 = function() {
        return (fi = w._emscripten_bind_MeshBuilder_AddUInt16Attribute_5 = w.asm.ia).apply(null, arguments);
      }, en = w._emscripten_bind_MeshBuilder_AddInt32Attribute_5 = function() {
        return (en = w._emscripten_bind_MeshBuilder_AddInt32Attribute_5 = w.asm.ja).apply(null, arguments);
      }, mn = w._emscripten_bind_MeshBuilder_AddUInt32Attribute_5 = function() {
        return (mn = w._emscripten_bind_MeshBuilder_AddUInt32Attribute_5 = w.asm.ka).apply(null, arguments);
      }, rn = w._emscripten_bind_MeshBuilder_AddMetadata_2 = function() {
        return (rn = w._emscripten_bind_MeshBuilder_AddMetadata_2 = w.asm.la).apply(null, arguments);
      }, He = w._emscripten_bind_MeshBuilder_SetMetadataForAttribute_3 = function() {
        return (He = w._emscripten_bind_MeshBuilder_SetMetadataForAttribute_3 = w.asm.ma).apply(null, arguments);
      }, Vn = w._emscripten_bind_MeshBuilder___destroy___0 = function() {
        return (Vn = w._emscripten_bind_MeshBuilder___destroy___0 = w.asm.na).apply(null, arguments);
      }, ti = w._emscripten_bind_Encoder_Encoder_0 = function() {
        return (ti = w._emscripten_bind_Encoder_Encoder_0 = w.asm.oa).apply(null, arguments);
      }, Ti = w._emscripten_bind_Encoder_SetEncodingMethod_1 = function() {
        return (Ti = w._emscripten_bind_Encoder_SetEncodingMethod_1 = w.asm.pa).apply(null, arguments);
      }, pr = w._emscripten_bind_Encoder_SetAttributeQuantization_2 = function() {
        return (pr = w._emscripten_bind_Encoder_SetAttributeQuantization_2 = w.asm.qa).apply(null, arguments);
      }, $r = w._emscripten_bind_Encoder_SetAttributeExplicitQuantization_5 = function() {
        return ($r = w._emscripten_bind_Encoder_SetAttributeExplicitQuantization_5 = w.asm.ra).apply(null, arguments);
      }, dr = w._emscripten_bind_Encoder_SetSpeedOptions_2 = function() {
        return (dr = w._emscripten_bind_Encoder_SetSpeedOptions_2 = w.asm.sa).apply(null, arguments);
      }, $i = w._emscripten_bind_Encoder_SetTrackEncodedProperties_1 = function() {
        return ($i = w._emscripten_bind_Encoder_SetTrackEncodedProperties_1 = w.asm.ta).apply(null, arguments);
      }, mr = w._emscripten_bind_Encoder_EncodeMeshToDracoBuffer_2 = function() {
        return (mr = w._emscripten_bind_Encoder_EncodeMeshToDracoBuffer_2 = w.asm.ua).apply(null, arguments);
      }, Xr = w._emscripten_bind_Encoder_EncodePointCloudToDracoBuffer_3 = function() {
        return (Xr = w._emscripten_bind_Encoder_EncodePointCloudToDracoBuffer_3 = w.asm.va).apply(null, arguments);
      }, Xi = w._emscripten_bind_Encoder_GetNumberOfEncodedPoints_0 = function() {
        return (Xi = w._emscripten_bind_Encoder_GetNumberOfEncodedPoints_0 = w.asm.wa).apply(null, arguments);
      }, Yr = w._emscripten_bind_Encoder_GetNumberOfEncodedFaces_0 = function() {
        return (Yr = w._emscripten_bind_Encoder_GetNumberOfEncodedFaces_0 = w.asm.xa).apply(null, arguments);
      }, Kr = w._emscripten_bind_Encoder___destroy___0 = function() {
        return (Kr = w._emscripten_bind_Encoder___destroy___0 = w.asm.ya).apply(null, arguments);
      }, Zr = w._emscripten_bind_ExpertEncoder_ExpertEncoder_1 = function() {
        return (Zr = w._emscripten_bind_ExpertEncoder_ExpertEncoder_1 = w.asm.za).apply(null, arguments);
      }, _r = w._emscripten_bind_ExpertEncoder_SetEncodingMethod_1 = function() {
        return (_r = w._emscripten_bind_ExpertEncoder_SetEncodingMethod_1 = w.asm.Aa).apply(null, arguments);
      }, Jr = w._emscripten_bind_ExpertEncoder_SetAttributeQuantization_2 = function() {
        return (Jr = w._emscripten_bind_ExpertEncoder_SetAttributeQuantization_2 = w.asm.Ba).apply(null, arguments);
      }, yr = w._emscripten_bind_ExpertEncoder_SetAttributeExplicitQuantization_5 = function() {
        return (yr = w._emscripten_bind_ExpertEncoder_SetAttributeExplicitQuantization_5 = w.asm.Ca).apply(null, arguments);
      }, Qr = w._emscripten_bind_ExpertEncoder_SetSpeedOptions_2 = function() {
        return (Qr = w._emscripten_bind_ExpertEncoder_SetSpeedOptions_2 = w.asm.Da).apply(null, arguments);
      }, ts = w._emscripten_bind_ExpertEncoder_SetTrackEncodedProperties_1 = function() {
        return (ts = w._emscripten_bind_ExpertEncoder_SetTrackEncodedProperties_1 = w.asm.Ea).apply(null, arguments);
      }, es = w._emscripten_bind_ExpertEncoder_EncodeToDracoBuffer_2 = function() {
        return (es = w._emscripten_bind_ExpertEncoder_EncodeToDracoBuffer_2 = w.asm.Fa).apply(null, arguments);
      }, hi = w._emscripten_bind_ExpertEncoder_GetNumberOfEncodedPoints_0 = function() {
        return (hi = w._emscripten_bind_ExpertEncoder_GetNumberOfEncodedPoints_0 = w.asm.Ga).apply(null, arguments);
      }, ns = w._emscripten_bind_ExpertEncoder_GetNumberOfEncodedFaces_0 = function() {
        return (ns = w._emscripten_bind_ExpertEncoder_GetNumberOfEncodedFaces_0 = w.asm.Ha).apply(null, arguments);
      }, is = w._emscripten_bind_ExpertEncoder___destroy___0 = function() {
        return (is = w._emscripten_bind_ExpertEncoder___destroy___0 = w.asm.Ia).apply(null, arguments);
      }, gr = w._emscripten_enum_draco_GeometryAttribute_Type_INVALID = function() {
        return (gr = w._emscripten_enum_draco_GeometryAttribute_Type_INVALID = w.asm.Ja).apply(null, arguments);
      }, vr = w._emscripten_enum_draco_GeometryAttribute_Type_POSITION = function() {
        return (vr = w._emscripten_enum_draco_GeometryAttribute_Type_POSITION = w.asm.Ka).apply(null, arguments);
      }, xr = w._emscripten_enum_draco_GeometryAttribute_Type_NORMAL = function() {
        return (xr = w._emscripten_enum_draco_GeometryAttribute_Type_NORMAL = w.asm.La).apply(null, arguments);
      }, rs = w._emscripten_enum_draco_GeometryAttribute_Type_COLOR = function() {
        return (rs = w._emscripten_enum_draco_GeometryAttribute_Type_COLOR = w.asm.Ma).apply(null, arguments);
      }, ss = w._emscripten_enum_draco_GeometryAttribute_Type_TEX_COORD = function() {
        return (ss = w._emscripten_enum_draco_GeometryAttribute_Type_TEX_COORD = w.asm.Na).apply(null, arguments);
      }, as = w._emscripten_enum_draco_GeometryAttribute_Type_GENERIC = function() {
        return (as = w._emscripten_enum_draco_GeometryAttribute_Type_GENERIC = w.asm.Oa).apply(null, arguments);
      }, os = w._emscripten_enum_draco_EncodedGeometryType_INVALID_GEOMETRY_TYPE = function() {
        return (os = w._emscripten_enum_draco_EncodedGeometryType_INVALID_GEOMETRY_TYPE = w.asm.Pa).apply(null, arguments);
      }, cs = w._emscripten_enum_draco_EncodedGeometryType_POINT_CLOUD = function() {
        return (cs = w._emscripten_enum_draco_EncodedGeometryType_POINT_CLOUD = w.asm.Qa).apply(null, arguments);
      }, us = w._emscripten_enum_draco_EncodedGeometryType_TRIANGULAR_MESH = function() {
        return (us = w._emscripten_enum_draco_EncodedGeometryType_TRIANGULAR_MESH = w.asm.Ra).apply(null, arguments);
      }, ls = w._emscripten_enum_draco_MeshEncoderMethod_MESH_SEQUENTIAL_ENCODING = function() {
        return (ls = w._emscripten_enum_draco_MeshEncoderMethod_MESH_SEQUENTIAL_ENCODING = w.asm.Sa).apply(null, arguments);
      }, br = w._emscripten_enum_draco_MeshEncoderMethod_MESH_EDGEBREAKER_ENCODING = function() {
        return (br = w._emscripten_enum_draco_MeshEncoderMethod_MESH_EDGEBREAKER_ENCODING = w.asm.Ta).apply(null, arguments);
      };
      w._malloc = function() {
        return (w._malloc = w.asm.Ua).apply(null, arguments);
      }, w._free = function() {
        return (w._free = w.asm.Va).apply(null, arguments);
      };
      var Ci = function() {
        return (Ci = w.asm.Wa).apply(null, arguments);
      };
      w.___start_em_js = 19116, w.___stop_em_js = 19214;
      var Yi;
      if (Tt = function at() {
        Yi || m(), Yi || (Tt = at);
      }, w.preInit)
        for (typeof w.preInit == "function" && (w.preInit = [w.preInit]); 0 < w.preInit.length; )
          w.preInit.pop()();
      m(), v.prototype = Object.create(v.prototype), v.prototype.constructor = v, v.prototype.__class__ = v, v.__cache__ = {}, w.WrapperObject = v, w.getCache = E, w.wrapPointer = _, w.castObject = function(at, xt) {
        return _(at.ptr, xt);
      }, w.NULL = _(0), w.destroy = function(at) {
        if (!at.__destroy__)
          throw "Error: Cannot destroy object. (Did you create it yourself?)";
        at.__destroy__(), delete E(at.__class__)[at.ptr];
      }, w.compare = function(at, xt) {
        return at.ptr === xt.ptr;
      }, w.getPointer = function(at) {
        return at.ptr;
      }, w.getClass = function(at) {
        return at.__class__;
      };
      var _e = { buffer: 0, size: 0, pos: 0, temps: [], needed: 0, prepare: function() {
        if (_e.needed) {
          for (var at = 0; at < _e.temps.length; at++)
            w._free(_e.temps[at]);
          _e.temps.length = 0, w._free(_e.buffer), _e.buffer = 0, _e.size += _e.needed, _e.needed = 0;
        }
        _e.buffer || (_e.size += 128, _e.buffer = w._malloc(_e.size), _e.buffer || c(void 0)), _e.pos = 0;
      }, alloc: function(at, xt) {
        return _e.buffer || c(void 0), at = at.length * xt.BYTES_PER_ELEMENT, at = at + 7 & -8, _e.pos + at >= _e.size ? (0 < at || c(void 0), _e.needed += at, xt = w._malloc(at), _e.temps.push(xt)) : (xt = _e.buffer + _e.pos, _e.pos += at), xt;
      }, copy: function(at, xt, Ot) {
        switch (Ot >>>= 0, xt.BYTES_PER_ELEMENT) {
          case 2:
            Ot >>>= 1;
            break;
          case 4:
            Ot >>>= 2;
            break;
          case 8:
            Ot >>>= 3;
        }
        for (var Bt = 0; Bt < at.length; Bt++)
          xt[Ot + Bt] = at[Bt];
      } };
      return C.prototype = Object.create(v.prototype), C.prototype.constructor = C, C.prototype.__class__ = C, C.__cache__ = {}, w.VoidPtr = C, C.prototype.__destroy__ = C.prototype.__destroy__ = function() {
        It(this.ptr);
      }, D.prototype = Object.create(v.prototype), D.prototype.constructor = D, D.prototype.__class__ = D, D.__cache__ = {}, w.GeometryAttribute = D, D.prototype.__destroy__ = D.prototype.__destroy__ = function() {
        ft(this.ptr);
      }, N.prototype = Object.create(v.prototype), N.prototype.constructor = N, N.prototype.__class__ = N, N.__cache__ = {}, w.PointAttribute = N, N.prototype.size = N.prototype.size = function() {
        return J(this.ptr);
      }, N.prototype.attribute_type = N.prototype.attribute_type = function() {
        return Rt(this.ptr);
      }, N.prototype.data_type = N.prototype.data_type = function() {
        return Nt(this.ptr);
      }, N.prototype.num_components = N.prototype.num_components = function() {
        return Yt(this.ptr);
      }, N.prototype.normalized = N.prototype.normalized = function() {
        return !!Ht(this.ptr);
      }, N.prototype.byte_stride = N.prototype.byte_stride = function() {
        return Pt(this.ptr);
      }, N.prototype.byte_offset = N.prototype.byte_offset = function() {
        return Mt(this.ptr);
      }, N.prototype.unique_id = N.prototype.unique_id = function() {
        return $t(this.ptr);
      }, N.prototype.__destroy__ = N.prototype.__destroy__ = function() {
        Kt(this.ptr);
      }, A.prototype = Object.create(v.prototype), A.prototype.constructor = A, A.prototype.__class__ = A, A.__cache__ = {}, w.PointCloud = A, A.prototype.num_attributes = A.prototype.num_attributes = function() {
        return Qt(this.ptr);
      }, A.prototype.num_points = A.prototype.num_points = function() {
        return ee(this.ptr);
      }, A.prototype.__destroy__ = A.prototype.__destroy__ = function() {
        Pe(this.ptr);
      }, I.prototype = Object.create(v.prototype), I.prototype.constructor = I, I.prototype.__class__ = I, I.__cache__ = {}, w.Mesh = I, I.prototype.num_faces = I.prototype.num_faces = function() {
        return Je(this.ptr);
      }, I.prototype.num_attributes = I.prototype.num_attributes = function() {
        return ve(this.ptr);
      }, I.prototype.num_points = I.prototype.num_points = function() {
        return tn(this.ptr);
      }, I.prototype.set_num_points = I.prototype.set_num_points = function(at) {
        var xt = this.ptr;
        at && typeof at == "object" && (at = at.ptr), dn(xt, at);
      }, I.prototype.__destroy__ = I.prototype.__destroy__ = function() {
        Qn(this.ptr);
      }, it.prototype = Object.create(v.prototype), it.prototype.constructor = it, it.prototype.__class__ = it, it.__cache__ = {}, w.Metadata = it, it.prototype.__destroy__ = it.prototype.__destroy__ = function() {
        Rn(this.ptr);
      }, V.prototype = Object.create(v.prototype), V.prototype.constructor = V, V.prototype.__class__ = V, V.__cache__ = {}, w.DracoInt8Array = V, V.prototype.GetValue = V.prototype.GetValue = function(at) {
        var xt = this.ptr;
        return at && typeof at == "object" && (at = at.ptr), ci(xt, at);
      }, V.prototype.size = V.prototype.size = function() {
        return Ai(this.ptr);
      }, V.prototype.__destroy__ = V.prototype.__destroy__ = function() {
        ui(this.ptr);
      }, mt.prototype = Object.create(v.prototype), mt.prototype.constructor = mt, mt.prototype.__class__ = mt, mt.__cache__ = {}, w.MetadataBuilder = mt, mt.prototype.AddStringEntry = mt.prototype.AddStringEntry = function(at, xt, Ot) {
        var Bt = this.ptr;
        return _e.prepare(), at && typeof at == "object" && (at = at.ptr), xt = xt && typeof xt == "object" ? xt.ptr : p(xt), Ot = Ot && typeof Ot == "object" ? Ot.ptr : p(Ot), !!Wi(Bt, at, xt, Ot);
      }, mt.prototype.AddIntEntry = mt.prototype.AddIntEntry = function(at, xt, Ot) {
        var Bt = this.ptr;
        return _e.prepare(), at && typeof at == "object" && (at = at.ptr), xt = xt && typeof xt == "object" ? xt.ptr : p(xt), Ot && typeof Ot == "object" && (Ot = Ot.ptr), !!qi(Bt, at, xt, Ot);
      }, mt.prototype.AddIntEntryArray = mt.prototype.AddIntEntryArray = function(at, xt, Ot, Bt) {
        var Zt = this.ptr;
        return _e.prepare(), at && typeof at == "object" && (at = at.ptr), xt = xt && typeof xt == "object" ? xt.ptr : p(xt), typeof Ot == "object" && (Ot = P(Ot)), Bt && typeof Bt == "object" && (Bt = Bt.ptr), !!St(Zt, at, xt, Ot, Bt);
      }, mt.prototype.AddDoubleEntry = mt.prototype.AddDoubleEntry = function(at, xt, Ot) {
        var Bt = this.ptr;
        return _e.prepare(), at && typeof at == "object" && (at = at.ptr), xt = xt && typeof xt == "object" ? xt.ptr : p(xt), Ot && typeof Ot == "object" && (Ot = Ot.ptr), !!kt(Bt, at, xt, Ot);
      }, mt.prototype.__destroy__ = mt.prototype.__destroy__ = function() {
        qt(this.ptr);
      }, k.prototype = Object.create(v.prototype), k.prototype.constructor = k, k.prototype.__class__ = k, k.__cache__ = {}, w.PointCloudBuilder = k, k.prototype.AddFloatAttribute = k.prototype.AddFloatAttribute = function(at, xt, Ot, Bt, Zt) {
        var pe = this.ptr;
        return _e.prepare(), at && typeof at == "object" && (at = at.ptr), xt && typeof xt == "object" && (xt = xt.ptr), Ot && typeof Ot == "object" && (Ot = Ot.ptr), Bt && typeof Bt == "object" && (Bt = Bt.ptr), typeof Zt == "object" && (Zt = W(Zt)), jt(pe, at, xt, Ot, Bt, Zt);
      }, k.prototype.AddInt8Attribute = k.prototype.AddInt8Attribute = function(at, xt, Ot, Bt, Zt) {
        var pe = this.ptr;
        return _e.prepare(), at && typeof at == "object" && (at = at.ptr), xt && typeof xt == "object" && (xt = xt.ptr), Ot && typeof Ot == "object" && (Ot = Ot.ptr), Bt && typeof Bt == "object" && (Bt = Bt.ptr), typeof Zt == "object" && (Zt = R(Zt)), le(pe, at, xt, Ot, Bt, Zt);
      }, k.prototype.AddUInt8Attribute = k.prototype.AddUInt8Attribute = function(at, xt, Ot, Bt, Zt) {
        var pe = this.ptr;
        return _e.prepare(), at && typeof at == "object" && (at = at.ptr), xt && typeof xt == "object" && (xt = xt.ptr), Ot && typeof Ot == "object" && (Ot = Ot.ptr), Bt && typeof Bt == "object" && (Bt = Bt.ptr), typeof Zt == "object" && (Zt = R(Zt)), me(pe, at, xt, Ot, Bt, Zt);
      }, k.prototype.AddInt16Attribute = k.prototype.AddInt16Attribute = function(at, xt, Ot, Bt, Zt) {
        var pe = this.ptr;
        return _e.prepare(), at && typeof at == "object" && (at = at.ptr), xt && typeof xt == "object" && (xt = xt.ptr), Ot && typeof Ot == "object" && (Ot = Ot.ptr), Bt && typeof Bt == "object" && (Bt = Bt.ptr), typeof Zt == "object" && (Zt = M(Zt)), ye(pe, at, xt, Ot, Bt, Zt);
      }, k.prototype.AddUInt16Attribute = k.prototype.AddUInt16Attribute = function(at, xt, Ot, Bt, Zt) {
        var pe = this.ptr;
        return _e.prepare(), at && typeof at == "object" && (at = at.ptr), xt && typeof xt == "object" && (xt = xt.ptr), Ot && typeof Ot == "object" && (Ot = Ot.ptr), Bt && typeof Bt == "object" && (Bt = Bt.ptr), typeof Zt == "object" && (Zt = M(Zt)), xe(pe, at, xt, Ot, Bt, Zt);
      }, k.prototype.AddInt32Attribute = k.prototype.AddInt32Attribute = function(at, xt, Ot, Bt, Zt) {
        var pe = this.ptr;
        return _e.prepare(), at && typeof at == "object" && (at = at.ptr), xt && typeof xt == "object" && (xt = xt.ptr), Ot && typeof Ot == "object" && (Ot = Ot.ptr), Bt && typeof Bt == "object" && (Bt = Bt.ptr), typeof Zt == "object" && (Zt = P(Zt)), Te(
          pe,
          at,
          xt,
          Ot,
          Bt,
          Zt
        );
      }, k.prototype.AddUInt32Attribute = k.prototype.AddUInt32Attribute = function(at, xt, Ot, Bt, Zt) {
        var pe = this.ptr;
        return _e.prepare(), at && typeof at == "object" && (at = at.ptr), xt && typeof xt == "object" && (xt = xt.ptr), Ot && typeof Ot == "object" && (Ot = Ot.ptr), Bt && typeof Bt == "object" && (Bt = Bt.ptr), typeof Zt == "object" && (Zt = P(Zt)), Ee(pe, at, xt, Ot, Bt, Zt);
      }, k.prototype.AddMetadata = k.prototype.AddMetadata = function(at, xt) {
        var Ot = this.ptr;
        return at && typeof at == "object" && (at = at.ptr), xt && typeof xt == "object" && (xt = xt.ptr), !!we(Ot, at, xt);
      }, k.prototype.SetMetadataForAttribute = k.prototype.SetMetadataForAttribute = function(at, xt, Ot) {
        var Bt = this.ptr;
        return at && typeof at == "object" && (at = at.ptr), xt && typeof xt == "object" && (xt = xt.ptr), Ot && typeof Ot == "object" && (Ot = Ot.ptr), !!We(Bt, at, xt, Ot);
      }, k.prototype.__destroy__ = k.prototype.__destroy__ = function() {
        fn(this.ptr);
      }, B.prototype = Object.create(v.prototype), B.prototype.constructor = B, B.prototype.__class__ = B, B.__cache__ = {}, w.MeshBuilder = B, B.prototype.AddFacesToMesh = B.prototype.AddFacesToMesh = function(at, xt, Ot) {
        var Bt = this.ptr;
        return _e.prepare(), at && typeof at == "object" && (at = at.ptr), xt && typeof xt == "object" && (xt = xt.ptr), typeof Ot == "object" && (Ot = P(Ot)), !!wn(Bt, at, xt, Ot);
      }, B.prototype.AddFloatAttributeToMesh = B.prototype.AddFloatAttributeToMesh = function(at, xt, Ot, Bt, Zt) {
        var pe = this.ptr;
        return _e.prepare(), at && typeof at == "object" && (at = at.ptr), xt && typeof xt == "object" && (xt = xt.ptr), Ot && typeof Ot == "object" && (Ot = Ot.ptr), Bt && typeof Bt == "object" && (Bt = Bt.ptr), typeof Zt == "object" && (Zt = W(Zt)), Ve(pe, at, xt, Ot, Bt, Zt);
      }, B.prototype.AddInt32AttributeToMesh = B.prototype.AddInt32AttributeToMesh = function(at, xt, Ot, Bt, Zt) {
        var pe = this.ptr;
        return _e.prepare(), at && typeof at == "object" && (at = at.ptr), xt && typeof xt == "object" && (xt = xt.ptr), Ot && typeof Ot == "object" && (Ot = Ot.ptr), Bt && typeof Bt == "object" && (Bt = Bt.ptr), typeof Zt == "object" && (Zt = P(Zt)), Ae(pe, at, xt, Ot, Bt, Zt);
      }, B.prototype.AddMetadataToMesh = B.prototype.AddMetadataToMesh = function(at, xt) {
        var Ot = this.ptr;
        return at && typeof at == "object" && (at = at.ptr), xt && typeof xt == "object" && (xt = xt.ptr), !!li(Ot, at, xt);
      }, B.prototype.AddFloatAttribute = B.prototype.AddFloatAttribute = function(at, xt, Ot, Bt, Zt) {
        var pe = this.ptr;
        return _e.prepare(), at && typeof at == "object" && (at = at.ptr), xt && typeof xt == "object" && (xt = xt.ptr), Ot && typeof Ot == "object" && (Ot = Ot.ptr), Bt && typeof Bt == "object" && (Bt = Bt.ptr), typeof Zt == "object" && (Zt = W(Zt)), ze(pe, at, xt, Ot, Bt, Zt);
      }, B.prototype.AddInt8Attribute = B.prototype.AddInt8Attribute = function(at, xt, Ot, Bt, Zt) {
        var pe = this.ptr;
        return _e.prepare(), at && typeof at == "object" && (at = at.ptr), xt && typeof xt == "object" && (xt = xt.ptr), Ot && typeof Ot == "object" && (Ot = Ot.ptr), Bt && typeof Bt == "object" && (Bt = Bt.ptr), typeof Zt == "object" && (Zt = R(Zt)), On(pe, at, xt, Ot, Bt, Zt);
      }, B.prototype.AddUInt8Attribute = B.prototype.AddUInt8Attribute = function(at, xt, Ot, Bt, Zt) {
        var pe = this.ptr;
        return _e.prepare(), at && typeof at == "object" && (at = at.ptr), xt && typeof xt == "object" && (xt = xt.ptr), Ot && typeof Ot == "object" && (Ot = Ot.ptr), Bt && typeof Bt == "object" && (Bt = Bt.ptr), typeof Zt == "object" && (Zt = R(Zt)), hn(pe, at, xt, Ot, Bt, Zt);
      }, B.prototype.AddInt16Attribute = B.prototype.AddInt16Attribute = function(at, xt, Ot, Bt, Zt) {
        var pe = this.ptr;
        return _e.prepare(), at && typeof at == "object" && (at = at.ptr), xt && typeof xt == "object" && (xt = xt.ptr), Ot && typeof Ot == "object" && (Ot = Ot.ptr), Bt && typeof Bt == "object" && (Bt = Bt.ptr), typeof Zt == "object" && (Zt = M(Zt)), Yn(pe, at, xt, Ot, Bt, Zt);
      }, B.prototype.AddUInt16Attribute = B.prototype.AddUInt16Attribute = function(at, xt, Ot, Bt, Zt) {
        var pe = this.ptr;
        return _e.prepare(), at && typeof at == "object" && (at = at.ptr), xt && typeof xt == "object" && (xt = xt.ptr), Ot && typeof Ot == "object" && (Ot = Ot.ptr), Bt && typeof Bt == "object" && (Bt = Bt.ptr), typeof Zt == "object" && (Zt = M(Zt)), fi(pe, at, xt, Ot, Bt, Zt);
      }, B.prototype.AddInt32Attribute = B.prototype.AddInt32Attribute = function(at, xt, Ot, Bt, Zt) {
        var pe = this.ptr;
        return _e.prepare(), at && typeof at == "object" && (at = at.ptr), xt && typeof xt == "object" && (xt = xt.ptr), Ot && typeof Ot == "object" && (Ot = Ot.ptr), Bt && typeof Bt == "object" && (Bt = Bt.ptr), typeof Zt == "object" && (Zt = P(Zt)), en(pe, at, xt, Ot, Bt, Zt);
      }, B.prototype.AddUInt32Attribute = B.prototype.AddUInt32Attribute = function(at, xt, Ot, Bt, Zt) {
        var pe = this.ptr;
        return _e.prepare(), at && typeof at == "object" && (at = at.ptr), xt && typeof xt == "object" && (xt = xt.ptr), Ot && typeof Ot == "object" && (Ot = Ot.ptr), Bt && typeof Bt == "object" && (Bt = Bt.ptr), typeof Zt == "object" && (Zt = P(Zt)), mn(pe, at, xt, Ot, Bt, Zt);
      }, B.prototype.AddMetadata = B.prototype.AddMetadata = function(at, xt) {
        var Ot = this.ptr;
        return at && typeof at == "object" && (at = at.ptr), xt && typeof xt == "object" && (xt = xt.ptr), !!rn(Ot, at, xt);
      }, B.prototype.SetMetadataForAttribute = B.prototype.SetMetadataForAttribute = function(at, xt, Ot) {
        var Bt = this.ptr;
        return at && typeof at == "object" && (at = at.ptr), xt && typeof xt == "object" && (xt = xt.ptr), Ot && typeof Ot == "object" && (Ot = Ot.ptr), !!He(Bt, at, xt, Ot);
      }, B.prototype.__destroy__ = B.prototype.__destroy__ = function() {
        Vn(this.ptr);
      }, G.prototype = Object.create(v.prototype), G.prototype.constructor = G, G.prototype.__class__ = G, G.__cache__ = {}, w.Encoder = G, G.prototype.SetEncodingMethod = G.prototype.SetEncodingMethod = function(at) {
        var xt = this.ptr;
        at && typeof at == "object" && (at = at.ptr), Ti(xt, at);
      }, G.prototype.SetAttributeQuantization = G.prototype.SetAttributeQuantization = function(at, xt) {
        var Ot = this.ptr;
        at && typeof at == "object" && (at = at.ptr), xt && typeof xt == "object" && (xt = xt.ptr), pr(Ot, at, xt);
      }, G.prototype.SetAttributeExplicitQuantization = G.prototype.SetAttributeExplicitQuantization = function(at, xt, Ot, Bt, Zt) {
        var pe = this.ptr;
        _e.prepare(), at && typeof at == "object" && (at = at.ptr), xt && typeof xt == "object" && (xt = xt.ptr), Ot && typeof Ot == "object" && (Ot = Ot.ptr), typeof Bt == "object" && (Bt = W(Bt)), Zt && typeof Zt == "object" && (Zt = Zt.ptr), $r(pe, at, xt, Ot, Bt, Zt);
      }, G.prototype.SetSpeedOptions = G.prototype.SetSpeedOptions = function(at, xt) {
        var Ot = this.ptr;
        at && typeof at == "object" && (at = at.ptr), xt && typeof xt == "object" && (xt = xt.ptr), dr(Ot, at, xt);
      }, G.prototype.SetTrackEncodedProperties = G.prototype.SetTrackEncodedProperties = function(at) {
        var xt = this.ptr;
        at && typeof at == "object" && (at = at.ptr), $i(xt, at);
      }, G.prototype.EncodeMeshToDracoBuffer = G.prototype.EncodeMeshToDracoBuffer = function(at, xt) {
        var Ot = this.ptr;
        return at && typeof at == "object" && (at = at.ptr), xt && typeof xt == "object" && (xt = xt.ptr), mr(Ot, at, xt);
      }, G.prototype.EncodePointCloudToDracoBuffer = G.prototype.EncodePointCloudToDracoBuffer = function(at, xt, Ot) {
        var Bt = this.ptr;
        return at && typeof at == "object" && (at = at.ptr), xt && typeof xt == "object" && (xt = xt.ptr), Ot && typeof Ot == "object" && (Ot = Ot.ptr), Xr(Bt, at, xt, Ot);
      }, G.prototype.GetNumberOfEncodedPoints = G.prototype.GetNumberOfEncodedPoints = function() {
        return Xi(this.ptr);
      }, G.prototype.GetNumberOfEncodedFaces = G.prototype.GetNumberOfEncodedFaces = function() {
        return Yr(this.ptr);
      }, G.prototype.__destroy__ = G.prototype.__destroy__ = function() {
        Kr(this.ptr);
      }, H.prototype = Object.create(v.prototype), H.prototype.constructor = H, H.prototype.__class__ = H, H.__cache__ = {}, w.ExpertEncoder = H, H.prototype.SetEncodingMethod = H.prototype.SetEncodingMethod = function(at) {
        var xt = this.ptr;
        at && typeof at == "object" && (at = at.ptr), _r(xt, at);
      }, H.prototype.SetAttributeQuantization = H.prototype.SetAttributeQuantization = function(at, xt) {
        var Ot = this.ptr;
        at && typeof at == "object" && (at = at.ptr), xt && typeof xt == "object" && (xt = xt.ptr), Jr(Ot, at, xt);
      }, H.prototype.SetAttributeExplicitQuantization = H.prototype.SetAttributeExplicitQuantization = function(at, xt, Ot, Bt, Zt) {
        var pe = this.ptr;
        _e.prepare(), at && typeof at == "object" && (at = at.ptr), xt && typeof xt == "object" && (xt = xt.ptr), Ot && typeof Ot == "object" && (Ot = Ot.ptr), typeof Bt == "object" && (Bt = W(Bt)), Zt && typeof Zt == "object" && (Zt = Zt.ptr), yr(pe, at, xt, Ot, Bt, Zt);
      }, H.prototype.SetSpeedOptions = H.prototype.SetSpeedOptions = function(at, xt) {
        var Ot = this.ptr;
        at && typeof at == "object" && (at = at.ptr), xt && typeof xt == "object" && (xt = xt.ptr), Qr(Ot, at, xt);
      }, H.prototype.SetTrackEncodedProperties = H.prototype.SetTrackEncodedProperties = function(at) {
        var xt = this.ptr;
        at && typeof at == "object" && (at = at.ptr), ts(xt, at);
      }, H.prototype.EncodeToDracoBuffer = H.prototype.EncodeToDracoBuffer = function(at, xt) {
        var Ot = this.ptr;
        return at && typeof at == "object" && (at = at.ptr), xt && typeof xt == "object" && (xt = xt.ptr), es(Ot, at, xt);
      }, H.prototype.GetNumberOfEncodedPoints = H.prototype.GetNumberOfEncodedPoints = function() {
        return hi(this.ptr);
      }, H.prototype.GetNumberOfEncodedFaces = H.prototype.GetNumberOfEncodedFaces = function() {
        return ns(this.ptr);
      }, H.prototype.__destroy__ = H.prototype.__destroy__ = function() {
        is(this.ptr);
      }, function() {
        function at() {
          w.INVALID = gr(), w.POSITION = vr(), w.NORMAL = xr(), w.COLOR = rs(), w.TEX_COORD = ss(), w.GENERIC = as(), w.INVALID_GEOMETRY_TYPE = os(), w.POINT_CLOUD = cs(), w.TRIANGULAR_MESH = us(), w.MESH_SEQUENTIAL_ENCODING = ls(), w.MESH_EDGEBREAKER_ENCODING = br();
        }
        gt ? at() : Z.unshift(at);
      }(), typeof w.onModuleParsed == "function" && w.onModuleParsed(), s.ready;
    };
  }();
  n.exports = i;
})(p_);
var V3 = p_.exports, d_ = { exports: {} };
(function(n, t) {
  var e = e || {};
  e.scope = {}, e.arrayIteratorImpl = function(r) {
    var s = 0;
    return function() {
      return s < r.length ? { done: !1, value: r[s++] } : { done: !0 };
    };
  }, e.arrayIterator = function(r) {
    return { next: e.arrayIteratorImpl(r) };
  }, e.makeIterator = function(r) {
    var s = typeof Symbol < "u" && Symbol.iterator && r[Symbol.iterator];
    return s ? s.call(r) : e.arrayIterator(r);
  }, e.ASSUME_ES5 = !1, e.ASSUME_NO_NATIVE_MAP = !1, e.ASSUME_NO_NATIVE_SET = !1, e.SIMPLE_FROUND_POLYFILL = !1, e.ISOLATE_POLYFILLS = !1, e.FORCE_POLYFILL_PROMISE = !1, e.FORCE_POLYFILL_PROMISE_WHEN_NO_UNHANDLED_REJECTION = !1, e.getGlobal = function(r) {
    r = [typeof globalThis == "object" && globalThis, r, typeof window == "object" && window, typeof self == "object" && self, typeof cn == "object" && cn];
    for (var s = 0; s < r.length; ++s) {
      var a = r[s];
      if (a && a.Math == Math)
        return a;
    }
    throw Error("Cannot find global object");
  }, e.global = e.getGlobal(cn), e.defineProperty = e.ASSUME_ES5 || typeof Object.defineProperties == "function" ? Object.defineProperty : function(r, s, a) {
    return r == Array.prototype || r == Object.prototype || (r[s] = a.value), r;
  }, e.IS_SYMBOL_NATIVE = typeof Symbol == "function" && typeof Symbol("x") == "symbol", e.TRUST_ES6_POLYFILLS = !e.ISOLATE_POLYFILLS || e.IS_SYMBOL_NATIVE, e.polyfills = {}, e.propertyToPolyfillSymbol = {}, e.POLYFILL_PREFIX = "$jscp$", e.polyfill = function(r, s, a, o) {
    s && (e.ISOLATE_POLYFILLS ? e.polyfillIsolated(r, s, a, o) : e.polyfillUnisolated(r, s, a, o));
  }, e.polyfillUnisolated = function(r, s, a, o) {
    for (a = e.global, r = r.split("."), o = 0; o < r.length - 1; o++) {
      var c = r[o];
      if (!(c in a))
        return;
      a = a[c];
    }
    r = r[r.length - 1], o = a[r], s = s(o), s != o && s != null && e.defineProperty(a, r, { configurable: !0, writable: !0, value: s });
  }, e.polyfillIsolated = function(r, s, a, o) {
    var c = r.split(".");
    r = c.length === 1, o = c[0], o = !r && o in e.polyfills ? e.polyfills : e.global;
    for (var h = 0; h < c.length - 1; h++) {
      var l = c[h];
      if (!(l in o))
        return;
      o = o[l];
    }
    c = c[c.length - 1], a = e.IS_SYMBOL_NATIVE && a === "es6" ? o[c] : null, s = s(a), s != null && (r ? e.defineProperty(e.polyfills, c, { configurable: !0, writable: !0, value: s }) : s !== a && (e.propertyToPolyfillSymbol[c] === void 0 && (a = 1e9 * Math.random() >>> 0, e.propertyToPolyfillSymbol[c] = e.IS_SYMBOL_NATIVE ? e.global.Symbol(c) : e.POLYFILL_PREFIX + a + "$" + c), e.defineProperty(o, e.propertyToPolyfillSymbol[c], { configurable: !0, writable: !0, value: s })));
  }, e.polyfill("Promise", function(r) {
    function s() {
      this.batch_ = null;
    }
    function a(l) {
      return l instanceof c ? l : new c(function(f, d) {
        f(l);
      });
    }
    if (r && (!(e.FORCE_POLYFILL_PROMISE || e.FORCE_POLYFILL_PROMISE_WHEN_NO_UNHANDLED_REJECTION && typeof e.global.PromiseRejectionEvent > "u") || !e.global.Promise || e.global.Promise.toString().indexOf("[native code]") === -1))
      return r;
    s.prototype.asyncExecute = function(l) {
      if (this.batch_ == null) {
        this.batch_ = [];
        var f = this;
        this.asyncExecuteFunction(function() {
          f.executeBatch_();
        });
      }
      this.batch_.push(l);
    };
    var o = e.global.setTimeout;
    s.prototype.asyncExecuteFunction = function(l) {
      o(l, 0);
    }, s.prototype.executeBatch_ = function() {
      for (; this.batch_ && this.batch_.length; ) {
        var l = this.batch_;
        this.batch_ = [];
        for (var f = 0; f < l.length; ++f) {
          var d = l[f];
          l[f] = null;
          try {
            d();
          } catch (m) {
            this.asyncThrow_(m);
          }
        }
      }
      this.batch_ = null;
    }, s.prototype.asyncThrow_ = function(l) {
      this.asyncExecuteFunction(function() {
        throw l;
      });
    };
    var c = function(l) {
      this.state_ = 0, this.result_ = void 0, this.onSettledCallbacks_ = [], this.isRejectionHandled_ = !1;
      var f = this.createResolveAndReject_();
      try {
        l(f.resolve, f.reject);
      } catch (d) {
        f.reject(d);
      }
    };
    c.prototype.createResolveAndReject_ = function() {
      function l(m) {
        return function(v) {
          d || (d = !0, m.call(f, v));
        };
      }
      var f = this, d = !1;
      return { resolve: l(this.resolveTo_), reject: l(this.reject_) };
    }, c.prototype.resolveTo_ = function(l) {
      if (l === this)
        this.reject_(new TypeError("A Promise cannot resolve to itself"));
      else if (l instanceof c)
        this.settleSameAsPromise_(l);
      else {
        t:
          switch (typeof l) {
            case "object":
              var f = l != null;
              break t;
            case "function":
              f = !0;
              break t;
            default:
              f = !1;
          }
        f ? this.resolveToNonPromiseObj_(l) : this.fulfill_(l);
      }
    }, c.prototype.resolveToNonPromiseObj_ = function(l) {
      var f = void 0;
      try {
        f = l.then;
      } catch (d) {
        this.reject_(d);
        return;
      }
      typeof f == "function" ? this.settleSameAsThenable_(f, l) : this.fulfill_(l);
    }, c.prototype.reject_ = function(l) {
      this.settle_(2, l);
    }, c.prototype.fulfill_ = function(l) {
      this.settle_(1, l);
    }, c.prototype.settle_ = function(l, f) {
      if (this.state_ != 0)
        throw Error("Cannot settle(" + l + ", " + f + "): Promise already settled in state" + this.state_);
      this.state_ = l, this.result_ = f, this.state_ === 2 && this.scheduleUnhandledRejectionCheck_(), this.executeOnSettledCallbacks_();
    }, c.prototype.scheduleUnhandledRejectionCheck_ = function() {
      var l = this;
      o(function() {
        if (l.notifyUnhandledRejection_()) {
          var f = e.global.console;
          typeof f < "u" && f.error(l.result_);
        }
      }, 1);
    }, c.prototype.notifyUnhandledRejection_ = function() {
      if (this.isRejectionHandled_)
        return !1;
      var l = e.global.CustomEvent, f = e.global.Event, d = e.global.dispatchEvent;
      return typeof d > "u" ? !0 : (typeof l == "function" ? l = new l("unhandledrejection", { cancelable: !0 }) : typeof f == "function" ? l = new f("unhandledrejection", { cancelable: !0 }) : (l = e.global.document.createEvent("CustomEvent"), l.initCustomEvent("unhandledrejection", !1, !0, l)), l.promise = this, l.reason = this.result_, d(l));
    }, c.prototype.executeOnSettledCallbacks_ = function() {
      if (this.onSettledCallbacks_ != null) {
        for (var l = 0; l < this.onSettledCallbacks_.length; ++l)
          h.asyncExecute(this.onSettledCallbacks_[l]);
        this.onSettledCallbacks_ = null;
      }
    };
    var h = new s();
    return c.prototype.settleSameAsPromise_ = function(l) {
      var f = this.createResolveAndReject_();
      l.callWhenSettled_(f.resolve, f.reject);
    }, c.prototype.settleSameAsThenable_ = function(l, f) {
      var d = this.createResolveAndReject_();
      try {
        l.call(f, d.resolve, d.reject);
      } catch (m) {
        d.reject(m);
      }
    }, c.prototype.then = function(l, f) {
      function d(_, p) {
        return typeof _ == "function" ? function(R) {
          try {
            m(_(R));
          } catch (M) {
            v(M);
          }
        } : p;
      }
      var m, v, E = new c(function(_, p) {
        m = _, v = p;
      });
      return this.callWhenSettled_(d(l, m), d(f, v)), E;
    }, c.prototype.catch = function(l) {
      return this.then(void 0, l);
    }, c.prototype.callWhenSettled_ = function(l, f) {
      function d() {
        switch (m.state_) {
          case 1:
            l(m.result_);
            break;
          case 2:
            f(m.result_);
            break;
          default:
            throw Error("Unexpected state: " + m.state_);
        }
      }
      var m = this;
      this.onSettledCallbacks_ == null ? h.asyncExecute(d) : this.onSettledCallbacks_.push(d), this.isRejectionHandled_ = !0;
    }, c.resolve = a, c.reject = function(l) {
      return new c(function(f, d) {
        d(l);
      });
    }, c.race = function(l) {
      return new c(function(f, d) {
        for (var m = e.makeIterator(l), v = m.next(); !v.done; v = m.next())
          a(v.value).callWhenSettled_(f, d);
      });
    }, c.all = function(l) {
      var f = e.makeIterator(l), d = f.next();
      return d.done ? a([]) : new c(function(m, v) {
        function E(R) {
          return function(M) {
            _[R] = M, p--, p == 0 && m(_);
          };
        }
        var _ = [], p = 0;
        do
          _.push(void 0), p++, a(d.value).callWhenSettled_(E(_.length - 1), v), d = f.next();
        while (!d.done);
      });
    }, c;
  }, "es6", "es3"), e.owns = function(r, s) {
    return Object.prototype.hasOwnProperty.call(r, s);
  }, e.assign = e.TRUST_ES6_POLYFILLS && typeof Object.assign == "function" ? Object.assign : function(r, s) {
    for (var a = 1; a < arguments.length; a++) {
      var o = arguments[a];
      if (o)
        for (var c in o)
          e.owns(o, c) && (r[c] = o[c]);
    }
    return r;
  }, e.polyfill("Object.assign", function(r) {
    return r || e.assign;
  }, "es6", "es3"), e.checkStringArgs = function(r, s, a) {
    if (r == null)
      throw new TypeError("The 'this' value for String.prototype." + a + " must not be null or undefined");
    if (s instanceof RegExp)
      throw new TypeError("First argument to String.prototype." + a + " must not be a regular expression");
    return r + "";
  }, e.polyfill("String.prototype.startsWith", function(r) {
    return r || function(s, a) {
      var o = e.checkStringArgs(this, s, "startsWith");
      s += "";
      var c = o.length, h = s.length;
      a = Math.max(0, Math.min(a | 0, o.length));
      for (var l = 0; l < h && a < c; )
        if (o[a++] != s[l++])
          return !1;
      return l >= h;
    };
  }, "es6", "es3"), e.polyfill("Array.prototype.copyWithin", function(r) {
    function s(a) {
      return a = Number(a), a === 1 / 0 || a === -1 / 0 ? a : a | 0;
    }
    return r || function(a, o, c) {
      var h = this.length;
      if (a = s(a), o = s(o), c = c === void 0 ? h : s(c), a = 0 > a ? Math.max(h + a, 0) : Math.min(a, h), o = 0 > o ? Math.max(h + o, 0) : Math.min(o, h), c = 0 > c ? Math.max(h + c, 0) : Math.min(c, h), a < o)
        for (; o < c; )
          o in this ? this[a++] = this[o++] : (delete this[a++], o++);
      else
        for (c = Math.min(c, h + o - a), a += c - o; c > o; )
          --c in this ? this[--a] = this[c] : delete this[--a];
      return this;
    };
  }, "es6", "es3"), e.typedArrayCopyWithin = function(r) {
    return r || Array.prototype.copyWithin;
  }, e.polyfill("Int8Array.prototype.copyWithin", e.typedArrayCopyWithin, "es6", "es5"), e.polyfill("Uint8Array.prototype.copyWithin", e.typedArrayCopyWithin, "es6", "es5"), e.polyfill("Uint8ClampedArray.prototype.copyWithin", e.typedArrayCopyWithin, "es6", "es5"), e.polyfill("Int16Array.prototype.copyWithin", e.typedArrayCopyWithin, "es6", "es5"), e.polyfill("Uint16Array.prototype.copyWithin", e.typedArrayCopyWithin, "es6", "es5"), e.polyfill("Int32Array.prototype.copyWithin", e.typedArrayCopyWithin, "es6", "es5"), e.polyfill("Uint32Array.prototype.copyWithin", e.typedArrayCopyWithin, "es6", "es5"), e.polyfill("Float32Array.prototype.copyWithin", e.typedArrayCopyWithin, "es6", "es5"), e.polyfill("Float64Array.prototype.copyWithin", e.typedArrayCopyWithin, "es6", "es5");
  var i = function() {
    var r = typeof document < "u" && document.currentScript ? document.currentScript.src : void 0;
    return typeof __filename < "u" && (r = r || __filename), function(s) {
      function a(et) {
        return b.locateFile ? b.locateFile(et, Et) : Et + et;
      }
      function o(et, bt, Ut) {
        var re = bt + Ut;
        for (Ut = bt; et[Ut] && !(Ut >= re); )
          ++Ut;
        if (16 < Ut - bt && et.buffer && tt)
          return tt.decode(et.subarray(bt, Ut));
        for (re = ""; bt < Ut; ) {
          var Me = et[bt++];
          if (Me & 128) {
            var be = et[bt++] & 63;
            if ((Me & 224) == 192)
              re += String.fromCharCode((Me & 31) << 6 | be);
            else {
              var ei = et[bt++] & 63;
              Me = (Me & 240) == 224 ? (Me & 15) << 12 | be << 6 | ei : (Me & 7) << 18 | be << 12 | ei << 6 | et[bt++] & 63, 65536 > Me ? re += String.fromCharCode(Me) : (Me -= 65536, re += String.fromCharCode(55296 | Me >> 10, 56320 | Me & 1023));
            }
          } else
            re += String.fromCharCode(Me);
        }
        return re;
      }
      function c(et, bt) {
        return et ? o(st, et, bt) : "";
      }
      function h() {
        var et = O.buffer;
        b.HEAP8 = gt = new Int8Array(et), b.HEAP16 = new Int16Array(et), b.HEAP32 = Tt = new Int32Array(et), b.HEAPU8 = st = new Uint8Array(et), b.HEAPU16 = new Uint16Array(et), b.HEAPU32 = Ft = new Uint32Array(et), b.HEAPF32 = new Float32Array(et), b.HEAPF64 = new Float64Array(et);
      }
      function l(et) {
        throw b.onAbort && b.onAbort(et), et = "Aborted(" + et + ")", g(et), Z = !0, et = new WebAssembly.RuntimeError(et + ". Build with -sASSERTIONS for more info."), q(et), et;
      }
      function f(et) {
        try {
          if (et == Rt && S)
            return new Uint8Array(S);
          if (wt)
            return wt(et);
          throw "both async and sync fetching of the wasm failed";
        } catch (bt) {
          l(bt);
        }
      }
      function d() {
        if (!S && (Y || K)) {
          if (typeof fetch == "function" && !Rt.startsWith("file://"))
            return fetch(Rt, { credentials: "same-origin" }).then(function(et) {
              if (!et.ok)
                throw "failed to load wasm binary file at '" + Rt + "'";
              return et.arrayBuffer();
            }).catch(function() {
              return f(Rt);
            });
          if (Q)
            return new Promise(function(et, bt) {
              Q(Rt, function(Ut) {
                et(new Uint8Array(Ut));
              }, bt);
            });
        }
        return Promise.resolve().then(function() {
          return f(Rt);
        });
      }
      function m(et) {
        for (; 0 < et.length; )
          et.shift()(b);
      }
      function v(et) {
        this.excPtr = et, this.ptr = et - 24, this.set_type = function(bt) {
          Ft[this.ptr + 4 >> 2] = bt;
        }, this.get_type = function() {
          return Ft[this.ptr + 4 >> 2];
        }, this.set_destructor = function(bt) {
          Ft[this.ptr + 8 >> 2] = bt;
        }, this.get_destructor = function() {
          return Ft[this.ptr + 8 >> 2];
        }, this.set_refcount = function(bt) {
          Tt[this.ptr >> 2] = bt;
        }, this.set_caught = function(bt) {
          gt[this.ptr + 12 >> 0] = bt ? 1 : 0;
        }, this.get_caught = function() {
          return gt[this.ptr + 12 >> 0] != 0;
        }, this.set_rethrown = function(bt) {
          gt[this.ptr + 13 >> 0] = bt ? 1 : 0;
        }, this.get_rethrown = function() {
          return gt[this.ptr + 13 >> 0] != 0;
        }, this.init = function(bt, Ut) {
          this.set_adjusted_ptr(0), this.set_type(bt), this.set_destructor(Ut), this.set_refcount(0), this.set_caught(!1), this.set_rethrown(!1);
        }, this.add_ref = function() {
          Tt[this.ptr >> 2] += 1;
        }, this.release_ref = function() {
          var bt = Tt[this.ptr >> 2];
          return Tt[this.ptr >> 2] = bt - 1, bt === 1;
        }, this.set_adjusted_ptr = function(bt) {
          Ft[this.ptr + 16 >> 2] = bt;
        }, this.get_adjusted_ptr = function() {
          return Ft[this.ptr + 16 >> 2];
        }, this.get_exception_ptr = function() {
          if (ac(this.get_type()))
            return Ft[this.excPtr >> 2];
          var bt = this.get_adjusted_ptr();
          return bt !== 0 ? bt : this.excPtr;
        };
      }
      function E() {
        function et() {
          if (!Fs && (Fs = !0, b.calledRun = !0, !Z)) {
            if (ft = !0, m(It), lt(b), b.onRuntimeInitialized && b.onRuntimeInitialized(), b.postRun)
              for (typeof b.postRun == "function" && (b.postRun = [b.postRun]); b.postRun.length; )
                z.unshift(b.postRun.shift());
            m(z);
          }
        }
        if (!(0 < nt)) {
          if (b.preRun)
            for (typeof b.preRun == "function" && (b.preRun = [b.preRun]); b.preRun.length; )
              ht.unshift(b.preRun.shift());
          m(ht), 0 < nt || (b.setStatus ? (b.setStatus("Running..."), setTimeout(function() {
            setTimeout(function() {
              b.setStatus("");
            }, 1), et();
          }, 1)) : et());
        }
      }
      function _() {
      }
      function p(et) {
        return (et || _).__cache__;
      }
      function R(et, bt) {
        var Ut = p(bt), re = Ut[et];
        return re || (re = Object.create((bt || _).prototype), re.ptr = et, Ut[et] = re);
      }
      function M(et) {
        if (typeof et == "string") {
          for (var bt = 0, Ut = 0; Ut < et.length; ++Ut) {
            var re = et.charCodeAt(Ut);
            127 >= re ? bt++ : 2047 >= re ? bt += 2 : 55296 <= re && 57343 >= re ? (bt += 4, ++Ut) : bt += 3;
          }
          if (bt = Array(bt + 1), Ut = 0, re = bt.length, 0 < re) {
            re = Ut + re - 1;
            for (var Me = 0; Me < et.length; ++Me) {
              var be = et.charCodeAt(Me);
              if (55296 <= be && 57343 >= be) {
                var ei = et.charCodeAt(++Me);
                be = 65536 + ((be & 1023) << 10) | ei & 1023;
              }
              if (127 >= be) {
                if (Ut >= re)
                  break;
                bt[Ut++] = be;
              } else {
                if (2047 >= be) {
                  if (Ut + 1 >= re)
                    break;
                  bt[Ut++] = 192 | be >> 6;
                } else {
                  if (65535 >= be) {
                    if (Ut + 2 >= re)
                      break;
                    bt[Ut++] = 224 | be >> 12;
                  } else {
                    if (Ut + 3 >= re)
                      break;
                    bt[Ut++] = 240 | be >> 18, bt[Ut++] = 128 | be >> 12 & 63;
                  }
                  bt[Ut++] = 128 | be >> 6 & 63;
                }
                bt[Ut++] = 128 | be & 63;
              }
            }
            bt[Ut] = 0;
          }
          return et = Ie.alloc(bt, gt), Ie.copy(bt, gt, et), et;
        }
        return et;
      }
      function P(et) {
        if (typeof et == "object") {
          var bt = Ie.alloc(et, gt);
          return Ie.copy(et, gt, bt), bt;
        }
        return et;
      }
      function W() {
        throw "cannot construct a VoidPtr, no constructor in IDL";
      }
      function C() {
        this.ptr = Pt(), p(C)[this.ptr] = this;
      }
      function D() {
        this.ptr = Kt(), p(D)[this.ptr] = this;
      }
      function N() {
        this.ptr = ee(), p(N)[this.ptr] = this;
      }
      function A() {
        this.ptr = Ne(), p(A)[this.ptr] = this;
      }
      function I() {
        this.ptr = ui(), p(I)[this.ptr] = this;
      }
      function it() {
        this.ptr = qt(), p(it)[this.ptr] = this;
      }
      function V() {
        this.ptr = me(), p(V)[this.ptr] = this;
      }
      function mt() {
        this.ptr = Ee(), p(mt)[this.ptr] = this;
      }
      function k() {
        this.ptr = wn(), p(k)[this.ptr] = this;
      }
      function B() {
        throw "cannot construct a Status, no constructor in IDL";
      }
      function G() {
        this.ptr = hn(), p(G)[this.ptr] = this;
      }
      function H() {
        this.ptr = mn(), p(H)[this.ptr] = this;
      }
      function w() {
        this.ptr = ti(), p(w)[this.ptr] = this;
      }
      function ut() {
        this.ptr = dr(), p(ut)[this.ptr] = this;
      }
      function pt() {
        this.ptr = Xi(), p(pt)[this.ptr] = this;
      }
      function _t() {
        this.ptr = _r(), p(_t)[this.ptr] = this;
      }
      function vt() {
        this.ptr = ts(), p(vt)[this.ptr] = this;
      }
      function F() {
        this.ptr = is(), p(F)[this.ptr] = this;
      }
      function rt() {
        this.ptr = us(), p(rt)[this.ptr] = this;
      }
      s = s === void 0 ? {} : s;
      var b = typeof s < "u" ? s : {}, lt, q;
      b.ready = new Promise(function(et, bt) {
        lt = et, q = bt;
      });
      var U = !1, L = !1;
      b.onRuntimeInitialized = function() {
        U = !0, L && typeof b.onModuleLoaded == "function" && b.onModuleLoaded(b);
      }, b.onModuleParsed = function() {
        L = !0, U && typeof b.onModuleLoaded == "function" && b.onModuleLoaded(b);
      }, b.isVersionSupported = function(et) {
        return typeof et != "string" ? !1 : (et = et.split("."), 2 > et.length || 3 < et.length ? !1 : et[0] == 1 && 0 <= et[1] && 5 >= et[1] ? !0 : !(et[0] != 0 || 10 < et[1]));
      };
      var j = Object.assign({}, b), Y = typeof window == "object", K = typeof importScripts == "function", yt = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string", Et = "";
      if (yt) {
        var Ct = Xe, Lt = Xe;
        Et = K ? Lt.dirname(Et) + "/" : __dirname + "/";
        var Wt = function(et, bt) {
          return et = et.startsWith("file://") ? new URL(et) : Lt.normalize(et), Ct.readFileSync(et, bt ? void 0 : "utf8");
        }, wt = function(et) {
          return et = Wt(et, !0), et.buffer || (et = new Uint8Array(et)), et;
        }, Q = function(et, bt, Ut) {
          et = et.startsWith("file://") ? new URL(et) : Lt.normalize(et), Ct.readFile(et, function(re, Me) {
            re ? Ut(re) : bt(Me.buffer);
          });
        };
        1 < process.argv.length && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2), b.inspect = function() {
          return "[Emscripten Module object]";
        };
      } else
        (Y || K) && (K ? Et = self.location.href : typeof document < "u" && document.currentScript && (Et = document.currentScript.src), r && (Et = r), Et = Et.indexOf("blob:") !== 0 ? Et.substr(0, Et.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", Wt = function(et) {
          var bt = new XMLHttpRequest();
          return bt.open("GET", et, !1), bt.send(null), bt.responseText;
        }, K && (wt = function(et) {
          var bt = new XMLHttpRequest();
          return bt.open("GET", et, !1), bt.responseType = "arraybuffer", bt.send(null), new Uint8Array(bt.response);
        }), Q = function(et, bt, Ut) {
          var re = new XMLHttpRequest();
          re.open("GET", et, !0), re.responseType = "arraybuffer", re.onload = function() {
            re.status == 200 || re.status == 0 && re.response ? bt(re.response) : Ut();
          }, re.onerror = Ut, re.send(null);
        });
      var y = b.print || console.log.bind(console), g = b.printErr || console.warn.bind(console);
      Object.assign(b, j), j = null;
      var S;
      b.wasmBinary && (S = b.wasmBinary), typeof WebAssembly != "object" && l("no native wasm support detected");
      var O, Z = !1, tt = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0, gt, st, Tt, Ft, ht = [], It = [], z = [], ft = !1, nt = 0, J = null, Rt = "draco_decoder.wasm";
      Rt.startsWith("data:application/octet-stream;base64,") || (Rt = a(Rt));
      var Nt = [null, [], []], Yt = { b: function(et, bt, Ut) {
        throw new v(et).init(bt, Ut), et;
      }, a: function() {
        l("");
      }, g: function(et, bt, Ut) {
        st.copyWithin(et, bt, bt + Ut);
      }, e: function(et) {
        var bt = st.length;
        if (et >>>= 0, 2147483648 < et)
          return !1;
        for (var Ut = 1; 4 >= Ut; Ut *= 2) {
          var re = bt * (1 + 0.2 / Ut);
          re = Math.min(re, et + 100663296);
          var Me = Math;
          re = Math.max(et, re), Me = Me.min.call(Me, 2147483648, re + (65536 - re % 65536) % 65536);
          t: {
            re = O.buffer;
            try {
              O.grow(Me - re.byteLength + 65535 >>> 16), h();
              var be = 1;
              break t;
            } catch {
            }
            be = void 0;
          }
          if (be)
            return !0;
        }
        return !1;
      }, f: function(et) {
        return 52;
      }, d: function(et, bt, Ut, re, Me) {
        return 70;
      }, c: function(et, bt, Ut, re) {
        for (var Me = 0, be = 0; be < Ut; be++) {
          var ei = Ft[bt >> 2], Er = Ft[bt + 4 >> 2];
          bt += 8;
          for (var Zi = 0; Zi < Er; Zi++) {
            var Ji = st[ei + Zi], Ii = Nt[et];
            Ji === 0 || Ji === 10 ? ((et === 1 ? y : g)(o(Ii, 0)), Ii.length = 0) : Ii.push(Ji);
          }
          Me += Er;
        }
        return Ft[re >> 2] = Me, 0;
      } };
      (function() {
        function et(Me, be) {
          b.asm = Me.exports, O = b.asm.h, h(), It.unshift(b.asm.i), nt--, b.monitorRunDependencies && b.monitorRunDependencies(nt), nt == 0 && J && (Me = J, J = null, Me());
        }
        function bt(Me) {
          et(Me.instance);
        }
        function Ut(Me) {
          return d().then(function(be) {
            return WebAssembly.instantiate(be, re);
          }).then(function(be) {
            return be;
          }).then(Me, function(be) {
            g("failed to asynchronously prepare wasm: " + be), l(be);
          });
        }
        var re = { a: Yt };
        if (nt++, b.monitorRunDependencies && b.monitorRunDependencies(nt), b.instantiateWasm)
          try {
            return b.instantiateWasm(re, et);
          } catch (Me) {
            g("Module.instantiateWasm callback failed with error: " + Me), q(Me);
          }
        return function() {
          return S || typeof WebAssembly.instantiateStreaming != "function" || Rt.startsWith("data:application/octet-stream;base64,") || Rt.startsWith("file://") || yt || typeof fetch != "function" ? Ut(bt) : fetch(Rt, { credentials: "same-origin" }).then(function(Me) {
            return WebAssembly.instantiateStreaming(Me, re).then(bt, function(be) {
              return g("wasm streaming compile failed: " + be), g("falling back to ArrayBuffer instantiation"), Ut(bt);
            });
          });
        }().catch(q), {};
      })();
      var Ht = b._emscripten_bind_VoidPtr___destroy___0 = function() {
        return (Ht = b._emscripten_bind_VoidPtr___destroy___0 = b.asm.k).apply(null, arguments);
      }, Pt = b._emscripten_bind_DecoderBuffer_DecoderBuffer_0 = function() {
        return (Pt = b._emscripten_bind_DecoderBuffer_DecoderBuffer_0 = b.asm.l).apply(null, arguments);
      }, Mt = b._emscripten_bind_DecoderBuffer_Init_2 = function() {
        return (Mt = b._emscripten_bind_DecoderBuffer_Init_2 = b.asm.m).apply(null, arguments);
      }, $t = b._emscripten_bind_DecoderBuffer___destroy___0 = function() {
        return ($t = b._emscripten_bind_DecoderBuffer___destroy___0 = b.asm.n).apply(null, arguments);
      }, Kt = b._emscripten_bind_AttributeTransformData_AttributeTransformData_0 = function() {
        return (Kt = b._emscripten_bind_AttributeTransformData_AttributeTransformData_0 = b.asm.o).apply(null, arguments);
      }, te = b._emscripten_bind_AttributeTransformData_transform_type_0 = function() {
        return (te = b._emscripten_bind_AttributeTransformData_transform_type_0 = b.asm.p).apply(null, arguments);
      }, Qt = b._emscripten_bind_AttributeTransformData___destroy___0 = function() {
        return (Qt = b._emscripten_bind_AttributeTransformData___destroy___0 = b.asm.q).apply(null, arguments);
      }, ee = b._emscripten_bind_GeometryAttribute_GeometryAttribute_0 = function() {
        return (ee = b._emscripten_bind_GeometryAttribute_GeometryAttribute_0 = b.asm.r).apply(null, arguments);
      }, Pe = b._emscripten_bind_GeometryAttribute___destroy___0 = function() {
        return (Pe = b._emscripten_bind_GeometryAttribute___destroy___0 = b.asm.s).apply(null, arguments);
      }, Ne = b._emscripten_bind_PointAttribute_PointAttribute_0 = function() {
        return (Ne = b._emscripten_bind_PointAttribute_PointAttribute_0 = b.asm.t).apply(null, arguments);
      }, Je = b._emscripten_bind_PointAttribute_size_0 = function() {
        return (Je = b._emscripten_bind_PointAttribute_size_0 = b.asm.u).apply(null, arguments);
      }, ve = b._emscripten_bind_PointAttribute_GetAttributeTransformData_0 = function() {
        return (ve = b._emscripten_bind_PointAttribute_GetAttributeTransformData_0 = b.asm.v).apply(null, arguments);
      }, tn = b._emscripten_bind_PointAttribute_attribute_type_0 = function() {
        return (tn = b._emscripten_bind_PointAttribute_attribute_type_0 = b.asm.w).apply(null, arguments);
      }, dn = b._emscripten_bind_PointAttribute_data_type_0 = function() {
        return (dn = b._emscripten_bind_PointAttribute_data_type_0 = b.asm.x).apply(null, arguments);
      }, Qn = b._emscripten_bind_PointAttribute_num_components_0 = function() {
        return (Qn = b._emscripten_bind_PointAttribute_num_components_0 = b.asm.y).apply(null, arguments);
      }, zn = b._emscripten_bind_PointAttribute_normalized_0 = function() {
        return (zn = b._emscripten_bind_PointAttribute_normalized_0 = b.asm.z).apply(null, arguments);
      }, Rn = b._emscripten_bind_PointAttribute_byte_stride_0 = function() {
        return (Rn = b._emscripten_bind_PointAttribute_byte_stride_0 = b.asm.A).apply(null, arguments);
      }, Gn = b._emscripten_bind_PointAttribute_byte_offset_0 = function() {
        return (Gn = b._emscripten_bind_PointAttribute_byte_offset_0 = b.asm.B).apply(null, arguments);
      }, ci = b._emscripten_bind_PointAttribute_unique_id_0 = function() {
        return (ci = b._emscripten_bind_PointAttribute_unique_id_0 = b.asm.C).apply(null, arguments);
      }, Ai = b._emscripten_bind_PointAttribute___destroy___0 = function() {
        return (Ai = b._emscripten_bind_PointAttribute___destroy___0 = b.asm.D).apply(null, arguments);
      }, ui = b._emscripten_bind_AttributeQuantizationTransform_AttributeQuantizationTransform_0 = function() {
        return (ui = b._emscripten_bind_AttributeQuantizationTransform_AttributeQuantizationTransform_0 = b.asm.E).apply(null, arguments);
      }, ji = b._emscripten_bind_AttributeQuantizationTransform_InitFromAttribute_1 = function() {
        return (ji = b._emscripten_bind_AttributeQuantizationTransform_InitFromAttribute_1 = b.asm.F).apply(null, arguments);
      }, Wi = b._emscripten_bind_AttributeQuantizationTransform_quantization_bits_0 = function() {
        return (Wi = b._emscripten_bind_AttributeQuantizationTransform_quantization_bits_0 = b.asm.G).apply(null, arguments);
      }, qi = b._emscripten_bind_AttributeQuantizationTransform_min_value_1 = function() {
        return (qi = b._emscripten_bind_AttributeQuantizationTransform_min_value_1 = b.asm.H).apply(null, arguments);
      }, St = b._emscripten_bind_AttributeQuantizationTransform_range_0 = function() {
        return (St = b._emscripten_bind_AttributeQuantizationTransform_range_0 = b.asm.I).apply(null, arguments);
      }, kt = b._emscripten_bind_AttributeQuantizationTransform___destroy___0 = function() {
        return (kt = b._emscripten_bind_AttributeQuantizationTransform___destroy___0 = b.asm.J).apply(null, arguments);
      }, qt = b._emscripten_bind_AttributeOctahedronTransform_AttributeOctahedronTransform_0 = function() {
        return (qt = b._emscripten_bind_AttributeOctahedronTransform_AttributeOctahedronTransform_0 = b.asm.K).apply(null, arguments);
      }, Xt = b._emscripten_bind_AttributeOctahedronTransform_InitFromAttribute_1 = function() {
        return (Xt = b._emscripten_bind_AttributeOctahedronTransform_InitFromAttribute_1 = b.asm.L).apply(
          null,
          arguments
        );
      }, jt = b._emscripten_bind_AttributeOctahedronTransform_quantization_bits_0 = function() {
        return (jt = b._emscripten_bind_AttributeOctahedronTransform_quantization_bits_0 = b.asm.M).apply(null, arguments);
      }, le = b._emscripten_bind_AttributeOctahedronTransform___destroy___0 = function() {
        return (le = b._emscripten_bind_AttributeOctahedronTransform___destroy___0 = b.asm.N).apply(null, arguments);
      }, me = b._emscripten_bind_PointCloud_PointCloud_0 = function() {
        return (me = b._emscripten_bind_PointCloud_PointCloud_0 = b.asm.O).apply(
          null,
          arguments
        );
      }, ye = b._emscripten_bind_PointCloud_num_attributes_0 = function() {
        return (ye = b._emscripten_bind_PointCloud_num_attributes_0 = b.asm.P).apply(null, arguments);
      }, xe = b._emscripten_bind_PointCloud_num_points_0 = function() {
        return (xe = b._emscripten_bind_PointCloud_num_points_0 = b.asm.Q).apply(null, arguments);
      }, Te = b._emscripten_bind_PointCloud___destroy___0 = function() {
        return (Te = b._emscripten_bind_PointCloud___destroy___0 = b.asm.R).apply(null, arguments);
      }, Ee = b._emscripten_bind_Mesh_Mesh_0 = function() {
        return (Ee = b._emscripten_bind_Mesh_Mesh_0 = b.asm.S).apply(null, arguments);
      }, we = b._emscripten_bind_Mesh_num_faces_0 = function() {
        return (we = b._emscripten_bind_Mesh_num_faces_0 = b.asm.T).apply(null, arguments);
      }, We = b._emscripten_bind_Mesh_num_attributes_0 = function() {
        return (We = b._emscripten_bind_Mesh_num_attributes_0 = b.asm.U).apply(null, arguments);
      }, fn = b._emscripten_bind_Mesh_num_points_0 = function() {
        return (fn = b._emscripten_bind_Mesh_num_points_0 = b.asm.V).apply(null, arguments);
      }, Qe = b._emscripten_bind_Mesh___destroy___0 = function() {
        return (Qe = b._emscripten_bind_Mesh___destroy___0 = b.asm.W).apply(null, arguments);
      }, wn = b._emscripten_bind_Metadata_Metadata_0 = function() {
        return (wn = b._emscripten_bind_Metadata_Metadata_0 = b.asm.X).apply(null, arguments);
      }, Ve = b._emscripten_bind_Metadata___destroy___0 = function() {
        return (Ve = b._emscripten_bind_Metadata___destroy___0 = b.asm.Y).apply(null, arguments);
      }, Ae = b._emscripten_bind_Status_code_0 = function() {
        return (Ae = b._emscripten_bind_Status_code_0 = b.asm.Z).apply(null, arguments);
      }, li = b._emscripten_bind_Status_ok_0 = function() {
        return (li = b._emscripten_bind_Status_ok_0 = b.asm._).apply(null, arguments);
      }, ze = b._emscripten_bind_Status_error_msg_0 = function() {
        return (ze = b._emscripten_bind_Status_error_msg_0 = b.asm.$).apply(null, arguments);
      }, On = b._emscripten_bind_Status___destroy___0 = function() {
        return (On = b._emscripten_bind_Status___destroy___0 = b.asm.aa).apply(null, arguments);
      }, hn = b._emscripten_bind_DracoFloat32Array_DracoFloat32Array_0 = function() {
        return (hn = b._emscripten_bind_DracoFloat32Array_DracoFloat32Array_0 = b.asm.ba).apply(null, arguments);
      }, Yn = b._emscripten_bind_DracoFloat32Array_GetValue_1 = function() {
        return (Yn = b._emscripten_bind_DracoFloat32Array_GetValue_1 = b.asm.ca).apply(null, arguments);
      }, fi = b._emscripten_bind_DracoFloat32Array_size_0 = function() {
        return (fi = b._emscripten_bind_DracoFloat32Array_size_0 = b.asm.da).apply(null, arguments);
      }, en = b._emscripten_bind_DracoFloat32Array___destroy___0 = function() {
        return (en = b._emscripten_bind_DracoFloat32Array___destroy___0 = b.asm.ea).apply(null, arguments);
      }, mn = b._emscripten_bind_DracoInt8Array_DracoInt8Array_0 = function() {
        return (mn = b._emscripten_bind_DracoInt8Array_DracoInt8Array_0 = b.asm.fa).apply(null, arguments);
      }, rn = b._emscripten_bind_DracoInt8Array_GetValue_1 = function() {
        return (rn = b._emscripten_bind_DracoInt8Array_GetValue_1 = b.asm.ga).apply(null, arguments);
      }, He = b._emscripten_bind_DracoInt8Array_size_0 = function() {
        return (He = b._emscripten_bind_DracoInt8Array_size_0 = b.asm.ha).apply(null, arguments);
      }, Vn = b._emscripten_bind_DracoInt8Array___destroy___0 = function() {
        return (Vn = b._emscripten_bind_DracoInt8Array___destroy___0 = b.asm.ia).apply(null, arguments);
      }, ti = b._emscripten_bind_DracoUInt8Array_DracoUInt8Array_0 = function() {
        return (ti = b._emscripten_bind_DracoUInt8Array_DracoUInt8Array_0 = b.asm.ja).apply(null, arguments);
      }, Ti = b._emscripten_bind_DracoUInt8Array_GetValue_1 = function() {
        return (Ti = b._emscripten_bind_DracoUInt8Array_GetValue_1 = b.asm.ka).apply(null, arguments);
      }, pr = b._emscripten_bind_DracoUInt8Array_size_0 = function() {
        return (pr = b._emscripten_bind_DracoUInt8Array_size_0 = b.asm.la).apply(null, arguments);
      }, $r = b._emscripten_bind_DracoUInt8Array___destroy___0 = function() {
        return ($r = b._emscripten_bind_DracoUInt8Array___destroy___0 = b.asm.ma).apply(null, arguments);
      }, dr = b._emscripten_bind_DracoInt16Array_DracoInt16Array_0 = function() {
        return (dr = b._emscripten_bind_DracoInt16Array_DracoInt16Array_0 = b.asm.na).apply(null, arguments);
      }, $i = b._emscripten_bind_DracoInt16Array_GetValue_1 = function() {
        return ($i = b._emscripten_bind_DracoInt16Array_GetValue_1 = b.asm.oa).apply(null, arguments);
      }, mr = b._emscripten_bind_DracoInt16Array_size_0 = function() {
        return (mr = b._emscripten_bind_DracoInt16Array_size_0 = b.asm.pa).apply(null, arguments);
      }, Xr = b._emscripten_bind_DracoInt16Array___destroy___0 = function() {
        return (Xr = b._emscripten_bind_DracoInt16Array___destroy___0 = b.asm.qa).apply(null, arguments);
      }, Xi = b._emscripten_bind_DracoUInt16Array_DracoUInt16Array_0 = function() {
        return (Xi = b._emscripten_bind_DracoUInt16Array_DracoUInt16Array_0 = b.asm.ra).apply(null, arguments);
      }, Yr = b._emscripten_bind_DracoUInt16Array_GetValue_1 = function() {
        return (Yr = b._emscripten_bind_DracoUInt16Array_GetValue_1 = b.asm.sa).apply(null, arguments);
      }, Kr = b._emscripten_bind_DracoUInt16Array_size_0 = function() {
        return (Kr = b._emscripten_bind_DracoUInt16Array_size_0 = b.asm.ta).apply(null, arguments);
      }, Zr = b._emscripten_bind_DracoUInt16Array___destroy___0 = function() {
        return (Zr = b._emscripten_bind_DracoUInt16Array___destroy___0 = b.asm.ua).apply(null, arguments);
      }, _r = b._emscripten_bind_DracoInt32Array_DracoInt32Array_0 = function() {
        return (_r = b._emscripten_bind_DracoInt32Array_DracoInt32Array_0 = b.asm.va).apply(null, arguments);
      }, Jr = b._emscripten_bind_DracoInt32Array_GetValue_1 = function() {
        return (Jr = b._emscripten_bind_DracoInt32Array_GetValue_1 = b.asm.wa).apply(null, arguments);
      }, yr = b._emscripten_bind_DracoInt32Array_size_0 = function() {
        return (yr = b._emscripten_bind_DracoInt32Array_size_0 = b.asm.xa).apply(null, arguments);
      }, Qr = b._emscripten_bind_DracoInt32Array___destroy___0 = function() {
        return (Qr = b._emscripten_bind_DracoInt32Array___destroy___0 = b.asm.ya).apply(null, arguments);
      }, ts = b._emscripten_bind_DracoUInt32Array_DracoUInt32Array_0 = function() {
        return (ts = b._emscripten_bind_DracoUInt32Array_DracoUInt32Array_0 = b.asm.za).apply(null, arguments);
      }, es = b._emscripten_bind_DracoUInt32Array_GetValue_1 = function() {
        return (es = b._emscripten_bind_DracoUInt32Array_GetValue_1 = b.asm.Aa).apply(null, arguments);
      }, hi = b._emscripten_bind_DracoUInt32Array_size_0 = function() {
        return (hi = b._emscripten_bind_DracoUInt32Array_size_0 = b.asm.Ba).apply(null, arguments);
      }, ns = b._emscripten_bind_DracoUInt32Array___destroy___0 = function() {
        return (ns = b._emscripten_bind_DracoUInt32Array___destroy___0 = b.asm.Ca).apply(null, arguments);
      }, is = b._emscripten_bind_MetadataQuerier_MetadataQuerier_0 = function() {
        return (is = b._emscripten_bind_MetadataQuerier_MetadataQuerier_0 = b.asm.Da).apply(null, arguments);
      }, gr = b._emscripten_bind_MetadataQuerier_HasEntry_2 = function() {
        return (gr = b._emscripten_bind_MetadataQuerier_HasEntry_2 = b.asm.Ea).apply(null, arguments);
      }, vr = b._emscripten_bind_MetadataQuerier_GetIntEntry_2 = function() {
        return (vr = b._emscripten_bind_MetadataQuerier_GetIntEntry_2 = b.asm.Fa).apply(null, arguments);
      }, xr = b._emscripten_bind_MetadataQuerier_GetIntEntryArray_3 = function() {
        return (xr = b._emscripten_bind_MetadataQuerier_GetIntEntryArray_3 = b.asm.Ga).apply(null, arguments);
      }, rs = b._emscripten_bind_MetadataQuerier_GetDoubleEntry_2 = function() {
        return (rs = b._emscripten_bind_MetadataQuerier_GetDoubleEntry_2 = b.asm.Ha).apply(null, arguments);
      }, ss = b._emscripten_bind_MetadataQuerier_GetStringEntry_2 = function() {
        return (ss = b._emscripten_bind_MetadataQuerier_GetStringEntry_2 = b.asm.Ia).apply(null, arguments);
      }, as = b._emscripten_bind_MetadataQuerier_NumEntries_1 = function() {
        return (as = b._emscripten_bind_MetadataQuerier_NumEntries_1 = b.asm.Ja).apply(null, arguments);
      }, os = b._emscripten_bind_MetadataQuerier_GetEntryName_2 = function() {
        return (os = b._emscripten_bind_MetadataQuerier_GetEntryName_2 = b.asm.Ka).apply(null, arguments);
      }, cs = b._emscripten_bind_MetadataQuerier___destroy___0 = function() {
        return (cs = b._emscripten_bind_MetadataQuerier___destroy___0 = b.asm.La).apply(null, arguments);
      }, us = b._emscripten_bind_Decoder_Decoder_0 = function() {
        return (us = b._emscripten_bind_Decoder_Decoder_0 = b.asm.Ma).apply(null, arguments);
      }, ls = b._emscripten_bind_Decoder_DecodeArrayToPointCloud_3 = function() {
        return (ls = b._emscripten_bind_Decoder_DecodeArrayToPointCloud_3 = b.asm.Na).apply(null, arguments);
      }, br = b._emscripten_bind_Decoder_DecodeArrayToMesh_3 = function() {
        return (br = b._emscripten_bind_Decoder_DecodeArrayToMesh_3 = b.asm.Oa).apply(null, arguments);
      }, Ci = b._emscripten_bind_Decoder_GetAttributeId_2 = function() {
        return (Ci = b._emscripten_bind_Decoder_GetAttributeId_2 = b.asm.Pa).apply(null, arguments);
      }, Yi = b._emscripten_bind_Decoder_GetAttributeIdByName_2 = function() {
        return (Yi = b._emscripten_bind_Decoder_GetAttributeIdByName_2 = b.asm.Qa).apply(null, arguments);
      }, _e = b._emscripten_bind_Decoder_GetAttributeIdByMetadataEntry_3 = function() {
        return (_e = b._emscripten_bind_Decoder_GetAttributeIdByMetadataEntry_3 = b.asm.Ra).apply(null, arguments);
      }, at = b._emscripten_bind_Decoder_GetAttribute_2 = function() {
        return (at = b._emscripten_bind_Decoder_GetAttribute_2 = b.asm.Sa).apply(null, arguments);
      }, xt = b._emscripten_bind_Decoder_GetAttributeByUniqueId_2 = function() {
        return (xt = b._emscripten_bind_Decoder_GetAttributeByUniqueId_2 = b.asm.Ta).apply(null, arguments);
      }, Ot = b._emscripten_bind_Decoder_GetMetadata_1 = function() {
        return (Ot = b._emscripten_bind_Decoder_GetMetadata_1 = b.asm.Ua).apply(null, arguments);
      }, Bt = b._emscripten_bind_Decoder_GetAttributeMetadata_2 = function() {
        return (Bt = b._emscripten_bind_Decoder_GetAttributeMetadata_2 = b.asm.Va).apply(null, arguments);
      }, Zt = b._emscripten_bind_Decoder_GetFaceFromMesh_3 = function() {
        return (Zt = b._emscripten_bind_Decoder_GetFaceFromMesh_3 = b.asm.Wa).apply(null, arguments);
      }, pe = b._emscripten_bind_Decoder_GetTriangleStripsFromMesh_2 = function() {
        return (pe = b._emscripten_bind_Decoder_GetTriangleStripsFromMesh_2 = b.asm.Xa).apply(null, arguments);
      }, Ri = b._emscripten_bind_Decoder_GetTrianglesUInt16Array_3 = function() {
        return (Ri = b._emscripten_bind_Decoder_GetTrianglesUInt16Array_3 = b.asm.Ya).apply(null, arguments);
      }, go = b._emscripten_bind_Decoder_GetTrianglesUInt32Array_3 = function() {
        return (go = b._emscripten_bind_Decoder_GetTrianglesUInt32Array_3 = b.asm.Za).apply(null, arguments);
      }, vo = b._emscripten_bind_Decoder_GetAttributeFloat_3 = function() {
        return (vo = b._emscripten_bind_Decoder_GetAttributeFloat_3 = b.asm._a).apply(null, arguments);
      }, Os = b._emscripten_bind_Decoder_GetAttributeFloatForAllPoints_3 = function() {
        return (Os = b._emscripten_bind_Decoder_GetAttributeFloatForAllPoints_3 = b.asm.$a).apply(null, arguments);
      }, xo = b._emscripten_bind_Decoder_GetAttributeIntForAllPoints_3 = function() {
        return (xo = b._emscripten_bind_Decoder_GetAttributeIntForAllPoints_3 = b.asm.ab).apply(null, arguments);
      }, bo = b._emscripten_bind_Decoder_GetAttributeInt8ForAllPoints_3 = function() {
        return (bo = b._emscripten_bind_Decoder_GetAttributeInt8ForAllPoints_3 = b.asm.bb).apply(null, arguments);
      }, Ta = b._emscripten_bind_Decoder_GetAttributeUInt8ForAllPoints_3 = function() {
        return (Ta = b._emscripten_bind_Decoder_GetAttributeUInt8ForAllPoints_3 = b.asm.cb).apply(null, arguments);
      }, Eo = b._emscripten_bind_Decoder_GetAttributeInt16ForAllPoints_3 = function() {
        return (Eo = b._emscripten_bind_Decoder_GetAttributeInt16ForAllPoints_3 = b.asm.db).apply(null, arguments);
      }, wo = b._emscripten_bind_Decoder_GetAttributeUInt16ForAllPoints_3 = function() {
        return (wo = b._emscripten_bind_Decoder_GetAttributeUInt16ForAllPoints_3 = b.asm.eb).apply(null, arguments);
      }, Mo = b._emscripten_bind_Decoder_GetAttributeInt32ForAllPoints_3 = function() {
        return (Mo = b._emscripten_bind_Decoder_GetAttributeInt32ForAllPoints_3 = b.asm.fb).apply(null, arguments);
      }, So = b._emscripten_bind_Decoder_GetAttributeUInt32ForAllPoints_3 = function() {
        return (So = b._emscripten_bind_Decoder_GetAttributeUInt32ForAllPoints_3 = b.asm.gb).apply(null, arguments);
      }, fs = b._emscripten_bind_Decoder_GetAttributeDataArrayForAllPoints_5 = function() {
        return (fs = b._emscripten_bind_Decoder_GetAttributeDataArrayForAllPoints_5 = b.asm.hb).apply(null, arguments);
      }, Ao = b._emscripten_bind_Decoder_SkipAttributeTransform_1 = function() {
        return (Ao = b._emscripten_bind_Decoder_SkipAttributeTransform_1 = b.asm.ib).apply(null, arguments);
      }, To = b._emscripten_bind_Decoder_GetEncodedGeometryType_Deprecated_1 = function() {
        return (To = b._emscripten_bind_Decoder_GetEncodedGeometryType_Deprecated_1 = b.asm.jb).apply(null, arguments);
      }, Co = b._emscripten_bind_Decoder_DecodeBufferToPointCloud_2 = function() {
        return (Co = b._emscripten_bind_Decoder_DecodeBufferToPointCloud_2 = b.asm.kb).apply(null, arguments);
      }, Ro = b._emscripten_bind_Decoder_DecodeBufferToMesh_2 = function() {
        return (Ro = b._emscripten_bind_Decoder_DecodeBufferToMesh_2 = b.asm.lb).apply(null, arguments);
      }, Io = b._emscripten_bind_Decoder___destroy___0 = function() {
        return (Io = b._emscripten_bind_Decoder___destroy___0 = b.asm.mb).apply(null, arguments);
      }, Ds = b._emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_INVALID_TRANSFORM = function() {
        return (Ds = b._emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_INVALID_TRANSFORM = b.asm.nb).apply(null, arguments);
      }, Po = b._emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_NO_TRANSFORM = function() {
        return (Po = b._emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_NO_TRANSFORM = b.asm.ob).apply(null, arguments);
      }, Lo = b._emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_QUANTIZATION_TRANSFORM = function() {
        return (Lo = b._emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_QUANTIZATION_TRANSFORM = b.asm.pb).apply(null, arguments);
      }, Oo = b._emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_OCTAHEDRON_TRANSFORM = function() {
        return (Oo = b._emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_OCTAHEDRON_TRANSFORM = b.asm.qb).apply(null, arguments);
      }, Do = b._emscripten_enum_draco_GeometryAttribute_Type_INVALID = function() {
        return (Do = b._emscripten_enum_draco_GeometryAttribute_Type_INVALID = b.asm.rb).apply(null, arguments);
      }, No = b._emscripten_enum_draco_GeometryAttribute_Type_POSITION = function() {
        return (No = b._emscripten_enum_draco_GeometryAttribute_Type_POSITION = b.asm.sb).apply(null, arguments);
      }, Ns = b._emscripten_enum_draco_GeometryAttribute_Type_NORMAL = function() {
        return (Ns = b._emscripten_enum_draco_GeometryAttribute_Type_NORMAL = b.asm.tb).apply(null, arguments);
      }, Fo = b._emscripten_enum_draco_GeometryAttribute_Type_COLOR = function() {
        return (Fo = b._emscripten_enum_draco_GeometryAttribute_Type_COLOR = b.asm.ub).apply(null, arguments);
      }, Uo = b._emscripten_enum_draco_GeometryAttribute_Type_TEX_COORD = function() {
        return (Uo = b._emscripten_enum_draco_GeometryAttribute_Type_TEX_COORD = b.asm.vb).apply(null, arguments);
      }, Bo = b._emscripten_enum_draco_GeometryAttribute_Type_GENERIC = function() {
        return (Bo = b._emscripten_enum_draco_GeometryAttribute_Type_GENERIC = b.asm.wb).apply(null, arguments);
      }, ko = b._emscripten_enum_draco_EncodedGeometryType_INVALID_GEOMETRY_TYPE = function() {
        return (ko = b._emscripten_enum_draco_EncodedGeometryType_INVALID_GEOMETRY_TYPE = b.asm.xb).apply(null, arguments);
      }, zo = b._emscripten_enum_draco_EncodedGeometryType_POINT_CLOUD = function() {
        return (zo = b._emscripten_enum_draco_EncodedGeometryType_POINT_CLOUD = b.asm.yb).apply(null, arguments);
      }, Go = b._emscripten_enum_draco_EncodedGeometryType_TRIANGULAR_MESH = function() {
        return (Go = b._emscripten_enum_draco_EncodedGeometryType_TRIANGULAR_MESH = b.asm.zb).apply(null, arguments);
      }, Vo = b._emscripten_enum_draco_DataType_DT_INVALID = function() {
        return (Vo = b._emscripten_enum_draco_DataType_DT_INVALID = b.asm.Ab).apply(null, arguments);
      }, Ho = b._emscripten_enum_draco_DataType_DT_INT8 = function() {
        return (Ho = b._emscripten_enum_draco_DataType_DT_INT8 = b.asm.Bb).apply(null, arguments);
      }, jo = b._emscripten_enum_draco_DataType_DT_UINT8 = function() {
        return (jo = b._emscripten_enum_draco_DataType_DT_UINT8 = b.asm.Cb).apply(null, arguments);
      }, Wo = b._emscripten_enum_draco_DataType_DT_INT16 = function() {
        return (Wo = b._emscripten_enum_draco_DataType_DT_INT16 = b.asm.Db).apply(null, arguments);
      }, qo = b._emscripten_enum_draco_DataType_DT_UINT16 = function() {
        return (qo = b._emscripten_enum_draco_DataType_DT_UINT16 = b.asm.Eb).apply(null, arguments);
      }, $o = b._emscripten_enum_draco_DataType_DT_INT32 = function() {
        return ($o = b._emscripten_enum_draco_DataType_DT_INT32 = b.asm.Fb).apply(null, arguments);
      }, Xo = b._emscripten_enum_draco_DataType_DT_UINT32 = function() {
        return (Xo = b._emscripten_enum_draco_DataType_DT_UINT32 = b.asm.Gb).apply(null, arguments);
      }, Yo = b._emscripten_enum_draco_DataType_DT_INT64 = function() {
        return (Yo = b._emscripten_enum_draco_DataType_DT_INT64 = b.asm.Hb).apply(null, arguments);
      }, Ko = b._emscripten_enum_draco_DataType_DT_UINT64 = function() {
        return (Ko = b._emscripten_enum_draco_DataType_DT_UINT64 = b.asm.Ib).apply(null, arguments);
      }, Zo = b._emscripten_enum_draco_DataType_DT_FLOAT32 = function() {
        return (Zo = b._emscripten_enum_draco_DataType_DT_FLOAT32 = b.asm.Jb).apply(
          null,
          arguments
        );
      }, Ki = b._emscripten_enum_draco_DataType_DT_FLOAT64 = function() {
        return (Ki = b._emscripten_enum_draco_DataType_DT_FLOAT64 = b.asm.Kb).apply(null, arguments);
      }, Jo = b._emscripten_enum_draco_DataType_DT_BOOL = function() {
        return (Jo = b._emscripten_enum_draco_DataType_DT_BOOL = b.asm.Lb).apply(null, arguments);
      }, Qo = b._emscripten_enum_draco_DataType_DT_TYPES_COUNT = function() {
        return (Qo = b._emscripten_enum_draco_DataType_DT_TYPES_COUNT = b.asm.Mb).apply(null, arguments);
      }, tc = b._emscripten_enum_draco_StatusCode_OK = function() {
        return (tc = b._emscripten_enum_draco_StatusCode_OK = b.asm.Nb).apply(null, arguments);
      }, ec = b._emscripten_enum_draco_StatusCode_DRACO_ERROR = function() {
        return (ec = b._emscripten_enum_draco_StatusCode_DRACO_ERROR = b.asm.Ob).apply(null, arguments);
      }, nc = b._emscripten_enum_draco_StatusCode_IO_ERROR = function() {
        return (nc = b._emscripten_enum_draco_StatusCode_IO_ERROR = b.asm.Pb).apply(null, arguments);
      }, ic = b._emscripten_enum_draco_StatusCode_INVALID_PARAMETER = function() {
        return (ic = b._emscripten_enum_draco_StatusCode_INVALID_PARAMETER = b.asm.Qb).apply(null, arguments);
      }, rc = b._emscripten_enum_draco_StatusCode_UNSUPPORTED_VERSION = function() {
        return (rc = b._emscripten_enum_draco_StatusCode_UNSUPPORTED_VERSION = b.asm.Rb).apply(null, arguments);
      }, sc = b._emscripten_enum_draco_StatusCode_UNKNOWN_VERSION = function() {
        return (sc = b._emscripten_enum_draco_StatusCode_UNKNOWN_VERSION = b.asm.Sb).apply(null, arguments);
      };
      b._malloc = function() {
        return (b._malloc = b.asm.Tb).apply(null, arguments);
      }, b._free = function() {
        return (b._free = b.asm.Ub).apply(null, arguments);
      };
      var ac = function() {
        return (ac = b.asm.Vb).apply(null, arguments);
      };
      b.___start_em_js = 15856, b.___stop_em_js = 15954;
      var Fs;
      if (J = function et() {
        Fs || E(), Fs || (J = et);
      }, b.preInit)
        for (typeof b.preInit == "function" && (b.preInit = [b.preInit]); 0 < b.preInit.length; )
          b.preInit.pop()();
      E(), _.prototype = Object.create(_.prototype), _.prototype.constructor = _, _.prototype.__class__ = _, _.__cache__ = {}, b.WrapperObject = _, b.getCache = p, b.wrapPointer = R, b.castObject = function(et, bt) {
        return R(et.ptr, bt);
      }, b.NULL = R(0), b.destroy = function(et) {
        if (!et.__destroy__)
          throw "Error: Cannot destroy object. (Did you create it yourself?)";
        et.__destroy__(), delete p(et.__class__)[et.ptr];
      }, b.compare = function(et, bt) {
        return et.ptr === bt.ptr;
      }, b.getPointer = function(et) {
        return et.ptr;
      }, b.getClass = function(et) {
        return et.__class__;
      };
      var Ie = { buffer: 0, size: 0, pos: 0, temps: [], needed: 0, prepare: function() {
        if (Ie.needed) {
          for (var et = 0; et < Ie.temps.length; et++)
            b._free(Ie.temps[et]);
          Ie.temps.length = 0, b._free(Ie.buffer), Ie.buffer = 0, Ie.size += Ie.needed, Ie.needed = 0;
        }
        Ie.buffer || (Ie.size += 128, Ie.buffer = b._malloc(Ie.size), Ie.buffer || l(void 0)), Ie.pos = 0;
      }, alloc: function(et, bt) {
        return Ie.buffer || l(void 0), et = et.length * bt.BYTES_PER_ELEMENT, et = et + 7 & -8, Ie.pos + et >= Ie.size ? (0 < et || l(void 0), Ie.needed += et, bt = b._malloc(et), Ie.temps.push(bt)) : (bt = Ie.buffer + Ie.pos, Ie.pos += et), bt;
      }, copy: function(et, bt, Ut) {
        switch (Ut >>>= 0, bt.BYTES_PER_ELEMENT) {
          case 2:
            Ut >>>= 1;
            break;
          case 4:
            Ut >>>= 2;
            break;
          case 8:
            Ut >>>= 3;
        }
        for (var re = 0; re < et.length; re++)
          bt[Ut + re] = et[re];
      } };
      return W.prototype = Object.create(_.prototype), W.prototype.constructor = W, W.prototype.__class__ = W, W.__cache__ = {}, b.VoidPtr = W, W.prototype.__destroy__ = W.prototype.__destroy__ = function() {
        Ht(this.ptr);
      }, C.prototype = Object.create(_.prototype), C.prototype.constructor = C, C.prototype.__class__ = C, C.__cache__ = {}, b.DecoderBuffer = C, C.prototype.Init = C.prototype.Init = function(et, bt) {
        var Ut = this.ptr;
        Ie.prepare(), typeof et == "object" && (et = P(et)), bt && typeof bt == "object" && (bt = bt.ptr), Mt(Ut, et, bt);
      }, C.prototype.__destroy__ = C.prototype.__destroy__ = function() {
        $t(this.ptr);
      }, D.prototype = Object.create(_.prototype), D.prototype.constructor = D, D.prototype.__class__ = D, D.__cache__ = {}, b.AttributeTransformData = D, D.prototype.transform_type = D.prototype.transform_type = function() {
        return te(this.ptr);
      }, D.prototype.__destroy__ = D.prototype.__destroy__ = function() {
        Qt(this.ptr);
      }, N.prototype = Object.create(_.prototype), N.prototype.constructor = N, N.prototype.__class__ = N, N.__cache__ = {}, b.GeometryAttribute = N, N.prototype.__destroy__ = N.prototype.__destroy__ = function() {
        Pe(this.ptr);
      }, A.prototype = Object.create(_.prototype), A.prototype.constructor = A, A.prototype.__class__ = A, A.__cache__ = {}, b.PointAttribute = A, A.prototype.size = A.prototype.size = function() {
        return Je(this.ptr);
      }, A.prototype.GetAttributeTransformData = A.prototype.GetAttributeTransformData = function() {
        return R(ve(this.ptr), D);
      }, A.prototype.attribute_type = A.prototype.attribute_type = function() {
        return tn(this.ptr);
      }, A.prototype.data_type = A.prototype.data_type = function() {
        return dn(this.ptr);
      }, A.prototype.num_components = A.prototype.num_components = function() {
        return Qn(this.ptr);
      }, A.prototype.normalized = A.prototype.normalized = function() {
        return !!zn(this.ptr);
      }, A.prototype.byte_stride = A.prototype.byte_stride = function() {
        return Rn(this.ptr);
      }, A.prototype.byte_offset = A.prototype.byte_offset = function() {
        return Gn(this.ptr);
      }, A.prototype.unique_id = A.prototype.unique_id = function() {
        return ci(this.ptr);
      }, A.prototype.__destroy__ = A.prototype.__destroy__ = function() {
        Ai(this.ptr);
      }, I.prototype = Object.create(_.prototype), I.prototype.constructor = I, I.prototype.__class__ = I, I.__cache__ = {}, b.AttributeQuantizationTransform = I, I.prototype.InitFromAttribute = I.prototype.InitFromAttribute = function(et) {
        var bt = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), !!ji(bt, et);
      }, I.prototype.quantization_bits = I.prototype.quantization_bits = function() {
        return Wi(this.ptr);
      }, I.prototype.min_value = I.prototype.min_value = function(et) {
        var bt = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), qi(bt, et);
      }, I.prototype.range = I.prototype.range = function() {
        return St(this.ptr);
      }, I.prototype.__destroy__ = I.prototype.__destroy__ = function() {
        kt(this.ptr);
      }, it.prototype = Object.create(_.prototype), it.prototype.constructor = it, it.prototype.__class__ = it, it.__cache__ = {}, b.AttributeOctahedronTransform = it, it.prototype.InitFromAttribute = it.prototype.InitFromAttribute = function(et) {
        var bt = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), !!Xt(bt, et);
      }, it.prototype.quantization_bits = it.prototype.quantization_bits = function() {
        return jt(this.ptr);
      }, it.prototype.__destroy__ = it.prototype.__destroy__ = function() {
        le(this.ptr);
      }, V.prototype = Object.create(_.prototype), V.prototype.constructor = V, V.prototype.__class__ = V, V.__cache__ = {}, b.PointCloud = V, V.prototype.num_attributes = V.prototype.num_attributes = function() {
        return ye(this.ptr);
      }, V.prototype.num_points = V.prototype.num_points = function() {
        return xe(this.ptr);
      }, V.prototype.__destroy__ = V.prototype.__destroy__ = function() {
        Te(this.ptr);
      }, mt.prototype = Object.create(_.prototype), mt.prototype.constructor = mt, mt.prototype.__class__ = mt, mt.__cache__ = {}, b.Mesh = mt, mt.prototype.num_faces = mt.prototype.num_faces = function() {
        return we(this.ptr);
      }, mt.prototype.num_attributes = mt.prototype.num_attributes = function() {
        return We(this.ptr);
      }, mt.prototype.num_points = mt.prototype.num_points = function() {
        return fn(this.ptr);
      }, mt.prototype.__destroy__ = mt.prototype.__destroy__ = function() {
        Qe(this.ptr);
      }, k.prototype = Object.create(_.prototype), k.prototype.constructor = k, k.prototype.__class__ = k, k.__cache__ = {}, b.Metadata = k, k.prototype.__destroy__ = k.prototype.__destroy__ = function() {
        Ve(this.ptr);
      }, B.prototype = Object.create(_.prototype), B.prototype.constructor = B, B.prototype.__class__ = B, B.__cache__ = {}, b.Status = B, B.prototype.code = B.prototype.code = function() {
        return Ae(this.ptr);
      }, B.prototype.ok = B.prototype.ok = function() {
        return !!li(this.ptr);
      }, B.prototype.error_msg = B.prototype.error_msg = function() {
        return c(ze(this.ptr));
      }, B.prototype.__destroy__ = B.prototype.__destroy__ = function() {
        On(this.ptr);
      }, G.prototype = Object.create(_.prototype), G.prototype.constructor = G, G.prototype.__class__ = G, G.__cache__ = {}, b.DracoFloat32Array = G, G.prototype.GetValue = G.prototype.GetValue = function(et) {
        var bt = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), Yn(bt, et);
      }, G.prototype.size = G.prototype.size = function() {
        return fi(this.ptr);
      }, G.prototype.__destroy__ = G.prototype.__destroy__ = function() {
        en(this.ptr);
      }, H.prototype = Object.create(_.prototype), H.prototype.constructor = H, H.prototype.__class__ = H, H.__cache__ = {}, b.DracoInt8Array = H, H.prototype.GetValue = H.prototype.GetValue = function(et) {
        var bt = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), rn(bt, et);
      }, H.prototype.size = H.prototype.size = function() {
        return He(this.ptr);
      }, H.prototype.__destroy__ = H.prototype.__destroy__ = function() {
        Vn(this.ptr);
      }, w.prototype = Object.create(_.prototype), w.prototype.constructor = w, w.prototype.__class__ = w, w.__cache__ = {}, b.DracoUInt8Array = w, w.prototype.GetValue = w.prototype.GetValue = function(et) {
        var bt = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), Ti(bt, et);
      }, w.prototype.size = w.prototype.size = function() {
        return pr(this.ptr);
      }, w.prototype.__destroy__ = w.prototype.__destroy__ = function() {
        $r(this.ptr);
      }, ut.prototype = Object.create(_.prototype), ut.prototype.constructor = ut, ut.prototype.__class__ = ut, ut.__cache__ = {}, b.DracoInt16Array = ut, ut.prototype.GetValue = ut.prototype.GetValue = function(et) {
        var bt = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), $i(bt, et);
      }, ut.prototype.size = ut.prototype.size = function() {
        return mr(this.ptr);
      }, ut.prototype.__destroy__ = ut.prototype.__destroy__ = function() {
        Xr(this.ptr);
      }, pt.prototype = Object.create(_.prototype), pt.prototype.constructor = pt, pt.prototype.__class__ = pt, pt.__cache__ = {}, b.DracoUInt16Array = pt, pt.prototype.GetValue = pt.prototype.GetValue = function(et) {
        var bt = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), Yr(bt, et);
      }, pt.prototype.size = pt.prototype.size = function() {
        return Kr(this.ptr);
      }, pt.prototype.__destroy__ = pt.prototype.__destroy__ = function() {
        Zr(this.ptr);
      }, _t.prototype = Object.create(_.prototype), _t.prototype.constructor = _t, _t.prototype.__class__ = _t, _t.__cache__ = {}, b.DracoInt32Array = _t, _t.prototype.GetValue = _t.prototype.GetValue = function(et) {
        var bt = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), Jr(bt, et);
      }, _t.prototype.size = _t.prototype.size = function() {
        return yr(this.ptr);
      }, _t.prototype.__destroy__ = _t.prototype.__destroy__ = function() {
        Qr(this.ptr);
      }, vt.prototype = Object.create(_.prototype), vt.prototype.constructor = vt, vt.prototype.__class__ = vt, vt.__cache__ = {}, b.DracoUInt32Array = vt, vt.prototype.GetValue = vt.prototype.GetValue = function(et) {
        var bt = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), es(bt, et);
      }, vt.prototype.size = vt.prototype.size = function() {
        return hi(this.ptr);
      }, vt.prototype.__destroy__ = vt.prototype.__destroy__ = function() {
        ns(this.ptr);
      }, F.prototype = Object.create(_.prototype), F.prototype.constructor = F, F.prototype.__class__ = F, F.__cache__ = {}, b.MetadataQuerier = F, F.prototype.HasEntry = F.prototype.HasEntry = function(et, bt) {
        var Ut = this.ptr;
        return Ie.prepare(), et && typeof et == "object" && (et = et.ptr), bt = bt && typeof bt == "object" ? bt.ptr : M(bt), !!gr(Ut, et, bt);
      }, F.prototype.GetIntEntry = F.prototype.GetIntEntry = function(et, bt) {
        var Ut = this.ptr;
        return Ie.prepare(), et && typeof et == "object" && (et = et.ptr), bt = bt && typeof bt == "object" ? bt.ptr : M(bt), vr(Ut, et, bt);
      }, F.prototype.GetIntEntryArray = F.prototype.GetIntEntryArray = function(et, bt, Ut) {
        var re = this.ptr;
        Ie.prepare(), et && typeof et == "object" && (et = et.ptr), bt = bt && typeof bt == "object" ? bt.ptr : M(bt), Ut && typeof Ut == "object" && (Ut = Ut.ptr), xr(re, et, bt, Ut);
      }, F.prototype.GetDoubleEntry = F.prototype.GetDoubleEntry = function(et, bt) {
        var Ut = this.ptr;
        return Ie.prepare(), et && typeof et == "object" && (et = et.ptr), bt = bt && typeof bt == "object" ? bt.ptr : M(bt), rs(Ut, et, bt);
      }, F.prototype.GetStringEntry = F.prototype.GetStringEntry = function(et, bt) {
        var Ut = this.ptr;
        return Ie.prepare(), et && typeof et == "object" && (et = et.ptr), bt = bt && typeof bt == "object" ? bt.ptr : M(bt), c(ss(Ut, et, bt));
      }, F.prototype.NumEntries = F.prototype.NumEntries = function(et) {
        var bt = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), as(bt, et);
      }, F.prototype.GetEntryName = F.prototype.GetEntryName = function(et, bt) {
        var Ut = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), bt && typeof bt == "object" && (bt = bt.ptr), c(os(Ut, et, bt));
      }, F.prototype.__destroy__ = F.prototype.__destroy__ = function() {
        cs(this.ptr);
      }, rt.prototype = Object.create(_.prototype), rt.prototype.constructor = rt, rt.prototype.__class__ = rt, rt.__cache__ = {}, b.Decoder = rt, rt.prototype.DecodeArrayToPointCloud = rt.prototype.DecodeArrayToPointCloud = function(et, bt, Ut) {
        var re = this.ptr;
        return Ie.prepare(), typeof et == "object" && (et = P(et)), bt && typeof bt == "object" && (bt = bt.ptr), Ut && typeof Ut == "object" && (Ut = Ut.ptr), R(ls(re, et, bt, Ut), B);
      }, rt.prototype.DecodeArrayToMesh = rt.prototype.DecodeArrayToMesh = function(et, bt, Ut) {
        var re = this.ptr;
        return Ie.prepare(), typeof et == "object" && (et = P(et)), bt && typeof bt == "object" && (bt = bt.ptr), Ut && typeof Ut == "object" && (Ut = Ut.ptr), R(br(re, et, bt, Ut), B);
      }, rt.prototype.GetAttributeId = rt.prototype.GetAttributeId = function(et, bt) {
        var Ut = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), bt && typeof bt == "object" && (bt = bt.ptr), Ci(Ut, et, bt);
      }, rt.prototype.GetAttributeIdByName = rt.prototype.GetAttributeIdByName = function(et, bt) {
        var Ut = this.ptr;
        return Ie.prepare(), et && typeof et == "object" && (et = et.ptr), bt = bt && typeof bt == "object" ? bt.ptr : M(bt), Yi(Ut, et, bt);
      }, rt.prototype.GetAttributeIdByMetadataEntry = rt.prototype.GetAttributeIdByMetadataEntry = function(et, bt, Ut) {
        var re = this.ptr;
        return Ie.prepare(), et && typeof et == "object" && (et = et.ptr), bt = bt && typeof bt == "object" ? bt.ptr : M(bt), Ut = Ut && typeof Ut == "object" ? Ut.ptr : M(Ut), _e(re, et, bt, Ut);
      }, rt.prototype.GetAttribute = rt.prototype.GetAttribute = function(et, bt) {
        var Ut = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), bt && typeof bt == "object" && (bt = bt.ptr), R(at(Ut, et, bt), A);
      }, rt.prototype.GetAttributeByUniqueId = rt.prototype.GetAttributeByUniqueId = function(et, bt) {
        var Ut = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), bt && typeof bt == "object" && (bt = bt.ptr), R(xt(Ut, et, bt), A);
      }, rt.prototype.GetMetadata = rt.prototype.GetMetadata = function(et) {
        var bt = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), R(Ot(bt, et), k);
      }, rt.prototype.GetAttributeMetadata = rt.prototype.GetAttributeMetadata = function(et, bt) {
        var Ut = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), bt && typeof bt == "object" && (bt = bt.ptr), R(Bt(Ut, et, bt), k);
      }, rt.prototype.GetFaceFromMesh = rt.prototype.GetFaceFromMesh = function(et, bt, Ut) {
        var re = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), bt && typeof bt == "object" && (bt = bt.ptr), Ut && typeof Ut == "object" && (Ut = Ut.ptr), !!Zt(re, et, bt, Ut);
      }, rt.prototype.GetTriangleStripsFromMesh = rt.prototype.GetTriangleStripsFromMesh = function(et, bt) {
        var Ut = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), bt && typeof bt == "object" && (bt = bt.ptr), pe(Ut, et, bt);
      }, rt.prototype.GetTrianglesUInt16Array = rt.prototype.GetTrianglesUInt16Array = function(et, bt, Ut) {
        var re = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), bt && typeof bt == "object" && (bt = bt.ptr), Ut && typeof Ut == "object" && (Ut = Ut.ptr), !!Ri(re, et, bt, Ut);
      }, rt.prototype.GetTrianglesUInt32Array = rt.prototype.GetTrianglesUInt32Array = function(et, bt, Ut) {
        var re = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), bt && typeof bt == "object" && (bt = bt.ptr), Ut && typeof Ut == "object" && (Ut = Ut.ptr), !!go(re, et, bt, Ut);
      }, rt.prototype.GetAttributeFloat = rt.prototype.GetAttributeFloat = function(et, bt, Ut) {
        var re = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), bt && typeof bt == "object" && (bt = bt.ptr), Ut && typeof Ut == "object" && (Ut = Ut.ptr), !!vo(re, et, bt, Ut);
      }, rt.prototype.GetAttributeFloatForAllPoints = rt.prototype.GetAttributeFloatForAllPoints = function(et, bt, Ut) {
        var re = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), bt && typeof bt == "object" && (bt = bt.ptr), Ut && typeof Ut == "object" && (Ut = Ut.ptr), !!Os(re, et, bt, Ut);
      }, rt.prototype.GetAttributeIntForAllPoints = rt.prototype.GetAttributeIntForAllPoints = function(et, bt, Ut) {
        var re = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), bt && typeof bt == "object" && (bt = bt.ptr), Ut && typeof Ut == "object" && (Ut = Ut.ptr), !!xo(re, et, bt, Ut);
      }, rt.prototype.GetAttributeInt8ForAllPoints = rt.prototype.GetAttributeInt8ForAllPoints = function(et, bt, Ut) {
        var re = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), bt && typeof bt == "object" && (bt = bt.ptr), Ut && typeof Ut == "object" && (Ut = Ut.ptr), !!bo(re, et, bt, Ut);
      }, rt.prototype.GetAttributeUInt8ForAllPoints = rt.prototype.GetAttributeUInt8ForAllPoints = function(et, bt, Ut) {
        var re = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), bt && typeof bt == "object" && (bt = bt.ptr), Ut && typeof Ut == "object" && (Ut = Ut.ptr), !!Ta(re, et, bt, Ut);
      }, rt.prototype.GetAttributeInt16ForAllPoints = rt.prototype.GetAttributeInt16ForAllPoints = function(et, bt, Ut) {
        var re = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), bt && typeof bt == "object" && (bt = bt.ptr), Ut && typeof Ut == "object" && (Ut = Ut.ptr), !!Eo(re, et, bt, Ut);
      }, rt.prototype.GetAttributeUInt16ForAllPoints = rt.prototype.GetAttributeUInt16ForAllPoints = function(et, bt, Ut) {
        var re = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), bt && typeof bt == "object" && (bt = bt.ptr), Ut && typeof Ut == "object" && (Ut = Ut.ptr), !!wo(re, et, bt, Ut);
      }, rt.prototype.GetAttributeInt32ForAllPoints = rt.prototype.GetAttributeInt32ForAllPoints = function(et, bt, Ut) {
        var re = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), bt && typeof bt == "object" && (bt = bt.ptr), Ut && typeof Ut == "object" && (Ut = Ut.ptr), !!Mo(re, et, bt, Ut);
      }, rt.prototype.GetAttributeUInt32ForAllPoints = rt.prototype.GetAttributeUInt32ForAllPoints = function(et, bt, Ut) {
        var re = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), bt && typeof bt == "object" && (bt = bt.ptr), Ut && typeof Ut == "object" && (Ut = Ut.ptr), !!So(re, et, bt, Ut);
      }, rt.prototype.GetAttributeDataArrayForAllPoints = rt.prototype.GetAttributeDataArrayForAllPoints = function(et, bt, Ut, re, Me) {
        var be = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), bt && typeof bt == "object" && (bt = bt.ptr), Ut && typeof Ut == "object" && (Ut = Ut.ptr), re && typeof re == "object" && (re = re.ptr), Me && typeof Me == "object" && (Me = Me.ptr), !!fs(be, et, bt, Ut, re, Me);
      }, rt.prototype.SkipAttributeTransform = rt.prototype.SkipAttributeTransform = function(et) {
        var bt = this.ptr;
        et && typeof et == "object" && (et = et.ptr), Ao(bt, et);
      }, rt.prototype.GetEncodedGeometryType_Deprecated = rt.prototype.GetEncodedGeometryType_Deprecated = function(et) {
        var bt = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), To(bt, et);
      }, rt.prototype.DecodeBufferToPointCloud = rt.prototype.DecodeBufferToPointCloud = function(et, bt) {
        var Ut = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), bt && typeof bt == "object" && (bt = bt.ptr), R(Co(Ut, et, bt), B);
      }, rt.prototype.DecodeBufferToMesh = rt.prototype.DecodeBufferToMesh = function(et, bt) {
        var Ut = this.ptr;
        return et && typeof et == "object" && (et = et.ptr), bt && typeof bt == "object" && (bt = bt.ptr), R(Ro(Ut, et, bt), B);
      }, rt.prototype.__destroy__ = rt.prototype.__destroy__ = function() {
        Io(this.ptr);
      }, function() {
        function et() {
          b.ATTRIBUTE_INVALID_TRANSFORM = Ds(), b.ATTRIBUTE_NO_TRANSFORM = Po(), b.ATTRIBUTE_QUANTIZATION_TRANSFORM = Lo(), b.ATTRIBUTE_OCTAHEDRON_TRANSFORM = Oo(), b.INVALID = Do(), b.POSITION = No(), b.NORMAL = Ns(), b.COLOR = Fo(), b.TEX_COORD = Uo(), b.GENERIC = Bo(), b.INVALID_GEOMETRY_TYPE = ko(), b.POINT_CLOUD = zo(), b.TRIANGULAR_MESH = Go(), b.DT_INVALID = Vo(), b.DT_INT8 = Ho(), b.DT_UINT8 = jo(), b.DT_INT16 = Wo(), b.DT_UINT16 = qo(), b.DT_INT32 = $o(), b.DT_UINT32 = Xo(), b.DT_INT64 = Yo(), b.DT_UINT64 = Ko(), b.DT_FLOAT32 = Zo(), b.DT_FLOAT64 = Ki(), b.DT_BOOL = Jo(), b.DT_TYPES_COUNT = Qo(), b.OK = tc(), b.DRACO_ERROR = ec(), b.IO_ERROR = nc(), b.INVALID_PARAMETER = ic(), b.UNSUPPORTED_VERSION = rc(), b.UNKNOWN_VERSION = sc();
        }
        ft ? et() : It.unshift(et);
      }(), typeof b.onModuleParsed == "function" && b.onModuleParsed(), b.Decoder.prototype.GetEncodedGeometryType = function(et) {
        if (et.__class__ && et.__class__ === b.DecoderBuffer)
          return b.Decoder.prototype.GetEncodedGeometryType_Deprecated(et);
        if (8 > et.byteLength)
          return b.INVALID_GEOMETRY_TYPE;
        switch (et[7]) {
          case 0:
            return b.POINT_CLOUD;
          case 1:
            return b.TRIANGULAR_MESH;
          default:
            return b.INVALID_GEOMETRY_TYPE;
        }
      }, s.ready;
    };
  }();
  n.exports = i;
})(d_);
var H3 = d_.exports, j3 = V3, W3 = H3, q3 = {
  createEncoderModule: j3,
  createDecoderModule: W3
}, m_ = { exports: {} };
(function(n, t) {
  (function(e) {
    n.exports = e();
  })(function() {
    return function e(i, r, s) {
      function a(h, l) {
        if (!r[h]) {
          if (!i[h]) {
            var f = typeof Ui == "function" && Ui;
            if (!l && f)
              return f(h, !0);
            if (o)
              return o(h, !0);
            throw new Error("Cannot find module '" + h + "'");
          }
          l = r[h] = { exports: {} }, i[h][0].call(l.exports, function(d) {
            var m = i[h][1][d];
            return a(m || d);
          }, l, l.exports, e, i, r, s);
        }
        return r[h].exports;
      }
      for (var o = typeof Ui == "function" && Ui, c = 0; c < s.length; c++)
        a(s[c]);
      return a;
    }({ 1: [function(e, i, r) {
      (function(s, a, o, c, h, l, f, d, m) {
        var v = e("crypto");
        function E(C, D) {
          D = R(C, D);
          var N;
          return (N = D.algorithm !== "passthrough" ? v.createHash(D.algorithm) : new W()).write === void 0 && (N.write = N.update, N.end = N.update), P(D, N).dispatch(C), N.update || N.end(""), N.digest ? N.digest(D.encoding === "buffer" ? void 0 : D.encoding) : (C = N.read(), D.encoding !== "buffer" ? C.toString(D.encoding) : C);
        }
        (r = i.exports = E).sha1 = function(C) {
          return E(C);
        }, r.keys = function(C) {
          return E(C, { excludeValues: !0, algorithm: "sha1", encoding: "hex" });
        }, r.MD5 = function(C) {
          return E(C, { algorithm: "md5", encoding: "hex" });
        }, r.keysMD5 = function(C) {
          return E(C, { algorithm: "md5", encoding: "hex", excludeValues: !0 });
        };
        var _ = v.getHashes ? v.getHashes().slice() : ["sha1", "md5"], p = (_.push("passthrough"), ["buffer", "hex", "binary", "base64"]);
        function R(C, D) {
          var N = {};
          if (N.algorithm = (D = D || {}).algorithm || "sha1", N.encoding = D.encoding || "hex", N.excludeValues = !!D.excludeValues, N.algorithm = N.algorithm.toLowerCase(), N.encoding = N.encoding.toLowerCase(), N.ignoreUnknown = D.ignoreUnknown === !0, N.respectType = D.respectType !== !1, N.respectFunctionNames = D.respectFunctionNames !== !1, N.respectFunctionProperties = D.respectFunctionProperties !== !1, N.unorderedArrays = D.unorderedArrays === !0, N.unorderedSets = D.unorderedSets !== !1, N.unorderedObjects = D.unorderedObjects !== !1, N.replacer = D.replacer || void 0, N.excludeKeys = D.excludeKeys || void 0, C === void 0)
            throw new Error("Object argument required.");
          for (var A = 0; A < _.length; ++A)
            _[A].toLowerCase() === N.algorithm.toLowerCase() && (N.algorithm = _[A]);
          if (_.indexOf(N.algorithm) === -1)
            throw new Error('Algorithm "' + N.algorithm + '"  not supported. supported values: ' + _.join(", "));
          if (p.indexOf(N.encoding) === -1 && N.algorithm !== "passthrough")
            throw new Error('Encoding "' + N.encoding + '"  not supported. supported values: ' + p.join(", "));
          return N;
        }
        function M(C) {
          if (typeof C == "function")
            return /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(C)) != null;
        }
        function P(C, D, N) {
          N = N || [];
          function A(I) {
            return D.update ? D.update(I, "utf8") : D.write(I, "utf8");
          }
          return { dispatch: function(I) {
            return this["_" + ((I = C.replacer ? C.replacer(I) : I) === null ? "null" : typeof I)](I);
          }, _object: function(I) {
            var it, V = Object.prototype.toString.call(I), mt = /\[object (.*)\]/i.exec(V);
            if (mt = (mt = mt ? mt[1] : "unknown:[" + V + "]").toLowerCase(), 0 <= (V = N.indexOf(I)))
              return this.dispatch("[CIRCULAR:" + V + "]");
            if (N.push(I), o !== void 0 && o.isBuffer && o.isBuffer(I))
              return A("buffer:"), A(I);
            if (mt === "object" || mt === "function" || mt === "asyncfunction")
              return V = Object.keys(I), C.unorderedObjects && (V = V.sort()), C.respectType === !1 || M(I) || V.splice(0, 0, "prototype", "__proto__", "constructor"), C.excludeKeys && (V = V.filter(function(k) {
                return !C.excludeKeys(k);
              })), A("object:" + V.length + ":"), it = this, V.forEach(function(k) {
                it.dispatch(k), A(":"), C.excludeValues || it.dispatch(I[k]), A(",");
              });
            if (!this["_" + mt]) {
              if (C.ignoreUnknown)
                return A("[" + mt + "]");
              throw new Error('Unknown object type "' + mt + '"');
            }
            this["_" + mt](I);
          }, _array: function(I, k) {
            k = k !== void 0 ? k : C.unorderedArrays !== !1;
            var V = this;
            if (A("array:" + I.length + ":"), !k || I.length <= 1)
              return I.forEach(function(B) {
                return V.dispatch(B);
              });
            var mt = [], k = I.map(function(B) {
              var G = new W(), H = N.slice();
              return P(C, G, H).dispatch(B), mt = mt.concat(H.slice(N.length)), G.read().toString();
            });
            return N = N.concat(mt), k.sort(), this._array(k, !1);
          }, _date: function(I) {
            return A("date:" + I.toJSON());
          }, _symbol: function(I) {
            return A("symbol:" + I.toString());
          }, _error: function(I) {
            return A("error:" + I.toString());
          }, _boolean: function(I) {
            return A("bool:" + I.toString());
          }, _string: function(I) {
            A("string:" + I.length + ":"), A(I.toString());
          }, _function: function(I) {
            A("fn:"), M(I) ? this.dispatch("[native]") : this.dispatch(I.toString()), C.respectFunctionNames !== !1 && this.dispatch("function-name:" + String(I.name)), C.respectFunctionProperties && this._object(I);
          }, _number: function(I) {
            return A("number:" + I.toString());
          }, _xml: function(I) {
            return A("xml:" + I.toString());
          }, _null: function() {
            return A("Null");
          }, _undefined: function() {
            return A("Undefined");
          }, _regexp: function(I) {
            return A("regex:" + I.toString());
          }, _uint8array: function(I) {
            return A("uint8array:"), this.dispatch(Array.prototype.slice.call(I));
          }, _uint8clampedarray: function(I) {
            return A("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(I));
          }, _int8array: function(I) {
            return A("int8array:"), this.dispatch(Array.prototype.slice.call(I));
          }, _uint16array: function(I) {
            return A("uint16array:"), this.dispatch(Array.prototype.slice.call(I));
          }, _int16array: function(I) {
            return A("int16array:"), this.dispatch(Array.prototype.slice.call(I));
          }, _uint32array: function(I) {
            return A("uint32array:"), this.dispatch(Array.prototype.slice.call(I));
          }, _int32array: function(I) {
            return A("int32array:"), this.dispatch(Array.prototype.slice.call(I));
          }, _float32array: function(I) {
            return A("float32array:"), this.dispatch(Array.prototype.slice.call(I));
          }, _float64array: function(I) {
            return A("float64array:"), this.dispatch(Array.prototype.slice.call(I));
          }, _arraybuffer: function(I) {
            return A("arraybuffer:"), this.dispatch(new Uint8Array(I));
          }, _url: function(I) {
            return A("url:" + I.toString());
          }, _map: function(I) {
            return A("map:"), I = Array.from(I), this._array(I, C.unorderedSets !== !1);
          }, _set: function(I) {
            return A("set:"), I = Array.from(I), this._array(I, C.unorderedSets !== !1);
          }, _file: function(I) {
            return A("file:"), this.dispatch([I.name, I.size, I.type, I.lastModfied]);
          }, _blob: function() {
            if (C.ignoreUnknown)
              return A("[blob]");
            throw Error(`Hashing Blob objects is currently not supported
(see https://github.com/puleos/object-hash/issues/26)
Use "options.replacer" or "options.ignoreUnknown"
`);
          }, _domwindow: function() {
            return A("domwindow");
          }, _bigint: function(I) {
            return A("bigint:" + I.toString());
          }, _process: function() {
            return A("process");
          }, _timer: function() {
            return A("timer");
          }, _pipe: function() {
            return A("pipe");
          }, _tcp: function() {
            return A("tcp");
          }, _udp: function() {
            return A("udp");
          }, _tty: function() {
            return A("tty");
          }, _statwatcher: function() {
            return A("statwatcher");
          }, _securecontext: function() {
            return A("securecontext");
          }, _connection: function() {
            return A("connection");
          }, _zlib: function() {
            return A("zlib");
          }, _context: function() {
            return A("context");
          }, _nodescript: function() {
            return A("nodescript");
          }, _httpparser: function() {
            return A("httpparser");
          }, _dataview: function() {
            return A("dataview");
          }, _signal: function() {
            return A("signal");
          }, _fsevent: function() {
            return A("fsevent");
          }, _tlswrap: function() {
            return A("tlswrap");
          } };
        }
        function W() {
          return { buf: "", write: function(C) {
            this.buf += C;
          }, end: function(C) {
            this.buf += C;
          }, read: function() {
            return this.buf;
          } };
        }
        r.writeToStream = function(C, D, N) {
          return N === void 0 && (N = D, D = {}), P(D = R(C, D), N).dispatch(C);
        };
      }).call(this, e("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_9a5aa49d.js", "/");
    }, { buffer: 3, crypto: 5, lYpoI2: 11 }], 2: [function(e, i, r) {
      (function(s, a, o, c, h, l, f, d, m) {
        (function(v) {
          var E = typeof Uint8Array < "u" ? Uint8Array : Array, _ = 43, p = 47, R = 48, M = 97, P = 65, W = 45, C = 95;
          function D(N) {
            return N = N.charCodeAt(0), N === _ || N === W ? 62 : N === p || N === C ? 63 : N < R ? -1 : N < R + 10 ? N - R + 26 + 26 : N < P + 26 ? N - P : N < M + 26 ? N - M + 26 : void 0;
          }
          v.toByteArray = function(N) {
            var A, I;
            if (0 < N.length % 4)
              throw new Error("Invalid string. Length must be a multiple of 4");
            var it = N.length, it = N.charAt(it - 2) === "=" ? 2 : N.charAt(it - 1) === "=" ? 1 : 0, V = new E(3 * N.length / 4 - it), mt = 0 < it ? N.length - 4 : N.length, k = 0;
            function B(G) {
              V[k++] = G;
            }
            for (A = 0; A < mt; A += 4, 0)
              B((16711680 & (I = D(N.charAt(A)) << 18 | D(N.charAt(A + 1)) << 12 | D(N.charAt(A + 2)) << 6 | D(N.charAt(A + 3)))) >> 16), B((65280 & I) >> 8), B(255 & I);
            return it == 2 ? B(255 & (I = D(N.charAt(A)) << 2 | D(N.charAt(A + 1)) >> 4)) : it == 1 && (B((I = D(N.charAt(A)) << 10 | D(N.charAt(A + 1)) << 4 | D(N.charAt(A + 2)) >> 2) >> 8 & 255), B(255 & I)), V;
          }, v.fromByteArray = function(N) {
            var A, I, it, V, mt = N.length % 3, k = "";
            function B(G) {
              return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(G);
            }
            for (A = 0, it = N.length - mt; A < it; A += 3)
              I = (N[A] << 16) + (N[A + 1] << 8) + N[A + 2], k += B((V = I) >> 18 & 63) + B(V >> 12 & 63) + B(V >> 6 & 63) + B(63 & V);
            switch (mt) {
              case 1:
                k = (k += B((I = N[N.length - 1]) >> 2)) + B(I << 4 & 63) + "==";
                break;
              case 2:
                k = (k = (k += B((I = (N[N.length - 2] << 8) + N[N.length - 1]) >> 10)) + B(I >> 4 & 63)) + B(I << 2 & 63) + "=";
            }
            return k;
          };
        })(r === void 0 ? this.base64js = {} : r);
      }).call(this, e("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib");
    }, { buffer: 3, lYpoI2: 11 }], 3: [function(e, i, r) {
      (function(s, a, _, c, h, l, f, d, m) {
        var v = e("base64-js"), E = e("ieee754");
        function _(L, j, Y) {
          if (!(this instanceof _))
            return new _(L, j, Y);
          var K, yt, Et, Ct, Lt = typeof L;
          if (j === "base64" && Lt == "string")
            for (L = (Ct = L).trim ? Ct.trim() : Ct.replace(/^\s+|\s+$/g, ""); L.length % 4 != 0; )
              L += "=";
          if (Lt == "number")
            K = w(L);
          else if (Lt == "string")
            K = _.byteLength(L, j);
          else {
            if (Lt != "object")
              throw new Error("First argument needs to be a number, array or string.");
            K = w(L.length);
          }
          if (_._useTypedArrays ? yt = _._augment(new Uint8Array(K)) : ((yt = this).length = K, yt._isBuffer = !0), _._useTypedArrays && typeof L.byteLength == "number")
            yt._set(L);
          else if (ut(Ct = L) || _.isBuffer(Ct) || Ct && typeof Ct == "object" && typeof Ct.length == "number")
            for (Et = 0; Et < K; Et++)
              _.isBuffer(L) ? yt[Et] = L.readUInt8(Et) : yt[Et] = L[Et];
          else if (Lt == "string")
            yt.write(L, 0, j);
          else if (Lt == "number" && !_._useTypedArrays && !Y)
            for (Et = 0; Et < K; Et++)
              yt[Et] = 0;
          return yt;
        }
        function p(L, j, Y, K) {
          return _._charsWritten = F(function(yt) {
            for (var Et = [], Ct = 0; Ct < yt.length; Ct++)
              Et.push(255 & yt.charCodeAt(Ct));
            return Et;
          }(j), L, Y, K);
        }
        function R(L, j, Y, K) {
          return _._charsWritten = F(function(yt) {
            for (var Et, Ct, Lt = [], Wt = 0; Wt < yt.length; Wt++)
              Ct = yt.charCodeAt(Wt), Et = Ct >> 8, Ct = Ct % 256, Lt.push(Ct), Lt.push(Et);
            return Lt;
          }(j), L, Y, K);
        }
        function M(L, j, Y) {
          var K = "";
          Y = Math.min(L.length, Y);
          for (var yt = j; yt < Y; yt++)
            K += String.fromCharCode(L[yt]);
          return K;
        }
        function P(L, j, Y, Et) {
          Et || (U(typeof Y == "boolean", "missing or invalid endian"), U(j != null, "missing offset"), U(j + 1 < L.length, "Trying to read beyond buffer length"));
          var yt, Et = L.length;
          if (!(Et <= j))
            return Y ? (yt = L[j], j + 1 < Et && (yt |= L[j + 1] << 8)) : (yt = L[j] << 8, j + 1 < Et && (yt |= L[j + 1])), yt;
        }
        function W(L, j, Y, Et) {
          Et || (U(typeof Y == "boolean", "missing or invalid endian"), U(j != null, "missing offset"), U(j + 3 < L.length, "Trying to read beyond buffer length"));
          var yt, Et = L.length;
          if (!(Et <= j))
            return Y ? (j + 2 < Et && (yt = L[j + 2] << 16), j + 1 < Et && (yt |= L[j + 1] << 8), yt |= L[j], j + 3 < Et && (yt += L[j + 3] << 24 >>> 0)) : (j + 1 < Et && (yt = L[j + 1] << 16), j + 2 < Et && (yt |= L[j + 2] << 8), j + 3 < Et && (yt |= L[j + 3]), yt += L[j] << 24 >>> 0), yt;
        }
        function C(L, j, Y, K) {
          if (K || (U(typeof Y == "boolean", "missing or invalid endian"), U(j != null, "missing offset"), U(j + 1 < L.length, "Trying to read beyond buffer length")), !(L.length <= j))
            return K = P(L, j, Y, !0), 32768 & K ? -1 * (65535 - K + 1) : K;
        }
        function D(L, j, Y, K) {
          if (K || (U(typeof Y == "boolean", "missing or invalid endian"), U(j != null, "missing offset"), U(j + 3 < L.length, "Trying to read beyond buffer length")), !(L.length <= j))
            return K = W(L, j, Y, !0), 2147483648 & K ? -1 * (4294967295 - K + 1) : K;
        }
        function N(L, j, Y, K) {
          return K || (U(typeof Y == "boolean", "missing or invalid endian"), U(j + 3 < L.length, "Trying to read beyond buffer length")), E.read(L, j, Y, 23, 4);
        }
        function A(L, j, Y, K) {
          return K || (U(typeof Y == "boolean", "missing or invalid endian"), U(j + 7 < L.length, "Trying to read beyond buffer length")), E.read(L, j, Y, 52, 8);
        }
        function I(L, j, Y, K, yt) {
          if (yt || (U(j != null, "missing value"), U(typeof K == "boolean", "missing or invalid endian"), U(Y != null, "missing offset"), U(Y + 1 < L.length, "trying to write beyond buffer length"), b(j, 65535)), yt = L.length, !(yt <= Y))
            for (var Et = 0, Ct = Math.min(yt - Y, 2); Et < Ct; Et++)
              L[Y + Et] = (j & 255 << 8 * (K ? Et : 1 - Et)) >>> 8 * (K ? Et : 1 - Et);
        }
        function it(L, j, Y, K, yt) {
          if (yt || (U(j != null, "missing value"), U(typeof K == "boolean", "missing or invalid endian"), U(Y != null, "missing offset"), U(Y + 3 < L.length, "trying to write beyond buffer length"), b(j, 4294967295)), yt = L.length, !(yt <= Y))
            for (var Et = 0, Ct = Math.min(yt - Y, 4); Et < Ct; Et++)
              L[Y + Et] = j >>> 8 * (K ? Et : 3 - Et) & 255;
        }
        function V(L, j, Y, K, yt) {
          yt || (U(j != null, "missing value"), U(typeof K == "boolean", "missing or invalid endian"), U(Y != null, "missing offset"), U(Y + 1 < L.length, "Trying to write beyond buffer length"), lt(j, 32767, -32768)), L.length <= Y || I(L, 0 <= j ? j : 65535 + j + 1, Y, K, yt);
        }
        function mt(L, j, Y, K, yt) {
          yt || (U(j != null, "missing value"), U(typeof K == "boolean", "missing or invalid endian"), U(Y != null, "missing offset"), U(Y + 3 < L.length, "Trying to write beyond buffer length"), lt(j, 2147483647, -2147483648)), L.length <= Y || it(L, 0 <= j ? j : 4294967295 + j + 1, Y, K, yt);
        }
        function k(L, j, Y, K, yt) {
          yt || (U(j != null, "missing value"), U(typeof K == "boolean", "missing or invalid endian"), U(Y != null, "missing offset"), U(Y + 3 < L.length, "Trying to write beyond buffer length"), q(j, 34028234663852886e22, -34028234663852886e22)), L.length <= Y || E.write(L, j, Y, K, 23, 4);
        }
        function B(L, j, Y, K, yt) {
          yt || (U(j != null, "missing value"), U(typeof K == "boolean", "missing or invalid endian"), U(Y != null, "missing offset"), U(Y + 7 < L.length, "Trying to write beyond buffer length"), q(j, 17976931348623157e292, -17976931348623157e292)), L.length <= Y || E.write(L, j, Y, K, 52, 8);
        }
        r.Buffer = _, r.SlowBuffer = _, r.INSPECT_MAX_BYTES = 50, _.poolSize = 8192, _._useTypedArrays = function() {
          try {
            var L = new ArrayBuffer(0), j = new Uint8Array(L);
            return j.foo = function() {
              return 42;
            }, j.foo() === 42 && typeof j.subarray == "function";
          } catch {
            return !1;
          }
        }(), _.isEncoding = function(L) {
          switch (String(L).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "raw":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return !0;
            default:
              return !1;
          }
        }, _.isBuffer = function(L) {
          return !(L == null || !L._isBuffer);
        }, _.byteLength = function(L, j) {
          var Y;
          switch (L += "", j || "utf8") {
            case "hex":
              Y = L.length / 2;
              break;
            case "utf8":
            case "utf-8":
              Y = _t(L).length;
              break;
            case "ascii":
            case "binary":
            case "raw":
              Y = L.length;
              break;
            case "base64":
              Y = vt(L).length;
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              Y = 2 * L.length;
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return Y;
        }, _.concat = function(L, j) {
          if (U(ut(L), `Usage: Buffer.concat(list, [totalLength])
list should be an Array.`), L.length === 0)
            return new _(0);
          if (L.length === 1)
            return L[0];
          if (typeof j != "number")
            for (yt = j = 0; yt < L.length; yt++)
              j += L[yt].length;
          for (var Y = new _(j), K = 0, yt = 0; yt < L.length; yt++) {
            var Et = L[yt];
            Et.copy(Y, K), K += Et.length;
          }
          return Y;
        }, _.prototype.write = function(L, j, Y, K) {
          isFinite(j) ? isFinite(Y) || (K = Y, Y = void 0) : (Wt = K, K = j, j = Y, Y = Wt), j = Number(j) || 0;
          var yt, Et, Ct, Lt, Wt = this.length - j;
          switch ((!Y || Wt < (Y = Number(Y))) && (Y = Wt), K = String(K || "utf8").toLowerCase()) {
            case "hex":
              yt = function(wt, Q, y, g) {
                y = Number(y) || 0;
                var S = wt.length - y;
                (!g || S < (g = Number(g))) && (g = S), U((S = Q.length) % 2 == 0, "Invalid hex string"), S / 2 < g && (g = S / 2);
                for (var O = 0; O < g; O++) {
                  var Z = parseInt(Q.substr(2 * O, 2), 16);
                  U(!isNaN(Z), "Invalid hex string"), wt[y + O] = Z;
                }
                return _._charsWritten = 2 * O, O;
              }(this, L, j, Y);
              break;
            case "utf8":
            case "utf-8":
              Et = this, Ct = j, Lt = Y, yt = _._charsWritten = F(_t(L), Et, Ct, Lt);
              break;
            case "ascii":
            case "binary":
              yt = p(this, L, j, Y);
              break;
            case "base64":
              Et = this, Ct = j, Lt = Y, yt = _._charsWritten = F(vt(L), Et, Ct, Lt);
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              yt = R(this, L, j, Y);
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return yt;
        }, _.prototype.toString = function(L, j, Y) {
          var K, yt, Et, Ct, Lt = this;
          if (L = String(L || "utf8").toLowerCase(), j = Number(j) || 0, (Y = Y !== void 0 ? Number(Y) : Lt.length) === j)
            return "";
          switch (L) {
            case "hex":
              K = function(Wt, wt, Q) {
                var y = Wt.length;
                (!wt || wt < 0) && (wt = 0), (!Q || Q < 0 || y < Q) && (Q = y);
                for (var g = "", S = wt; S < Q; S++)
                  g += pt(Wt[S]);
                return g;
              }(Lt, j, Y);
              break;
            case "utf8":
            case "utf-8":
              K = function(Wt, wt, Q) {
                var y = "", g = "";
                Q = Math.min(Wt.length, Q);
                for (var S = wt; S < Q; S++)
                  Wt[S] <= 127 ? (y += rt(g) + String.fromCharCode(Wt[S]), g = "") : g += "%" + Wt[S].toString(16);
                return y + rt(g);
              }(Lt, j, Y);
              break;
            case "ascii":
            case "binary":
              K = M(Lt, j, Y);
              break;
            case "base64":
              yt = Lt, Ct = Y, K = (Et = j) === 0 && Ct === yt.length ? v.fromByteArray(yt) : v.fromByteArray(yt.slice(Et, Ct));
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              K = function(Wt, wt, Q) {
                for (var y = Wt.slice(wt, Q), g = "", S = 0; S < y.length; S += 2)
                  g += String.fromCharCode(y[S] + 256 * y[S + 1]);
                return g;
              }(Lt, j, Y);
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return K;
        }, _.prototype.toJSON = function() {
          return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
        }, _.prototype.copy = function(L, j, Y, K) {
          if (j = j || 0, (K = K || K === 0 ? K : this.length) !== (Y = Y || 0) && L.length !== 0 && this.length !== 0) {
            U(Y <= K, "sourceEnd < sourceStart"), U(0 <= j && j < L.length, "targetStart out of bounds"), U(0 <= Y && Y < this.length, "sourceStart out of bounds"), U(0 <= K && K <= this.length, "sourceEnd out of bounds"), K > this.length && (K = this.length);
            var yt = (K = L.length - j < K - Y ? L.length - j + Y : K) - Y;
            if (yt < 100 || !_._useTypedArrays)
              for (var Et = 0; Et < yt; Et++)
                L[Et + j] = this[Et + Y];
            else
              L._set(this.subarray(Y, Y + yt), j);
          }
        }, _.prototype.slice = function(L, j) {
          var Y = this.length;
          if (L = H(L, Y, 0), j = H(j, Y, Y), _._useTypedArrays)
            return _._augment(this.subarray(L, j));
          for (var K = j - L, yt = new _(K, void 0, !0), Et = 0; Et < K; Et++)
            yt[Et] = this[Et + L];
          return yt;
        }, _.prototype.get = function(L) {
          return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(L);
        }, _.prototype.set = function(L, j) {
          return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(L, j);
        }, _.prototype.readUInt8 = function(L, j) {
          if (j || (U(L != null, "missing offset"), U(L < this.length, "Trying to read beyond buffer length")), !(L >= this.length))
            return this[L];
        }, _.prototype.readUInt16LE = function(L, j) {
          return P(this, L, !0, j);
        }, _.prototype.readUInt16BE = function(L, j) {
          return P(this, L, !1, j);
        }, _.prototype.readUInt32LE = function(L, j) {
          return W(this, L, !0, j);
        }, _.prototype.readUInt32BE = function(L, j) {
          return W(this, L, !1, j);
        }, _.prototype.readInt8 = function(L, j) {
          if (j || (U(L != null, "missing offset"), U(L < this.length, "Trying to read beyond buffer length")), !(L >= this.length))
            return 128 & this[L] ? -1 * (255 - this[L] + 1) : this[L];
        }, _.prototype.readInt16LE = function(L, j) {
          return C(this, L, !0, j);
        }, _.prototype.readInt16BE = function(L, j) {
          return C(this, L, !1, j);
        }, _.prototype.readInt32LE = function(L, j) {
          return D(this, L, !0, j);
        }, _.prototype.readInt32BE = function(L, j) {
          return D(this, L, !1, j);
        }, _.prototype.readFloatLE = function(L, j) {
          return N(this, L, !0, j);
        }, _.prototype.readFloatBE = function(L, j) {
          return N(this, L, !1, j);
        }, _.prototype.readDoubleLE = function(L, j) {
          return A(this, L, !0, j);
        }, _.prototype.readDoubleBE = function(L, j) {
          return A(this, L, !1, j);
        }, _.prototype.writeUInt8 = function(L, j, Y) {
          Y || (U(L != null, "missing value"), U(j != null, "missing offset"), U(j < this.length, "trying to write beyond buffer length"), b(L, 255)), j >= this.length || (this[j] = L);
        }, _.prototype.writeUInt16LE = function(L, j, Y) {
          I(this, L, j, !0, Y);
        }, _.prototype.writeUInt16BE = function(L, j, Y) {
          I(this, L, j, !1, Y);
        }, _.prototype.writeUInt32LE = function(L, j, Y) {
          it(this, L, j, !0, Y);
        }, _.prototype.writeUInt32BE = function(L, j, Y) {
          it(this, L, j, !1, Y);
        }, _.prototype.writeInt8 = function(L, j, Y) {
          Y || (U(L != null, "missing value"), U(j != null, "missing offset"), U(j < this.length, "Trying to write beyond buffer length"), lt(L, 127, -128)), j >= this.length || (0 <= L ? this.writeUInt8(L, j, Y) : this.writeUInt8(255 + L + 1, j, Y));
        }, _.prototype.writeInt16LE = function(L, j, Y) {
          V(this, L, j, !0, Y);
        }, _.prototype.writeInt16BE = function(L, j, Y) {
          V(this, L, j, !1, Y);
        }, _.prototype.writeInt32LE = function(L, j, Y) {
          mt(this, L, j, !0, Y);
        }, _.prototype.writeInt32BE = function(L, j, Y) {
          mt(this, L, j, !1, Y);
        }, _.prototype.writeFloatLE = function(L, j, Y) {
          k(this, L, j, !0, Y);
        }, _.prototype.writeFloatBE = function(L, j, Y) {
          k(this, L, j, !1, Y);
        }, _.prototype.writeDoubleLE = function(L, j, Y) {
          B(this, L, j, !0, Y);
        }, _.prototype.writeDoubleBE = function(L, j, Y) {
          B(this, L, j, !1, Y);
        }, _.prototype.fill = function(L, j, Y) {
          if (j = j || 0, Y = Y || this.length, U(typeof (L = typeof (L = L || 0) == "string" ? L.charCodeAt(0) : L) == "number" && !isNaN(L), "value is not a number"), U(j <= Y, "end < start"), Y !== j && this.length !== 0) {
            U(0 <= j && j < this.length, "start out of bounds"), U(0 <= Y && Y <= this.length, "end out of bounds");
            for (var K = j; K < Y; K++)
              this[K] = L;
          }
        }, _.prototype.inspect = function() {
          for (var L = [], j = this.length, Y = 0; Y < j; Y++)
            if (L[Y] = pt(this[Y]), Y === r.INSPECT_MAX_BYTES) {
              L[Y + 1] = "...";
              break;
            }
          return "<Buffer " + L.join(" ") + ">";
        }, _.prototype.toArrayBuffer = function() {
          if (typeof Uint8Array > "u")
            throw new Error("Buffer.toArrayBuffer not supported in this browser");
          if (_._useTypedArrays)
            return new _(this).buffer;
          for (var L = new Uint8Array(this.length), j = 0, Y = L.length; j < Y; j += 1)
            L[j] = this[j];
          return L.buffer;
        };
        var G = _.prototype;
        function H(L, j, Y) {
          return typeof L != "number" ? Y : j <= (L = ~~L) ? j : 0 <= L || 0 <= (L += j) ? L : 0;
        }
        function w(L) {
          return (L = ~~Math.ceil(+L)) < 0 ? 0 : L;
        }
        function ut(L) {
          return (Array.isArray || function(j) {
            return Object.prototype.toString.call(j) === "[object Array]";
          })(L);
        }
        function pt(L) {
          return L < 16 ? "0" + L.toString(16) : L.toString(16);
        }
        function _t(L) {
          for (var j = [], Y = 0; Y < L.length; Y++) {
            var K = L.charCodeAt(Y);
            if (K <= 127)
              j.push(L.charCodeAt(Y));
            else
              for (var yt = Y, Et = (55296 <= K && K <= 57343 && Y++, encodeURIComponent(L.slice(yt, Y + 1)).substr(1).split("%")), Ct = 0; Ct < Et.length; Ct++)
                j.push(parseInt(Et[Ct], 16));
          }
          return j;
        }
        function vt(L) {
          return v.toByteArray(L);
        }
        function F(L, j, Y, K) {
          for (var yt = 0; yt < K && !(yt + Y >= j.length || yt >= L.length); yt++)
            j[yt + Y] = L[yt];
          return yt;
        }
        function rt(L) {
          try {
            return decodeURIComponent(L);
          } catch {
            return "�";
          }
        }
        function b(L, j) {
          U(typeof L == "number", "cannot write a non-number as a number"), U(0 <= L, "specified a negative value for writing an unsigned value"), U(L <= j, "value is larger than maximum value for type"), U(Math.floor(L) === L, "value has a fractional component");
        }
        function lt(L, j, Y) {
          U(typeof L == "number", "cannot write a non-number as a number"), U(L <= j, "value larger than maximum allowed value"), U(Y <= L, "value smaller than minimum allowed value"), U(Math.floor(L) === L, "value has a fractional component");
        }
        function q(L, j, Y) {
          U(typeof L == "number", "cannot write a non-number as a number"), U(L <= j, "value larger than maximum allowed value"), U(Y <= L, "value smaller than minimum allowed value");
        }
        function U(L, j) {
          if (!L)
            throw new Error(j || "Failed assertion");
        }
        _._augment = function(L) {
          return L._isBuffer = !0, L._get = L.get, L._set = L.set, L.get = G.get, L.set = G.set, L.write = G.write, L.toString = G.toString, L.toLocaleString = G.toString, L.toJSON = G.toJSON, L.copy = G.copy, L.slice = G.slice, L.readUInt8 = G.readUInt8, L.readUInt16LE = G.readUInt16LE, L.readUInt16BE = G.readUInt16BE, L.readUInt32LE = G.readUInt32LE, L.readUInt32BE = G.readUInt32BE, L.readInt8 = G.readInt8, L.readInt16LE = G.readInt16LE, L.readInt16BE = G.readInt16BE, L.readInt32LE = G.readInt32LE, L.readInt32BE = G.readInt32BE, L.readFloatLE = G.readFloatLE, L.readFloatBE = G.readFloatBE, L.readDoubleLE = G.readDoubleLE, L.readDoubleBE = G.readDoubleBE, L.writeUInt8 = G.writeUInt8, L.writeUInt16LE = G.writeUInt16LE, L.writeUInt16BE = G.writeUInt16BE, L.writeUInt32LE = G.writeUInt32LE, L.writeUInt32BE = G.writeUInt32BE, L.writeInt8 = G.writeInt8, L.writeInt16LE = G.writeInt16LE, L.writeInt16BE = G.writeInt16BE, L.writeInt32LE = G.writeInt32LE, L.writeInt32BE = G.writeInt32BE, L.writeFloatLE = G.writeFloatLE, L.writeFloatBE = G.writeFloatBE, L.writeDoubleLE = G.writeDoubleLE, L.writeDoubleBE = G.writeDoubleBE, L.fill = G.fill, L.inspect = G.inspect, L.toArrayBuffer = G.toArrayBuffer, L;
        };
      }).call(this, e("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer");
    }, { "base64-js": 2, buffer: 3, ieee754: 10, lYpoI2: 11 }], 4: [function(e, i, r) {
      (function(s, a, v, c, h, l, f, d, m) {
        var v = e("buffer").Buffer, E = 4, _ = new v(E);
        _.fill(0), i.exports = { hash: function(p, R, M, P) {
          for (var W = R(function(I, it) {
            I.length % E != 0 && (V = I.length + (E - I.length % E), I = v.concat([I, _], V));
            for (var V, mt = [], k = it ? I.readInt32BE : I.readInt32LE, B = 0; B < I.length; B += E)
              mt.push(k.call(I, B));
            return mt;
          }(p = v.isBuffer(p) ? p : new v(p), P), 8 * p.length), R = P, C = new v(M), D = R ? C.writeInt32BE : C.writeInt32LE, N = 0; N < W.length; N++)
            D.call(C, W[N], 4 * N, !0);
          return C;
        } };
      }).call(this, e("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { buffer: 3, lYpoI2: 11 }], 5: [function(e, i, r) {
      (function(s, a, v, c, h, l, f, d, m) {
        var v = e("buffer").Buffer, E = e("./sha"), _ = e("./sha256"), p = e("./rng"), R = { sha1: E, sha256: _, md5: e("./md5") }, M = 64, P = new v(M);
        function W(I, it) {
          var V = R[I = I || "sha1"], mt = [];
          return V || C("algorithm:", I, "is not yet supported"), { update: function(k) {
            return v.isBuffer(k) || (k = new v(k)), mt.push(k), k.length, this;
          }, digest: function(k) {
            var B = v.concat(mt), B = it ? function(G, H, w) {
              v.isBuffer(H) || (H = new v(H)), v.isBuffer(w) || (w = new v(w)), H.length > M ? H = G(H) : H.length < M && (H = v.concat([H, P], M));
              for (var ut = new v(M), pt = new v(M), _t = 0; _t < M; _t++)
                ut[_t] = 54 ^ H[_t], pt[_t] = 92 ^ H[_t];
              return w = G(v.concat([ut, w])), G(v.concat([pt, w]));
            }(V, it, B) : V(B);
            return mt = null, k ? B.toString(k) : B;
          } };
        }
        function C() {
          var I = [].slice.call(arguments).join(" ");
          throw new Error([I, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join(`
`));
        }
        P.fill(0), r.createHash = function(I) {
          return W(I);
        }, r.createHmac = W, r.randomBytes = function(I, it) {
          if (!it || !it.call)
            return new v(p(I));
          try {
            it.call(this, void 0, new v(p(I)));
          } catch (V) {
            it(V);
          }
        };
        var D, N = ["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], A = function(I) {
          r[I] = function() {
            C("sorry,", I, "is not implemented yet");
          };
        };
        for (D in N)
          A(N[D]);
      }).call(this, e("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./md5": 6, "./rng": 7, "./sha": 8, "./sha256": 9, buffer: 3, lYpoI2: 11 }], 6: [function(e, i, r) {
      (function(s, a, o, c, h, l, f, d, m) {
        var v = e("./helpers");
        function E(C, D) {
          C[D >> 5] |= 128 << D % 32, C[14 + (D + 64 >>> 9 << 4)] = D;
          for (var N = 1732584193, A = -271733879, I = -1732584194, it = 271733878, V = 0; V < C.length; V += 16) {
            var mt = N, k = A, B = I, G = it, N = p(N, A, I, it, C[V + 0], 7, -680876936), it = p(it, N, A, I, C[V + 1], 12, -389564586), I = p(I, it, N, A, C[V + 2], 17, 606105819), A = p(A, I, it, N, C[V + 3], 22, -1044525330);
            N = p(N, A, I, it, C[V + 4], 7, -176418897), it = p(it, N, A, I, C[V + 5], 12, 1200080426), I = p(I, it, N, A, C[V + 6], 17, -1473231341), A = p(A, I, it, N, C[V + 7], 22, -45705983), N = p(N, A, I, it, C[V + 8], 7, 1770035416), it = p(it, N, A, I, C[V + 9], 12, -1958414417), I = p(I, it, N, A, C[V + 10], 17, -42063), A = p(A, I, it, N, C[V + 11], 22, -1990404162), N = p(N, A, I, it, C[V + 12], 7, 1804603682), it = p(it, N, A, I, C[V + 13], 12, -40341101), I = p(I, it, N, A, C[V + 14], 17, -1502002290), N = R(N, A = p(A, I, it, N, C[V + 15], 22, 1236535329), I, it, C[V + 1], 5, -165796510), it = R(it, N, A, I, C[V + 6], 9, -1069501632), I = R(I, it, N, A, C[V + 11], 14, 643717713), A = R(A, I, it, N, C[V + 0], 20, -373897302), N = R(N, A, I, it, C[V + 5], 5, -701558691), it = R(it, N, A, I, C[V + 10], 9, 38016083), I = R(I, it, N, A, C[V + 15], 14, -660478335), A = R(A, I, it, N, C[V + 4], 20, -405537848), N = R(N, A, I, it, C[V + 9], 5, 568446438), it = R(it, N, A, I, C[V + 14], 9, -1019803690), I = R(I, it, N, A, C[V + 3], 14, -187363961), A = R(A, I, it, N, C[V + 8], 20, 1163531501), N = R(N, A, I, it, C[V + 13], 5, -1444681467), it = R(it, N, A, I, C[V + 2], 9, -51403784), I = R(I, it, N, A, C[V + 7], 14, 1735328473), N = M(N, A = R(A, I, it, N, C[V + 12], 20, -1926607734), I, it, C[V + 5], 4, -378558), it = M(it, N, A, I, C[V + 8], 11, -2022574463), I = M(I, it, N, A, C[V + 11], 16, 1839030562), A = M(A, I, it, N, C[V + 14], 23, -35309556), N = M(N, A, I, it, C[V + 1], 4, -1530992060), it = M(it, N, A, I, C[V + 4], 11, 1272893353), I = M(I, it, N, A, C[V + 7], 16, -155497632), A = M(A, I, it, N, C[V + 10], 23, -1094730640), N = M(N, A, I, it, C[V + 13], 4, 681279174), it = M(it, N, A, I, C[V + 0], 11, -358537222), I = M(I, it, N, A, C[V + 3], 16, -722521979), A = M(A, I, it, N, C[V + 6], 23, 76029189), N = M(N, A, I, it, C[V + 9], 4, -640364487), it = M(it, N, A, I, C[V + 12], 11, -421815835), I = M(I, it, N, A, C[V + 15], 16, 530742520), N = P(N, A = M(A, I, it, N, C[V + 2], 23, -995338651), I, it, C[V + 0], 6, -198630844), it = P(it, N, A, I, C[V + 7], 10, 1126891415), I = P(I, it, N, A, C[V + 14], 15, -1416354905), A = P(A, I, it, N, C[V + 5], 21, -57434055), N = P(N, A, I, it, C[V + 12], 6, 1700485571), it = P(it, N, A, I, C[V + 3], 10, -1894986606), I = P(I, it, N, A, C[V + 10], 15, -1051523), A = P(A, I, it, N, C[V + 1], 21, -2054922799), N = P(N, A, I, it, C[V + 8], 6, 1873313359), it = P(it, N, A, I, C[V + 15], 10, -30611744), I = P(I, it, N, A, C[V + 6], 15, -1560198380), A = P(A, I, it, N, C[V + 13], 21, 1309151649), N = P(N, A, I, it, C[V + 4], 6, -145523070), it = P(it, N, A, I, C[V + 11], 10, -1120210379), I = P(I, it, N, A, C[V + 2], 15, 718787259), A = P(A, I, it, N, C[V + 9], 21, -343485551), N = W(N, mt), A = W(A, k), I = W(I, B), it = W(it, G);
          }
          return Array(N, A, I, it);
        }
        function _(C, D, N, A, I, it) {
          return W((D = W(W(D, C), W(A, it))) << I | D >>> 32 - I, N);
        }
        function p(C, D, N, A, I, it, V) {
          return _(D & N | ~D & A, C, D, I, it, V);
        }
        function R(C, D, N, A, I, it, V) {
          return _(D & A | N & ~A, C, D, I, it, V);
        }
        function M(C, D, N, A, I, it, V) {
          return _(D ^ N ^ A, C, D, I, it, V);
        }
        function P(C, D, N, A, I, it, V) {
          return _(N ^ (D | ~A), C, D, I, it, V);
        }
        function W(C, D) {
          var N = (65535 & C) + (65535 & D);
          return (C >> 16) + (D >> 16) + (N >> 16) << 16 | 65535 & N;
        }
        i.exports = function(C) {
          return v.hash(C, E, 16);
        };
      }).call(this, e("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 7: [function(e, i, r) {
      (function(s, a, o, c, h, l, f, d, m) {
        i.exports = function(v) {
          for (var E, _ = new Array(v), p = 0; p < v; p++)
            !(3 & p) && (E = 4294967296 * Math.random()), _[p] = E >>> ((3 & p) << 3) & 255;
          return _;
        };
      }).call(this, e("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { buffer: 3, lYpoI2: 11 }], 8: [function(e, i, r) {
      (function(s, a, o, c, h, l, f, d, m) {
        var v = e("./helpers");
        function E(R, M) {
          R[M >> 5] |= 128 << 24 - M % 32, R[15 + (M + 64 >> 9 << 4)] = M;
          for (var P, W, C, D = Array(80), N = 1732584193, A = -271733879, I = -1732584194, it = 271733878, V = -1009589776, mt = 0; mt < R.length; mt += 16) {
            for (var k = N, B = A, G = I, H = it, w = V, ut = 0; ut < 80; ut++) {
              D[ut] = ut < 16 ? R[mt + ut] : p(D[ut - 3] ^ D[ut - 8] ^ D[ut - 14] ^ D[ut - 16], 1);
              var pt = _(_(p(N, 5), (pt = A, W = I, C = it, (P = ut) < 20 ? pt & W | ~pt & C : !(P < 40) && P < 60 ? pt & W | pt & C | W & C : pt ^ W ^ C)), _(_(V, D[ut]), (P = ut) < 20 ? 1518500249 : P < 40 ? 1859775393 : P < 60 ? -1894007588 : -899497514)), V = it, it = I, I = p(A, 30), A = N, N = pt;
            }
            N = _(N, k), A = _(A, B), I = _(I, G), it = _(it, H), V = _(V, w);
          }
          return Array(N, A, I, it, V);
        }
        function _(R, M) {
          var P = (65535 & R) + (65535 & M);
          return (R >> 16) + (M >> 16) + (P >> 16) << 16 | 65535 & P;
        }
        function p(R, M) {
          return R << M | R >>> 32 - M;
        }
        i.exports = function(R) {
          return v.hash(R, E, 20, !0);
        };
      }).call(this, e("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 9: [function(e, i, r) {
      (function(s, a, o, c, h, l, f, d, m) {
        function v(M, P) {
          var W = (65535 & M) + (65535 & P);
          return (M >> 16) + (P >> 16) + (W >> 16) << 16 | 65535 & W;
        }
        function E(M, P) {
          var W, C = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298), D = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225), N = new Array(64);
          M[P >> 5] |= 128 << 24 - P % 32, M[15 + (P + 64 >> 9 << 4)] = P;
          for (var A, I, it = 0; it < M.length; it += 16) {
            for (var V = D[0], mt = D[1], k = D[2], B = D[3], G = D[4], H = D[5], w = D[6], ut = D[7], pt = 0; pt < 64; pt++)
              N[pt] = pt < 16 ? M[pt + it] : v(v(v((I = N[pt - 2], p(I, 17) ^ p(I, 19) ^ R(I, 10)), N[pt - 7]), (I = N[pt - 15], p(I, 7) ^ p(I, 18) ^ R(I, 3))), N[pt - 16]), W = v(v(v(v(ut, p(I = G, 6) ^ p(I, 11) ^ p(I, 25)), G & H ^ ~G & w), C[pt]), N[pt]), A = v(p(A = V, 2) ^ p(A, 13) ^ p(A, 22), V & mt ^ V & k ^ mt & k), ut = w, w = H, H = G, G = v(B, W), B = k, k = mt, mt = V, V = v(W, A);
            D[0] = v(V, D[0]), D[1] = v(mt, D[1]), D[2] = v(k, D[2]), D[3] = v(B, D[3]), D[4] = v(G, D[4]), D[5] = v(H, D[5]), D[6] = v(w, D[6]), D[7] = v(ut, D[7]);
          }
          return D;
        }
        var _ = e("./helpers"), p = function(M, P) {
          return M >>> P | M << 32 - P;
        }, R = function(M, P) {
          return M >>> P;
        };
        i.exports = function(M) {
          return _.hash(M, E, 32, !0);
        };
      }).call(this, e("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 10: [function(e, i, r) {
      (function(s, a, o, c, h, l, f, d, m) {
        r.read = function(v, E, _, p, it) {
          var M, P, W = 8 * it - p - 1, C = (1 << W) - 1, D = C >> 1, N = -7, A = _ ? it - 1 : 0, I = _ ? -1 : 1, it = v[E + A];
          for (A += I, M = it & (1 << -N) - 1, it >>= -N, N += W; 0 < N; M = 256 * M + v[E + A], A += I, N -= 8)
            ;
          for (P = M & (1 << -N) - 1, M >>= -N, N += p; 0 < N; P = 256 * P + v[E + A], A += I, N -= 8)
            ;
          if (M === 0)
            M = 1 - D;
          else {
            if (M === C)
              return P ? NaN : 1 / 0 * (it ? -1 : 1);
            P += Math.pow(2, p), M -= D;
          }
          return (it ? -1 : 1) * P * Math.pow(2, M - p);
        }, r.write = function(v, E, _, p, R, V) {
          var P, W, C = 8 * V - R - 1, D = (1 << C) - 1, N = D >> 1, A = R === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, I = p ? 0 : V - 1, it = p ? 1 : -1, V = E < 0 || E === 0 && 1 / E < 0 ? 1 : 0;
          for (E = Math.abs(E), isNaN(E) || E === 1 / 0 ? (W = isNaN(E) ? 1 : 0, P = D) : (P = Math.floor(Math.log(E) / Math.LN2), E * (p = Math.pow(2, -P)) < 1 && (P--, p *= 2), 2 <= (E += 1 <= P + N ? A / p : A * Math.pow(2, 1 - N)) * p && (P++, p /= 2), D <= P + N ? (W = 0, P = D) : 1 <= P + N ? (W = (E * p - 1) * Math.pow(2, R), P += N) : (W = E * Math.pow(2, N - 1) * Math.pow(2, R), P = 0)); 8 <= R; v[_ + I] = 255 & W, I += it, W /= 256, R -= 8)
            ;
          for (P = P << R | W, C += R; 0 < C; v[_ + I] = 255 & P, I += it, P /= 256, C -= 8)
            ;
          v[_ + I - it] |= 128 * V;
        };
      }).call(this, e("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/ieee754/index.js", "/node_modules/gulp-browserify/node_modules/ieee754");
    }, { buffer: 3, lYpoI2: 11 }], 11: [function(e, i, r) {
      (function(s, a, o, c, h, l, f, d, m) {
        var v, E, _;
        function p() {
        }
        (s = i.exports = {}).nextTick = (E = typeof window < "u" && window.setImmediate, _ = typeof window < "u" && window.postMessage && window.addEventListener, E ? function(R) {
          return window.setImmediate(R);
        } : _ ? (v = [], window.addEventListener("message", function(R) {
          var M = R.source;
          M !== window && M !== null || R.data !== "process-tick" || (R.stopPropagation(), 0 < v.length && v.shift()());
        }, !0), function(R) {
          v.push(R), window.postMessage("process-tick", "*");
        }) : function(R) {
          setTimeout(R, 0);
        }), s.title = "browser", s.browser = !0, s.env = {}, s.argv = [], s.on = p, s.addListener = p, s.once = p, s.off = p, s.removeListener = p, s.removeAllListeners = p, s.emit = p, s.binding = function(R) {
          throw new Error("process.binding is not supported");
        }, s.cwd = function() {
          return "/";
        }, s.chdir = function(R) {
          throw new Error("process.chdir is not supported");
        };
      }).call(this, e("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process");
    }, { buffer: 3, lYpoI2: 11 }] }, {}, [1])(1);
  });
})(m_);
var __ = m_.exports;
const Rf = Be, Kp = mo, $3 = Ma, Zp = Rf.defined, sr = Rf.RuntimeError, Ga = Rf.WebGLConstants;
var X3 = Y3;
function Y3(n, t, e, i, r, s) {
  let a, o;
  const c = n.accessors[t.indices];
  if (c.count = e.numberOfFaces * 3, i) {
    a = new s.Decoder(), o = K3(
      s,
      a,
      e.buffer
    );
    const l = Z3(
      c,
      s,
      a,
      o,
      e.numberOfFaces
    );
    c.bufferView = Kp(n, l), c.byteOffset = 0;
  }
  const h = t.extensions.KHR_draco_mesh_compression.attributes;
  for (const l in h)
    if (Object.prototype.hasOwnProperty.call(h, l)) {
      const f = n.accessors[t.attributes[l]];
      if (f.count = e.numberOfPoints, i) {
        const d = a.GetAttributeByUniqueId(
          o,
          h[l]
        ), m = J3(
          s,
          a,
          o,
          d
        );
        f.min = m.minValues, f.max = m.maxValues, f.bufferView = Kp(
          n,
          m.attributeBuffer
        ), f.byteOffset = 0;
      } else if (Zp(f.min) && Zp(f.max)) {
        const d = Q3(
          l,
          f,
          r
        );
        f.min = d.min, f.max = d.max;
      }
    }
  return i && (s.destroy(o), s.destroy(a)), n;
}
function K3(n, t, e) {
  const i = new Uint8Array(e.buffer), r = new n.DecoderBuffer();
  if (r.Init(i, i.length), t.GetEncodedGeometryType(r) !== n.TRIANGULAR_MESH)
    throw n.destroy(t), new sr("Compressed data is not a mesh.");
  const a = new n.Mesh(), o = t.DecodeBufferToMesh(r, a);
  if (!o.ok() || a.ptr === 0)
    throw n.destroy(t), new sr(
      `Draco decoding failed: ${o.error_msg()}`
    );
  return n.destroy(r), a;
}
function Z3(n, t, e, i, r) {
  const s = r * 3;
  let a;
  n.componentType === Ga.BYTE ? a = new Int8Array(s) : n.componentType === Ga.UNSIGNED_BYTE ? a = new Uint8Array(s) : n.componentType === Ga.SHORT ? a = new Int16Array(s) : n.componentType === Ga.UNSIGNED_SHORT ? a = new Uint16Array(s) : a = new Uint32Array(s);
  const o = new t.DracoInt32Array();
  for (let h = 0; h < r; ++h) {
    e.GetFaceFromMesh(i, h, o);
    const l = h * 3;
    a[l] = o.GetValue(0), a[l + 1] = o.GetValue(1), a[l + 2] = o.GetValue(2);
  }
  return t.destroy(o), Buffer.from(a.buffer);
}
function J3(n, t, e, i) {
  const r = i.num_components(), s = e.num_points();
  let a, o;
  if (i.data_type() === 1) {
    if (a = new n.DracoInt8Array(), !t.GetAttributeInt8ForAllPoints(
      e,
      i,
      a
    ))
      throw new sr(
        `Could not get attribute data for id:${i.unique_id().toString()}`
      );
    o = new Int8Array(a.size());
  } else if (i.data_type() === 2) {
    if (a = new n.DracoUInt8Array(), !t.GetAttributeUInt8ForAllPoints(
      e,
      i,
      a
    ))
      throw new sr(
        `Could not get attribute data for id:${i.unique_id().toString()}`
      );
    o = new Uint8Array(a.size());
  } else if (i.data_type() === 3) {
    if (a = new n.DracoInt16Array(), !t.GetAttributeInt16ForAllPoints(
      e,
      i,
      a
    ))
      throw new sr(
        `Could not get attribute data for id:${i.unique_id().toString()}`
      );
    o = new Int16Array(a.size());
  } else if (i.data_type() === 4) {
    if (a = new n.DracoUInt16Array(), !t.GetAttributeUInt16ForAllPoints(
      e,
      i,
      a
    ))
      throw new sr(
        `Could not get attribute data for id:${i.unique_id().toString()}`
      );
    o = new Uint16Array(a.size());
  } else if (i.data_type() === 6) {
    if (a = new n.DracoUInt32Array(), !t.GetAttributeUInt32ForAllPoints(
      e,
      i,
      a
    ))
      throw new sr(
        `Could not get attribute data for id:${i.unique_id().toString()}`
      );
    o = new Uint32Array(a.size());
  } else if (i.data_type() === 5) {
    if (a = new n.DracoInt32Array(), !t.GetAttributeInt32ForAllPoints(
      e,
      i,
      a
    ))
      throw new sr(
        `Could not get attribute data for id:${i.unique_id().toString()}`
      );
    o = new Int32Array(a.size());
  } else {
    if (a = new n.DracoFloat32Array(), !t.GetAttributeFloatForAllPoints(
      e,
      i,
      a
    ))
      throw new sr(
        `Could not get attribute data for id:${i.unique_id().toString()}`
      );
    o = new Float32Array(a.size());
  }
  const c = [], h = [];
  for (let f = 0; f < r; f++)
    c.push(Number.POSITIVE_INFINITY), h.push(Number.NEGATIVE_INFINITY);
  for (let f = 0; f < s; f++)
    for (let d = 0; d < r; d++) {
      const m = f * r + d;
      o[m] = a.GetValue(m), c[d] = Math.min(o[m], c[d]), h[d] = Math.max(o[m], h[d]);
    }
  return n.destroy(a), {
    attributeBuffer: Buffer.from(o.buffer),
    minValues: c,
    maxValues: h
  };
}
function Q3(n, t, e) {
  const i = $3(t.type);
  let r = 0;
  for (let v = 0; v < i; ++v) {
    const E = t.max[v] - t.min[v];
    E > r && (r = E);
  }
  r === 0 && (r = 1);
  let s = n;
  n.indexOf("_") > 0 && (s = s.substring(0, n.indexOf("_"))), s !== "POSITION" && s !== "NORMAL" && s !== "COLOR" && s !== "TEXCOORD" && (s = "GENERIC");
  const o = (1 << e[s]) - 1, c = o / r, h = Array(i).fill(0), l = Array(i).fill(0);
  for (let v = 0; v < i; ++v) {
    const E = t.min[v] - t.min[v], _ = t.max[v] - t.min[v], p = Math.floor(E * c + 0.5), R = Math.floor(_ * c + 0.5);
    h[v] = p - 1, l[v] = R + 1;
  }
  const f = r / o, d = Array(i).fill(0), m = Array(i).fill(0);
  for (let v = 0; v < i; ++v)
    d[v] = h[v] * f + t.min[v], m[v] = l[v] * f + t.min[v], t.componentType !== Ga.FLOAT && (d[v] = Math.ceil(d[v] - 0.5), m[v] = Math.floor(m[v] + 0.5));
  return {
    min: d,
    max: m
  };
}
const yo = Be, Jp = __, tR = mo, eR = Wr, nR = n_, Si = Ln, If = Mf, iR = ho, rR = yo.clone, sR = yo.ComponentDatatype, Qp = yo.defaultValue, y_ = yo.defined, g_ = yo.numberOfComponentsForType;
var aR = oR;
function oR(n) {
  let t, e, i, r;
  const s = {}, a = {}, o = {};
  let c = !1;
  Si.mesh(n, function(h) {
    Si.meshPrimitive(h, function(l) {
      const f = Jp({
        indices: l.indices,
        attributes: l.attributes,
        targets: l.targets,
        mode: l.mode
      });
      if (y_(s[f])) {
        const v = Qp(a[f], []);
        a[f] = v, v.push(l);
        return;
      }
      s[f] = l;
      const d = Jp({
        attributes: l.attributes,
        targets: l.targets,
        mode: l.mode
      }), m = Qp(
        o[d],
        []
      );
      o[d] = m, m.push(l);
    });
  });
  for (e in o)
    if (Object.prototype.hasOwnProperty.call(o, e)) {
      if (i = o[e], r = i.length, r === 1)
        continue;
      c = !0;
      const h = fR(n, i[0]), l = hR(n, i[0]);
      for (t = 0; t < r; ++t)
        uR(n, i[t], h, l);
    }
  if (c) {
    for (e in a)
      if (Object.prototype.hasOwnProperty.call(a, e)) {
        const h = s[e];
        for (i = a[e], r = i.length, t = 0; t < r; ++t)
          cR(h, i[t]);
      }
    iR(n, ["accessor", "bufferView", "buffer"]);
  }
  return n;
}
function cR(n, t) {
  t.indices = n.indices, Si.meshPrimitiveAttribute(
    n,
    function(e, i) {
      t.attributes[i] = e;
    }
  ), Si.meshPrimitiveTarget(n, function(e, i) {
    Si.meshPrimitiveTargetAttribute(
      e,
      function(r, s) {
        t.targets[i][s] = r;
      }
    );
  });
}
function uR(n, t, e, i) {
  const r = n.accessors[t.indices], s = If(n, r), a = {}, o = [];
  let c = 0;
  const h = s.length;
  for (let l = 0; l < h; ++l) {
    const f = s[l];
    let d = a[f];
    y_(d) || (d = c++, a[f] = d), o.push(d);
  }
  t.indices = v_(n, r, o), Si.meshPrimitiveAttribute(t, function(l, f) {
    t.attributes[f] = td(
      n,
      l,
      f,
      e,
      a,
      c
    );
  }), Si.meshPrimitiveTarget(t, function(l, f) {
    Si.meshPrimitiveTargetAttribute(
      l,
      function(d, m) {
        l[m] = td(
          n,
          d,
          m,
          i[f],
          a,
          c
        );
      }
    );
  });
}
function td(n, t, e, i, r, s) {
  const a = n.accessors[t], o = g_(a.type), c = i[e], h = new Array(s * o);
  return lR(c, h, r, o), v_(n, a, h);
}
function lR(n, t, e, i) {
  for (const r in e)
    if (Object.prototype.hasOwnProperty.call(e, r)) {
      const s = e[r];
      for (let a = 0; a < i; ++a)
        t[s * i + a] = n[r * i + a];
    }
}
function v_(n, t, e) {
  const i = t.componentType, r = t.type, s = g_(r), a = e.length / s, o = Buffer.from(
    sR.createTypedArray(i, e).buffer
  ), c = tR(n, o), h = rR(t, !0), l = eR(n.accessors, h);
  h.bufferView = c, h.byteOffset = 0, h.count = a;
  const f = nR(n, h);
  return h.min = f.min, h.max = f.max, l;
}
function fR(n, t) {
  const e = {};
  return Si.meshPrimitiveAttribute(t, function(i, r) {
    e[r] = If(
      n,
      n.accessors[i]
    );
  }), e;
}
function hR(n, t) {
  const e = [];
  return Si.meshPrimitiveTarget(t, function(i) {
    const r = {};
    e.push(r), Si.meshPrimitiveTargetAttribute(
      i,
      function(s, a) {
        r[a] = If(
          n,
          n.accessors[s]
        );
      }
    );
  }), e;
}
const qr = Be, ed = q3, pR = __, nd = ff, x_ = mo, dR = i_, mR = po, Hl = Wr, ki = Ln, _R = Ma, id = Mf, yR = ho, gR = X3, vR = aR, $c = qr.Cartesian3, rd = qr.Check, sd = qr.clone, b_ = qr.ComponentDatatype, gi = qr.defaultValue, Fi = qr.defined, ml = qr.RuntimeError, Oi = qr.WebGLConstants;
let _l, ad;
var xR = Eu;
function Eu(n, t) {
  return Fi(_l) || (_l = nd.resolve(ed.createEncoderModule({})), ad = nd.resolve(ed.createDecoderModule({}))), _l.then(function(e) {
    return ad.then(function(i) {
      return bR(n, t, e, i);
    });
  });
}
function bR(n, t, e, i) {
  t = gi(t, {});
  const r = gi(t.dracoOptions, {}), s = Eu.defaults, a = gi(
    r.compressionLevel,
    s.compressionLevel
  ), o = gi(
    r.uncompressedFallback,
    s.uncompressedFallback
  ), c = gi(
    r.unifiedQuantization,
    s.unifiedQuantization
  ), h = r.quantizationVolume, l = c || Fi(h), f = TR(r);
  cd("compressionLevel", a, 0, 10);
  for (const _ in f)
    Object.prototype.hasOwnProperty.call(
      f,
      _
    ) && cd(
      `quantizationBitsValues[${_}]`,
      f[_],
      0,
      30
    );
  vR(n);
  const d = {};
  let m, v;
  if (Fi(h))
    m = $c.pack(h.minimum, new Array(3)), v = $c.maximumComponent(
      $c.subtract(
        h.maximum,
        h.minimum,
        new $c()
      )
    );
  else if (c) {
    const _ = n.accessors, p = new Array(3).fill(Number.POSITIVE_INFINITY), R = new Array(3).fill(Number.NEGATIVE_INFINITY);
    ki.accessorWithSemantic(n, "POSITION", function(M) {
      const P = _[M];
      if (P.type !== "VEC3")
        throw new ml(
          "Could not perform unified quantization. Input contains position accessor with an unsupported number of components."
        );
      const W = P.min, C = P.max;
      for (let D = 0; D < 3; ++D)
        p[D] = Math.min(p[D], W[D]), R[D] = Math.max(R[D], C[D]);
    }), m = p, v = Math.max(R[0] - p[0], R[1] - p[1], R[2] - p[2]);
  }
  let E = !1;
  return ki.mesh(n, function(_) {
    ki.meshPrimitive(_, function(p) {
      if (Fi(p.mode) && p.mode !== Oi.TRIANGLES)
        return;
      Fi(p.indices) || ER(n, p), E = !0;
      const R = {
        attributes: p.attributes,
        indices: p.indices,
        mode: p.mode
      }, M = pR(R);
      if (Fi(d[M])) {
        MR(
          p,
          d[M]
        );
        return;
      }
      d[M] = p;
      const P = new e.Encoder(), W = new e.MeshBuilder(), C = new e.Mesh(), D = id(
        n,
        n.accessors[p.indices]
      ), N = new Uint32Array(D), A = N.length / 3;
      W.AddFacesToMesh(C, A, N);
      const I = {};
      ki.meshPrimitiveAttribute(
        p,
        function(B, G) {
          const H = n.accessors[B], w = H.componentType, ut = H.count, pt = _R(H.type), _t = id(n, H), vt = AR(w), F = b_.createTypedArray(
            w,
            _t
          );
          let rt = G;
          G.indexOf("_") > 0 && (rt = rt.substring(0, G.indexOf("_")));
          let b;
          rt === "POSITION" || rt === "NORMAL" || rt === "COLOR" ? b = e[rt] : rt === "TEXCOORD" ? b = e.TEX_COORD : b = e.GENERIC;
          const lt = W[vt](
            C,
            b,
            ut,
            pt,
            F
          );
          if (lt === -1)
            throw new ml(
              `Error: Failed adding attribute ${G}`
            );
          I[G] = lt, f[rt] > 0 && (rt === "POSITION" && l ? P.SetAttributeExplicitQuantization(
            e.POSITION,
            f[rt],
            3,
            m,
            v
          ) : P.SetAttributeQuantization(
            b,
            f[rt]
          ));
        }
      );
      const it = new e.DracoInt8Array();
      P.SetSpeedOptions(10 - a, 10 - a), Fi(p.targets) && P.SetEncodingMethod(e.MESH_SEQUENTIAL_ENCODING), P.SetTrackEncodedProperties(!0);
      const V = P.EncodeMeshToDracoBuffer(
        C,
        it
      );
      if (V <= 0)
        throw new ml("Error: Draco encoding failed.");
      const mt = Buffer.alloc(V);
      for (let B = 0; B < V; ++B)
        mt[B] = it.GetValue(B);
      const k = {
        buffer: mt,
        numberOfPoints: P.GetNumberOfEncodedPoints(),
        numberOfFaces: P.GetNumberOfEncodedFaces()
      };
      wR(
        n,
        p,
        I,
        k,
        o,
        f,
        i
      ), e.destroy(it), e.destroy(C), e.destroy(W), e.destroy(P);
    });
  }), E && (o ? mR(n, "KHR_draco_mesh_compression") : dR(n, "KHR_draco_mesh_compression"), yR(n, ["accessor", "bufferView", "buffer"]), o && SR(n)), n;
}
function ER(n, t) {
  const e = n.accessors[t.attributes.POSITION].count, i = e < 65535 ? Oi.UNSIGNED_SHORT : Oi.UNSIGNED_INT, r = b_.createTypedArray(i, e);
  for (let c = 0; c < e; ++c)
    r[c] = c;
  const s = Buffer.from(r.buffer), o = {
    bufferView: x_(n, s),
    byteOffset: 0,
    componentType: i,
    count: e,
    type: "SCALAR",
    min: [0],
    max: [e - 1]
  };
  t.indices = Hl(n.accessors, o);
}
function wR(n, t, e, i, r, s, a) {
  if (!r) {
    const c = sd(n.accessors[t.indices]);
    delete c.bufferView, delete c.byteOffset, t.indices = Hl(n.accessors, c), ki.meshPrimitiveAttribute(t, function(h, l) {
      const f = sd(n.accessors[h]);
      delete f.bufferView, delete f.byteOffset, t.attributes[l] = Hl(
        n.accessors,
        f
      );
    });
  }
  const o = x_(n, i.buffer);
  t.extensions = gi(t.extensions, {}), t.extensions.KHR_draco_mesh_compression = {
    bufferView: o,
    attributes: e
  }, n = gR(
    n,
    t,
    i,
    r,
    s,
    a
  );
}
function MR(n, t) {
  ki.meshPrimitiveAttribute(
    t,
    function(i, r) {
      n.attributes[r] = i;
    }
  ), n.indices = t.indices;
  const e = t.extensions.KHR_draco_mesh_compression;
  n.extensions = gi(n.extensions, {}), n.extensions.KHR_draco_mesh_compression = {
    bufferView: e.bufferView,
    attributes: e.attributes
  };
}
function E_(n, t, e) {
  const i = n.bufferViews[t], r = n.buffers[i.buffer];
  r.extras._pipeline.mergedBufferName = e;
}
function od(n, t, e) {
  const i = n.accessors[t].bufferView;
  Fi(i) && E_(n, i, e);
}
function SR(n) {
  ki.accessorContainingVertexAttributeData(n, function(t) {
    od(n, t, "uncompressed");
  }), ki.accessorContainingIndexData(n, function(t) {
    od(n, t, "uncompressed");
  }), ki.mesh(n, function(t) {
    ki.meshPrimitive(t, function(e) {
      Fi(e.extensions) && Fi(e.extensions.KHR_draco_mesh_compression) && E_(
        n,
        e.extensions.KHR_draco_mesh_compression.bufferView,
        "draco"
      );
    });
  });
}
function AR(n) {
  switch (n) {
    case Oi.UNSIGNED_BYTE:
      return "AddUInt8Attribute";
    case Oi.BYTE:
      return "AddInt8Attribute";
    case Oi.UNSIGNED_SHORT:
      return "AddUInt16Attribute";
    case Oi.SHORT:
      return "AddInt16Attribute";
    case Oi.UNSIGNED_INT:
      return "AddUInt32Attribute";
    case Oi.INT:
      return "AddInt32Attribute";
    case Oi.FLOAT:
      return "AddFloatAttribute";
  }
}
function cd(n, t, e, i) {
  rd.typeOf.number.greaterThanOrEquals(n, t, e), rd.typeOf.number.lessThanOrEquals(n, t, i);
}
function TR(n) {
  const t = Eu.defaults;
  return {
    POSITION: gi(
      n.quantizePositionBits,
      t.quantizePositionBits
    ),
    NORMAL: gi(
      n.quantizeNormalBits,
      t.quantizeNormalBits
    ),
    TEXCOORD: gi(
      n.quantizeTexcoordBits,
      t.quantizeTexcoordBits
    ),
    COLOR: gi(
      n.quantizeColorBits,
      t.quantizeColorBits
    ),
    GENERIC: gi(
      n.quantizeGenericBits,
      t.quantizeGenericBits
    )
  };
}
Eu.defaults = {
  compressionLevel: 7,
  quantizePositionBits: 11,
  quantizeNormalBits: 8,
  quantizeTexcoordBits: 10,
  quantizeColorBits: 8,
  quantizeSkinBits: 8,
  quantizeGenericBits: 8,
  uncompressedFallback: !1,
  unifiedQuantization: !1
};
const Pf = Be, CR = ff, RR = uS, IR = lf, PR = hS, LR = d2, OR = b2, DR = M2, NR = ho, FR = DC, UR = I3, BR = xR, kR = Pf.clone, sa = Pf.defaultValue, w_ = Pf.defined;
var M_ = Lf;
function Lf(n, t) {
  const e = Lf.defaults;
  t = w_(t) ? kR(t) : {}, t.separateBuffers = sa(t.separate, e.separate), t.separateShaders = sa(t.separate, e.separate), t.separateTextures = sa(t.separateTextures, e.separateTextures) || t.separate, t.stats = sa(t.stats, e.stats), t.logger = sa(t.logger, VR()), t.separateResources = {}, t.customStages = sa(t.customStages, []);
  const i = [
    IR,
    LR,
    FR,
    RR
  ], r = [UR, DR, OR], s = GR(t), a = i.concat(
    t.customStages,
    s,
    r
  );
  return CR.each(a, function(o) {
    return o(n, t);
  }).then(function() {
    return zR(n, t, !0), {
      gltf: n,
      separateResources: t.separateResources
    };
  });
}
function zR(n, t, e) {
  t.stats && (t.logger(e ? "Statistics after:" : "Statistics before:"), t.logger(PR(n).toString()));
}
function GR(n) {
  const t = [];
  return w_(n.dracoOptions) && t.push(BR), n.keepUnusedElements || t.push(function(e, i) {
    NR(e);
  }), t;
}
function VR() {
  return function(n) {
    console.log(n);
  };
}
Lf.defaults = {
  /**
   * Gets or sets whether to write out separate buffers, shaders, and textures instead of embedding them in the glTF
   * @type Boolean
   * @default false
   */
  separate: !1,
  /**
   * Gets or sets whether to write out separate textures only.
   * @type Boolean
   * @default false
   */
  separateTextures: !1,
  /**
   * Gets or sets whether to print statistics to console for input and output glTF files.
   * @type Boolean
   * @default false
   */
  stats: !1,
  /**
   * Keep unused 'node', 'mesh' and 'material' elements.
   * @type Boolean
   * @default false
   */
  keepUnusedElements: !1,
  /**
   * When false, materials with KHR_techniques_webgl, KHR_blend, or KHR_materials_common will be converted to PBR.
   * @type Boolean
   * @default false
   */
  keepLegacyExtensions: !1,
  /**
   * Gets or sets whether to compress the meshes using Draco. Adds the KHR_draco_mesh_compression extension.
   * @type Boolean
   * @default false
   */
  compressDracoMeshes: !1
};
const S_ = Be, HR = JM, jR = M_, WR = S_.clone, jl = S_.defined;
var qR = $R;
function $R(n, t) {
  return t = jl(t) ? WR(t) : {}, t.forceMergeBuffers = !t.separate, t.bufferStorage = {
    buffer: void 0
  }, jR(n, t).then(function(e) {
    return {
      glb: XR(e.gltf, t.bufferStorage.buffer),
      separateResources: e.separateResources
    };
  });
}
function XR(n, t) {
  const e = HR(n, 20);
  let i = 20 + e.length;
  jl(t) && (i += 8 + t.length);
  const r = Buffer.alloc(i);
  let s = 0;
  return r.writeUInt32LE(1179937895, s), s += 4, r.writeUInt32LE(2, s), s += 4, r.writeUInt32LE(i, s), s += 4, r.writeUInt32LE(e.length, s), s += 4, r.writeUInt32LE(1313821514, s), s += 4, e.copy(r, s), s += e.length, jl(t) && (r.writeUInt32LE(t.length, s), s += 4, r.writeUInt32LE(5130562, s), s += 4, t.copy(r, s)), r;
}
const YR = om, KR = qR;
var ZR = JR;
function JR(n, t) {
  const e = YR(n);
  return KR(e, t);
}
const QR = /* @__PURE__ */ Wl(ZR), tI = om, eI = M_;
var nI = iI;
function iI(n, t) {
  const e = tI(n);
  return eI(e, t);
}
const rI = /* @__PURE__ */ Wl(nI), A_ = () => {
  console.log("-h", "      -----show help"), console.log("-i", "      -----input file path must a zip file"), console.log("-o", "      -----output file path"), console.log("-c", "      -----set model center to origin true is to origin false is not"), console.log("-f", "      -----set model extrudeHeight by shp filed"), console.log("-d", "      -----use draco compress model true is use false is not");
}, sI = {
  dracoOptions: {
    compressionLevel: 7
  }
}, aI = (n) => n.search(".gltf") !== -1, oI = () => {
  console.time("done");
  const n = process.argv.slice(2);
  if (n.findIndex((d) => d === "-h") !== -1) {
    A_();
    return;
  }
  const e = n.findIndex((d) => d === "-d"), i = n[n.findIndex((d) => d === "-i") + 1], r = n.findIndex((d) => d === "-f");
  let s = null;
  r !== -1 && (s = n[r + 1]);
  const a = n.findIndex((d) => d === "-s");
  let o;
  a !== -1 && (o = (void 0)(n[a + 1]), o = JSON.parse(o));
  const c = n[n.findIndex((d) => d === "-o") + 1], h = n[n.findIndex((d) => d === "-c") + 1], l = (void 0)(i), f = new CM();
  o && f.setColorJson(o), f.addEventListener("progress", (d) => {
    const { data: m } = d;
    console.log(`convert shp to gltf ${m.currentSize} / ${m.size}`);
  }), f.parseWithBuffer(l, {
    height: s,
    center: h
  }).then(async (d) => {
    let m = Buffer.from(d);
    if (e !== -1) {
      console.log("use draco compress glb or gltf......"), console.time("use draco compress glb or gltf");
      const v = await QR(m, sI);
      console.timeEnd("use draco compress glb or gltf"), m = v.glb;
    }
    if (aI(c)) {
      const v = await rI(m);
      m = JSON.stringify(v.gltf);
    }
    (void 0)(c, m, (v) => {
      if (v) {
        console.log(v);
        return;
      }
      console.timeEnd("done");
    });
  });
};
try {
  oI();
} catch (n) {
  console.error(n), A_();
}
